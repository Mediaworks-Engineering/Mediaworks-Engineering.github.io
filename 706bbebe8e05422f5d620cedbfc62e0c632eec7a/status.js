typeof window !== "undefined" &&
    (function webpackUniversalModuleDefinition(root, factory) {
        if (typeof exports === "object" && typeof module === "object") module.exports = factory();
        else if (typeof define === "function" && define.amd) define([], factory);
        else if (typeof exports === "object") exports["Hls"] = factory();
        else root["Hls"] = factory();
    })(this, function () {
        return (function (modules) {
            var installedModules = {};
            function __webpack_require__(moduleId) {
                if (installedModules[moduleId]) {
                    return installedModules[moduleId].exports;
                }
                var module = (installedModules[moduleId] = { i: moduleId, l: false, exports: {} });
                modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
                module.l = true;
                return module.exports;
            }
            __webpack_require__.m = modules;
            __webpack_require__.c = installedModules;
            __webpack_require__.d = function (exports, name, getter) {
                if (!__webpack_require__.o(exports, name)) {
                    Object.defineProperty(exports, name, { enumerable: true, get: getter });
                }
            };
            __webpack_require__.r = function (exports) {
                if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
                }
                Object.defineProperty(exports, "__esModule", { value: true });
            };
            __webpack_require__.t = function (value, mode) {
                if (mode & 1) value = __webpack_require__(value);
                if (mode & 8) return value;
                if (mode & 4 && typeof value === "object" && value && value.__esModule) return value;
                var ns = Object.create(null);
                __webpack_require__.r(ns);
                Object.defineProperty(ns, "default", { enumerable: true, value: value });
                if (mode & 2 && typeof value != "string")
                    for (var key in value)
                        __webpack_require__.d(
                            ns,
                            key,
                            function (key) {
                                return value[key];
                            }.bind(null, key)
                        );
                return ns;
            };
            __webpack_require__.n = function (module) {
                var getter =
                    module && module.__esModule
                        ? function getDefault() {
                              return module["default"];
                          }
                        : function getModuleExports() {
                              return module;
                          };
                __webpack_require__.d(getter, "a", getter);
                return getter;
            };
            __webpack_require__.o = function (object, property) {
                return Object.prototype.hasOwnProperty.call(object, property);
            };
            __webpack_require__.p = "/dist/";
            return __webpack_require__((__webpack_require__.s = "./src/hls.ts"));
        })({
            "./node_modules/eventemitter3/index.js": function (module, exports, __webpack_require__) {
                "use strict";
                var has = Object.prototype.hasOwnProperty,
                    prefix = "~";
                function Events() {}
                if (Object.create) {
                    Events.prototype = Object.create(null);
                    if (!new Events().__proto__) prefix = false;
                }
                function EE(fn, context, once) {
                    this.fn = fn;
                    this.context = context;
                    this.once = once || false;
                }
                function addListener(emitter, event, fn, context, once) {
                    if (typeof fn !== "function") {
                        throw new TypeError("The listener must be a function");
                    }
                    var listener = new EE(fn, context || emitter, once),
                        evt = prefix ? prefix + event : event;
                    if (!emitter._events[evt]) (emitter._events[evt] = listener), emitter._eventsCount++;
                    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
                    else emitter._events[evt] = [emitter._events[evt], listener];
                    return emitter;
                }
                function clearEvent(emitter, evt) {
                    if (--emitter._eventsCount === 0) emitter._events = new Events();
                    else delete emitter._events[evt];
                }
                function EventEmitter() {
                    this._events = new Events();
                    this._eventsCount = 0;
                }
                EventEmitter.prototype.eventNames = function eventNames() {
                    var names = [],
                        events,
                        name;
                    if (this._eventsCount === 0) return names;
                    for (name in (events = this._events)) {
                        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
                    }
                    if (Object.getOwnPropertySymbols) {
                        return names.concat(Object.getOwnPropertySymbols(events));
                    }
                    return names;
                };
                EventEmitter.prototype.listeners = function listeners(event) {
                    var evt = prefix ? prefix + event : event,
                        handlers = this._events[evt];
                    if (!handlers) return [];
                    if (handlers.fn) return [handlers.fn];
                    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
                        ee[i] = handlers[i].fn;
                    }
                    return ee;
                };
                EventEmitter.prototype.listenerCount = function listenerCount(event) {
                    var evt = prefix ? prefix + event : event,
                        listeners = this._events[evt];
                    if (!listeners) return 0;
                    if (listeners.fn) return 1;
                    return listeners.length;
                };
                EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
                    var evt = prefix ? prefix + event : event;
                    if (!this._events[evt]) return false;
                    var listeners = this._events[evt],
                        len = arguments.length,
                        args,
                        i;
                    if (listeners.fn) {
                        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
                        switch (len) {
                            case 1:
                                return listeners.fn.call(listeners.context), true;
                            case 2:
                                return listeners.fn.call(listeners.context, a1), true;
                            case 3:
                                return listeners.fn.call(listeners.context, a1, a2), true;
                            case 4:
                                return listeners.fn.call(listeners.context, a1, a2, a3), true;
                            case 5:
                                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
                            case 6:
                                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
                        }
                        for (i = 1, args = new Array(len - 1); i < len; i++) {
                            args[i - 1] = arguments[i];
                        }
                        listeners.fn.apply(listeners.context, args);
                    } else {
                        var length = listeners.length,
                            j;
                        for (i = 0; i < length; i++) {
                            if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
                            switch (len) {
                                case 1:
                                    listeners[i].fn.call(listeners[i].context);
                                    break;
                                case 2:
                                    listeners[i].fn.call(listeners[i].context, a1);
                                    break;
                                case 3:
                                    listeners[i].fn.call(listeners[i].context, a1, a2);
                                    break;
                                case 4:
                                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                                    break;
                                default:
                                    if (!args)
                                        for (j = 1, args = new Array(len - 1); j < len; j++) {
                                            args[j - 1] = arguments[j];
                                        }
                                    listeners[i].fn.apply(listeners[i].context, args);
                            }
                        }
                    }
                    return true;
                };
                EventEmitter.prototype.on = function on(event, fn, context) {
                    return addListener(this, event, fn, context, false);
                };
                EventEmitter.prototype.once = function once(event, fn, context) {
                    return addListener(this, event, fn, context, true);
                };
                EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
                    var evt = prefix ? prefix + event : event;
                    if (!this._events[evt]) return this;
                    if (!fn) {
                        clearEvent(this, evt);
                        return this;
                    }
                    var listeners = this._events[evt];
                    if (listeners.fn) {
                        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
                            clearEvent(this, evt);
                        }
                    } else {
                        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
                            if (listeners[i].fn !== fn || (once && !listeners[i].once) || (context && listeners[i].context !== context)) {
                                events.push(listeners[i]);
                            }
                        }
                        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
                        else clearEvent(this, evt);
                    }
                    return this;
                };
                EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
                    var evt;
                    if (event) {
                        evt = prefix ? prefix + event : event;
                        if (this._events[evt]) clearEvent(this, evt);
                    } else {
                        this._events = new Events();
                        this._eventsCount = 0;
                    }
                    return this;
                };
                EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
                EventEmitter.prototype.addListener = EventEmitter.prototype.on;
                EventEmitter.prefixed = prefix;
                EventEmitter.EventEmitter = EventEmitter;
                if (true) {
                    module.exports = EventEmitter;
                }
            },
            "./node_modules/url-toolkit/src/url-toolkit.js": function (module, exports, __webpack_require__) {
                (function (root) {
                    var URL_REGEX = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/;
                    var FIRST_SEGMENT_REGEX = /^(?=([^\/?#]*))\1([^]*)$/;
                    var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
                    var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;
                    var URLToolkit = {
                        buildAbsoluteURL: function (baseURL, relativeURL, opts) {
                            opts = opts || {};
                            baseURL = baseURL.trim();
                            relativeURL = relativeURL.trim();
                            if (!relativeURL) {
                                if (!opts.alwaysNormalize) {
                                    return baseURL;
                                }
                                var basePartsForNormalise = URLToolkit.parseURL(baseURL);
                                if (!basePartsForNormalise) {
                                    throw new Error("Error trying to parse base URL.");
                                }
                                basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);
                                return URLToolkit.buildURLFromParts(basePartsForNormalise);
                            }
                            var relativeParts = URLToolkit.parseURL(relativeURL);
                            if (!relativeParts) {
                                throw new Error("Error trying to parse relative URL.");
                            }
                            if (relativeParts.scheme) {
                                if (!opts.alwaysNormalize) {
                                    return relativeURL;
                                }
                                relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
                                return URLToolkit.buildURLFromParts(relativeParts);
                            }
                            var baseParts = URLToolkit.parseURL(baseURL);
                            if (!baseParts) {
                                throw new Error("Error trying to parse base URL.");
                            }
                            if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== "/") {
                                var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
                                baseParts.netLoc = pathParts[1];
                                baseParts.path = pathParts[2];
                            }
                            if (baseParts.netLoc && !baseParts.path) {
                                baseParts.path = "/";
                            }
                            var builtParts = { scheme: baseParts.scheme, netLoc: relativeParts.netLoc, path: null, params: relativeParts.params, query: relativeParts.query, fragment: relativeParts.fragment };
                            if (!relativeParts.netLoc) {
                                builtParts.netLoc = baseParts.netLoc;
                                if (relativeParts.path[0] !== "/") {
                                    if (!relativeParts.path) {
                                        builtParts.path = baseParts.path;
                                        if (!relativeParts.params) {
                                            builtParts.params = baseParts.params;
                                            if (!relativeParts.query) {
                                                builtParts.query = baseParts.query;
                                            }
                                        }
                                    } else {
                                        var baseURLPath = baseParts.path;
                                        var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf("/") + 1) + relativeParts.path;
                                        builtParts.path = URLToolkit.normalizePath(newPath);
                                    }
                                }
                            }
                            if (builtParts.path === null) {
                                builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;
                            }
                            return URLToolkit.buildURLFromParts(builtParts);
                        },
                        parseURL: function (url) {
                            var parts = URL_REGEX.exec(url);
                            if (!parts) {
                                return null;
                            }
                            return { scheme: parts[1] || "", netLoc: parts[2] || "", path: parts[3] || "", params: parts[4] || "", query: parts[5] || "", fragment: parts[6] || "" };
                        },
                        normalizePath: function (path) {
                            path = path.split("").reverse().join("").replace(SLASH_DOT_REGEX, "");
                            while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, "")).length) {}
                            return path.split("").reverse().join("");
                        },
                        buildURLFromParts: function (parts) {
                            return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
                        },
                    };
                    if (true) module.exports = URLToolkit;
                    else {
                    }
                })(this);
            },
            "./node_modules/webworkify-webpack/index.js": function (module, exports, __webpack_require__) {
                function webpackBootstrapFunc(modules) {
                    var installedModules = {};
                    function __webpack_require__(moduleId) {
                        if (installedModules[moduleId]) return installedModules[moduleId].exports;
                        var module = (installedModules[moduleId] = { i: moduleId, l: false, exports: {} });
                        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
                        module.l = true;
                        return module.exports;
                    }
                    __webpack_require__.m = modules;
                    __webpack_require__.c = installedModules;
                    __webpack_require__.i = function (value) {
                        return value;
                    };
                    __webpack_require__.d = function (exports, name, getter) {
                        if (!__webpack_require__.o(exports, name)) {
                            Object.defineProperty(exports, name, { configurable: false, enumerable: true, get: getter });
                        }
                    };
                    __webpack_require__.r = function (exports) {
                        Object.defineProperty(exports, "__esModule", { value: true });
                    };
                    __webpack_require__.n = function (module) {
                        var getter =
                            module && module.__esModule
                                ? function getDefault() {
                                      return module["default"];
                                  }
                                : function getModuleExports() {
                                      return module;
                                  };
                        __webpack_require__.d(getter, "a", getter);
                        return getter;
                    };
                    __webpack_require__.o = function (object, property) {
                        return Object.prototype.hasOwnProperty.call(object, property);
                    };
                    __webpack_require__.p = "/";
                    __webpack_require__.oe = function (err) {
                        console.error(err);
                        throw err;
                    };
                    var f = __webpack_require__((__webpack_require__.s = ENTRY_MODULE));
                    return f.default || f;
                }
                var moduleNameReqExp = "[\\.|\\-|\\+|\\w|/|@]+";
                var dependencyRegExp = "\\(\\s*(/\\*.*?\\*/)?\\s*.*?(" + moduleNameReqExp + ").*?\\)";
                function quoteRegExp(str) {
                    return (str + "").replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
                }
                function isNumeric(n) {
                    return !isNaN(1 * n);
                }
                function getModuleDependencies(sources, module, queueName) {
                    var retval = {};
                    retval[queueName] = [];
                    var fnString = module.toString();
                    var wrapperSignature = fnString.match(/^function\s?\w*\(\w+,\s*\w+,\s*(\w+)\)/);
                    if (!wrapperSignature) return retval;
                    var webpackRequireName = wrapperSignature[1];
                    var re = new RegExp("(\\\\n|\\W)" + quoteRegExp(webpackRequireName) + dependencyRegExp, "g");
                    var match;
                    while ((match = re.exec(fnString))) {
                        if (match[3] === "dll-reference") continue;
                        retval[queueName].push(match[3]);
                    }
                    re = new RegExp("\\(" + quoteRegExp(webpackRequireName) + '\\("(dll-reference\\s(' + moduleNameReqExp + '))"\\)\\)' + dependencyRegExp, "g");
                    while ((match = re.exec(fnString))) {
                        if (!sources[match[2]]) {
                            retval[queueName].push(match[1]);
                            sources[match[2]] = __webpack_require__(match[1]).m;
                        }
                        retval[match[2]] = retval[match[2]] || [];
                        retval[match[2]].push(match[4]);
                    }
                    var keys = Object.keys(retval);
                    for (var i = 0; i < keys.length; i++) {
                        for (var j = 0; j < retval[keys[i]].length; j++) {
                            if (isNumeric(retval[keys[i]][j])) {
                                retval[keys[i]][j] = 1 * retval[keys[i]][j];
                            }
                        }
                    }
                    return retval;
                }
                function hasValuesInQueues(queues) {
                    var keys = Object.keys(queues);
                    return keys.reduce(function (hasValues, key) {
                        return hasValues || queues[key].length > 0;
                    }, false);
                }
                function getRequiredModules(sources, moduleId) {
                    var modulesQueue = { main: [moduleId] };
                    var requiredModules = { main: [] };
                    var seenModules = { main: {} };
                    while (hasValuesInQueues(modulesQueue)) {
                        var queues = Object.keys(modulesQueue);
                        for (var i = 0; i < queues.length; i++) {
                            var queueName = queues[i];
                            var queue = modulesQueue[queueName];
                            var moduleToCheck = queue.pop();
                            seenModules[queueName] = seenModules[queueName] || {};
                            if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) continue;
                            seenModules[queueName][moduleToCheck] = true;
                            requiredModules[queueName] = requiredModules[queueName] || [];
                            requiredModules[queueName].push(moduleToCheck);
                            var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName);
                            var newModulesKeys = Object.keys(newModules);
                            for (var j = 0; j < newModulesKeys.length; j++) {
                                modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || [];
                                modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]]);
                            }
                        }
                    }
                    return requiredModules;
                }
                module.exports = function (moduleId, options) {
                    options = options || {};
                    var sources = { main: __webpack_require__.m };
                    var requiredModules = options.all ? { main: Object.keys(sources.main) } : getRequiredModules(sources, moduleId);
                    var src = "";
                    Object.keys(requiredModules)
                        .filter(function (m) {
                            return m !== "main";
                        })
                        .forEach(function (module) {
                            var entryModule = 0;
                            while (requiredModules[module][entryModule]) {
                                entryModule++;
                            }
                            requiredModules[module].push(entryModule);
                            sources[module][entryModule] = "(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })";
                            src =
                                src +
                                "var " +
                                module +
                                " = (" +
                                webpackBootstrapFunc.toString().replace("ENTRY_MODULE", JSON.stringify(entryModule)) +
                                ")({" +
                                requiredModules[module]
                                    .map(function (id) {
                                        return "" + JSON.stringify(id) + ": " + sources[module][id].toString();
                                    })
                                    .join(",") +
                                "});\n";
                        });
                    src =
                        src +
                        "new ((" +
                        webpackBootstrapFunc.toString().replace("ENTRY_MODULE", JSON.stringify(moduleId)) +
                        ")({" +
                        requiredModules.main
                            .map(function (id) {
                                return "" + JSON.stringify(id) + ": " + sources.main[id].toString();
                            })
                            .join(",") +
                        "}))(self);";
                    var blob = new window.Blob([src], { type: "text/javascript" });
                    if (options.bare) {
                        return blob;
                    }
                    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;
                    var workerUrl = URL.createObjectURL(blob);
                    var worker = new window.Worker(workerUrl);
                    worker.objectURL = workerUrl;
                    return worker;
                };
            },
            "./src/config.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "hlsDefaultConfig", function () {
                    return hlsDefaultConfig;
                });
                __webpack_require__.d(__webpack_exports__, "mergeConfig", function () {
                    return mergeConfig;
                });
                __webpack_require__.d(__webpack_exports__, "enableStreamingMode", function () {
                    return enableStreamingMode;
                });
                var _controller_abr_controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/controller/abr-controller.ts");
                var _controller_audio_stream_controller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/controller/audio-stream-controller.ts");
                var _controller_audio_track_controller__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/controller/audio-track-controller.ts");
                var _controller_subtitle_stream_controller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/controller/subtitle-stream-controller.ts");
                var _controller_subtitle_track_controller__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/controller/subtitle-track-controller.ts");
                var _controller_buffer_controller__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/controller/buffer-controller.ts");
                var _controller_timeline_controller__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/controller/timeline-controller.ts");
                var _controller_cap_level_controller__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/controller/cap-level-controller.ts");
                var _controller_fps_controller__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./src/controller/fps-controller.ts");
                var _controller_eme_controller__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./src/controller/eme-controller.ts");
                var _controller_cmcd_controller__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./src/controller/cmcd-controller.ts");
                var _utils_xhr_loader__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./src/utils/xhr-loader.ts");
                var _utils_fetch_loader__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./src/utils/fetch-loader.ts");
                var _utils_cues__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./src/utils/cues.ts");
                var _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./src/utils/mediakeys-helper.ts");
                var _utils_logger__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./src/utils/logger.ts");
                function _extends() {
                    _extends = Object.assign
                        ? Object.assign.bind()
                        : function (target) {
                              for (var i = 1; i < arguments.length; i++) {
                                  var source = arguments[i];
                                  for (var key in source) {
                                      if (Object.prototype.hasOwnProperty.call(source, key)) {
                                          target[key] = source[key];
                                      }
                                  }
                              }
                              return target;
                          };
                    return _extends.apply(this, arguments);
                }
                function ownKeys(object, enumerableOnly) {
                    var keys = Object.keys(object);
                    if (Object.getOwnPropertySymbols) {
                        var symbols = Object.getOwnPropertySymbols(object);
                        enumerableOnly &&
                            (symbols = symbols.filter(function (sym) {
                                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                            })),
                            keys.push.apply(keys, symbols);
                    }
                    return keys;
                }
                function _objectSpread(target) {
                    for (var i = 1; i < arguments.length; i++) {
                        var source = null != arguments[i] ? arguments[i] : {};
                        i % 2
                            ? ownKeys(Object(source), !0).forEach(function (key) {
                                  _defineProperty(target, key, source[key]);
                              })
                            : Object.getOwnPropertyDescriptors
                            ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source))
                            : ownKeys(Object(source)).forEach(function (key) {
                                  Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                              });
                    }
                    return target;
                }
                function _defineProperty(obj, key, value) {
                    if (key in obj) {
                        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
                    } else {
                        obj[key] = value;
                    }
                    return obj;
                }
                var hlsDefaultConfig = _objectSpread(
                    _objectSpread(
                        {
                            autoStartLoad: true,
                            startPosition: -1,
                            defaultAudioCodec: undefined,
                            debug: false,
                            capLevelOnFPSDrop: false,
                            capLevelToPlayerSize: false,
                            ignoreDevicePixelRatio: false,
                            initialLiveManifestSize: 1,
                            maxBufferLength: 30,
                            backBufferLength: Infinity,
                            maxBufferSize: 60 * 1e3 * 1e3,
                            maxBufferHole: 0.1,
                            highBufferWatchdogPeriod: 2,
                            nudgeOffset: 0.1,
                            nudgeMaxRetry: 3,
                            maxFragLookUpTolerance: 0.25,
                            liveSyncDurationCount: 3,
                            liveMaxLatencyDurationCount: Infinity,
                            liveSyncDuration: undefined,
                            liveMaxLatencyDuration: undefined,
                            maxLiveSyncPlaybackRate: 1,
                            liveDurationInfinity: false,
                            liveBackBufferLength: null,
                            maxMaxBufferLength: 600,
                            enableWorker: true,
                            enableSoftwareAES: true,
                            manifestLoadingTimeOut: 1e4,
                            manifestLoadingMaxRetry: 1,
                            manifestLoadingRetryDelay: 1e3,
                            manifestLoadingMaxRetryTimeout: 64e3,
                            startLevel: undefined,
                            levelLoadingTimeOut: 1e4,
                            levelLoadingMaxRetry: 4,
                            levelLoadingRetryDelay: 1e3,
                            levelLoadingMaxRetryTimeout: 64e3,
                            fragLoadingTimeOut: 2e4,
                            fragLoadingMaxRetry: 6,
                            fragLoadingRetryDelay: 1e3,
                            fragLoadingMaxRetryTimeout: 64e3,
                            startFragPrefetch: false,
                            fpsDroppedMonitoringPeriod: 5e3,
                            fpsDroppedMonitoringThreshold: 0.2,
                            appendErrorMaxRetry: 3,
                            loader: _utils_xhr_loader__WEBPACK_IMPORTED_MODULE_11__["default"],
                            fLoader: undefined,
                            pLoader: undefined,
                            xhrSetup: undefined,
                            licenseXhrSetup: undefined,
                            licenseResponseCallback: undefined,
                            abrController: _controller_abr_controller__WEBPACK_IMPORTED_MODULE_0__["default"],
                            bufferController: _controller_buffer_controller__WEBPACK_IMPORTED_MODULE_5__["default"],
                            capLevelController: _controller_cap_level_controller__WEBPACK_IMPORTED_MODULE_7__["default"],
                            fpsController: _controller_fps_controller__WEBPACK_IMPORTED_MODULE_8__["default"],
                            stretchShortVideoTrack: false,
                            maxAudioFramesDrift: 1,
                            forceKeyFrameOnDiscontinuity: true,
                            abrEwmaFastLive: 3,
                            abrEwmaSlowLive: 9,
                            abrEwmaFastVoD: 3,
                            abrEwmaSlowVoD: 9,
                            abrEwmaDefaultEstimate: 5e5,
                            abrBandWidthFactor: 0.95,
                            abrBandWidthUpFactor: 0.7,
                            abrMaxWithRealBitrate: false,
                            maxStarvationDelay: 4,
                            maxLoadingDelay: 4,
                            minAutoBitrate: 0,
                            emeEnabled: false,
                            widevineLicenseUrl: undefined,
                            drmSystemOptions: {},
                            requestMediaKeySystemAccessFunc: _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_14__["requestMediaKeySystemAccess"],
                            testBandwidth: true,
                            progressive: false,
                            lowLatencyMode: true,
                            cmcd: undefined,
                            enableDateRangeMetadataCues: true,
                            enableEmsgMetadataCues: true,
                            enableID3MetadataCues: true,
                        },
                        timelineConfig()
                    ),
                    {},
                    {
                        subtitleStreamController: true ? _controller_subtitle_stream_controller__WEBPACK_IMPORTED_MODULE_3__["SubtitleStreamController"] : undefined,
                        subtitleTrackController: true ? _controller_subtitle_track_controller__WEBPACK_IMPORTED_MODULE_4__["default"] : undefined,
                        timelineController: true ? _controller_timeline_controller__WEBPACK_IMPORTED_MODULE_6__["TimelineController"] : undefined,
                        audioStreamController: true ? _controller_audio_stream_controller__WEBPACK_IMPORTED_MODULE_1__["default"] : undefined,
                        audioTrackController: true ? _controller_audio_track_controller__WEBPACK_IMPORTED_MODULE_2__["default"] : undefined,
                        emeController: true ? _controller_eme_controller__WEBPACK_IMPORTED_MODULE_9__["default"] : undefined,
                        cmcdController: true ? _controller_cmcd_controller__WEBPACK_IMPORTED_MODULE_10__["default"] : undefined,
                    }
                );
                function timelineConfig() {
                    return {
                        cueHandler: _utils_cues__WEBPACK_IMPORTED_MODULE_13__["default"],
                        enableWebVTT: true,
                        enableIMSC1: true,
                        enableCEA708Captions: true,
                        captionsTextTrack1Label: "English",
                        captionsTextTrack1LanguageCode: "en",
                        captionsTextTrack2Label: "Spanish",
                        captionsTextTrack2LanguageCode: "es",
                        captionsTextTrack3Label: "Unknown CC",
                        captionsTextTrack3LanguageCode: "",
                        captionsTextTrack4Label: "Unknown CC",
                        captionsTextTrack4LanguageCode: "",
                        renderTextTracksNatively: true,
                    };
                }
                function mergeConfig(defaultConfig, userConfig) {
                    if ((userConfig.liveSyncDurationCount || userConfig.liveMaxLatencyDurationCount) && (userConfig.liveSyncDuration || userConfig.liveMaxLatencyDuration)) {
                        throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
                    }
                    if (userConfig.liveMaxLatencyDurationCount !== undefined && (userConfig.liveSyncDurationCount === undefined || userConfig.liveMaxLatencyDurationCount <= userConfig.liveSyncDurationCount)) {
                        throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
                    }
                    if (userConfig.liveMaxLatencyDuration !== undefined && (userConfig.liveSyncDuration === undefined || userConfig.liveMaxLatencyDuration <= userConfig.liveSyncDuration)) {
                        throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
                    }
                    return _extends({}, defaultConfig, userConfig);
                }
                function enableStreamingMode(config) {
                    var currentLoader = config.loader;
                    if (currentLoader !== _utils_fetch_loader__WEBPACK_IMPORTED_MODULE_12__["default"] && currentLoader !== _utils_xhr_loader__WEBPACK_IMPORTED_MODULE_11__["default"]) {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_15__["logger"].log("[config]: Custom loader detected, cannot enable progressive streaming");
                        config.progressive = false;
                    } else {
                        var canStreamProgressively = Object(_utils_fetch_loader__WEBPACK_IMPORTED_MODULE_12__["fetchSupported"])();
                        if (canStreamProgressively) {
                            config.loader = _utils_fetch_loader__WEBPACK_IMPORTED_MODULE_12__["default"];
                            config.progressive = true;
                            config.enableSoftwareAES = true;
                            _utils_logger__WEBPACK_IMPORTED_MODULE_15__["logger"].log("[config]: Progressive streaming enabled, using FetchLoader");
                        }
                    }
                }
            },
            "./src/controller/abr-controller.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/polyfills/number.ts");
                var _utils_ewma_bandwidth_estimator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/ewma-bandwidth-estimator.ts");
                var _events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/events.ts");
                var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/errors.ts");
                var _types_loader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/types/loader.ts");
                var _utils_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/utils/logger.ts");
                function _defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    Object.defineProperty(Constructor, "prototype", { writable: false });
                    return Constructor;
                }
                var AbrController = (function () {
                    function AbrController(hls) {
                        this.hls = void 0;
                        this.lastLoadedFragLevel = 0;
                        this._nextAutoLevel = -1;
                        this.timer = void 0;
                        this.onCheck = this._abandonRulesCheck.bind(this);
                        this.fragCurrent = null;
                        this.partCurrent = null;
                        this.bitrateTestDelay = 0;
                        this.bwEstimator = void 0;
                        this.hls = hls;
                        var config = hls.config;
                        this.bwEstimator = new _utils_ewma_bandwidth_estimator__WEBPACK_IMPORTED_MODULE_1__["default"](config.abrEwmaSlowVoD, config.abrEwmaFastVoD, config.abrEwmaDefaultEstimate);
                        this.registerListeners();
                    }
                    var _proto = AbrController.prototype;
                    _proto.registerListeners = function registerListeners() {
                        var hls = this.hls;
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].FRAG_LOADING, this.onFragLoading, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].FRAG_LOADED, this.onFragLoaded, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].FRAG_BUFFERED, this.onFragBuffered, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].LEVEL_LOADED, this.onLevelLoaded, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].ERROR, this.onError, this);
                    };
                    _proto.unregisterListeners = function unregisterListeners() {
                        var hls = this.hls;
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].FRAG_LOADING, this.onFragLoading, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].FRAG_LOADED, this.onFragLoaded, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].FRAG_BUFFERED, this.onFragBuffered, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].LEVEL_LOADED, this.onLevelLoaded, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].ERROR, this.onError, this);
                    };
                    _proto.destroy = function destroy() {
                        this.unregisterListeners();
                        this.clearTimer();
                        this.hls = this.onCheck = null;
                        this.fragCurrent = this.partCurrent = null;
                    };
                    _proto.onFragLoading = function onFragLoading(event, data) {
                        var frag = data.frag;
                        if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_4__["PlaylistLevelType"].MAIN) {
                            if (!this.timer) {
                                var _data$part;
                                this.fragCurrent = frag;
                                this.partCurrent = (_data$part = data.part) != null ? _data$part : null;
                                this.timer = self.setInterval(this.onCheck, 100);
                            }
                        }
                    };
                    _proto.onLevelLoaded = function onLevelLoaded(event, data) {
                        var config = this.hls.config;
                        if (data.details.live) {
                            this.bwEstimator.update(config.abrEwmaSlowLive, config.abrEwmaFastLive);
                        } else {
                            this.bwEstimator.update(config.abrEwmaSlowVoD, config.abrEwmaFastVoD);
                        }
                    };
                    _proto._abandonRulesCheck = function _abandonRulesCheck() {
                        var frag = this.fragCurrent,
                            part = this.partCurrent,
                            hls = this.hls;
                        var autoLevelEnabled = hls.autoLevelEnabled,
                            config = hls.config,
                            media = hls.media;
                        if (!frag || !media) {
                            return;
                        }
                        var stats = part ? part.stats : frag.stats;
                        var duration = part ? part.duration : frag.duration;
                        if (stats.aborted || (stats.loaded && stats.loaded === stats.total) || frag.level === 0) {
                            this.clearTimer();
                            this._nextAutoLevel = -1;
                            return;
                        }
                        if (!autoLevelEnabled || media.paused || !media.playbackRate || !media.readyState) {
                            return;
                        }
                        var bufferInfo = hls.mainForwardBufferInfo;
                        if (bufferInfo === null) {
                            return;
                        }
                        var requestDelay = performance.now() - stats.loading.start;
                        var playbackRate = Math.abs(media.playbackRate);
                        if (requestDelay <= (500 * duration) / playbackRate) {
                            return;
                        }
                        var loadedFirstByte = stats.loaded && stats.loading.first;
                        var bwEstimate = this.bwEstimator.getEstimate();
                        var levels = hls.levels,
                            minAutoLevel = hls.minAutoLevel;
                        var level = levels[frag.level];
                        var expectedLen = stats.total || Math.max(stats.loaded, Math.round((duration * level.maxBitrate) / 8));
                        var loadRate = loadedFirstByte ? (stats.loaded * 1e3) / requestDelay : 0;
                        var fragLoadedDelay = loadRate ? (expectedLen - stats.loaded) / loadRate : (expectedLen * 8) / bwEstimate;
                        var bufferStarvationDelay = bufferInfo.len / playbackRate;
                        if (fragLoadedDelay <= bufferStarvationDelay) {
                            return;
                        }
                        var fragLevelNextLoadedDelay = Number.POSITIVE_INFINITY;
                        var nextLoadLevel;
                        for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {
                            var levelNextBitrate = levels[nextLoadLevel].maxBitrate;
                            fragLevelNextLoadedDelay = loadRate ? (duration * levelNextBitrate) / (8 * 0.8 * loadRate) : (duration * levelNextBitrate) / bwEstimate;
                            if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
                                break;
                            }
                        }
                        if (fragLevelNextLoadedDelay >= fragLoadedDelay) {
                            return;
                        }
                        _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].warn(
                            "Fragment " +
                                frag.sn +
                                (part ? " part " + part.index : "") +
                                " of level " +
                                frag.level +
                                " is loading too slowly and will cause an underbuffer; aborting and switching to level " +
                                nextLoadLevel +
                                "\n      Current BW estimate: " +
                                (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(bwEstimate) ? (bwEstimate / 1024).toFixed(3) : "Unknown") +
                                " Kb/s\n      Estimated load time for current fragment: " +
                                fragLoadedDelay.toFixed(3) +
                                " s\n      Estimated load time for the next fragment: " +
                                fragLevelNextLoadedDelay.toFixed(3) +
                                " s\n      Time to underbuffer: " +
                                bufferStarvationDelay.toFixed(3) +
                                " s"
                        );
                        hls.nextLoadLevel = nextLoadLevel;
                        if (loadedFirstByte) {
                            this.bwEstimator.sample(requestDelay, stats.loaded);
                        }
                        this.clearTimer();
                        if (frag.loader) {
                            this.fragCurrent = this.partCurrent = null;
                            frag.loader.abort();
                        }
                        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].FRAG_LOAD_EMERGENCY_ABORTED, { frag: frag, part: part, stats: stats });
                    };
                    _proto.onFragLoaded = function onFragLoaded(event, _ref) {
                        var frag = _ref.frag,
                            part = _ref.part;
                        if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_4__["PlaylistLevelType"].MAIN && Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(frag.sn)) {
                            var stats = part ? part.stats : frag.stats;
                            var duration = part ? part.duration : frag.duration;
                            this.clearTimer();
                            this.lastLoadedFragLevel = frag.level;
                            this._nextAutoLevel = -1;
                            if (this.hls.config.abrMaxWithRealBitrate) {
                                var level = this.hls.levels[frag.level];
                                var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + stats.loaded;
                                var loadedDuration = (level.loaded ? level.loaded.duration : 0) + duration;
                                level.loaded = { bytes: loadedBytes, duration: loadedDuration };
                                level.realBitrate = Math.round((8 * loadedBytes) / loadedDuration);
                            }
                            if (frag.bitrateTest) {
                                var fragBufferedData = { stats: stats, frag: frag, part: part, id: frag.type };
                                this.onFragBuffered(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].FRAG_BUFFERED, fragBufferedData);
                            }
                        }
                    };
                    _proto.onFragBuffered = function onFragBuffered(event, data) {
                        var frag = data.frag,
                            part = data.part;
                        var stats = part ? part.stats : frag.stats;
                        if (stats.aborted) {
                            return;
                        }
                        if (frag.type !== _types_loader__WEBPACK_IMPORTED_MODULE_4__["PlaylistLevelType"].MAIN || frag.sn === "initSegment") {
                            return;
                        }
                        var processingMs = stats.parsing.end - stats.loading.start;
                        this.bwEstimator.sample(processingMs, stats.loaded);
                        stats.bwEstimate = this.bwEstimator.getEstimate();
                        if (frag.bitrateTest) {
                            this.bitrateTestDelay = processingMs / 1e3;
                        } else {
                            this.bitrateTestDelay = 0;
                        }
                    };
                    _proto.onError = function onError(event, data) {
                        switch (data.details) {
                            case _errors__WEBPACK_IMPORTED_MODULE_3__["ErrorDetails"].FRAG_LOAD_ERROR:
                            case _errors__WEBPACK_IMPORTED_MODULE_3__["ErrorDetails"].FRAG_LOAD_TIMEOUT:
                                this.clearTimer();
                                break;
                            default:
                                break;
                        }
                    };
                    _proto.clearTimer = function clearTimer() {
                        self.clearInterval(this.timer);
                        this.timer = undefined;
                    };
                    _proto.getNextABRAutoLevel = function getNextABRAutoLevel() {
                        var fragCurrent = this.fragCurrent,
                            partCurrent = this.partCurrent,
                            hls = this.hls;
                        var maxAutoLevel = hls.maxAutoLevel,
                            config = hls.config,
                            minAutoLevel = hls.minAutoLevel,
                            media = hls.media;
                        var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;
                        var pos = media ? media.currentTime : 0;
                        var playbackRate = media && media.playbackRate !== 0 ? Math.abs(media.playbackRate) : 1;
                        var avgbw = this.bwEstimator ? this.bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate;
                        var bufferInfo = hls.mainForwardBufferInfo;
                        var bufferStarvationDelay = (bufferInfo ? bufferInfo.len : 0) / playbackRate;
                        var bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor);
                        if (bestLevel >= 0) {
                            return bestLevel;
                        }
                        _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].trace((bufferStarvationDelay ? "rebuffering expected" : "buffer is empty") + ", finding optimal quality level");
                        var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay;
                        var bwFactor = config.abrBandWidthFactor;
                        var bwUpFactor = config.abrBandWidthUpFactor;
                        if (!bufferStarvationDelay) {
                            var bitrateTestDelay = this.bitrateTestDelay;
                            if (bitrateTestDelay) {
                                var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;
                                maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;
                                _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].trace(
                                    "bitrate test took " + Math.round(1e3 * bitrateTestDelay) + "ms, set first fragment max fetchDuration to " + Math.round(1e3 * maxStarvationDelay) + " ms"
                                );
                                bwFactor = bwUpFactor = 1;
                            }
                        }
                        bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor);
                        return Math.max(bestLevel, 0);
                    };
                    _proto.findBestLevel = function findBestLevel(currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor) {
                        var _level$details;
                        var fragCurrent = this.fragCurrent,
                            partCurrent = this.partCurrent,
                            currentLevel = this.lastLoadedFragLevel;
                        var levels = this.hls.levels;
                        var level = levels[currentLevel];
                        var live = !!(level !== null && level !== void 0 && (_level$details = level.details) !== null && _level$details !== void 0 && _level$details.live);
                        var currentCodecSet = level === null || level === void 0 ? void 0 : level.codecSet;
                        var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;
                        for (var i = maxAutoLevel; i >= minAutoLevel; i--) {
                            var levelInfo = levels[i];
                            if (!levelInfo || (currentCodecSet && levelInfo.codecSet !== currentCodecSet)) {
                                continue;
                            }
                            var levelDetails = levelInfo.details;
                            var avgDuration =
                                (partCurrent ? (levelDetails === null || levelDetails === void 0 ? void 0 : levelDetails.partTarget) : levelDetails === null || levelDetails === void 0 ? void 0 : levelDetails.averagetargetduration) ||
                                currentFragDuration;
                            var adjustedbw = void 0;
                            if (i <= currentLevel) {
                                adjustedbw = bwFactor * currentBw;
                            } else {
                                adjustedbw = bwUpFactor * currentBw;
                            }
                            var bitrate = levels[i].maxBitrate;
                            var fetchDuration = (bitrate * avgDuration) / adjustedbw;
                            _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].trace(
                                "level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: " + i + "/" + Math.round(adjustedbw) + "/" + bitrate + "/" + avgDuration + "/" + maxFetchDuration + "/" + fetchDuration
                            );
                            if (
                                adjustedbw > bitrate &&
                                (fetchDuration === 0 ||
                                    !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(fetchDuration) ||
                                    (live && !this.bitrateTestDelay) ||
                                    fetchDuration < maxFetchDuration)
                            ) {
                                return i;
                            }
                        }
                        return -1;
                    };
                    _createClass(AbrController, [
                        {
                            key: "nextAutoLevel",
                            get: function get() {
                                var forcedAutoLevel = this._nextAutoLevel;
                                var bwEstimator = this.bwEstimator;
                                if (forcedAutoLevel !== -1 && !bwEstimator.canEstimate()) {
                                    return forcedAutoLevel;
                                }
                                var nextABRAutoLevel = this.getNextABRAutoLevel();
                                if (forcedAutoLevel !== -1 && this.hls.levels[nextABRAutoLevel].loadError) {
                                    return forcedAutoLevel;
                                }
                                if (forcedAutoLevel !== -1) {
                                    nextABRAutoLevel = Math.min(forcedAutoLevel, nextABRAutoLevel);
                                }
                                return nextABRAutoLevel;
                            },
                            set: function set(nextLevel) {
                                this._nextAutoLevel = nextLevel;
                            },
                        },
                    ]);
                    return AbrController;
                })();
                __webpack_exports__["default"] = AbrController;
            },
            "./src/controller/audio-stream-controller.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/polyfills/number.ts");
                var _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/controller/base-stream-controller.ts");
                var _events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/events.ts");
                var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/utils/buffer-helper.ts");
                var _fragment_tracker__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/controller/fragment-tracker.ts");
                var _types_level__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/types/level.ts");
                var _types_loader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/types/loader.ts");
                var _loader_fragment__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/loader/fragment.ts");
                var _demux_chunk_cache__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./src/demux/chunk-cache.ts");
                var _demux_transmuxer_interface__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./src/demux/transmuxer-interface.ts");
                var _types_transmuxer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./src/types/transmuxer.ts");
                var _fragment_finders__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./src/controller/fragment-finders.ts");
                var _utils_discontinuities__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./src/utils/discontinuities.ts");
                var _errors__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./src/errors.ts");
                function _extends() {
                    _extends = Object.assign
                        ? Object.assign.bind()
                        : function (target) {
                              for (var i = 1; i < arguments.length; i++) {
                                  var source = arguments[i];
                                  for (var key in source) {
                                      if (Object.prototype.hasOwnProperty.call(source, key)) {
                                          target[key] = source[key];
                                      }
                                  }
                              }
                              return target;
                          };
                    return _extends.apply(this, arguments);
                }
                function _inheritsLoose(subClass, superClass) {
                    subClass.prototype = Object.create(superClass.prototype);
                    subClass.prototype.constructor = subClass;
                    _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf
                        ? Object.setPrototypeOf.bind()
                        : function _setPrototypeOf(o, p) {
                              o.__proto__ = p;
                              return o;
                          };
                    return _setPrototypeOf(o, p);
                }
                var TICK_INTERVAL = 100;
                var AudioStreamController = (function (_BaseStreamController) {
                    _inheritsLoose(AudioStreamController, _BaseStreamController);
                    function AudioStreamController(hls, fragmentTracker) {
                        var _this;
                        _this = _BaseStreamController.call(this, hls, fragmentTracker, "[audio-stream-controller]") || this;
                        _this.videoBuffer = null;
                        _this.videoTrackCC = -1;
                        _this.waitingVideoCC = -1;
                        _this.audioSwitch = false;
                        _this.trackId = -1;
                        _this.waitingData = null;
                        _this.mainDetails = null;
                        _this.bufferFlushed = false;
                        _this.cachedTrackLoadedData = null;
                        _this._registerListeners();
                        return _this;
                    }
                    var _proto = AudioStreamController.prototype;
                    _proto.onHandlerDestroying = function onHandlerDestroying() {
                        this._unregisterListeners();
                        this.mainDetails = null;
                    };
                    _proto._registerListeners = function _registerListeners() {
                        var hls = this.hls;
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].LEVEL_LOADED, this.onLevelLoaded, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].ERROR, this.onError, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].BUFFER_RESET, this.onBufferReset, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].BUFFER_CREATED, this.onBufferCreated, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].BUFFER_FLUSHED, this.onBufferFlushed, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].INIT_PTS_FOUND, this.onInitPtsFound, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].FRAG_BUFFERED, this.onFragBuffered, this);
                    };
                    _proto._unregisterListeners = function _unregisterListeners() {
                        var hls = this.hls;
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].LEVEL_LOADED, this.onLevelLoaded, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].ERROR, this.onError, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].BUFFER_RESET, this.onBufferReset, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].BUFFER_CREATED, this.onBufferCreated, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].BUFFER_FLUSHED, this.onBufferFlushed, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].INIT_PTS_FOUND, this.onInitPtsFound, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].FRAG_BUFFERED, this.onFragBuffered, this);
                    };
                    _proto.onInitPtsFound = function onInitPtsFound(event, _ref) {
                        var frag = _ref.frag,
                            id = _ref.id,
                            initPTS = _ref.initPTS;
                        if (id === "main") {
                            var cc = frag.cc;
                            this.initPTS[frag.cc] = initPTS;
                            this.log("InitPTS for cc: " + cc + " found from main: " + initPTS);
                            this.videoTrackCC = cc;
                            if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_INIT_PTS) {
                                this.tick();
                            }
                        }
                    };
                    _proto.startLoad = function startLoad(startPosition) {
                        if (!this.levels) {
                            this.startPosition = startPosition;
                            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].STOPPED;
                            return;
                        }
                        var lastCurrentTime = this.lastCurrentTime;
                        this.stopLoad();
                        this.setInterval(TICK_INTERVAL);
                        this.fragLoadError = 0;
                        if (lastCurrentTime > 0 && startPosition === -1) {
                            this.log("Override startPosition with lastCurrentTime @" + lastCurrentTime.toFixed(3));
                            startPosition = lastCurrentTime;
                            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
                        } else {
                            this.loadedmetadata = false;
                            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_TRACK;
                        }
                        this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
                        this.tick();
                    };
                    _proto.doTick = function doTick() {
                        switch (this.state) {
                            case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE:
                                this.doTickIdle();
                                break;
                            case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_TRACK: {
                                var _levels$trackId;
                                var levels = this.levels,
                                    trackId = this.trackId;
                                var details = levels === null || levels === void 0 ? void 0 : (_levels$trackId = levels[trackId]) === null || _levels$trackId === void 0 ? void 0 : _levels$trackId.details;
                                if (details) {
                                    if (this.waitForCdnTuneIn(details)) {
                                        break;
                                    }
                                    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_INIT_PTS;
                                }
                                break;
                            }
                            case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].FRAG_LOADING_WAITING_RETRY: {
                                var _this$media;
                                var now = performance.now();
                                var retryDate = this.retryDate;
                                if (!retryDate || now >= retryDate || ((_this$media = this.media) !== null && _this$media !== void 0 && _this$media.seeking)) {
                                    this.log("RetryDate reached, switch back to IDLE state");
                                    this.resetStartWhenNotLoaded(this.trackId);
                                    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
                                }
                                break;
                            }
                            case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_INIT_PTS: {
                                var waitingData = this.waitingData;
                                if (waitingData) {
                                    var frag = waitingData.frag,
                                        part = waitingData.part,
                                        cache = waitingData.cache,
                                        complete = waitingData.complete;
                                    if (this.initPTS[frag.cc] !== undefined) {
                                        this.waitingData = null;
                                        this.waitingVideoCC = -1;
                                        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].FRAG_LOADING;
                                        var payload = cache.flush();
                                        var data = { frag: frag, part: part, payload: payload, networkDetails: null };
                                        this._handleFragmentLoadProgress(data);
                                        if (complete) {
                                            _BaseStreamController.prototype._handleFragmentLoadComplete.call(this, data);
                                        }
                                    } else if (this.videoTrackCC !== this.waitingVideoCC) {
                                        this.log("Waiting fragment cc (" + frag.cc + ") cancelled because video is at cc " + this.videoTrackCC);
                                        this.clearWaitingFragment();
                                    } else {
                                        var pos = this.getLoadPosition();
                                        var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__["BufferHelper"].bufferInfo(this.mediaBuffer, pos, this.config.maxBufferHole);
                                        var waitingFragmentAtPosition = Object(_fragment_finders__WEBPACK_IMPORTED_MODULE_11__["fragmentWithinToleranceTest"])(bufferInfo.end, this.config.maxFragLookUpTolerance, frag);
                                        if (waitingFragmentAtPosition < 0) {
                                            this.log("Waiting fragment cc (" + frag.cc + ") @ " + frag.start + " cancelled because another fragment at " + bufferInfo.end + " is needed");
                                            this.clearWaitingFragment();
                                        }
                                    }
                                } else {
                                    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
                                }
                            }
                        }
                        this.onTickEnd();
                    };
                    _proto.clearWaitingFragment = function clearWaitingFragment() {
                        var waitingData = this.waitingData;
                        if (waitingData) {
                            this.fragmentTracker.removeFragment(waitingData.frag);
                            this.waitingData = null;
                            this.waitingVideoCC = -1;
                            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
                        }
                    };
                    _proto.resetLoadingState = function resetLoadingState() {
                        this.clearWaitingFragment();
                        _BaseStreamController.prototype.resetLoadingState.call(this);
                    };
                    _proto.onTickEnd = function onTickEnd() {
                        var media = this.media;
                        if (!media || !media.readyState) {
                            return;
                        }
                        var mediaBuffer = this.mediaBuffer ? this.mediaBuffer : media;
                        var buffered = mediaBuffer.buffered;
                        if (!this.loadedmetadata && buffered.length) {
                            this.loadedmetadata = true;
                        }
                        this.lastCurrentTime = media.currentTime;
                    };
                    _proto.doTickIdle = function doTickIdle() {
                        var _frag$decryptdata, _frag$decryptdata2;
                        var hls = this.hls,
                            levels = this.levels,
                            media = this.media,
                            trackId = this.trackId;
                        var config = hls.config;
                        if (!levels || !levels[trackId]) {
                            return;
                        }
                        if (!media && (this.startFragRequested || !config.startFragPrefetch)) {
                            return;
                        }
                        var levelInfo = levels[trackId];
                        var trackDetails = levelInfo.details;
                        if (!trackDetails || (trackDetails.live && this.levelLastLoaded !== trackId) || this.waitForCdnTuneIn(trackDetails)) {
                            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_TRACK;
                            return;
                        }
                        var bufferable = this.mediaBuffer ? this.mediaBuffer : this.media;
                        if (this.bufferFlushed && bufferable) {
                            this.bufferFlushed = false;
                            this.afterBufferFlushed(bufferable, _loader_fragment__WEBPACK_IMPORTED_MODULE_7__["ElementaryStreamTypes"].AUDIO, _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].AUDIO);
                        }
                        var bufferInfo = this.getFwdBufferInfo(bufferable, _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].AUDIO);
                        if (bufferInfo === null) {
                            return;
                        }
                        var mainBufferInfo = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].MAIN);
                        var bufferLen = bufferInfo.len;
                        var maxBufLen = this.getMaxBufferLength(mainBufferInfo === null || mainBufferInfo === void 0 ? void 0 : mainBufferInfo.len);
                        var audioSwitch = this.audioSwitch;
                        if (bufferLen >= maxBufLen && !audioSwitch) {
                            return;
                        }
                        if (!audioSwitch && this._streamEnded(bufferInfo, trackDetails)) {
                            hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].BUFFER_EOS, { type: "audio" });
                            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].ENDED;
                            return;
                        }
                        var fragments = trackDetails.fragments;
                        var start = fragments[0].start;
                        var targetBufferTime = bufferInfo.end;
                        if (audioSwitch && media) {
                            var pos = this.getLoadPosition();
                            targetBufferTime = pos;
                            if (trackDetails.PTSKnown && pos < start) {
                                if (bufferInfo.end > start || bufferInfo.nextStart) {
                                    this.log("Alt audio track ahead of main track, seek to start of alt audio track");
                                    media.currentTime = start + 0.05;
                                }
                            }
                        }
                        if (mainBufferInfo && targetBufferTime > mainBufferInfo.end + trackDetails.targetduration) {
                            return;
                        }
                        if ((!mainBufferInfo || !mainBufferInfo.len) && bufferInfo.len) {
                            return;
                        }
                        var frag = this.getNextFragment(targetBufferTime, trackDetails);
                        if (!frag) {
                            this.bufferFlushed = true;
                            return;
                        }
                        if (
                            ((_frag$decryptdata = frag.decryptdata) === null || _frag$decryptdata === void 0 ? void 0 : _frag$decryptdata.keyFormat) === "identity" &&
                            !((_frag$decryptdata2 = frag.decryptdata) !== null && _frag$decryptdata2 !== void 0 && _frag$decryptdata2.key)
                        ) {
                            this.loadKey(frag, trackDetails);
                        } else {
                            this.loadFragment(frag, trackDetails, targetBufferTime);
                        }
                    };
                    _proto.getMaxBufferLength = function getMaxBufferLength(mainBufferLength) {
                        var maxConfigBuffer = _BaseStreamController.prototype.getMaxBufferLength.call(this);
                        if (!mainBufferLength) {
                            return maxConfigBuffer;
                        }
                        return Math.max(maxConfigBuffer, mainBufferLength);
                    };
                    _proto.onMediaDetaching = function onMediaDetaching() {
                        this.videoBuffer = null;
                        _BaseStreamController.prototype.onMediaDetaching.call(this);
                    };
                    _proto.onAudioTracksUpdated = function onAudioTracksUpdated(event, _ref2) {
                        var audioTracks = _ref2.audioTracks;
                        this.resetTransmuxer();
                        this.levels = audioTracks.map(function (mediaPlaylist) {
                            return new _types_level__WEBPACK_IMPORTED_MODULE_5__["Level"](mediaPlaylist);
                        });
                    };
                    _proto.onAudioTrackSwitching = function onAudioTrackSwitching(event, data) {
                        var altAudio = !!data.url;
                        this.trackId = data.id;
                        var fragCurrent = this.fragCurrent;
                        if (fragCurrent !== null && fragCurrent !== void 0 && fragCurrent.loader) {
                            fragCurrent.loader.abort();
                        }
                        this.fragCurrent = null;
                        this.clearWaitingFragment();
                        if (!altAudio) {
                            this.resetTransmuxer();
                        } else {
                            this.setInterval(TICK_INTERVAL);
                        }
                        if (altAudio) {
                            this.audioSwitch = true;
                            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
                        } else {
                            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].STOPPED;
                        }
                        this.tick();
                    };
                    _proto.onManifestLoading = function onManifestLoading() {
                        this.mainDetails = null;
                        this.fragmentTracker.removeAllFragments();
                        this.startPosition = this.lastCurrentTime = 0;
                        this.bufferFlushed = false;
                    };
                    _proto.onLevelLoaded = function onLevelLoaded(event, data) {
                        this.mainDetails = data.details;
                        if (this.cachedTrackLoadedData !== null) {
                            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].AUDIO_TRACK_LOADED, this.cachedTrackLoadedData);
                            this.cachedTrackLoadedData = null;
                        }
                    };
                    _proto.onAudioTrackLoaded = function onAudioTrackLoaded(event, data) {
                        var _track$details;
                        if (this.mainDetails == null) {
                            this.cachedTrackLoadedData = data;
                            return;
                        }
                        var levels = this.levels;
                        var newDetails = data.details,
                            trackId = data.id;
                        if (!levels) {
                            this.warn("Audio tracks were reset while loading level " + trackId);
                            return;
                        }
                        this.log("Track " + trackId + " loaded [" + newDetails.startSN + "," + newDetails.endSN + "],duration:" + newDetails.totalduration);
                        var track = levels[trackId];
                        var sliding = 0;
                        if (newDetails.live || ((_track$details = track.details) !== null && _track$details !== void 0 && _track$details.live)) {
                            var mainDetails = this.mainDetails;
                            if (!newDetails.fragments[0]) {
                                newDetails.deltaUpdateFailed = true;
                            }
                            if (newDetails.deltaUpdateFailed || !mainDetails) {
                                return;
                            }
                            if (!track.details && newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {
                                Object(_utils_discontinuities__WEBPACK_IMPORTED_MODULE_12__["alignMediaPlaylistByPDT"])(newDetails, mainDetails);
                                sliding = newDetails.fragments[0].start;
                            } else {
                                sliding = this.alignPlaylists(newDetails, track.details);
                            }
                        }
                        track.details = newDetails;
                        this.levelLastLoaded = trackId;
                        if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {
                            this.setStartPosition(track.details, sliding);
                        }
                        if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_TRACK && !this.waitForCdnTuneIn(newDetails)) {
                            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
                        }
                        this.tick();
                    };
                    _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(data) {
                        var _frag$initSegment;
                        var frag = data.frag,
                            part = data.part,
                            payload = data.payload;
                        var config = this.config,
                            trackId = this.trackId,
                            levels = this.levels;
                        if (!levels) {
                            this.warn("Audio tracks were reset while fragment load was in progress. Fragment " + frag.sn + " of level " + frag.level + " will not be buffered");
                            return;
                        }
                        var track = levels[trackId];
                        console.assert(track, "Audio track is defined on fragment load progress");
                        var details = track.details;
                        console.assert(details, "Audio track details are defined on fragment load progress");
                        var audioCodec = config.defaultAudioCodec || track.audioCodec || "mp4a.40.2";
                        var transmuxer = this.transmuxer;
                        if (!transmuxer) {
                            transmuxer = this.transmuxer = new _demux_transmuxer_interface__WEBPACK_IMPORTED_MODULE_9__["default"](
                                this.hls,
                                _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].AUDIO,
                                this._handleTransmuxComplete.bind(this),
                                this._handleTransmuxerFlush.bind(this)
                            );
                        }
                        var initPTS = this.initPTS[frag.cc];
                        var initSegmentData = (_frag$initSegment = frag.initSegment) === null || _frag$initSegment === void 0 ? void 0 : _frag$initSegment.data;
                        if (initPTS !== undefined) {
                            var accurateTimeOffset = false;
                            var partIndex = part ? part.index : -1;
                            var partial = partIndex !== -1;
                            var chunkMeta = new _types_transmuxer__WEBPACK_IMPORTED_MODULE_10__["ChunkMetadata"](frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);
                            transmuxer.push(payload, initSegmentData, audioCodec, "", frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);
                        } else {
                            this.log("Unknown video PTS for cc " + frag.cc + ", waiting for video PTS before demuxing audio frag " + frag.sn + " of [" + details.startSN + " ," + details.endSN + "],track " + trackId);
                            var _this$waitingData = (this.waitingData = this.waitingData || { frag: frag, part: part, cache: new _demux_chunk_cache__WEBPACK_IMPORTED_MODULE_8__["default"](), complete: false }),
                                cache = _this$waitingData.cache;
                            cache.push(new Uint8Array(payload));
                            this.waitingVideoCC = this.videoTrackCC;
                            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_INIT_PTS;
                        }
                    };
                    _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedData) {
                        if (this.waitingData) {
                            this.waitingData.complete = true;
                            return;
                        }
                        _BaseStreamController.prototype._handleFragmentLoadComplete.call(this, fragLoadedData);
                    };
                    _proto.onBufferReset = function onBufferReset() {
                        this.mediaBuffer = this.videoBuffer = null;
                        this.loadedmetadata = false;
                    };
                    _proto.onBufferCreated = function onBufferCreated(event, data) {
                        var audioTrack = data.tracks.audio;
                        if (audioTrack) {
                            this.mediaBuffer = audioTrack.buffer || null;
                        }
                        if (data.tracks.video) {
                            this.videoBuffer = data.tracks.video.buffer || null;
                        }
                    };
                    _proto.onFragBuffered = function onFragBuffered(event, data) {
                        var frag = data.frag,
                            part = data.part;
                        if (frag.type !== _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].AUDIO) {
                            return;
                        }
                        if (this.fragContextChanged(frag)) {
                            this.warn("Fragment " + frag.sn + (part ? " p: " + part.index : "") + " of level " + frag.level + " finished buffering, but was aborted. state: " + this.state + ", audioSwitch: " + this.audioSwitch);
                            return;
                        }
                        if (frag.sn !== "initSegment") {
                            this.fragPrevious = frag;
                            if (this.audioSwitch) {
                                this.audioSwitch = false;
                                this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].AUDIO_TRACK_SWITCHED, { id: this.trackId });
                            }
                        }
                        this.fragBufferedComplete(frag, part);
                    };
                    _proto.onError = function onError(event, data) {
                        switch (data.details) {
                            case _errors__WEBPACK_IMPORTED_MODULE_13__["ErrorDetails"].FRAG_LOAD_ERROR:
                            case _errors__WEBPACK_IMPORTED_MODULE_13__["ErrorDetails"].FRAG_LOAD_TIMEOUT:
                            case _errors__WEBPACK_IMPORTED_MODULE_13__["ErrorDetails"].KEY_LOAD_ERROR:
                            case _errors__WEBPACK_IMPORTED_MODULE_13__["ErrorDetails"].KEY_LOAD_TIMEOUT:
                                this.onFragmentOrKeyLoadError(_types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].AUDIO, data);
                                break;
                            case _errors__WEBPACK_IMPORTED_MODULE_13__["ErrorDetails"].AUDIO_TRACK_LOAD_ERROR:
                            case _errors__WEBPACK_IMPORTED_MODULE_13__["ErrorDetails"].AUDIO_TRACK_LOAD_TIMEOUT:
                                if (this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].ERROR && this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].STOPPED) {
                                    this.state = data.fatal ? _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].ERROR : _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
                                    this.warn(data.details + " while loading frag, switching to " + this.state + " state");
                                }
                                break;
                            case _errors__WEBPACK_IMPORTED_MODULE_13__["ErrorDetails"].BUFFER_FULL_ERROR:
                                if (data.parent === "audio" && (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].PARSING || this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].PARSED)) {
                                    var flushBuffer = true;
                                    var bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].AUDIO);
                                    if (bufferedInfo && bufferedInfo.len > 0.5) {
                                        flushBuffer = !this.reduceMaxBufferLength(bufferedInfo.len);
                                    }
                                    if (flushBuffer) {
                                        this.warn("Buffer full error also media.currentTime is not buffered, flush audio buffer");
                                        this.fragCurrent = null;
                                        _BaseStreamController.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, "audio");
                                    }
                                    this.resetLoadingState();
                                }
                                break;
                            default:
                                break;
                        }
                    };
                    _proto.onBufferFlushed = function onBufferFlushed(event, _ref3) {
                        var type = _ref3.type;
                        if (type === _loader_fragment__WEBPACK_IMPORTED_MODULE_7__["ElementaryStreamTypes"].AUDIO) {
                            this.bufferFlushed = true;
                        }
                    };
                    _proto._handleTransmuxComplete = function _handleTransmuxComplete(transmuxResult) {
                        var _id3$samples;
                        var id = "audio";
                        var hls = this.hls;
                        var remuxResult = transmuxResult.remuxResult,
                            chunkMeta = transmuxResult.chunkMeta;
                        var context = this.getCurrentContext(chunkMeta);
                        if (!context) {
                            this.warn("The loading context changed while buffering fragment " + chunkMeta.sn + " of level " + chunkMeta.level + ". This chunk will not be buffered.");
                            this.resetStartWhenNotLoaded(chunkMeta.level);
                            return;
                        }
                        var frag = context.frag,
                            part = context.part,
                            details = context.level.details;
                        var audio = remuxResult.audio,
                            text = remuxResult.text,
                            id3 = remuxResult.id3,
                            initSegment = remuxResult.initSegment;
                        if (this.fragContextChanged(frag) || !details) {
                            return;
                        }
                        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].PARSING;
                        if (this.audioSwitch && audio) {
                            this.completeAudioSwitch();
                        }
                        if (initSegment !== null && initSegment !== void 0 && initSegment.tracks) {
                            this._bufferInitSegment(initSegment.tracks, frag, chunkMeta);
                            hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].FRAG_PARSING_INIT_SEGMENT, { frag: frag, id: id, tracks: initSegment.tracks });
                        }
                        if (audio) {
                            var startPTS = audio.startPTS,
                                endPTS = audio.endPTS,
                                startDTS = audio.startDTS,
                                endDTS = audio.endDTS;
                            if (part) {
                                part.elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_7__["ElementaryStreamTypes"].AUDIO] = { startPTS: startPTS, endPTS: endPTS, startDTS: startDTS, endDTS: endDTS };
                            }
                            frag.setElementaryStreamInfo(_loader_fragment__WEBPACK_IMPORTED_MODULE_7__["ElementaryStreamTypes"].AUDIO, startPTS, endPTS, startDTS, endDTS);
                            this.bufferFragmentData(audio, frag, part, chunkMeta);
                        }
                        if (id3 !== null && id3 !== void 0 && (_id3$samples = id3.samples) !== null && _id3$samples !== void 0 && _id3$samples.length) {
                            var emittedID3 = _extends({ id: id, frag: frag, details: details }, id3);
                            hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].FRAG_PARSING_METADATA, emittedID3);
                        }
                        if (text) {
                            var emittedText = _extends({ id: id, frag: frag, details: details }, text);
                            hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].FRAG_PARSING_USERDATA, emittedText);
                        }
                    };
                    _proto._bufferInitSegment = function _bufferInitSegment(tracks, frag, chunkMeta) {
                        if (this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].PARSING) {
                            return;
                        }
                        if (tracks.video) {
                            delete tracks.video;
                        }
                        var track = tracks.audio;
                        if (!track) {
                            return;
                        }
                        track.levelCodec = track.codec;
                        track.id = "audio";
                        this.log("Init audio buffer, container:" + track.container + ", codecs[parsed]=[" + track.codec + "]");
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].BUFFER_CODECS, tracks);
                        var initSegment = track.initSegment;
                        if (initSegment !== null && initSegment !== void 0 && initSegment.byteLength) {
                            var segment = { type: "audio", frag: frag, part: null, chunkMeta: chunkMeta, parent: frag.type, data: initSegment };
                            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].BUFFER_APPENDING, segment);
                        }
                        this.tick();
                    };
                    _proto.loadFragment = function loadFragment(frag, trackDetails, targetBufferTime) {
                        var fragState = this.fragmentTracker.getState(frag);
                        this.fragCurrent = frag;
                        if (this.audioSwitch || fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_4__["FragmentState"].NOT_LOADED || fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_4__["FragmentState"].PARTIAL) {
                            if (frag.sn === "initSegment") {
                                this._loadInitSegment(frag);
                            } else if (trackDetails.live && !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(this.initPTS[frag.cc])) {
                                this.log("Waiting for video PTS in continuity counter " + frag.cc + " of live stream before loading audio fragment " + frag.sn + " of level " + this.trackId);
                                this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_INIT_PTS;
                            } else {
                                this.startFragRequested = true;
                                _BaseStreamController.prototype.loadFragment.call(this, frag, trackDetails, targetBufferTime);
                            }
                        }
                    };
                    _proto.completeAudioSwitch = function completeAudioSwitch() {
                        var hls = this.hls,
                            media = this.media,
                            trackId = this.trackId;
                        if (media) {
                            this.log("Switching audio track : flushing all audio");
                            _BaseStreamController.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, "audio");
                        }
                        this.audioSwitch = false;
                        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].AUDIO_TRACK_SWITCHED, { id: trackId });
                    };
                    return AudioStreamController;
                })(_base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["default"]);
                __webpack_exports__["default"] = AudioStreamController;
            },
            "./src/controller/audio-track-controller.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/events.ts");
                var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/errors.ts");
                var _base_playlist_controller__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/controller/base-playlist-controller.ts");
                var _types_loader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/types/loader.ts");
                function _defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    Object.defineProperty(Constructor, "prototype", { writable: false });
                    return Constructor;
                }
                function _inheritsLoose(subClass, superClass) {
                    subClass.prototype = Object.create(superClass.prototype);
                    subClass.prototype.constructor = subClass;
                    _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf
                        ? Object.setPrototypeOf.bind()
                        : function _setPrototypeOf(o, p) {
                              o.__proto__ = p;
                              return o;
                          };
                    return _setPrototypeOf(o, p);
                }
                var AudioTrackController = (function (_BasePlaylistControll) {
                    _inheritsLoose(AudioTrackController, _BasePlaylistControll);
                    function AudioTrackController(hls) {
                        var _this;
                        _this = _BasePlaylistControll.call(this, hls, "[audio-track-controller]") || this;
                        _this.tracks = [];
                        _this.groupId = null;
                        _this.tracksInGroup = [];
                        _this.trackId = -1;
                        _this.trackName = "";
                        _this.selectDefaultTrack = true;
                        _this.registerListeners();
                        return _this;
                    }
                    var _proto = AudioTrackController.prototype;
                    _proto.registerListeners = function registerListeners() {
                        var hls = this.hls;
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MANIFEST_PARSED, this.onManifestParsed, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].LEVEL_LOADING, this.onLevelLoading, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].LEVEL_SWITCHING, this.onLevelSwitching, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, this.onError, this);
                    };
                    _proto.unregisterListeners = function unregisterListeners() {
                        var hls = this.hls;
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MANIFEST_PARSED, this.onManifestParsed, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].LEVEL_LOADING, this.onLevelLoading, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].LEVEL_SWITCHING, this.onLevelSwitching, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, this.onError, this);
                    };
                    _proto.destroy = function destroy() {
                        this.unregisterListeners();
                        this.tracks.length = 0;
                        this.tracksInGroup.length = 0;
                        _BasePlaylistControll.prototype.destroy.call(this);
                    };
                    _proto.onManifestLoading = function onManifestLoading() {
                        this.tracks = [];
                        this.groupId = null;
                        this.tracksInGroup = [];
                        this.trackId = -1;
                        this.trackName = "";
                        this.selectDefaultTrack = true;
                    };
                    _proto.onManifestParsed = function onManifestParsed(event, data) {
                        this.tracks = data.audioTracks || [];
                    };
                    _proto.onAudioTrackLoaded = function onAudioTrackLoaded(event, data) {
                        var id = data.id,
                            details = data.details;
                        var currentTrack = this.tracksInGroup[id];
                        if (!currentTrack) {
                            this.warn("Invalid audio track id " + id);
                            return;
                        }
                        var curDetails = currentTrack.details;
                        currentTrack.details = data.details;
                        this.log("audioTrack " + id + " loaded [" + details.startSN + "-" + details.endSN + "]");
                        if (id === this.trackId) {
                            this.retryCount = 0;
                            this.playlistLoaded(id, data, curDetails);
                        }
                    };
                    _proto.onLevelLoading = function onLevelLoading(event, data) {
                        this.switchLevel(data.level);
                    };
                    _proto.onLevelSwitching = function onLevelSwitching(event, data) {
                        this.switchLevel(data.level);
                    };
                    _proto.switchLevel = function switchLevel(levelIndex) {
                        var levelInfo = this.hls.levels[levelIndex];
                        if (!(levelInfo !== null && levelInfo !== void 0 && levelInfo.audioGroupIds)) {
                            return;
                        }
                        var audioGroupId = levelInfo.audioGroupIds[levelInfo.urlId];
                        if (this.groupId !== audioGroupId) {
                            this.groupId = audioGroupId;
                            var audioTracks = this.tracks.filter(function (track) {
                                return !audioGroupId || track.groupId === audioGroupId;
                            });
                            if (
                                this.selectDefaultTrack &&
                                !audioTracks.some(function (track) {
                                    return track.default;
                                })
                            ) {
                                this.selectDefaultTrack = false;
                            }
                            this.tracksInGroup = audioTracks;
                            var audioTracksUpdated = { audioTracks: audioTracks };
                            this.log("Updating audio tracks, " + audioTracks.length + ' track(s) found in "' + audioGroupId + '" group-id');
                            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].AUDIO_TRACKS_UPDATED, audioTracksUpdated);
                            this.selectInitialTrack();
                        }
                    };
                    _proto.onError = function onError(event, data) {
                        _BasePlaylistControll.prototype.onError.call(this, event, data);
                        if (data.fatal || !data.context) {
                            return;
                        }
                        if (data.context.type === _types_loader__WEBPACK_IMPORTED_MODULE_3__["PlaylistContextType"].AUDIO_TRACK && data.context.id === this.trackId && data.context.groupId === this.groupId) {
                            this.retryLoadingOrFail(data);
                        }
                    };
                    _proto.setAudioTrack = function setAudioTrack(newId) {
                        var tracks = this.tracksInGroup;
                        if (newId < 0 || newId >= tracks.length) {
                            this.warn("Invalid id passed to audio-track controller");
                            return;
                        }
                        this.clearTimer();
                        var lastTrack = tracks[this.trackId];
                        this.log("Now switching to audio-track index " + newId);
                        var track = tracks[newId];
                        var id = track.id,
                            _track$groupId = track.groupId,
                            groupId = _track$groupId === void 0 ? "" : _track$groupId,
                            name = track.name,
                            type = track.type,
                            url = track.url;
                        this.trackId = newId;
                        this.trackName = name;
                        this.selectDefaultTrack = false;
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].AUDIO_TRACK_SWITCHING, { id: id, groupId: groupId, name: name, type: type, url: url });
                        if (track.details && !track.details.live) {
                            return;
                        }
                        var hlsUrlParameters = this.switchParams(track.url, lastTrack === null || lastTrack === void 0 ? void 0 : lastTrack.details);
                        this.loadPlaylist(hlsUrlParameters);
                    };
                    _proto.selectInitialTrack = function selectInitialTrack() {
                        var audioTracks = this.tracksInGroup;
                        console.assert(audioTracks.length, "Initial audio track should be selected when tracks are known");
                        var currentAudioTrackName = this.trackName;
                        var trackId = this.findTrackId(currentAudioTrackName) || this.findTrackId();
                        if (trackId !== -1) {
                            this.setAudioTrack(trackId);
                        } else {
                            this.warn("No track found for running audio group-ID: " + this.groupId);
                            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, {
                                type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].MEDIA_ERROR,
                                details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].AUDIO_TRACK_LOAD_ERROR,
                                fatal: true,
                            });
                        }
                    };
                    _proto.findTrackId = function findTrackId(name) {
                        var audioTracks = this.tracksInGroup;
                        for (var i = 0; i < audioTracks.length; i++) {
                            var track = audioTracks[i];
                            if (!this.selectDefaultTrack || track.default) {
                                if (!name || name === track.name) {
                                    return track.id;
                                }
                            }
                        }
                        return -1;
                    };
                    _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {
                        var audioTrack = this.tracksInGroup[this.trackId];
                        if (this.shouldLoadTrack(audioTrack)) {
                            var id = audioTrack.id;
                            var groupId = audioTrack.groupId;
                            var url = audioTrack.url;
                            if (hlsUrlParameters) {
                                try {
                                    url = hlsUrlParameters.addDirectives(url);
                                } catch (error) {
                                    this.warn("Could not construct new URL with HLS Delivery Directives: " + error);
                                }
                            }
                            this.log("loading audio-track playlist for id: " + id);
                            this.clearTimer();
                            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].AUDIO_TRACK_LOADING, { url: url, id: id, groupId: groupId, deliveryDirectives: hlsUrlParameters || null });
                        }
                    };
                    _createClass(AudioTrackController, [
                        {
                            key: "audioTracks",
                            get: function get() {
                                return this.tracksInGroup;
                            },
                        },
                        {
                            key: "audioTrack",
                            get: function get() {
                                return this.trackId;
                            },
                            set: function set(newId) {
                                this.selectDefaultTrack = false;
                                this.setAudioTrack(newId);
                            },
                        },
                    ]);
                    return AudioTrackController;
                })(_base_playlist_controller__WEBPACK_IMPORTED_MODULE_2__["default"]);
                __webpack_exports__["default"] = AudioTrackController;
            },
            "./src/controller/base-playlist-controller.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "default", function () {
                    return BasePlaylistController;
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/polyfills/number.ts");
                var _types_level__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/types/level.ts");
                var _level_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/controller/level-helper.ts");
                var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/utils/logger.ts");
                var _errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/errors.ts");
                var BasePlaylistController = (function () {
                    function BasePlaylistController(hls, logPrefix) {
                        this.hls = void 0;
                        this.timer = -1;
                        this.canLoad = false;
                        this.retryCount = 0;
                        this.log = void 0;
                        this.warn = void 0;
                        this.log = _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].log.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"], logPrefix + ":");
                        this.warn = _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].warn.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"], logPrefix + ":");
                        this.hls = hls;
                    }
                    var _proto = BasePlaylistController.prototype;
                    _proto.destroy = function destroy() {
                        this.clearTimer();
                        this.hls = this.log = this.warn = null;
                    };
                    _proto.onError = function onError(event, data) {
                        if (data.fatal && data.type === _errors__WEBPACK_IMPORTED_MODULE_4__["ErrorTypes"].NETWORK_ERROR) {
                            this.clearTimer();
                        }
                    };
                    _proto.clearTimer = function clearTimer() {
                        clearTimeout(this.timer);
                        this.timer = -1;
                    };
                    _proto.startLoad = function startLoad() {
                        this.canLoad = true;
                        this.retryCount = 0;
                        this.loadPlaylist();
                    };
                    _proto.stopLoad = function stopLoad() {
                        this.canLoad = false;
                        this.clearTimer();
                    };
                    _proto.switchParams = function switchParams(playlistUri, previous) {
                        var renditionReports = previous === null || previous === void 0 ? void 0 : previous.renditionReports;
                        if (renditionReports) {
                            for (var i = 0; i < renditionReports.length; i++) {
                                var attr = renditionReports[i];
                                var uri = "" + attr.URI;
                                if (uri === playlistUri.slice(-uri.length)) {
                                    var msn = parseInt(attr["LAST-MSN"]);
                                    var part = parseInt(attr["LAST-PART"]);
                                    if (previous && this.hls.config.lowLatencyMode) {
                                        var currentGoal = Math.min(previous.age - previous.partTarget, previous.targetduration);
                                        if (part !== undefined && currentGoal > previous.partTarget) {
                                            part += 1;
                                        }
                                    }
                                    if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(msn)) {
                                        return new _types_level__WEBPACK_IMPORTED_MODULE_1__["HlsUrlParameters"](
                                            msn,
                                            Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(part) ? part : undefined,
                                            _types_level__WEBPACK_IMPORTED_MODULE_1__["HlsSkip"].No
                                        );
                                    }
                                }
                            }
                        }
                    };
                    _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {};
                    _proto.shouldLoadTrack = function shouldLoadTrack(track) {
                        return this.canLoad && track && !!track.url && (!track.details || track.details.live);
                    };
                    _proto.playlistLoaded = function playlistLoaded(index, data, previousDetails) {
                        var _this = this;
                        var details = data.details,
                            stats = data.stats;
                        var elapsed = stats.loading.end ? Math.max(0, self.performance.now() - stats.loading.end) : 0;
                        details.advancedDateTime = Date.now() - elapsed;
                        if (details.live || (previousDetails !== null && previousDetails !== void 0 && previousDetails.live)) {
                            details.reloaded(previousDetails);
                            if (previousDetails) {
                                this.log("live playlist " + index + " " + (details.advanced ? "REFRESHED " + details.lastPartSn + "-" + details.lastPartIndex : "MISSED"));
                            }
                            if (previousDetails && details.fragments.length > 0) {
                                Object(_level_helper__WEBPACK_IMPORTED_MODULE_2__["mergeDetails"])(previousDetails, details);
                            }
                            if (!this.canLoad || !details.live) {
                                return;
                            }
                            var deliveryDirectives;
                            var msn = undefined;
                            var part = undefined;
                            if (details.canBlockReload && details.endSN && details.advanced) {
                                var lowLatencyMode = this.hls.config.lowLatencyMode;
                                var lastPartSn = details.lastPartSn;
                                var endSn = details.endSN;
                                var lastPartIndex = details.lastPartIndex;
                                var hasParts = lastPartIndex !== -1;
                                var lastPart = lastPartSn === endSn;
                                var nextSnStartIndex = lowLatencyMode ? 0 : lastPartIndex;
                                if (hasParts) {
                                    msn = lastPart ? endSn + 1 : lastPartSn;
                                    part = lastPart ? nextSnStartIndex : lastPartIndex + 1;
                                } else {
                                    msn = endSn + 1;
                                }
                                var lastAdvanced = details.age;
                                var cdnAge = lastAdvanced + details.ageHeader;
                                var currentGoal = Math.min(cdnAge - details.partTarget, details.targetduration * 1.5);
                                if (currentGoal > 0) {
                                    if (previousDetails && currentGoal > previousDetails.tuneInGoal) {
                                        this.warn("CDN Tune-in goal increased from: " + previousDetails.tuneInGoal + " to: " + currentGoal + " with playlist age: " + details.age);
                                        currentGoal = 0;
                                    } else {
                                        var segments = Math.floor(currentGoal / details.targetduration);
                                        msn += segments;
                                        if (part !== undefined) {
                                            var parts = Math.round((currentGoal % details.targetduration) / details.partTarget);
                                            part += parts;
                                        }
                                        this.log("CDN Tune-in age: " + details.ageHeader + "s last advanced " + lastAdvanced.toFixed(2) + "s goal: " + currentGoal + " skip sn " + segments + " to part " + part);
                                    }
                                    details.tuneInGoal = currentGoal;
                                }
                                deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);
                                if (lowLatencyMode || !lastPart) {
                                    this.loadPlaylist(deliveryDirectives);
                                    return;
                                }
                            } else {
                                deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);
                            }
                            var reloadInterval = Object(_level_helper__WEBPACK_IMPORTED_MODULE_2__["computeReloadInterval"])(details, stats);
                            if (msn !== undefined && details.canBlockReload) {
                                reloadInterval -= details.partTarget || 1;
                            }
                            this.log("reload live playlist " + index + " in " + Math.round(reloadInterval) + " ms");
                            this.timer = self.setTimeout(function () {
                                return _this.loadPlaylist(deliveryDirectives);
                            }, reloadInterval);
                        } else {
                            this.clearTimer();
                        }
                    };
                    _proto.getDeliveryDirectives = function getDeliveryDirectives(details, previousDeliveryDirectives, msn, part) {
                        var skip = Object(_types_level__WEBPACK_IMPORTED_MODULE_1__["getSkipValue"])(details, msn);
                        if (previousDeliveryDirectives !== null && previousDeliveryDirectives !== void 0 && previousDeliveryDirectives.skip && details.deltaUpdateFailed) {
                            msn = previousDeliveryDirectives.msn;
                            part = previousDeliveryDirectives.part;
                            skip = _types_level__WEBPACK_IMPORTED_MODULE_1__["HlsSkip"].No;
                        }
                        return new _types_level__WEBPACK_IMPORTED_MODULE_1__["HlsUrlParameters"](msn, part, skip);
                    };
                    _proto.retryLoadingOrFail = function retryLoadingOrFail(errorEvent) {
                        var _this2 = this;
                        var config = this.hls.config;
                        var retry = this.retryCount < config.levelLoadingMaxRetry;
                        if (retry) {
                            var _errorEvent$context;
                            this.retryCount++;
                            if (errorEvent.details.indexOf("LoadTimeOut") > -1 && (_errorEvent$context = errorEvent.context) !== null && _errorEvent$context !== void 0 && _errorEvent$context.deliveryDirectives) {
                                this.warn("retry playlist loading #" + this.retryCount + ' after "' + errorEvent.details + '"');
                                this.loadPlaylist();
                            } else {
                                var delay = Math.min(Math.pow(2, this.retryCount) * config.levelLoadingRetryDelay, config.levelLoadingMaxRetryTimeout);
                                this.timer = self.setTimeout(function () {
                                    return _this2.loadPlaylist();
                                }, delay);
                                this.warn("retry playlist loading #" + this.retryCount + " in " + delay + ' ms after "' + errorEvent.details + '"');
                            }
                        } else {
                            this.warn('cannot recover from error "' + errorEvent.details + '"');
                            this.clearTimer();
                            errorEvent.fatal = true;
                        }
                        return retry;
                    };
                    return BasePlaylistController;
                })();
            },
            "./src/controller/base-stream-controller.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "State", function () {
                    return State;
                });
                __webpack_require__.d(__webpack_exports__, "default", function () {
                    return BaseStreamController;
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/polyfills/number.ts");
                var _task_loop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/task-loop.ts");
                var _fragment_tracker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/controller/fragment-tracker.ts");
                var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/utils/buffer-helper.ts");
                var _utils_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/utils/logger.ts");
                var _events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/events.ts");
                var _errors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/errors.ts");
                var _types_transmuxer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/types/transmuxer.ts");
                var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./src/utils/mp4-tools.ts");
                var _utils_discontinuities__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./src/utils/discontinuities.ts");
                var _fragment_finders__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./src/controller/fragment-finders.ts");
                var _level_helper__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./src/controller/level-helper.ts");
                var _loader_fragment_loader__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./src/loader/fragment-loader.ts");
                var _crypt_decrypter__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./src/crypt/decrypter.ts");
                var _utils_time_ranges__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("./src/utils/time-ranges.ts");
                var _types_loader__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("./src/types/loader.ts");
                function _defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    Object.defineProperty(Constructor, "prototype", { writable: false });
                    return Constructor;
                }
                function _assertThisInitialized(self) {
                    if (self === void 0) {
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return self;
                }
                function _inheritsLoose(subClass, superClass) {
                    subClass.prototype = Object.create(superClass.prototype);
                    subClass.prototype.constructor = subClass;
                    _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf
                        ? Object.setPrototypeOf.bind()
                        : function _setPrototypeOf(o, p) {
                              o.__proto__ = p;
                              return o;
                          };
                    return _setPrototypeOf(o, p);
                }
                var State = {
                    STOPPED: "STOPPED",
                    IDLE: "IDLE",
                    KEY_LOADING: "KEY_LOADING",
                    FRAG_LOADING: "FRAG_LOADING",
                    FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
                    WAITING_TRACK: "WAITING_TRACK",
                    PARSING: "PARSING",
                    PARSED: "PARSED",
                    ENDED: "ENDED",
                    ERROR: "ERROR",
                    WAITING_INIT_PTS: "WAITING_INIT_PTS",
                    WAITING_LEVEL: "WAITING_LEVEL",
                };
                var BaseStreamController = (function (_TaskLoop) {
                    _inheritsLoose(BaseStreamController, _TaskLoop);
                    function BaseStreamController(hls, fragmentTracker, logPrefix) {
                        var _this;
                        _this = _TaskLoop.call(this) || this;
                        _this.hls = void 0;
                        _this.fragPrevious = null;
                        _this.fragCurrent = null;
                        _this.fragmentTracker = void 0;
                        _this.transmuxer = null;
                        _this._state = State.STOPPED;
                        _this.media = null;
                        _this.mediaBuffer = null;
                        _this.config = void 0;
                        _this.bitrateTest = false;
                        _this.lastCurrentTime = 0;
                        _this.nextLoadPosition = 0;
                        _this.startPosition = 0;
                        _this.loadedmetadata = false;
                        _this.fragLoadError = 0;
                        _this.retryDate = 0;
                        _this.levels = null;
                        _this.fragmentLoader = void 0;
                        _this.levelLastLoaded = null;
                        _this.startFragRequested = false;
                        _this.decrypter = void 0;
                        _this.initPTS = [];
                        _this.onvseeking = null;
                        _this.onvended = null;
                        _this.logPrefix = "";
                        _this.log = void 0;
                        _this.warn = void 0;
                        _this.logPrefix = logPrefix;
                        _this.log = _utils_logger__WEBPACK_IMPORTED_MODULE_4__["logger"].log.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_4__["logger"], logPrefix + ":");
                        _this.warn = _utils_logger__WEBPACK_IMPORTED_MODULE_4__["logger"].warn.bind(_utils_logger__WEBPACK_IMPORTED_MODULE_4__["logger"], logPrefix + ":");
                        _this.hls = hls;
                        _this.fragmentLoader = new _loader_fragment_loader__WEBPACK_IMPORTED_MODULE_12__["default"](hls.config);
                        _this.fragmentTracker = fragmentTracker;
                        _this.config = hls.config;
                        _this.decrypter = new _crypt_decrypter__WEBPACK_IMPORTED_MODULE_13__["default"](hls, hls.config);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].KEY_LOADED, _this.onKeyLoaded, _assertThisInitialized(_this));
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].LEVEL_SWITCHING, _this.onLevelSwitching, _assertThisInitialized(_this));
                        return _this;
                    }
                    var _proto = BaseStreamController.prototype;
                    _proto.doTick = function doTick() {
                        this.onTickEnd();
                    };
                    _proto.onTickEnd = function onTickEnd() {};
                    _proto.startLoad = function startLoad(startPosition) {};
                    _proto.stopLoad = function stopLoad() {
                        this.fragmentLoader.abort();
                        var frag = this.fragCurrent;
                        if (frag) {
                            this.fragmentTracker.removeFragment(frag);
                        }
                        this.resetTransmuxer();
                        this.fragCurrent = null;
                        this.fragPrevious = null;
                        this.clearInterval();
                        this.clearNextTick();
                        this.state = State.STOPPED;
                    };
                    _proto._streamEnded = function _streamEnded(bufferInfo, levelDetails) {
                        var fragCurrent = this.fragCurrent,
                            fragmentTracker = this.fragmentTracker;
                        if (!levelDetails.live && fragCurrent && this.media && fragCurrent.sn >= levelDetails.endSN && !bufferInfo.nextStart) {
                            var partList = levelDetails.partList;
                            if (partList !== null && partList !== void 0 && partList.length) {
                                var lastPart = partList[partList.length - 1];
                                var lastPartBuffered = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__["BufferHelper"].isBuffered(this.media, lastPart.start + lastPart.duration / 2);
                                return lastPartBuffered;
                            }
                            var fragState = fragmentTracker.getState(fragCurrent);
                            return fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_2__["FragmentState"].PARTIAL || fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_2__["FragmentState"].OK;
                        }
                        return false;
                    };
                    _proto.onMediaAttached = function onMediaAttached(event, data) {
                        var media = (this.media = this.mediaBuffer = data.media);
                        this.onvseeking = this.onMediaSeeking.bind(this);
                        this.onvended = this.onMediaEnded.bind(this);
                        media.addEventListener("seeking", this.onvseeking);
                        media.addEventListener("ended", this.onvended);
                        var config = this.config;
                        if (this.levels && config.autoStartLoad && this.state === State.STOPPED) {
                            this.startLoad(config.startPosition);
                        }
                    };
                    _proto.onMediaDetaching = function onMediaDetaching() {
                        var media = this.media;
                        if (media !== null && media !== void 0 && media.ended) {
                            this.log("MSE detaching and video ended, reset startPosition");
                            this.startPosition = this.lastCurrentTime = 0;
                        }
                        if (media && this.onvseeking && this.onvended) {
                            media.removeEventListener("seeking", this.onvseeking);
                            media.removeEventListener("ended", this.onvended);
                            this.onvseeking = this.onvended = null;
                        }
                        this.media = this.mediaBuffer = null;
                        this.loadedmetadata = false;
                        this.fragmentTracker.removeAllFragments();
                        this.stopLoad();
                    };
                    _proto.onMediaSeeking = function onMediaSeeking() {
                        var config = this.config,
                            fragCurrent = this.fragCurrent,
                            media = this.media,
                            mediaBuffer = this.mediaBuffer,
                            state = this.state;
                        var currentTime = media ? media.currentTime : 0;
                        var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__["BufferHelper"].bufferInfo(mediaBuffer ? mediaBuffer : media, currentTime, config.maxBufferHole);
                        this.log("media seeking to " + (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(currentTime) ? currentTime.toFixed(3) : currentTime) + ", state: " + state);
                        if (state === State.ENDED) {
                            this.resetLoadingState();
                        } else if (fragCurrent && !bufferInfo.len) {
                            var tolerance = config.maxFragLookUpTolerance;
                            var fragStartOffset = fragCurrent.start - tolerance;
                            var fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
                            var pastFragment = currentTime > fragEndOffset;
                            if (currentTime < fragStartOffset || pastFragment) {
                                if (pastFragment && fragCurrent.loader) {
                                    this.log("seeking outside of buffer while fragment load in progress, cancel fragment load");
                                    fragCurrent.loader.abort();
                                }
                                this.resetLoadingState();
                            }
                        }
                        if (media) {
                            this.lastCurrentTime = currentTime;
                        }
                        if (!this.loadedmetadata && !bufferInfo.len) {
                            this.nextLoadPosition = this.startPosition = currentTime;
                        }
                        this.tickImmediate();
                    };
                    _proto.onMediaEnded = function onMediaEnded() {
                        this.startPosition = this.lastCurrentTime = 0;
                    };
                    _proto.onKeyLoaded = function onKeyLoaded(event, data) {
                        if (this.state !== State.KEY_LOADING || data.frag !== this.fragCurrent || !this.levels) {
                            return;
                        }
                        this.state = State.IDLE;
                        var levelDetails = this.levels[data.frag.level].details;
                        if (levelDetails) {
                            this.loadFragment(data.frag, levelDetails, data.frag.start);
                        }
                    };
                    _proto.onLevelSwitching = function onLevelSwitching(event, data) {
                        this.fragLoadError = 0;
                    };
                    _proto.onHandlerDestroying = function onHandlerDestroying() {
                        this.stopLoad();
                        _TaskLoop.prototype.onHandlerDestroying.call(this);
                    };
                    _proto.onHandlerDestroyed = function onHandlerDestroyed() {
                        this.state = State.STOPPED;
                        this.hls.off(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].KEY_LOADED, this.onKeyLoaded, this);
                        this.hls.off(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].LEVEL_SWITCHING, this.onLevelSwitching, this);
                        if (this.fragmentLoader) {
                            this.fragmentLoader.destroy();
                        }
                        if (this.decrypter) {
                            this.decrypter.destroy();
                        }
                        this.hls = this.log = this.warn = this.decrypter = this.fragmentLoader = this.fragmentTracker = null;
                        _TaskLoop.prototype.onHandlerDestroyed.call(this);
                    };
                    _proto.loadKey = function loadKey(frag, details) {
                        this.log("Loading key for " + frag.sn + " of [" + details.startSN + "-" + details.endSN + "], " + (this.logPrefix === "[stream-controller]" ? "level" : "track") + " " + frag.level);
                        this.state = State.KEY_LOADING;
                        this.fragCurrent = frag;
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].KEY_LOADING, { frag: frag });
                    };
                    _proto.loadFragment = function loadFragment(frag, levelDetails, targetBufferTime) {
                        this._loadFragForPlayback(frag, levelDetails, targetBufferTime);
                    };
                    _proto._loadFragForPlayback = function _loadFragForPlayback(frag, levelDetails, targetBufferTime) {
                        var _this2 = this;
                        var progressCallback = function progressCallback(data) {
                            if (_this2.fragContextChanged(frag)) {
                                _this2.warn("Fragment " + frag.sn + (data.part ? " p: " + data.part.index : "") + " of level " + frag.level + " was dropped during download.");
                                _this2.fragmentTracker.removeFragment(frag);
                                return;
                            }
                            frag.stats.chunkCount++;
                            _this2._handleFragmentLoadProgress(data);
                        };
                        this._doFragLoad(frag, levelDetails, targetBufferTime, progressCallback)
                            .then(function (data) {
                                if (!data) {
                                    return;
                                }
                                _this2.fragLoadError = 0;
                                var state = _this2.state;
                                if (_this2.fragContextChanged(frag)) {
                                    if (state === State.FRAG_LOADING || (!_this2.fragCurrent && state === State.PARSING)) {
                                        _this2.fragmentTracker.removeFragment(frag);
                                        _this2.state = State.IDLE;
                                    }
                                    return;
                                }
                                if ("payload" in data) {
                                    _this2.log("Loaded fragment " + frag.sn + " of level " + frag.level);
                                    _this2.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].FRAG_LOADED, data);
                                }
                                _this2._handleFragmentLoadComplete(data);
                            })
                            .catch(function (reason) {
                                if (_this2.state === State.STOPPED || _this2.state === State.ERROR) {
                                    return;
                                }
                                _this2.warn(reason);
                                _this2.resetFragmentLoading(frag);
                            });
                    };
                    _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset, type) {
                        if (type === void 0) {
                            type = null;
                        }
                        if (!(startOffset - endOffset)) {
                            return;
                        }
                        var flushScope = { startOffset: startOffset, endOffset: endOffset, type: type };
                        this.fragLoadError = 0;
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].BUFFER_FLUSHING, flushScope);
                    };
                    _proto._loadInitSegment = function _loadInitSegment(frag) {
                        var _this3 = this;
                        this._doFragLoad(frag)
                            .then(function (data) {
                                if (!data || _this3.fragContextChanged(frag) || !_this3.levels) {
                                    throw new Error("init load aborted");
                                }
                                return data;
                            })
                            .then(function (data) {
                                var hls = _this3.hls;
                                var payload = data.payload;
                                var decryptData = frag.decryptdata;
                                if (payload && payload.byteLength > 0 && decryptData && decryptData.key && decryptData.iv && decryptData.method === "AES-128") {
                                    var startTime = self.performance.now();
                                    return _this3.decrypter.webCryptoDecrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).then(function (decryptedData) {
                                        var endTime = self.performance.now();
                                        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].FRAG_DECRYPTED, { frag: frag, payload: decryptedData, stats: { tstart: startTime, tdecrypt: endTime } });
                                        data.payload = decryptedData;
                                        return data;
                                    });
                                }
                                return data;
                            })
                            .then(function (data) {
                                var fragCurrent = _this3.fragCurrent,
                                    hls = _this3.hls,
                                    levels = _this3.levels;
                                if (!levels) {
                                    throw new Error("init load aborted, missing levels");
                                }
                                var details = levels[frag.level].details;
                                console.assert(details, "Level details are defined when init segment is loaded");
                                var stats = frag.stats;
                                _this3.state = State.IDLE;
                                _this3.fragLoadError = 0;
                                frag.data = new Uint8Array(data.payload);
                                stats.parsing.start = stats.buffering.start = self.performance.now();
                                stats.parsing.end = stats.buffering.end = self.performance.now();
                                if (data.frag === fragCurrent) {
                                    hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].FRAG_BUFFERED, { stats: stats, frag: fragCurrent, part: null, id: frag.type });
                                }
                                _this3.tick();
                            })
                            .catch(function (reason) {
                                if (_this3.state === State.STOPPED || _this3.state === State.ERROR) {
                                    return;
                                }
                                _this3.warn(reason);
                                _this3.resetFragmentLoading(frag);
                            });
                    };
                    _proto.fragContextChanged = function fragContextChanged(frag) {
                        var fragCurrent = this.fragCurrent;
                        return !frag || !fragCurrent || frag.level !== fragCurrent.level || frag.sn !== fragCurrent.sn || frag.urlId !== fragCurrent.urlId;
                    };
                    _proto.fragBufferedComplete = function fragBufferedComplete(frag, part) {
                        var media = this.mediaBuffer ? this.mediaBuffer : this.media;
                        this.log(
                            "Buffered " +
                                frag.type +
                                " sn: " +
                                frag.sn +
                                (part ? " part: " + part.index : "") +
                                " of " +
                                (this.logPrefix === "[stream-controller]" ? "level" : "track") +
                                " " +
                                frag.level +
                                " " +
                                (media ? _utils_time_ranges__WEBPACK_IMPORTED_MODULE_14__["default"].toString(_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__["BufferHelper"].getBuffered(media)) : "(detached)")
                        );
                        this.state = State.IDLE;
                        if (!media) {
                            return;
                        }
                        if (!this.loadedmetadata && media.buffered.length && this.fragCurrent === this.fragPrevious) {
                            this.loadedmetadata = true;
                            this.seekToStartPos();
                        }
                        this.tick();
                    };
                    _proto.seekToStartPos = function seekToStartPos() {};
                    _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedEndData) {
                        var transmuxer = this.transmuxer;
                        if (!transmuxer) {
                            return;
                        }
                        var frag = fragLoadedEndData.frag,
                            part = fragLoadedEndData.part,
                            partsLoaded = fragLoadedEndData.partsLoaded;
                        var complete =
                            !partsLoaded ||
                            partsLoaded.length === 0 ||
                            partsLoaded.some(function (fragLoaded) {
                                return !fragLoaded;
                            });
                        var chunkMeta = new _types_transmuxer__WEBPACK_IMPORTED_MODULE_7__["ChunkMetadata"](frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, !complete);
                        transmuxer.flush(chunkMeta);
                    };
                    _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(frag) {};
                    _proto._doFragLoad = function _doFragLoad(frag, details, targetBufferTime, progressCallback) {
                        var _this4 = this;
                        if (targetBufferTime === void 0) {
                            targetBufferTime = null;
                        }
                        if (!this.levels) {
                            throw new Error("frag load aborted, missing levels");
                        }
                        targetBufferTime = Math.max(frag.start, targetBufferTime || 0);
                        if (this.config.lowLatencyMode && details) {
                            var partList = details.partList;
                            if (partList && progressCallback) {
                                if (targetBufferTime > frag.end && details.fragmentHint) {
                                    frag = details.fragmentHint;
                                }
                                var partIndex = this.getNextPart(partList, frag, targetBufferTime);
                                if (partIndex > -1) {
                                    var part = partList[partIndex];
                                    this.log(
                                        "Loading part sn: " +
                                            frag.sn +
                                            " p: " +
                                            part.index +
                                            " cc: " +
                                            frag.cc +
                                            " of playlist [" +
                                            details.startSN +
                                            "-" +
                                            details.endSN +
                                            "] parts [0-" +
                                            partIndex +
                                            "-" +
                                            (partList.length - 1) +
                                            "] " +
                                            (this.logPrefix === "[stream-controller]" ? "level" : "track") +
                                            ": " +
                                            frag.level +
                                            ", target: " +
                                            parseFloat(targetBufferTime.toFixed(3))
                                    );
                                    this.nextLoadPosition = part.start + part.duration;
                                    this.state = State.FRAG_LOADING;
                                    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].FRAG_LOADING, { frag: frag, part: partList[partIndex], targetBufferTime: targetBufferTime });
                                    return this.doFragPartsLoad(frag, partList, partIndex, progressCallback).catch(function (error) {
                                        return _this4.handleFragLoadError(error);
                                    });
                                } else if (!frag.url || this.loadedEndOfParts(partList, targetBufferTime)) {
                                    return Promise.resolve(null);
                                }
                            }
                        }
                        this.log(
                            "Loading fragment " +
                                frag.sn +
                                " cc: " +
                                frag.cc +
                                " " +
                                (details ? "of [" + details.startSN + "-" + details.endSN + "] " : "") +
                                (this.logPrefix === "[stream-controller]" ? "level" : "track") +
                                ": " +
                                frag.level +
                                ", target: " +
                                parseFloat(targetBufferTime.toFixed(3))
                        );
                        if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(frag.sn) && !this.bitrateTest) {
                            this.nextLoadPosition = frag.start + frag.duration;
                        }
                        this.state = State.FRAG_LOADING;
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].FRAG_LOADING, { frag: frag, targetBufferTime: targetBufferTime });
                        return this.fragmentLoader.load(frag, progressCallback).catch(function (error) {
                            return _this4.handleFragLoadError(error);
                        });
                    };
                    _proto.doFragPartsLoad = function doFragPartsLoad(frag, partList, partIndex, progressCallback) {
                        var _this5 = this;
                        return new Promise(function (resolve, reject) {
                            var partsLoaded = [];
                            var loadPartIndex = function loadPartIndex(index) {
                                var part = partList[index];
                                _this5.fragmentLoader
                                    .loadPart(frag, part, progressCallback)
                                    .then(function (partLoadedData) {
                                        partsLoaded[part.index] = partLoadedData;
                                        var loadedPart = partLoadedData.part;
                                        _this5.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].FRAG_LOADED, partLoadedData);
                                        var nextPart = partList[index + 1];
                                        if (nextPart && nextPart.fragment === frag) {
                                            loadPartIndex(index + 1);
                                        } else {
                                            return resolve({ frag: frag, part: loadedPart, partsLoaded: partsLoaded });
                                        }
                                    })
                                    .catch(reject);
                            };
                            loadPartIndex(partIndex);
                        });
                    };
                    _proto.handleFragLoadError = function handleFragLoadError(_ref) {
                        var data = _ref.data;
                        if (data && data.details === _errors__WEBPACK_IMPORTED_MODULE_6__["ErrorDetails"].INTERNAL_ABORTED) {
                            this.handleFragLoadAborted(data.frag, data.part);
                        } else {
                            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].ERROR, data);
                        }
                        return null;
                    };
                    _proto._handleTransmuxerFlush = function _handleTransmuxerFlush(chunkMeta) {
                        var context = this.getCurrentContext(chunkMeta);
                        if (!context || this.state !== State.PARSING) {
                            if (!this.fragCurrent) {
                                this.state = State.IDLE;
                            }
                            return;
                        }
                        var frag = context.frag,
                            part = context.part,
                            level = context.level;
                        var now = self.performance.now();
                        frag.stats.parsing.end = now;
                        if (part) {
                            part.stats.parsing.end = now;
                        }
                        this.updateLevelTiming(frag, part, level, chunkMeta.partial);
                    };
                    _proto.getCurrentContext = function getCurrentContext(chunkMeta) {
                        var levels = this.levels;
                        var levelIndex = chunkMeta.level,
                            sn = chunkMeta.sn,
                            partIndex = chunkMeta.part;
                        if (!levels || !levels[levelIndex]) {
                            this.warn("Levels object was unset while buffering fragment " + sn + " of level " + levelIndex + ". The current chunk will not be buffered.");
                            return null;
                        }
                        var level = levels[levelIndex];
                        var part = partIndex > -1 ? Object(_level_helper__WEBPACK_IMPORTED_MODULE_11__["getPartWith"])(level, sn, partIndex) : null;
                        var frag = part ? part.fragment : Object(_level_helper__WEBPACK_IMPORTED_MODULE_11__["getFragmentWithSN"])(level, sn, this.fragCurrent);
                        if (!frag) {
                            return null;
                        }
                        return { frag: frag, part: part, level: level };
                    };
                    _proto.bufferFragmentData = function bufferFragmentData(data, frag, part, chunkMeta) {
                        if (!data || this.state !== State.PARSING) {
                            return;
                        }
                        var data1 = data.data1,
                            data2 = data.data2;
                        var buffer = data1;
                        if (data1 && data2) {
                            buffer = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_8__["appendUint8Array"])(data1, data2);
                        }
                        if (!buffer || !buffer.length) {
                            return;
                        }
                        var segment = { type: data.type, frag: frag, part: part, chunkMeta: chunkMeta, parent: frag.type, data: buffer };
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].BUFFER_APPENDING, segment);
                        if (data.dropped && data.independent && !part) {
                            this.flushBufferGap(frag);
                        }
                    };
                    _proto.flushBufferGap = function flushBufferGap(frag) {
                        var media = this.media;
                        if (!media) {
                            return;
                        }
                        if (!_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__["BufferHelper"].isBuffered(media, media.currentTime)) {
                            this.flushMainBuffer(0, frag.start);
                            return;
                        }
                        var currentTime = media.currentTime;
                        var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__["BufferHelper"].bufferInfo(media, currentTime, 0);
                        var fragDuration = frag.duration;
                        var segmentFraction = Math.min(this.config.maxFragLookUpTolerance * 2, fragDuration * 0.25);
                        var start = Math.max(Math.min(frag.start - segmentFraction, bufferInfo.end - segmentFraction), currentTime + segmentFraction);
                        if (frag.start - start > segmentFraction) {
                            this.flushMainBuffer(start, frag.start);
                        }
                    };
                    _proto.getFwdBufferInfo = function getFwdBufferInfo(bufferable, type) {
                        var config = this.config;
                        var pos = this.getLoadPosition();
                        if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(pos)) {
                            return null;
                        }
                        var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__["BufferHelper"].bufferInfo(bufferable, pos, config.maxBufferHole);
                        if (bufferInfo.len === 0 && bufferInfo.nextStart !== undefined) {
                            var bufferedFragAtPos = this.fragmentTracker.getBufferedFrag(pos, type);
                            if (bufferedFragAtPos && bufferInfo.nextStart < bufferedFragAtPos.end) {
                                return _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__["BufferHelper"].bufferInfo(bufferable, pos, Math.max(bufferInfo.nextStart, config.maxBufferHole));
                            }
                        }
                        return bufferInfo;
                    };
                    _proto.getMaxBufferLength = function getMaxBufferLength(levelBitrate) {
                        var config = this.config;
                        var maxBufLen;
                        if (levelBitrate) {
                            maxBufLen = Math.max((8 * config.maxBufferSize) / levelBitrate, config.maxBufferLength);
                        } else {
                            maxBufLen = config.maxBufferLength;
                        }
                        return Math.min(maxBufLen, config.maxMaxBufferLength);
                    };
                    _proto.reduceMaxBufferLength = function reduceMaxBufferLength(threshold) {
                        var config = this.config;
                        var minLength = threshold || config.maxBufferLength;
                        if (config.maxMaxBufferLength >= minLength) {
                            config.maxMaxBufferLength /= 2;
                            this.warn("Reduce max buffer length to " + config.maxMaxBufferLength + "s");
                            return true;
                        }
                        return false;
                    };
                    _proto.getNextFragment = function getNextFragment(pos, levelDetails) {
                        var fragments = levelDetails.fragments;
                        var fragLen = fragments.length;
                        if (!fragLen) {
                            return null;
                        }
                        var config = this.config;
                        var start = fragments[0].start;
                        var frag;
                        if (levelDetails.live) {
                            var initialLiveManifestSize = config.initialLiveManifestSize;
                            if (fragLen < initialLiveManifestSize) {
                                this.warn("Not enough fragments to start playback (have: " + fragLen + ", need: " + initialLiveManifestSize + ")");
                                return null;
                            }
                            if (!levelDetails.PTSKnown && !this.startFragRequested && this.startPosition === -1) {
                                frag = this.getInitialLiveFragment(levelDetails, fragments);
                                this.startPosition = frag ? this.hls.liveSyncPosition || frag.start : pos;
                            }
                        } else if (pos <= start) {
                            frag = fragments[0];
                        }
                        if (!frag) {
                            var end = config.lowLatencyMode ? levelDetails.partEnd : levelDetails.fragmentEnd;
                            frag = this.getFragmentAtPosition(pos, end, levelDetails);
                        }
                        return this.mapToInitFragWhenRequired(frag);
                    };
                    _proto.mapToInitFragWhenRequired = function mapToInitFragWhenRequired(frag) {
                        if (frag !== null && frag !== void 0 && frag.initSegment && !(frag !== null && frag !== void 0 && frag.initSegment.data) && !this.bitrateTest) {
                            return frag.initSegment;
                        }
                        return frag;
                    };
                    _proto.getNextPart = function getNextPart(partList, frag, targetBufferTime) {
                        var nextPart = -1;
                        var contiguous = false;
                        var independentAttrOmitted = true;
                        for (var i = 0, len = partList.length; i < len; i++) {
                            var part = partList[i];
                            independentAttrOmitted = independentAttrOmitted && !part.independent;
                            if (nextPart > -1 && targetBufferTime < part.start) {
                                break;
                            }
                            var loaded = part.loaded;
                            if (!loaded && (contiguous || part.independent || independentAttrOmitted) && part.fragment === frag) {
                                nextPart = i;
                            }
                            contiguous = loaded;
                        }
                        return nextPart;
                    };
                    _proto.loadedEndOfParts = function loadedEndOfParts(partList, targetBufferTime) {
                        var lastPart = partList[partList.length - 1];
                        return lastPart && targetBufferTime > lastPart.start && lastPart.loaded;
                    };
                    _proto.getInitialLiveFragment = function getInitialLiveFragment(levelDetails, fragments) {
                        var fragPrevious = this.fragPrevious;
                        var frag = null;
                        if (fragPrevious) {
                            if (levelDetails.hasProgramDateTime) {
                                this.log("Live playlist, switching playlist, load frag with same PDT: " + fragPrevious.programDateTime);
                                frag = Object(_fragment_finders__WEBPACK_IMPORTED_MODULE_10__["findFragmentByPDT"])(fragments, fragPrevious.endProgramDateTime, this.config.maxFragLookUpTolerance);
                            }
                            if (!frag) {
                                var targetSN = fragPrevious.sn + 1;
                                if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
                                    var fragNext = fragments[targetSN - levelDetails.startSN];
                                    if (fragPrevious.cc === fragNext.cc) {
                                        frag = fragNext;
                                        this.log("Live playlist, switching playlist, load frag with next SN: " + frag.sn);
                                    }
                                }
                                if (!frag) {
                                    frag = Object(_fragment_finders__WEBPACK_IMPORTED_MODULE_10__["findFragWithCC"])(fragments, fragPrevious.cc);
                                    if (frag) {
                                        this.log("Live playlist, switching playlist, load frag with same CC: " + frag.sn);
                                    }
                                }
                            }
                        } else {
                            var liveStart = this.hls.liveSyncPosition;
                            if (liveStart !== null) {
                                frag = this.getFragmentAtPosition(liveStart, this.bitrateTest ? levelDetails.fragmentEnd : levelDetails.edge, levelDetails);
                            }
                        }
                        return frag;
                    };
                    _proto.getFragmentAtPosition = function getFragmentAtPosition(bufferEnd, end, levelDetails) {
                        var config = this.config,
                            fragPrevious = this.fragPrevious;
                        var fragments = levelDetails.fragments,
                            endSN = levelDetails.endSN;
                        var fragmentHint = levelDetails.fragmentHint;
                        var tolerance = config.maxFragLookUpTolerance;
                        var loadingParts = !!(config.lowLatencyMode && levelDetails.partList && fragmentHint);
                        if (loadingParts && fragmentHint && !this.bitrateTest) {
                            fragments = fragments.concat(fragmentHint);
                            endSN = fragmentHint.sn;
                        }
                        var frag;
                        if (bufferEnd < end) {
                            var lookupTolerance = bufferEnd > end - tolerance ? 0 : tolerance;
                            frag = Object(_fragment_finders__WEBPACK_IMPORTED_MODULE_10__["findFragmentByPTS"])(fragPrevious, fragments, bufferEnd, lookupTolerance);
                        } else {
                            frag = fragments[fragments.length - 1];
                        }
                        if (frag) {
                            var curSNIdx = frag.sn - levelDetails.startSN;
                            if (fragPrevious && frag.sn === fragPrevious.sn && !loadingParts) {
                                var sameLevel = fragPrevious && frag.level === fragPrevious.level;
                                if (sameLevel) {
                                    var nextFrag = fragments[curSNIdx + 1];
                                    if (frag.sn < endSN && this.fragmentTracker.getState(nextFrag) !== _fragment_tracker__WEBPACK_IMPORTED_MODULE_2__["FragmentState"].OK) {
                                        this.log("SN " + frag.sn + " just loaded, load next one: " + nextFrag.sn);
                                        frag = nextFrag;
                                    } else {
                                        frag = null;
                                    }
                                }
                            }
                        }
                        return frag;
                    };
                    _proto.synchronizeToLiveEdge = function synchronizeToLiveEdge(levelDetails) {
                        var config = this.config,
                            media = this.media;
                        if (!media) {
                            return;
                        }
                        var liveSyncPosition = this.hls.liveSyncPosition;
                        var currentTime = media.currentTime;
                        var start = levelDetails.fragments[0].start;
                        var end = levelDetails.edge;
                        var withinSlidingWindow = currentTime >= start - config.maxFragLookUpTolerance && currentTime <= end;
                        if (liveSyncPosition !== null && media.duration > liveSyncPosition && (currentTime < liveSyncPosition || !withinSlidingWindow)) {
                            var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;
                            if ((!withinSlidingWindow && media.readyState < 4) || currentTime < end - maxLatency) {
                                if (!this.loadedmetadata) {
                                    this.nextLoadPosition = liveSyncPosition;
                                }
                                if (media.readyState) {
                                    this.warn("Playback: " + currentTime.toFixed(3) + " is located too far from the end of live sliding playlist: " + end + ", reset currentTime to : " + liveSyncPosition.toFixed(3));
                                    media.currentTime = liveSyncPosition;
                                }
                            }
                        }
                    };
                    _proto.alignPlaylists = function alignPlaylists(details, previousDetails) {
                        var levels = this.levels,
                            levelLastLoaded = this.levelLastLoaded,
                            fragPrevious = this.fragPrevious;
                        var lastLevel = levelLastLoaded !== null ? levels[levelLastLoaded] : null;
                        var length = details.fragments.length;
                        if (!length) {
                            this.warn("No fragments in live playlist");
                            return 0;
                        }
                        var slidingStart = details.fragments[0].start;
                        var firstLevelLoad = !previousDetails;
                        var aligned = details.alignedSliding && Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(slidingStart);
                        if (firstLevelLoad || (!aligned && !slidingStart)) {
                            Object(_utils_discontinuities__WEBPACK_IMPORTED_MODULE_9__["alignStream"])(fragPrevious, lastLevel, details);
                            var alignedSlidingStart = details.fragments[0].start;
                            this.log(
                                "Live playlist sliding: " +
                                    alignedSlidingStart.toFixed(2) +
                                    " start-sn: " +
                                    (previousDetails ? previousDetails.startSN : "na") +
                                    "->" +
                                    details.startSN +
                                    " prev-sn: " +
                                    (fragPrevious ? fragPrevious.sn : "na") +
                                    " fragments: " +
                                    length
                            );
                            return alignedSlidingStart;
                        }
                        return slidingStart;
                    };
                    _proto.waitForCdnTuneIn = function waitForCdnTuneIn(details) {
                        var advancePartLimit = 3;
                        return details.live && details.canBlockReload && details.partTarget && details.tuneInGoal > Math.max(details.partHoldBack, details.partTarget * advancePartLimit);
                    };
                    _proto.setStartPosition = function setStartPosition(details, sliding) {
                        var startPosition = this.startPosition;
                        if (startPosition < sliding) {
                            startPosition = -1;
                        }
                        if (startPosition === -1 || this.lastCurrentTime === -1) {
                            var startTimeOffset = details.startTimeOffset;
                            if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(startTimeOffset)) {
                                startPosition = sliding + startTimeOffset;
                                if (startTimeOffset < 0) {
                                    startPosition += details.totalduration;
                                }
                                startPosition = Math.min(Math.max(sliding, startPosition), sliding + details.totalduration);
                                this.log("Start time offset " + startTimeOffset + " found in playlist, adjust startPosition to " + startPosition);
                                this.startPosition = startPosition;
                            } else if (details.live) {
                                startPosition = this.hls.liveSyncPosition || sliding;
                            } else {
                                this.startPosition = startPosition = 0;
                            }
                            this.lastCurrentTime = startPosition;
                        }
                        this.nextLoadPosition = startPosition;
                    };
                    _proto.getLoadPosition = function getLoadPosition() {
                        var media = this.media;
                        var pos = 0;
                        if (this.loadedmetadata && media) {
                            pos = media.currentTime;
                        } else if (this.nextLoadPosition) {
                            pos = this.nextLoadPosition;
                        }
                        return pos;
                    };
                    _proto.handleFragLoadAborted = function handleFragLoadAborted(frag, part) {
                        if (this.transmuxer && frag.sn !== "initSegment" && frag.stats.aborted) {
                            this.warn("Fragment " + frag.sn + (part ? " part" + part.index : "") + " of level " + frag.level + " was aborted");
                            this.resetFragmentLoading(frag);
                        }
                    };
                    _proto.resetFragmentLoading = function resetFragmentLoading(frag) {
                        if (!this.fragCurrent || (!this.fragContextChanged(frag) && this.state !== State.FRAG_LOADING_WAITING_RETRY)) {
                            this.state = State.IDLE;
                        }
                    };
                    _proto.onFragmentOrKeyLoadError = function onFragmentOrKeyLoadError(filterType, data) {
                        if (data.fatal) {
                            return;
                        }
                        var frag = data.frag;
                        if (!frag || frag.type !== filterType) {
                            return;
                        }
                        var fragCurrent = this.fragCurrent;
                        console.assert(fragCurrent && frag.sn === fragCurrent.sn && frag.level === fragCurrent.level && frag.urlId === fragCurrent.urlId, "Frag load error must match current frag to retry");
                        var config = this.config;
                        if (this.fragLoadError + 1 <= config.fragLoadingMaxRetry) {
                            if (!this.loadedmetadata) {
                                this.startFragRequested = false;
                                this.nextLoadPosition = this.startPosition;
                            }
                            var delay = Math.min(Math.pow(2, this.fragLoadError) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);
                            this.warn("Fragment " + frag.sn + " of " + filterType + " " + frag.level + " failed to load, retrying in " + delay + "ms");
                            this.retryDate = self.performance.now() + delay;
                            this.fragLoadError++;
                            this.state = State.FRAG_LOADING_WAITING_RETRY;
                        } else if (data.levelRetry) {
                            if (filterType === _types_loader__WEBPACK_IMPORTED_MODULE_15__["PlaylistLevelType"].AUDIO) {
                                this.fragCurrent = null;
                            }
                            this.fragLoadError = 0;
                            this.state = State.IDLE;
                        } else {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_4__["logger"].error(data.details + " reaches max retry, redispatch as fatal ...");
                            data.fatal = true;
                            this.hls.stopLoad();
                            this.state = State.ERROR;
                        }
                    };
                    _proto.afterBufferFlushed = function afterBufferFlushed(media, bufferType, playlistType) {
                        if (!media) {
                            return;
                        }
                        var bufferedTimeRanges = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_3__["BufferHelper"].getBuffered(media);
                        this.fragmentTracker.detectEvictedFragments(bufferType, bufferedTimeRanges, playlistType);
                        if (this.state === State.ENDED) {
                            this.resetLoadingState();
                        }
                    };
                    _proto.resetLoadingState = function resetLoadingState() {
                        this.fragCurrent = null;
                        this.fragPrevious = null;
                        this.state = State.IDLE;
                    };
                    _proto.resetStartWhenNotLoaded = function resetStartWhenNotLoaded(level) {
                        if (!this.loadedmetadata) {
                            this.startFragRequested = false;
                            var details = this.levels ? this.levels[level].details : null;
                            if (details !== null && details !== void 0 && details.live) {
                                this.startPosition = -1;
                                this.setStartPosition(details, 0);
                                this.resetLoadingState();
                            } else {
                                this.nextLoadPosition = this.startPosition;
                            }
                        }
                    };
                    _proto.updateLevelTiming = function updateLevelTiming(frag, part, level, partial) {
                        var _this6 = this;
                        var details = level.details;
                        console.assert(!!details, "level.details must be defined");
                        var parsed = Object.keys(frag.elementaryStreams).reduce(function (result, type) {
                            var info = frag.elementaryStreams[type];
                            if (info) {
                                var parsedDuration = info.endPTS - info.startPTS;
                                if (parsedDuration <= 0) {
                                    _this6.warn("Could not parse fragment " + frag.sn + " " + type + " duration reliably (" + parsedDuration + ")");
                                    return result || false;
                                }
                                var drift = partial ? 0 : Object(_level_helper__WEBPACK_IMPORTED_MODULE_11__["updateFragPTSDTS"])(details, frag, info.startPTS, info.endPTS, info.startDTS, info.endDTS);
                                _this6.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].LEVEL_PTS_UPDATED, { details: details, level: level, drift: drift, type: type, frag: frag, start: info.startPTS, end: info.endPTS });
                                return true;
                            }
                            return result;
                        }, false);
                        if (!parsed) {
                            this.warn("Found no media in fragment " + frag.sn + " of level " + level.id + " resetting transmuxer to fallback to playlist timing");
                            this.resetTransmuxer();
                        }
                        this.state = State.PARSED;
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_5__["Events"].FRAG_PARSED, { frag: frag, part: part });
                    };
                    _proto.resetTransmuxer = function resetTransmuxer() {
                        if (this.transmuxer) {
                            this.transmuxer.destroy();
                            this.transmuxer = null;
                        }
                    };
                    _createClass(BaseStreamController, [
                        {
                            key: "state",
                            get: function get() {
                                return this._state;
                            },
                            set: function set(nextState) {
                                var previousState = this._state;
                                if (previousState !== nextState) {
                                    this._state = nextState;
                                    this.log(previousState + "->" + nextState);
                                }
                            },
                        },
                    ]);
                    return BaseStreamController;
                })(_task_loop__WEBPACK_IMPORTED_MODULE_1__["default"]);
            },
            "./src/controller/buffer-controller.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "default", function () {
                    return BufferController;
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/polyfills/number.ts");
                var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/events.ts");
                var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/logger.ts");
                var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/errors.ts");
                var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/utils/buffer-helper.ts");
                var _utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/utils/mediasource-helper.ts");
                var _loader_fragment__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/loader/fragment.ts");
                var _buffer_operation_queue__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/controller/buffer-operation-queue.ts");
                var MediaSource = Object(_utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_5__["getMediaSource"])();
                var VIDEO_CODEC_PROFILE_REPACE = /([ha]vc.)(?:\.[^.,]+)+/;
                var BufferController = (function () {
                    function BufferController(_hls) {
                        var _this = this;
                        this.details = null;
                        this._objectUrl = null;
                        this.operationQueue = void 0;
                        this.listeners = void 0;
                        this.hls = void 0;
                        this.bufferCodecEventsExpected = 0;
                        this._bufferCodecEventsTotal = 0;
                        this.media = null;
                        this.mediaSource = null;
                        this.appendError = 0;
                        this.tracks = {};
                        this.pendingTracks = {};
                        this.sourceBuffer = void 0;
                        this._onMediaSourceOpen = function () {
                            var hls = _this.hls,
                                media = _this.media,
                                mediaSource = _this.mediaSource;
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("[buffer-controller]: Media source opened");
                            if (media) {
                                _this.updateMediaElementDuration();
                                hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_ATTACHED, { media: media });
                            }
                            if (mediaSource) {
                                mediaSource.removeEventListener("sourceopen", _this._onMediaSourceOpen);
                            }
                            _this.checkPendingTracks();
                        };
                        this._onMediaSourceClose = function () {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("[buffer-controller]: Media source closed");
                        };
                        this._onMediaSourceEnded = function () {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("[buffer-controller]: Media source ended");
                        };
                        this.hls = _hls;
                        this._initSourceBuffer();
                        this.registerListeners();
                    }
                    var _proto = BufferController.prototype;
                    _proto.hasSourceTypes = function hasSourceTypes() {
                        return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0;
                    };
                    _proto.destroy = function destroy() {
                        this.unregisterListeners();
                        this.details = null;
                    };
                    _proto.registerListeners = function registerListeners() {
                        var hls = this.hls;
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_ATTACHING, this.onMediaAttaching, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_PARSED, this.onManifestParsed, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_RESET, this.onBufferReset, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_APPENDING, this.onBufferAppending, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_CODECS, this.onBufferCodecs, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_EOS, this.onBufferEos, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_FLUSHING, this.onBufferFlushing, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVEL_UPDATED, this.onLevelUpdated, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_PARSED, this.onFragParsed, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_CHANGED, this.onFragChanged, this);
                    };
                    _proto.unregisterListeners = function unregisterListeners() {
                        var hls = this.hls;
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_ATTACHING, this.onMediaAttaching, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_PARSED, this.onManifestParsed, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_RESET, this.onBufferReset, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_APPENDING, this.onBufferAppending, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_CODECS, this.onBufferCodecs, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_EOS, this.onBufferEos, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_FLUSHING, this.onBufferFlushing, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVEL_UPDATED, this.onLevelUpdated, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_PARSED, this.onFragParsed, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_CHANGED, this.onFragChanged, this);
                    };
                    _proto._initSourceBuffer = function _initSourceBuffer() {
                        this.sourceBuffer = {};
                        this.operationQueue = new _buffer_operation_queue__WEBPACK_IMPORTED_MODULE_7__["default"](this.sourceBuffer);
                        this.listeners = { audio: [], video: [], audiovideo: [] };
                    };
                    _proto.onManifestParsed = function onManifestParsed(event, data) {
                        var codecEvents = 2;
                        if ((data.audio && !data.video) || !data.altAudio) {
                            codecEvents = 1;
                        }
                        this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = codecEvents;
                        this.details = null;
                        _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log(this.bufferCodecEventsExpected + " bufferCodec event(s) expected");
                    };
                    _proto.onMediaAttaching = function onMediaAttaching(event, data) {
                        var media = (this.media = data.media);
                        if (media && MediaSource) {
                            var ms = (this.mediaSource = new MediaSource());
                            ms.addEventListener("sourceopen", this._onMediaSourceOpen);
                            ms.addEventListener("sourceended", this._onMediaSourceEnded);
                            ms.addEventListener("sourceclose", this._onMediaSourceClose);
                            media.src = self.URL.createObjectURL(ms);
                            this._objectUrl = media.src;
                        }
                    };
                    _proto.onMediaDetaching = function onMediaDetaching() {
                        var media = this.media,
                            mediaSource = this.mediaSource,
                            _objectUrl = this._objectUrl;
                        if (mediaSource) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("[buffer-controller]: media source detaching");
                            if (mediaSource.readyState === "open") {
                                try {
                                    mediaSource.endOfStream();
                                } catch (err) {
                                    _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn("[buffer-controller]: onMediaDetaching: " + err.message + " while calling endOfStream");
                                }
                            }
                            this.onBufferReset();
                            mediaSource.removeEventListener("sourceopen", this._onMediaSourceOpen);
                            mediaSource.removeEventListener("sourceended", this._onMediaSourceEnded);
                            mediaSource.removeEventListener("sourceclose", this._onMediaSourceClose);
                            if (media) {
                                if (_objectUrl) {
                                    self.URL.revokeObjectURL(_objectUrl);
                                }
                                if (media.src === _objectUrl) {
                                    media.removeAttribute("src");
                                    media.load();
                                } else {
                                    _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn("[buffer-controller]: media.src was changed by a third party - skip cleanup");
                                }
                            }
                            this.mediaSource = null;
                            this.media = null;
                            this._objectUrl = null;
                            this.bufferCodecEventsExpected = this._bufferCodecEventsTotal;
                            this.pendingTracks = {};
                            this.tracks = {};
                        }
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_DETACHED, undefined);
                    };
                    _proto.onBufferReset = function onBufferReset() {
                        var _this2 = this;
                        this.getSourceBufferTypes().forEach(function (type) {
                            var sb = _this2.sourceBuffer[type];
                            try {
                                if (sb) {
                                    _this2.removeBufferListeners(type);
                                    if (_this2.mediaSource) {
                                        _this2.mediaSource.removeSourceBuffer(sb);
                                    }
                                    _this2.sourceBuffer[type] = undefined;
                                }
                            } catch (err) {
                                _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn("[buffer-controller]: Failed to reset the " + type + " buffer", err);
                            }
                        });
                        this._initSourceBuffer();
                    };
                    _proto.onBufferCodecs = function onBufferCodecs(event, data) {
                        var _this3 = this;
                        var sourceBufferCount = this.getSourceBufferTypes().length;
                        Object.keys(data).forEach(function (trackName) {
                            if (sourceBufferCount) {
                                var track = _this3.tracks[trackName];
                                if (track && typeof track.buffer.changeType === "function") {
                                    var _data$trackName = data[trackName],
                                        id = _data$trackName.id,
                                        codec = _data$trackName.codec,
                                        levelCodec = _data$trackName.levelCodec,
                                        container = _data$trackName.container,
                                        metadata = _data$trackName.metadata;
                                    var currentCodec = (track.levelCodec || track.codec).replace(VIDEO_CODEC_PROFILE_REPACE, "$1");
                                    var nextCodec = (levelCodec || codec).replace(VIDEO_CODEC_PROFILE_REPACE, "$1");
                                    if (currentCodec !== nextCodec) {
                                        var mimeType = container + ";codecs=" + (levelCodec || codec);
                                        _this3.appendChangeType(trackName, mimeType);
                                        _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("[buffer-controller]: switching codec " + currentCodec + " to " + nextCodec);
                                        _this3.tracks[trackName] = { buffer: track.buffer, codec: codec, container: container, levelCodec: levelCodec, metadata: metadata, id: id };
                                    }
                                }
                            } else {
                                _this3.pendingTracks[trackName] = data[trackName];
                            }
                        });
                        if (sourceBufferCount) {
                            return;
                        }
                        this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);
                        if (this.mediaSource && this.mediaSource.readyState === "open") {
                            this.checkPendingTracks();
                        }
                    };
                    _proto.appendChangeType = function appendChangeType(type, mimeType) {
                        var _this4 = this;
                        var operationQueue = this.operationQueue;
                        var operation = {
                            execute: function execute() {
                                var sb = _this4.sourceBuffer[type];
                                if (sb) {
                                    _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("[buffer-controller]: changing " + type + " sourceBuffer type to " + mimeType);
                                    sb.changeType(mimeType);
                                }
                                operationQueue.shiftAndExecuteNext(type);
                            },
                            onStart: function onStart() {},
                            onComplete: function onComplete() {},
                            onError: function onError(e) {
                                _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn("[buffer-controller]: Failed to change " + type + " SourceBuffer type", e);
                            },
                        };
                        operationQueue.append(operation, type);
                    };
                    _proto.onBufferAppending = function onBufferAppending(event, eventData) {
                        var _this5 = this;
                        var hls = this.hls,
                            operationQueue = this.operationQueue,
                            tracks = this.tracks;
                        var data = eventData.data,
                            type = eventData.type,
                            frag = eventData.frag,
                            part = eventData.part,
                            chunkMeta = eventData.chunkMeta;
                        var chunkStats = chunkMeta.buffering[type];
                        var bufferAppendingStart = self.performance.now();
                        chunkStats.start = bufferAppendingStart;
                        var fragBuffering = frag.stats.buffering;
                        var partBuffering = part ? part.stats.buffering : null;
                        if (fragBuffering.start === 0) {
                            fragBuffering.start = bufferAppendingStart;
                        }
                        if (partBuffering && partBuffering.start === 0) {
                            partBuffering.start = bufferAppendingStart;
                        }
                        var audioTrack = tracks.audio;
                        var checkTimestampOffset = type === "audio" && chunkMeta.id === 1 && (audioTrack === null || audioTrack === void 0 ? void 0 : audioTrack.container) === "audio/mpeg";
                        var operation = {
                            execute: function execute() {
                                chunkStats.executeStart = self.performance.now();
                                if (checkTimestampOffset) {
                                    var sb = _this5.sourceBuffer[type];
                                    if (sb) {
                                        var delta = frag.start - sb.timestampOffset;
                                        if (Math.abs(delta) >= 0.1) {
                                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("[buffer-controller]: Updating audio SourceBuffer timestampOffset to " + frag.start + " (delta: " + delta + ") sn: " + frag.sn + ")");
                                            sb.timestampOffset = frag.start;
                                        }
                                    }
                                }
                                _this5.appendExecutor(data, type);
                            },
                            onStart: function onStart() {},
                            onComplete: function onComplete() {
                                var end = self.performance.now();
                                chunkStats.executeEnd = chunkStats.end = end;
                                if (fragBuffering.first === 0) {
                                    fragBuffering.first = end;
                                }
                                if (partBuffering && partBuffering.first === 0) {
                                    partBuffering.first = end;
                                }
                                var sourceBuffer = _this5.sourceBuffer;
                                var timeRanges = {};
                                for (var _type in sourceBuffer) {
                                    timeRanges[_type] = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__["BufferHelper"].getBuffered(sourceBuffer[_type]);
                                }
                                _this5.appendError = 0;
                                _this5.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_APPENDED, { type: type, frag: frag, part: part, chunkMeta: chunkMeta, parent: frag.type, timeRanges: timeRanges });
                            },
                            onError: function onError(err) {
                                _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error("[buffer-controller]: Error encountered while trying to append to the " + type + " SourceBuffer", err);
                                var event = {
                                    type: _errors__WEBPACK_IMPORTED_MODULE_3__["ErrorTypes"].MEDIA_ERROR,
                                    parent: frag.type,
                                    details: _errors__WEBPACK_IMPORTED_MODULE_3__["ErrorDetails"].BUFFER_APPEND_ERROR,
                                    err: err,
                                    fatal: false,
                                };
                                if (err.code === DOMException.QUOTA_EXCEEDED_ERR) {
                                    event.details = _errors__WEBPACK_IMPORTED_MODULE_3__["ErrorDetails"].BUFFER_FULL_ERROR;
                                } else {
                                    _this5.appendError++;
                                    event.details = _errors__WEBPACK_IMPORTED_MODULE_3__["ErrorDetails"].BUFFER_APPEND_ERROR;
                                    if (_this5.appendError > hls.config.appendErrorMaxRetry) {
                                        _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error("[buffer-controller]: Failed " + hls.config.appendErrorMaxRetry + " times to append segment in sourceBuffer");
                                        event.fatal = true;
                                        hls.stopLoad();
                                    }
                                }
                                hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, event);
                            },
                        };
                        operationQueue.append(operation, type);
                    };
                    _proto.onBufferFlushing = function onBufferFlushing(event, data) {
                        var _this6 = this;
                        var operationQueue = this.operationQueue;
                        var flushOperation = function flushOperation(type) {
                            return {
                                execute: _this6.removeExecutor.bind(_this6, type, data.startOffset, data.endOffset),
                                onStart: function onStart() {},
                                onComplete: function onComplete() {
                                    _this6.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_FLUSHED, { type: type });
                                },
                                onError: function onError(e) {
                                    _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn("[buffer-controller]: Failed to remove from " + type + " SourceBuffer", e);
                                },
                            };
                        };
                        if (data.type) {
                            operationQueue.append(flushOperation(data.type), data.type);
                        } else {
                            this.getSourceBufferTypes().forEach(function (type) {
                                operationQueue.append(flushOperation(type), type);
                            });
                        }
                    };
                    _proto.onFragParsed = function onFragParsed(event, data) {
                        var _this7 = this;
                        var frag = data.frag,
                            part = data.part;
                        var buffersAppendedTo = [];
                        var elementaryStreams = part ? part.elementaryStreams : frag.elementaryStreams;
                        if (elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_6__["ElementaryStreamTypes"].AUDIOVIDEO]) {
                            buffersAppendedTo.push("audiovideo");
                        } else {
                            if (elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_6__["ElementaryStreamTypes"].AUDIO]) {
                                buffersAppendedTo.push("audio");
                            }
                            if (elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_6__["ElementaryStreamTypes"].VIDEO]) {
                                buffersAppendedTo.push("video");
                            }
                        }
                        var onUnblocked = function onUnblocked() {
                            var now = self.performance.now();
                            frag.stats.buffering.end = now;
                            if (part) {
                                part.stats.buffering.end = now;
                            }
                            var stats = part ? part.stats : frag.stats;
                            _this7.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_BUFFERED, { frag: frag, part: part, stats: stats, id: frag.type });
                        };
                        if (buffersAppendedTo.length === 0) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn("Fragments must have at least one ElementaryStreamType set. type: " + frag.type + " level: " + frag.level + " sn: " + frag.sn);
                        }
                        this.blockBuffers(onUnblocked, buffersAppendedTo);
                    };
                    _proto.onFragChanged = function onFragChanged(event, data) {
                        this.flushBackBuffer();
                    };
                    _proto.onBufferEos = function onBufferEos(event, data) {
                        var _this8 = this;
                        var ended = this.getSourceBufferTypes().reduce(function (acc, type) {
                            var sb = _this8.sourceBuffer[type];
                            if (!data.type || data.type === type) {
                                if (sb && !sb.ended) {
                                    sb.ended = true;
                                    _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("[buffer-controller]: " + type + " sourceBuffer now EOS");
                                }
                            }
                            return acc && !!(!sb || sb.ended);
                        }, true);
                        if (ended) {
                            this.blockBuffers(function () {
                                var mediaSource = _this8.mediaSource;
                                if (!mediaSource || mediaSource.readyState !== "open") {
                                    return;
                                }
                                mediaSource.endOfStream();
                            });
                        }
                    };
                    _proto.onLevelUpdated = function onLevelUpdated(event, _ref) {
                        var details = _ref.details;
                        if (!details.fragments.length) {
                            return;
                        }
                        this.details = details;
                        if (this.getSourceBufferTypes().length) {
                            this.blockBuffers(this.updateMediaElementDuration.bind(this));
                        } else {
                            this.updateMediaElementDuration();
                        }
                    };
                    _proto.flushBackBuffer = function flushBackBuffer() {
                        var hls = this.hls,
                            details = this.details,
                            media = this.media,
                            sourceBuffer = this.sourceBuffer;
                        if (!media || details === null) {
                            return;
                        }
                        var sourceBufferTypes = this.getSourceBufferTypes();
                        if (!sourceBufferTypes.length) {
                            return;
                        }
                        var backBufferLength = details.live && hls.config.liveBackBufferLength !== null ? hls.config.liveBackBufferLength : hls.config.backBufferLength;
                        if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(backBufferLength) || backBufferLength < 0) {
                            return;
                        }
                        var currentTime = media.currentTime;
                        var targetDuration = details.levelTargetDuration;
                        var maxBackBufferLength = Math.max(backBufferLength, targetDuration);
                        var targetBackBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration - maxBackBufferLength;
                        sourceBufferTypes.forEach(function (type) {
                            var sb = sourceBuffer[type];
                            if (sb) {
                                var buffered = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__["BufferHelper"].getBuffered(sb);
                                if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {
                                    hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BACK_BUFFER_REACHED, { bufferEnd: targetBackBufferPosition });
                                    if (details.live) {
                                        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LIVE_BACK_BUFFER_REACHED, { bufferEnd: targetBackBufferPosition });
                                    }
                                    hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_FLUSHING, { startOffset: 0, endOffset: targetBackBufferPosition, type: type });
                                }
                            }
                        });
                    };
                    _proto.updateMediaElementDuration = function updateMediaElementDuration() {
                        if (!this.details || !this.media || !this.mediaSource || this.mediaSource.readyState !== "open") {
                            return;
                        }
                        var details = this.details,
                            hls = this.hls,
                            media = this.media,
                            mediaSource = this.mediaSource;
                        var levelDuration = details.fragments[0].start + details.totalduration;
                        var mediaDuration = media.duration;
                        var msDuration = Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(mediaSource.duration) ? mediaSource.duration : 0;
                        if (details.live && hls.config.liveDurationInfinity) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("[buffer-controller]: Media Source duration is set to Infinity");
                            mediaSource.duration = Infinity;
                            this.updateSeekableRange(details);
                        } else if ((levelDuration > msDuration && levelDuration > mediaDuration) || !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(mediaDuration)) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("[buffer-controller]: Updating Media Source duration to " + levelDuration.toFixed(3));
                            mediaSource.duration = levelDuration;
                        }
                    };
                    _proto.updateSeekableRange = function updateSeekableRange(levelDetails) {
                        var mediaSource = this.mediaSource;
                        var fragments = levelDetails.fragments;
                        var len = fragments.length;
                        if (len && levelDetails.live && mediaSource !== null && mediaSource !== void 0 && mediaSource.setLiveSeekableRange) {
                            var start = Math.max(0, fragments[0].start);
                            var end = Math.max(start, start + levelDetails.totalduration);
                            mediaSource.setLiveSeekableRange(start, end);
                        }
                    };
                    _proto.checkPendingTracks = function checkPendingTracks() {
                        var bufferCodecEventsExpected = this.bufferCodecEventsExpected,
                            operationQueue = this.operationQueue,
                            pendingTracks = this.pendingTracks;
                        var pendingTracksCount = Object.keys(pendingTracks).length;
                        if ((pendingTracksCount && !bufferCodecEventsExpected) || pendingTracksCount === 2) {
                            this.createSourceBuffers(pendingTracks);
                            this.pendingTracks = {};
                            var buffers = this.getSourceBufferTypes();
                            if (buffers.length === 0) {
                                this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, {
                                    type: _errors__WEBPACK_IMPORTED_MODULE_3__["ErrorTypes"].MEDIA_ERROR,
                                    details: _errors__WEBPACK_IMPORTED_MODULE_3__["ErrorDetails"].BUFFER_INCOMPATIBLE_CODECS_ERROR,
                                    fatal: true,
                                    reason: "could not create source buffer for media codec(s)",
                                });
                                return;
                            }
                            buffers.forEach(function (type) {
                                operationQueue.executeNext(type);
                            });
                        }
                    };
                    _proto.createSourceBuffers = function createSourceBuffers(tracks) {
                        var sourceBuffer = this.sourceBuffer,
                            mediaSource = this.mediaSource;
                        if (!mediaSource) {
                            throw Error("createSourceBuffers called when mediaSource was null");
                        }
                        var tracksCreated = 0;
                        for (var trackName in tracks) {
                            if (!sourceBuffer[trackName]) {
                                var track = tracks[trackName];
                                if (!track) {
                                    throw Error("source buffer exists for track " + trackName + ", however track does not");
                                }
                                var codec = track.levelCodec || track.codec;
                                var mimeType = track.container + ";codecs=" + codec;
                                _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("[buffer-controller]: creating sourceBuffer(" + mimeType + ")");
                                try {
                                    var sb = (sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType));
                                    var sbName = trackName;
                                    this.addBufferListener(sbName, "updatestart", this._onSBUpdateStart);
                                    this.addBufferListener(sbName, "updateend", this._onSBUpdateEnd);
                                    this.addBufferListener(sbName, "error", this._onSBUpdateError);
                                    this.tracks[trackName] = { buffer: sb, codec: codec, container: track.container, levelCodec: track.levelCodec, metadata: track.metadata, id: track.id };
                                    tracksCreated++;
                                } catch (err) {
                                    _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error("[buffer-controller]: error while trying to add sourceBuffer: " + err.message);
                                    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, {
                                        type: _errors__WEBPACK_IMPORTED_MODULE_3__["ErrorTypes"].MEDIA_ERROR,
                                        details: _errors__WEBPACK_IMPORTED_MODULE_3__["ErrorDetails"].BUFFER_ADD_CODEC_ERROR,
                                        fatal: false,
                                        error: err,
                                        mimeType: mimeType,
                                    });
                                }
                            }
                        }
                        if (tracksCreated) {
                            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_CREATED, { tracks: this.tracks });
                        }
                    };
                    _proto._onSBUpdateStart = function _onSBUpdateStart(type) {
                        var operationQueue = this.operationQueue;
                        var operation = operationQueue.current(type);
                        operation.onStart();
                    };
                    _proto._onSBUpdateEnd = function _onSBUpdateEnd(type) {
                        var operationQueue = this.operationQueue;
                        var operation = operationQueue.current(type);
                        operation.onComplete();
                        operationQueue.shiftAndExecuteNext(type);
                    };
                    _proto._onSBUpdateError = function _onSBUpdateError(type, event) {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error("[buffer-controller]: " + type + " SourceBuffer error", event);
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, {
                            type: _errors__WEBPACK_IMPORTED_MODULE_3__["ErrorTypes"].MEDIA_ERROR,
                            details: _errors__WEBPACK_IMPORTED_MODULE_3__["ErrorDetails"].BUFFER_APPENDING_ERROR,
                            fatal: false,
                        });
                        var operation = this.operationQueue.current(type);
                        if (operation) {
                            operation.onError(event);
                        }
                    };
                    _proto.removeExecutor = function removeExecutor(type, startOffset, endOffset) {
                        var media = this.media,
                            mediaSource = this.mediaSource,
                            operationQueue = this.operationQueue,
                            sourceBuffer = this.sourceBuffer;
                        var sb = sourceBuffer[type];
                        if (!media || !mediaSource || !sb) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn("[buffer-controller]: Attempting to remove from the " + type + " SourceBuffer, but it does not exist");
                            operationQueue.shiftAndExecuteNext(type);
                            return;
                        }
                        var mediaDuration = Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(media.duration) ? media.duration : Infinity;
                        var msDuration = Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(mediaSource.duration) ? mediaSource.duration : Infinity;
                        var removeStart = Math.max(0, startOffset);
                        var removeEnd = Math.min(endOffset, mediaDuration, msDuration);
                        if (removeEnd > removeStart) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("[buffer-controller]: Removing [" + removeStart + "," + removeEnd + "] from the " + type + " SourceBuffer");
                            console.assert(!sb.updating, type + " sourceBuffer must not be updating");
                            sb.remove(removeStart, removeEnd);
                        } else {
                            operationQueue.shiftAndExecuteNext(type);
                        }
                    };
                    _proto.appendExecutor = function appendExecutor(data, type) {
                        var operationQueue = this.operationQueue,
                            sourceBuffer = this.sourceBuffer;
                        var sb = sourceBuffer[type];
                        if (!sb) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn("[buffer-controller]: Attempting to append to the " + type + " SourceBuffer, but it does not exist");
                            operationQueue.shiftAndExecuteNext(type);
                            return;
                        }
                        sb.ended = false;
                        console.assert(!sb.updating, type + " sourceBuffer must not be updating");
                        sb.appendBuffer(data);
                    };
                    _proto.blockBuffers = function blockBuffers(onUnblocked, buffers) {
                        var _this9 = this;
                        if (buffers === void 0) {
                            buffers = this.getSourceBufferTypes();
                        }
                        if (!buffers.length) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("[buffer-controller]: Blocking operation requested, but no SourceBuffers exist");
                            Promise.resolve().then(onUnblocked);
                            return;
                        }
                        var operationQueue = this.operationQueue;
                        var blockingOperations = buffers.map(function (type) {
                            return operationQueue.appendBlocker(type);
                        });
                        Promise.all(blockingOperations).then(function () {
                            onUnblocked();
                            buffers.forEach(function (type) {
                                var sb = _this9.sourceBuffer[type];
                                if (!sb || !sb.updating) {
                                    operationQueue.shiftAndExecuteNext(type);
                                }
                            });
                        });
                    };
                    _proto.getSourceBufferTypes = function getSourceBufferTypes() {
                        return Object.keys(this.sourceBuffer);
                    };
                    _proto.addBufferListener = function addBufferListener(type, event, fn) {
                        var buffer = this.sourceBuffer[type];
                        if (!buffer) {
                            return;
                        }
                        var listener = fn.bind(this, type);
                        this.listeners[type].push({ event: event, listener: listener });
                        buffer.addEventListener(event, listener);
                    };
                    _proto.removeBufferListeners = function removeBufferListeners(type) {
                        var buffer = this.sourceBuffer[type];
                        if (!buffer) {
                            return;
                        }
                        this.listeners[type].forEach(function (l) {
                            buffer.removeEventListener(l.event, l.listener);
                        });
                    };
                    return BufferController;
                })();
            },
            "./src/controller/buffer-operation-queue.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "default", function () {
                    return BufferOperationQueue;
                });
                var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/logger.ts");
                var BufferOperationQueue = (function () {
                    function BufferOperationQueue(sourceBufferReference) {
                        this.buffers = void 0;
                        this.queues = { video: [], audio: [], audiovideo: [] };
                        this.buffers = sourceBufferReference;
                    }
                    var _proto = BufferOperationQueue.prototype;
                    _proto.append = function append(operation, type) {
                        var queue = this.queues[type];
                        queue.push(operation);
                        if (queue.length === 1 && this.buffers[type]) {
                            this.executeNext(type);
                        }
                    };
                    _proto.insertAbort = function insertAbort(operation, type) {
                        var queue = this.queues[type];
                        queue.unshift(operation);
                        this.executeNext(type);
                    };
                    _proto.appendBlocker = function appendBlocker(type) {
                        var execute;
                        var promise = new Promise(function (resolve) {
                            execute = resolve;
                        });
                        var operation = { execute: execute, onStart: function onStart() {}, onComplete: function onComplete() {}, onError: function onError() {} };
                        this.append(operation, type);
                        return promise;
                    };
                    _proto.executeNext = function executeNext(type) {
                        var buffers = this.buffers,
                            queues = this.queues;
                        var sb = buffers[type];
                        var queue = queues[type];
                        if (queue.length) {
                            var operation = queue[0];
                            try {
                                operation.execute();
                            } catch (e) {
                                _utils_logger__WEBPACK_IMPORTED_MODULE_0__["logger"].warn("[buffer-operation-queue]: Unhandled exception executing the current operation");
                                operation.onError(e);
                                if (!sb || !sb.updating) {
                                    queue.shift();
                                    this.executeNext(type);
                                }
                            }
                        }
                    };
                    _proto.shiftAndExecuteNext = function shiftAndExecuteNext(type) {
                        this.queues[type].shift();
                        this.executeNext(type);
                    };
                    _proto.current = function current(type) {
                        return this.queues[type][0];
                    };
                    return BufferOperationQueue;
                })();
            },
            "./src/controller/cap-level-controller.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/events.ts");
                function _defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    Object.defineProperty(Constructor, "prototype", { writable: false });
                    return Constructor;
                }
                var CapLevelController = (function () {
                    function CapLevelController(hls) {
                        this.autoLevelCapping = void 0;
                        this.firstLevel = void 0;
                        this.media = void 0;
                        this.restrictedLevels = void 0;
                        this.timer = void 0;
                        this.hls = void 0;
                        this.streamController = void 0;
                        this.clientRect = void 0;
                        this.hls = hls;
                        this.autoLevelCapping = Number.POSITIVE_INFINITY;
                        this.firstLevel = -1;
                        this.media = null;
                        this.restrictedLevels = [];
                        this.timer = undefined;
                        this.clientRect = null;
                        this.registerListeners();
                    }
                    var _proto = CapLevelController.prototype;
                    _proto.setStreamController = function setStreamController(streamController) {
                        this.streamController = streamController;
                    };
                    _proto.destroy = function destroy() {
                        this.unregisterListener();
                        if (this.hls.config.capLevelToPlayerSize) {
                            this.stopCapping();
                        }
                        this.media = null;
                        this.clientRect = null;
                        this.hls = this.streamController = null;
                    };
                    _proto.registerListeners = function registerListeners() {
                        var hls = this.hls;
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_ATTACHING, this.onMediaAttaching, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MANIFEST_PARSED, this.onManifestParsed, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].BUFFER_CODECS, this.onBufferCodecs, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
                    };
                    _proto.unregisterListener = function unregisterListener() {
                        var hls = this.hls;
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_ATTACHING, this.onMediaAttaching, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MANIFEST_PARSED, this.onManifestParsed, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].BUFFER_CODECS, this.onBufferCodecs, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
                    };
                    _proto.onFpsDropLevelCapping = function onFpsDropLevelCapping(event, data) {
                        if (CapLevelController.isLevelAllowed(data.droppedLevel, this.restrictedLevels)) {
                            this.restrictedLevels.push(data.droppedLevel);
                        }
                    };
                    _proto.onMediaAttaching = function onMediaAttaching(event, data) {
                        this.media = data.media instanceof HTMLVideoElement ? data.media : null;
                    };
                    _proto.onManifestParsed = function onManifestParsed(event, data) {
                        var hls = this.hls;
                        this.restrictedLevels = [];
                        this.firstLevel = data.firstLevel;
                        if (hls.config.capLevelToPlayerSize && data.video) {
                            this.startCapping();
                        }
                    };
                    _proto.onBufferCodecs = function onBufferCodecs(event, data) {
                        var hls = this.hls;
                        if (hls.config.capLevelToPlayerSize && data.video) {
                            this.startCapping();
                        }
                    };
                    _proto.onMediaDetaching = function onMediaDetaching() {
                        this.stopCapping();
                    };
                    _proto.detectPlayerSize = function detectPlayerSize() {
                        if (this.media && this.mediaHeight > 0 && this.mediaWidth > 0) {
                            var levels = this.hls.levels;
                            if (levels.length) {
                                var hls = this.hls;
                                hls.autoLevelCapping = this.getMaxLevel(levels.length - 1);
                                if (hls.autoLevelCapping > this.autoLevelCapping && this.streamController) {
                                    this.streamController.nextLevelSwitch();
                                }
                                this.autoLevelCapping = hls.autoLevelCapping;
                            }
                        }
                    };
                    _proto.getMaxLevel = function getMaxLevel(capLevelIndex) {
                        var _this = this;
                        var levels = this.hls.levels;
                        if (!levels.length) {
                            return -1;
                        }
                        var validLevels = levels.filter(function (level, index) {
                            return CapLevelController.isLevelAllowed(index, _this.restrictedLevels) && index <= capLevelIndex;
                        });
                        this.clientRect = null;
                        return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);
                    };
                    _proto.startCapping = function startCapping() {
                        if (this.timer) {
                            return;
                        }
                        this.autoLevelCapping = Number.POSITIVE_INFINITY;
                        this.hls.firstLevel = this.getMaxLevel(this.firstLevel);
                        self.clearInterval(this.timer);
                        this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3);
                        this.detectPlayerSize();
                    };
                    _proto.stopCapping = function stopCapping() {
                        this.restrictedLevels = [];
                        this.firstLevel = -1;
                        this.autoLevelCapping = Number.POSITIVE_INFINITY;
                        if (this.timer) {
                            self.clearInterval(this.timer);
                            this.timer = undefined;
                        }
                    };
                    _proto.getDimensions = function getDimensions() {
                        if (this.clientRect) {
                            return this.clientRect;
                        }
                        var media = this.media;
                        var boundsRect = { width: 0, height: 0 };
                        if (media) {
                            var clientRect = media.getBoundingClientRect();
                            boundsRect.width = clientRect.width;
                            boundsRect.height = clientRect.height;
                            if (!boundsRect.width && !boundsRect.height) {
                                boundsRect.width = clientRect.right - clientRect.left || media.width || 0;
                                boundsRect.height = clientRect.bottom - clientRect.top || media.height || 0;
                            }
                        }
                        this.clientRect = boundsRect;
                        return boundsRect;
                    };
                    CapLevelController.isLevelAllowed = function isLevelAllowed(level, restrictedLevels) {
                        if (restrictedLevels === void 0) {
                            restrictedLevels = [];
                        }
                        return restrictedLevels.indexOf(level) === -1;
                    };
                    CapLevelController.getMaxLevelByMediaSize = function getMaxLevelByMediaSize(levels, width, height) {
                        if (!levels || !levels.length) {
                            return -1;
                        }
                        var atGreatestBandwidth = function atGreatestBandwidth(curLevel, nextLevel) {
                            if (!nextLevel) {
                                return true;
                            }
                            return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;
                        };
                        var maxLevelIndex = levels.length - 1;
                        for (var i = 0; i < levels.length; i += 1) {
                            var level = levels[i];
                            if ((level.width >= width || level.height >= height) && atGreatestBandwidth(level, levels[i + 1])) {
                                maxLevelIndex = i;
                                break;
                            }
                        }
                        return maxLevelIndex;
                    };
                    _createClass(CapLevelController, [
                        {
                            key: "mediaWidth",
                            get: function get() {
                                return this.getDimensions().width * this.contentScaleFactor;
                            },
                        },
                        {
                            key: "mediaHeight",
                            get: function get() {
                                return this.getDimensions().height * this.contentScaleFactor;
                            },
                        },
                        {
                            key: "contentScaleFactor",
                            get: function get() {
                                var pixelRatio = 1;
                                if (!this.hls.config.ignoreDevicePixelRatio) {
                                    try {
                                        pixelRatio = self.devicePixelRatio;
                                    } catch (e) {}
                                }
                                return pixelRatio;
                            },
                        },
                    ]);
                    return CapLevelController;
                })();
                __webpack_exports__["default"] = CapLevelController;
            },
            "./src/controller/cmcd-controller.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "default", function () {
                    return CMCDController;
                });
                var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/events.ts");
                var _types_cmcd__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/types/cmcd.ts");
                var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/buffer-helper.ts");
                var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/utils/logger.ts");
                function _defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    Object.defineProperty(Constructor, "prototype", { writable: false });
                    return Constructor;
                }
                function _createForOfIteratorHelperLoose(o, allowArrayLike) {
                    var it = (typeof Symbol !== "undefined" && o[Symbol.iterator]) || o["@@iterator"];
                    if (it) return (it = it.call(o)).next.bind(it);
                    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || (allowArrayLike && o && typeof o.length === "number")) {
                        if (it) o = it;
                        var i = 0;
                        return function () {
                            if (i >= o.length) return { done: true };
                            return { done: false, value: o[i++] };
                        };
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                function _unsupportedIterableToArray(o, minLen) {
                    if (!o) return;
                    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
                    var n = Object.prototype.toString.call(o).slice(8, -1);
                    if (n === "Object" && o.constructor) n = o.constructor.name;
                    if (n === "Map" || n === "Set") return Array.from(o);
                    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
                }
                function _arrayLikeToArray(arr, len) {
                    if (len == null || len > arr.length) len = arr.length;
                    for (var i = 0, arr2 = new Array(len); i < len; i++) {
                        arr2[i] = arr[i];
                    }
                    return arr2;
                }
                function _extends() {
                    _extends = Object.assign
                        ? Object.assign.bind()
                        : function (target) {
                              for (var i = 1; i < arguments.length; i++) {
                                  var source = arguments[i];
                                  for (var key in source) {
                                      if (Object.prototype.hasOwnProperty.call(source, key)) {
                                          target[key] = source[key];
                                      }
                                  }
                              }
                              return target;
                          };
                    return _extends.apply(this, arguments);
                }
                var CMCDController = (function () {
                    function CMCDController(hls) {
                        var _this = this;
                        this.hls = void 0;
                        this.config = void 0;
                        this.media = void 0;
                        this.sid = void 0;
                        this.cid = void 0;
                        this.useHeaders = false;
                        this.initialized = false;
                        this.starved = false;
                        this.buffering = true;
                        this.audioBuffer = void 0;
                        this.videoBuffer = void 0;
                        this.onWaiting = function () {
                            if (_this.initialized) {
                                _this.starved = true;
                            }
                            _this.buffering = true;
                        };
                        this.onPlaying = function () {
                            if (!_this.initialized) {
                                _this.initialized = true;
                            }
                            _this.buffering = false;
                        };
                        this.applyPlaylistData = function (context) {
                            try {
                                _this.apply(context, { ot: _types_cmcd__WEBPACK_IMPORTED_MODULE_1__["CMCDObjectType"].MANIFEST, su: !_this.initialized });
                            } catch (error) {
                                _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].warn("Could not generate manifest CMCD data.", error);
                            }
                        };
                        this.applyFragmentData = function (context) {
                            try {
                                var fragment = context.frag;
                                var level = _this.hls.levels[fragment.level];
                                var ot = _this.getObjectType(fragment);
                                var data = { d: fragment.duration * 1e3, ot: ot };
                                if (
                                    ot === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__["CMCDObjectType"].VIDEO ||
                                    ot === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__["CMCDObjectType"].AUDIO ||
                                    ot == _types_cmcd__WEBPACK_IMPORTED_MODULE_1__["CMCDObjectType"].MUXED
                                ) {
                                    data.br = level.bitrate / 1e3;
                                    data.tb = _this.getTopBandwidth(ot) / 1e3;
                                    data.bl = _this.getBufferLength(ot);
                                }
                                _this.apply(context, data);
                            } catch (error) {
                                _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].warn("Could not generate segment CMCD data.", error);
                            }
                        };
                        this.hls = hls;
                        var config = (this.config = hls.config);
                        var cmcd = config.cmcd;
                        if (cmcd != null) {
                            config.pLoader = this.createPlaylistLoader();
                            config.fLoader = this.createFragmentLoader();
                            this.sid = cmcd.sessionId || CMCDController.uuid();
                            this.cid = cmcd.contentId;
                            this.useHeaders = cmcd.useHeaders === true;
                            this.registerListeners();
                        }
                    }
                    var _proto = CMCDController.prototype;
                    _proto.registerListeners = function registerListeners() {
                        var hls = this.hls;
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_DETACHED, this.onMediaDetached, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].BUFFER_CREATED, this.onBufferCreated, this);
                    };
                    _proto.unregisterListeners = function unregisterListeners() {
                        var hls = this.hls;
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_DETACHED, this.onMediaDetached, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].BUFFER_CREATED, this.onBufferCreated, this);
                        this.onMediaDetached();
                    };
                    _proto.destroy = function destroy() {
                        this.unregisterListeners();
                        this.hls = this.config = this.audioBuffer = this.videoBuffer = null;
                    };
                    _proto.onMediaAttached = function onMediaAttached(event, data) {
                        this.media = data.media;
                        this.media.addEventListener("waiting", this.onWaiting);
                        this.media.addEventListener("playing", this.onPlaying);
                    };
                    _proto.onMediaDetached = function onMediaDetached() {
                        if (!this.media) {
                            return;
                        }
                        this.media.removeEventListener("waiting", this.onWaiting);
                        this.media.removeEventListener("playing", this.onPlaying);
                        this.media = null;
                    };
                    _proto.onBufferCreated = function onBufferCreated(event, data) {
                        var _data$tracks$audio, _data$tracks$video;
                        this.audioBuffer = (_data$tracks$audio = data.tracks.audio) === null || _data$tracks$audio === void 0 ? void 0 : _data$tracks$audio.buffer;
                        this.videoBuffer = (_data$tracks$video = data.tracks.video) === null || _data$tracks$video === void 0 ? void 0 : _data$tracks$video.buffer;
                    };
                    _proto.createData = function createData() {
                        var _this$media;
                        return {
                            v: _types_cmcd__WEBPACK_IMPORTED_MODULE_1__["CMCDVersion"],
                            sf: _types_cmcd__WEBPACK_IMPORTED_MODULE_1__["CMCDStreamingFormat"].HLS,
                            sid: this.sid,
                            cid: this.cid,
                            pr: (_this$media = this.media) === null || _this$media === void 0 ? void 0 : _this$media.playbackRate,
                            mtp: this.hls.bandwidthEstimate / 1e3,
                        };
                    };
                    _proto.apply = function apply(context, data) {
                        if (data === void 0) {
                            data = {};
                        }
                        _extends(data, this.createData());
                        var isVideo =
                            data.ot === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__["CMCDObjectType"].INIT ||
                            data.ot === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__["CMCDObjectType"].VIDEO ||
                            data.ot === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__["CMCDObjectType"].MUXED;
                        if (this.starved && isVideo) {
                            data.bs = true;
                            data.su = true;
                            this.starved = false;
                        }
                        if (data.su == null) {
                            data.su = this.buffering;
                        }
                        if (this.useHeaders) {
                            var headers = CMCDController.toHeaders(data);
                            if (!Object.keys(headers).length) {
                                return;
                            }
                            if (!context.headers) {
                                context.headers = {};
                            }
                            _extends(context.headers, headers);
                        } else {
                            var query = CMCDController.toQuery(data);
                            if (!query) {
                                return;
                            }
                            context.url = CMCDController.appendQueryToUri(context.url, query);
                        }
                    };
                    _proto.getObjectType = function getObjectType(fragment) {
                        var type = fragment.type;
                        if (type === "subtitle") {
                            return _types_cmcd__WEBPACK_IMPORTED_MODULE_1__["CMCDObjectType"].TIMED_TEXT;
                        }
                        if (fragment.sn === "initSegment") {
                            return _types_cmcd__WEBPACK_IMPORTED_MODULE_1__["CMCDObjectType"].INIT;
                        }
                        if (type === "audio") {
                            return _types_cmcd__WEBPACK_IMPORTED_MODULE_1__["CMCDObjectType"].AUDIO;
                        }
                        if (type === "main") {
                            if (!this.hls.audioTracks.length) {
                                return _types_cmcd__WEBPACK_IMPORTED_MODULE_1__["CMCDObjectType"].MUXED;
                            }
                            return _types_cmcd__WEBPACK_IMPORTED_MODULE_1__["CMCDObjectType"].VIDEO;
                        }
                        return undefined;
                    };
                    _proto.getTopBandwidth = function getTopBandwidth(type) {
                        var bitrate = 0;
                        var levels;
                        var hls = this.hls;
                        if (type === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__["CMCDObjectType"].AUDIO) {
                            levels = hls.audioTracks;
                        } else {
                            var max = hls.maxAutoLevel;
                            var len = max > -1 ? max + 1 : hls.levels.length;
                            levels = hls.levels.slice(0, len);
                        }
                        for (var _iterator = _createForOfIteratorHelperLoose(levels), _step; !(_step = _iterator()).done; ) {
                            var level = _step.value;
                            if (level.bitrate > bitrate) {
                                bitrate = level.bitrate;
                            }
                        }
                        return bitrate > 0 ? bitrate : NaN;
                    };
                    _proto.getBufferLength = function getBufferLength(type) {
                        var media = this.hls.media;
                        var buffer = type === _types_cmcd__WEBPACK_IMPORTED_MODULE_1__["CMCDObjectType"].AUDIO ? this.audioBuffer : this.videoBuffer;
                        if (!buffer || !media) {
                            return NaN;
                        }
                        var info = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_2__["BufferHelper"].bufferInfo(buffer, media.currentTime, this.config.maxBufferHole);
                        return info.len * 1e3;
                    };
                    _proto.createPlaylistLoader = function createPlaylistLoader() {
                        var pLoader = this.config.pLoader;
                        var apply = this.applyPlaylistData;
                        var Ctor = pLoader || this.config.loader;
                        return (function () {
                            function CmcdPlaylistLoader(config) {
                                this.loader = void 0;
                                this.loader = new Ctor(config);
                            }
                            var _proto2 = CmcdPlaylistLoader.prototype;
                            _proto2.destroy = function destroy() {
                                this.loader.destroy();
                            };
                            _proto2.abort = function abort() {
                                this.loader.abort();
                            };
                            _proto2.load = function load(context, config, callbacks) {
                                apply(context);
                                this.loader.load(context, config, callbacks);
                            };
                            _createClass(CmcdPlaylistLoader, [
                                {
                                    key: "stats",
                                    get: function get() {
                                        return this.loader.stats;
                                    },
                                },
                                {
                                    key: "context",
                                    get: function get() {
                                        return this.loader.context;
                                    },
                                },
                            ]);
                            return CmcdPlaylistLoader;
                        })();
                    };
                    _proto.createFragmentLoader = function createFragmentLoader() {
                        var fLoader = this.config.fLoader;
                        var apply = this.applyFragmentData;
                        var Ctor = fLoader || this.config.loader;
                        return (function () {
                            function CmcdFragmentLoader(config) {
                                this.loader = void 0;
                                this.loader = new Ctor(config);
                            }
                            var _proto3 = CmcdFragmentLoader.prototype;
                            _proto3.destroy = function destroy() {
                                this.loader.destroy();
                            };
                            _proto3.abort = function abort() {
                                this.loader.abort();
                            };
                            _proto3.load = function load(context, config, callbacks) {
                                apply(context);
                                this.loader.load(context, config, callbacks);
                            };
                            _createClass(CmcdFragmentLoader, [
                                {
                                    key: "stats",
                                    get: function get() {
                                        return this.loader.stats;
                                    },
                                },
                                {
                                    key: "context",
                                    get: function get() {
                                        return this.loader.context;
                                    },
                                },
                            ]);
                            return CmcdFragmentLoader;
                        })();
                    };
                    CMCDController.uuid = function uuid() {
                        var url = URL.createObjectURL(new Blob());
                        var uuid = url.toString();
                        URL.revokeObjectURL(url);
                        return uuid.slice(uuid.lastIndexOf("/") + 1);
                    };
                    CMCDController.serialize = function serialize(data) {
                        var results = [];
                        var isValid = function isValid(value) {
                            return !Number.isNaN(value) && value != null && value !== "" && value !== false;
                        };
                        var toRounded = function toRounded(value) {
                            return Math.round(value);
                        };
                        var toHundred = function toHundred(value) {
                            return toRounded(value / 100) * 100;
                        };
                        var toUrlSafe = function toUrlSafe(value) {
                            return encodeURIComponent(value);
                        };
                        var formatters = { br: toRounded, d: toRounded, bl: toHundred, dl: toHundred, mtp: toHundred, nor: toUrlSafe, rtp: toHundred, tb: toRounded };
                        var keys = Object.keys(data || {}).sort();
                        for (var _iterator2 = _createForOfIteratorHelperLoose(keys), _step2; !(_step2 = _iterator2()).done; ) {
                            var key = _step2.value;
                            var value = data[key];
                            if (!isValid(value)) {
                                continue;
                            }
                            if (key === "v" && value === 1) {
                                continue;
                            }
                            if (key == "pr" && value === 1) {
                                continue;
                            }
                            var formatter = formatters[key];
                            if (formatter) {
                                value = formatter(value);
                            }
                            var type = typeof value;
                            var result = void 0;
                            if (key === "ot" || key === "sf" || key === "st") {
                                result = key + "=" + value;
                            } else if (type === "boolean") {
                                result = key;
                            } else if (type === "number") {
                                result = key + "=" + value;
                            } else {
                                result = key + "=" + JSON.stringify(value);
                            }
                            results.push(result);
                        }
                        return results.join(",");
                    };
                    CMCDController.toHeaders = function toHeaders(data) {
                        var keys = Object.keys(data);
                        var headers = {};
                        var headerNames = ["Object", "Request", "Session", "Status"];
                        var headerGroups = [{}, {}, {}, {}];
                        var headerMap = { br: 0, d: 0, ot: 0, tb: 0, bl: 1, dl: 1, mtp: 1, nor: 1, nrr: 1, su: 1, cid: 2, pr: 2, sf: 2, sid: 2, st: 2, v: 2, bs: 3, rtp: 3 };
                        for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
                            var key = _keys[_i];
                            var index = headerMap[key] != null ? headerMap[key] : 1;
                            headerGroups[index][key] = data[key];
                        }
                        for (var i = 0; i < headerGroups.length; i++) {
                            var value = CMCDController.serialize(headerGroups[i]);
                            if (value) {
                                headers["CMCD-" + headerNames[i]] = value;
                            }
                        }
                        return headers;
                    };
                    CMCDController.toQuery = function toQuery(data) {
                        return "CMCD=" + encodeURIComponent(CMCDController.serialize(data));
                    };
                    CMCDController.appendQueryToUri = function appendQueryToUri(uri, query) {
                        if (!query) {
                            return uri;
                        }
                        var separator = uri.includes("?") ? "&" : "?";
                        return "" + uri + separator + query;
                    };
                    return CMCDController;
                })();
            },
            "./src/controller/eme-controller.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/events.ts");
                var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/errors.ts");
                var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/logger.ts");
                var _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/utils/mediakeys-helper.ts");
                function _defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    Object.defineProperty(Constructor, "prototype", { writable: false });
                    return Constructor;
                }
                var MAX_LICENSE_REQUEST_FAILURES = 3;
                var createWidevineMediaKeySystemConfigurations = function createWidevineMediaKeySystemConfigurations(audioCodecs, videoCodecs, drmSystemOptions) {
                    var baseConfig = { audioCapabilities: [], videoCapabilities: [] };
                    audioCodecs.forEach(function (codec) {
                        baseConfig.audioCapabilities.push({ contentType: 'audio/mp4; codecs="' + codec + '"', robustness: drmSystemOptions.audioRobustness || "" });
                    });
                    videoCodecs.forEach(function (codec) {
                        baseConfig.videoCapabilities.push({ contentType: 'video/mp4; codecs="' + codec + '"', robustness: drmSystemOptions.videoRobustness || "" });
                    });
                    return [baseConfig];
                };
                var getSupportedMediaKeySystemConfigurations = function getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, drmSystemOptions) {
                    switch (keySystem) {
                        case _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__["KeySystems"].WIDEVINE:
                            return createWidevineMediaKeySystemConfigurations(audioCodecs, videoCodecs, drmSystemOptions);
                        default:
                            throw new Error("Unknown key-system: " + keySystem);
                    }
                };
                var EMEController = (function () {
                    function EMEController(hls) {
                        this.hls = void 0;
                        this._widevineLicenseUrl = void 0;
                        this._licenseXhrSetup = void 0;
                        this._licenseResponseCallback = void 0;
                        this._emeEnabled = void 0;
                        this._requestMediaKeySystemAccess = void 0;
                        this._drmSystemOptions = void 0;
                        this._config = void 0;
                        this._mediaKeysList = [];
                        this._media = null;
                        this._hasSetMediaKeys = false;
                        this._requestLicenseFailureCount = 0;
                        this.mediaKeysPromise = null;
                        this._onMediaEncrypted = this.onMediaEncrypted.bind(this);
                        this.hls = hls;
                        this._config = hls.config;
                        this._widevineLicenseUrl = this._config.widevineLicenseUrl;
                        this._licenseXhrSetup = this._config.licenseXhrSetup;
                        this._licenseResponseCallback = this._config.licenseResponseCallback;
                        this._emeEnabled = this._config.emeEnabled;
                        this._requestMediaKeySystemAccess = this._config.requestMediaKeySystemAccessFunc;
                        this._drmSystemOptions = this._config.drmSystemOptions;
                        this._registerListeners();
                    }
                    var _proto = EMEController.prototype;
                    _proto.destroy = function destroy() {
                        this._unregisterListeners();
                        this.hls = this._onMediaEncrypted = null;
                        this._requestMediaKeySystemAccess = null;
                    };
                    _proto._registerListeners = function _registerListeners() {
                        this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
                        this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_DETACHED, this.onMediaDetached, this);
                        this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MANIFEST_PARSED, this.onManifestParsed, this);
                    };
                    _proto._unregisterListeners = function _unregisterListeners() {
                        this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
                        this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_DETACHED, this.onMediaDetached, this);
                        this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MANIFEST_PARSED, this.onManifestParsed, this);
                    };
                    _proto.getLicenseServerUrl = function getLicenseServerUrl(keySystem) {
                        switch (keySystem) {
                            case _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__["KeySystems"].WIDEVINE:
                                if (!this._widevineLicenseUrl) {
                                    break;
                                }
                                return this._widevineLicenseUrl;
                        }
                        throw new Error('no license server URL configured for key-system "' + keySystem + '"');
                    };
                    _proto._attemptKeySystemAccess = function _attemptKeySystemAccess(keySystem, audioCodecs, videoCodecs) {
                        var _this = this;
                        var mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, this._drmSystemOptions);
                        _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("Requesting encrypted media key-system access");
                        var keySystemAccessPromise = this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs);
                        this.mediaKeysPromise = keySystemAccessPromise.then(function (mediaKeySystemAccess) {
                            return _this._onMediaKeySystemAccessObtained(keySystem, mediaKeySystemAccess);
                        });
                        keySystemAccessPromise.catch(function (err) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error('Failed to obtain key-system "' + keySystem + '" access:', err);
                        });
                    };
                    _proto._onMediaKeySystemAccessObtained = function _onMediaKeySystemAccessObtained(keySystem, mediaKeySystemAccess) {
                        var _this2 = this;
                        _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log('Access for key-system "' + keySystem + '" obtained');
                        var mediaKeysListItem = { mediaKeysSessionInitialized: false, mediaKeySystemAccess: mediaKeySystemAccess, mediaKeySystemDomain: keySystem };
                        this._mediaKeysList.push(mediaKeysListItem);
                        var mediaKeysPromise = Promise.resolve()
                            .then(function () {
                                return mediaKeySystemAccess.createMediaKeys();
                            })
                            .then(function (mediaKeys) {
                                mediaKeysListItem.mediaKeys = mediaKeys;
                                _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log('Media-keys created for key-system "' + keySystem + '"');
                                _this2._onMediaKeysCreated();
                                return mediaKeys;
                            });
                        mediaKeysPromise.catch(function (err) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error("Failed to create media-keys:", err);
                        });
                        return mediaKeysPromise;
                    };
                    _proto._onMediaKeysCreated = function _onMediaKeysCreated() {
                        var _this3 = this;
                        this._mediaKeysList.forEach(function (mediaKeysListItem) {
                            if (!mediaKeysListItem.mediaKeysSession) {
                                mediaKeysListItem.mediaKeysSession = mediaKeysListItem.mediaKeys.createSession();
                                _this3._onNewMediaKeySession(mediaKeysListItem.mediaKeysSession);
                            }
                        });
                    };
                    _proto._onNewMediaKeySession = function _onNewMediaKeySession(keySession) {
                        var _this4 = this;
                        _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("New key-system session " + keySession.sessionId);
                        keySession.addEventListener(
                            "message",
                            function (event) {
                                _this4._onKeySessionMessage(keySession, event.message);
                            },
                            false
                        );
                    };
                    _proto._onKeySessionMessage = function _onKeySessionMessage(keySession, message) {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("Got EME message event, creating license request");
                        this._requestLicense(message, function (data) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("Received license data (length: " + (data ? data.byteLength : data) + "), updating key-session");
                            keySession.update(data).catch(function (err) {
                                _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn("Updating key-session failed: " + err);
                            });
                        });
                    };
                    _proto.onMediaEncrypted = function onMediaEncrypted(e) {
                        var _this5 = this;
                        _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log('Media is encrypted using "' + e.initDataType + '" init data type');
                        if (!this.mediaKeysPromise) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error("Fatal: Media is encrypted but no CDM access or no keys have been requested");
                            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, {
                                type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].KEY_SYSTEM_ERROR,
                                details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].KEY_SYSTEM_NO_KEYS,
                                fatal: true,
                            });
                            return;
                        }
                        var finallySetKeyAndStartSession = function finallySetKeyAndStartSession(mediaKeys) {
                            if (!_this5._media) {
                                return;
                            }
                            _this5._attemptSetMediaKeys(mediaKeys);
                            _this5._generateRequestWithPreferredKeySession(e.initDataType, e.initData);
                        };
                        this.mediaKeysPromise.then(finallySetKeyAndStartSession).catch(finallySetKeyAndStartSession);
                    };
                    _proto._attemptSetMediaKeys = function _attemptSetMediaKeys(mediaKeys) {
                        if (!this._media) {
                            throw new Error("Attempted to set mediaKeys without first attaching a media element");
                        }
                        if (!this._hasSetMediaKeys) {
                            var keysListItem = this._mediaKeysList[0];
                            if (!keysListItem || !keysListItem.mediaKeys) {
                                _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error("Fatal: Media is encrypted but no CDM access or no keys have been obtained yet");
                                this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, {
                                    type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].KEY_SYSTEM_ERROR,
                                    details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].KEY_SYSTEM_NO_KEYS,
                                    fatal: true,
                                });
                                return;
                            }
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("Setting keys for encrypted media");
                            this._media.setMediaKeys(keysListItem.mediaKeys);
                            this._hasSetMediaKeys = true;
                        }
                    };
                    _proto._generateRequestWithPreferredKeySession = function _generateRequestWithPreferredKeySession(initDataType, initData) {
                        var _this6 = this;
                        var keysListItem = this._mediaKeysList[0];
                        if (!keysListItem) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error("Fatal: Media is encrypted but not any key-system access has been obtained yet");
                            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, {
                                type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].KEY_SYSTEM_ERROR,
                                details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].KEY_SYSTEM_NO_ACCESS,
                                fatal: true,
                            });
                            return;
                        }
                        if (keysListItem.mediaKeysSessionInitialized) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn("Key-Session already initialized but requested again");
                            return;
                        }
                        var keySession = keysListItem.mediaKeysSession;
                        if (!keySession) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error("Fatal: Media is encrypted but no key-session existing");
                            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, {
                                type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].KEY_SYSTEM_ERROR,
                                details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].KEY_SYSTEM_NO_SESSION,
                                fatal: true,
                            });
                            return;
                        }
                        if (!initData) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn("Fatal: initData required for generating a key session is null");
                            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, {
                                type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].KEY_SYSTEM_ERROR,
                                details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].KEY_SYSTEM_NO_INIT_DATA,
                                fatal: true,
                            });
                            return;
                        }
                        _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log('Generating key-session request for "' + initDataType + '" init data type');
                        keysListItem.mediaKeysSessionInitialized = true;
                        keySession
                            .generateRequest(initDataType, initData)
                            .then(function () {
                                _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].debug("Key-session generation succeeded");
                            })
                            .catch(function (err) {
                                _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error("Error generating key-session request:", err);
                                _this6.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, {
                                    type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].KEY_SYSTEM_ERROR,
                                    details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].KEY_SYSTEM_NO_SESSION,
                                    fatal: false,
                                });
                            });
                    };
                    _proto._createLicenseXhr = function _createLicenseXhr(url, keyMessage, callback) {
                        var xhr = new XMLHttpRequest();
                        xhr.responseType = "arraybuffer";
                        xhr.onreadystatechange = this._onLicenseRequestReadyStageChange.bind(this, xhr, url, keyMessage, callback);
                        var licenseXhrSetup = this._licenseXhrSetup;
                        if (licenseXhrSetup) {
                            try {
                                licenseXhrSetup.call(this.hls, xhr, url);
                                licenseXhrSetup = undefined;
                            } catch (e) {
                                _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error(e);
                            }
                        }
                        try {
                            if (!xhr.readyState) {
                                xhr.open("POST", url, true);
                            }
                            if (licenseXhrSetup) {
                                licenseXhrSetup.call(this.hls, xhr, url);
                            }
                        } catch (e) {
                            throw new Error("issue setting up KeySystem license XHR " + e);
                        }
                        return xhr;
                    };
                    _proto._onLicenseRequestReadyStageChange = function _onLicenseRequestReadyStageChange(xhr, url, keyMessage, callback) {
                        switch (xhr.readyState) {
                            case 4:
                                if (xhr.status === 200) {
                                    this._requestLicenseFailureCount = 0;
                                    _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("License request succeeded");
                                    var _data = xhr.response;
                                    var licenseResponseCallback = this._licenseResponseCallback;
                                    if (licenseResponseCallback) {
                                        try {
                                            _data = licenseResponseCallback.call(this.hls, xhr, url);
                                        } catch (e) {
                                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error(e);
                                        }
                                    }
                                    callback(_data);
                                } else {
                                    _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error("License Request XHR failed (" + url + "). Status: " + xhr.status + " (" + xhr.statusText + ")");
                                    this._requestLicenseFailureCount++;
                                    if (this._requestLicenseFailureCount > MAX_LICENSE_REQUEST_FAILURES) {
                                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, {
                                            type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].KEY_SYSTEM_ERROR,
                                            details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                                            fatal: true,
                                        });
                                        return;
                                    }
                                    var attemptsLeft = MAX_LICENSE_REQUEST_FAILURES - this._requestLicenseFailureCount + 1;
                                    _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn("Retrying license request, " + attemptsLeft + " attempts left");
                                    this._requestLicense(keyMessage, callback);
                                }
                                break;
                        }
                    };
                    _proto._generateLicenseRequestChallenge = function _generateLicenseRequestChallenge(keysListItem, keyMessage) {
                        switch (keysListItem.mediaKeySystemDomain) {
                            case _utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__["KeySystems"].WIDEVINE:
                                return keyMessage;
                        }
                        throw new Error("unsupported key-system: " + keysListItem.mediaKeySystemDomain);
                    };
                    _proto._requestLicense = function _requestLicense(keyMessage, callback) {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("Requesting content license for key-system");
                        var keysListItem = this._mediaKeysList[0];
                        if (!keysListItem) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error("Fatal error: Media is encrypted but no key-system access has been obtained yet");
                            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, {
                                type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].KEY_SYSTEM_ERROR,
                                details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].KEY_SYSTEM_NO_ACCESS,
                                fatal: true,
                            });
                            return;
                        }
                        try {
                            var _url = this.getLicenseServerUrl(keysListItem.mediaKeySystemDomain);
                            var _xhr = this._createLicenseXhr(_url, keyMessage, callback);
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("Sending license request to URL: " + _url);
                            var challenge = this._generateLicenseRequestChallenge(keysListItem, keyMessage);
                            _xhr.send(challenge);
                        } catch (e) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error("Failure requesting DRM license: " + e);
                            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, {
                                type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].KEY_SYSTEM_ERROR,
                                details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                                fatal: true,
                            });
                        }
                    };
                    _proto.onMediaAttached = function onMediaAttached(event, data) {
                        if (!this._emeEnabled) {
                            return;
                        }
                        var media = data.media;
                        this._media = media;
                        media.addEventListener("encrypted", this._onMediaEncrypted);
                    };
                    _proto.onMediaDetached = function onMediaDetached() {
                        var media = this._media;
                        var mediaKeysList = this._mediaKeysList;
                        if (!media) {
                            return;
                        }
                        media.removeEventListener("encrypted", this._onMediaEncrypted);
                        this._media = null;
                        this._mediaKeysList = [];
                        Promise.all(
                            mediaKeysList.map(function (mediaKeysListItem) {
                                if (mediaKeysListItem.mediaKeysSession) {
                                    return mediaKeysListItem.mediaKeysSession.close().catch(function () {});
                                }
                            })
                        )
                            .then(function () {
                                return media.setMediaKeys(null);
                            })
                            .catch(function () {});
                    };
                    _proto.onManifestParsed = function onManifestParsed(event, data) {
                        if (!this._emeEnabled) {
                            return;
                        }
                        var audioCodecs = data.levels
                            .map(function (level) {
                                return level.audioCodec;
                            })
                            .filter(function (audioCodec) {
                                return !!audioCodec;
                            });
                        var videoCodecs = data.levels
                            .map(function (level) {
                                return level.videoCodec;
                            })
                            .filter(function (videoCodec) {
                                return !!videoCodec;
                            });
                        this._attemptKeySystemAccess(_utils_mediakeys_helper__WEBPACK_IMPORTED_MODULE_3__["KeySystems"].WIDEVINE, audioCodecs, videoCodecs);
                    };
                    _createClass(EMEController, [
                        {
                            key: "requestMediaKeySystemAccess",
                            get: function get() {
                                if (!this._requestMediaKeySystemAccess) {
                                    throw new Error("No requestMediaKeySystemAccess function configured");
                                }
                                return this._requestMediaKeySystemAccess;
                            },
                        },
                    ]);
                    return EMEController;
                })();
                __webpack_exports__["default"] = EMEController;
            },
            "./src/controller/fps-controller.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/events.ts");
                var _utils_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/logger.ts");
                var FPSController = (function () {
                    function FPSController(hls) {
                        this.hls = void 0;
                        this.isVideoPlaybackQualityAvailable = false;
                        this.timer = void 0;
                        this.media = null;
                        this.lastTime = void 0;
                        this.lastDroppedFrames = 0;
                        this.lastDecodedFrames = 0;
                        this.streamController = void 0;
                        this.hls = hls;
                        this.registerListeners();
                    }
                    var _proto = FPSController.prototype;
                    _proto.setStreamController = function setStreamController(streamController) {
                        this.streamController = streamController;
                    };
                    _proto.registerListeners = function registerListeners() {
                        this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_ATTACHING, this.onMediaAttaching, this);
                    };
                    _proto.unregisterListeners = function unregisterListeners() {
                        this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_ATTACHING, this.onMediaAttaching);
                    };
                    _proto.destroy = function destroy() {
                        if (this.timer) {
                            clearInterval(this.timer);
                        }
                        this.unregisterListeners();
                        this.isVideoPlaybackQualityAvailable = false;
                        this.media = null;
                    };
                    _proto.onMediaAttaching = function onMediaAttaching(event, data) {
                        var config = this.hls.config;
                        if (config.capLevelOnFPSDrop) {
                            var media = data.media instanceof self.HTMLVideoElement ? data.media : null;
                            this.media = media;
                            if (media && typeof media.getVideoPlaybackQuality === "function") {
                                this.isVideoPlaybackQualityAvailable = true;
                            }
                            self.clearInterval(this.timer);
                            this.timer = self.setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);
                        }
                    };
                    _proto.checkFPS = function checkFPS(video, decodedFrames, droppedFrames) {
                        var currentTime = performance.now();
                        if (decodedFrames) {
                            if (this.lastTime) {
                                var currentPeriod = currentTime - this.lastTime;
                                var currentDropped = droppedFrames - this.lastDroppedFrames;
                                var currentDecoded = decodedFrames - this.lastDecodedFrames;
                                var droppedFPS = (1e3 * currentDropped) / currentPeriod;
                                var hls = this.hls;
                                hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].FPS_DROP, { currentDropped: currentDropped, currentDecoded: currentDecoded, totalDroppedFrames: droppedFrames });
                                if (droppedFPS > 0) {
                                    if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {
                                        var currentLevel = hls.currentLevel;
                                        _utils_logger__WEBPACK_IMPORTED_MODULE_1__["logger"].warn("drop FPS ratio greater than max allowed value for currentLevel: " + currentLevel);
                                        if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {
                                            currentLevel = currentLevel - 1;
                                            hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].FPS_DROP_LEVEL_CAPPING, { level: currentLevel, droppedLevel: hls.currentLevel });
                                            hls.autoLevelCapping = currentLevel;
                                            this.streamController.nextLevelSwitch();
                                        }
                                    }
                                }
                            }
                            this.lastTime = currentTime;
                            this.lastDroppedFrames = droppedFrames;
                            this.lastDecodedFrames = decodedFrames;
                        }
                    };
                    _proto.checkFPSInterval = function checkFPSInterval() {
                        var video = this.media;
                        if (video) {
                            if (this.isVideoPlaybackQualityAvailable) {
                                var videoPlaybackQuality = video.getVideoPlaybackQuality();
                                this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
                            } else {
                                this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);
                            }
                        }
                    };
                    return FPSController;
                })();
                __webpack_exports__["default"] = FPSController;
            },
            "./src/controller/fragment-finders.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "findFragmentByPDT", function () {
                    return findFragmentByPDT;
                });
                __webpack_require__.d(__webpack_exports__, "findFragmentByPTS", function () {
                    return findFragmentByPTS;
                });
                __webpack_require__.d(__webpack_exports__, "fragmentWithinToleranceTest", function () {
                    return fragmentWithinToleranceTest;
                });
                __webpack_require__.d(__webpack_exports__, "pdtWithinToleranceTest", function () {
                    return pdtWithinToleranceTest;
                });
                __webpack_require__.d(__webpack_exports__, "findFragWithCC", function () {
                    return findFragWithCC;
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/polyfills/number.ts");
                var _utils_binary_search__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/binary-search.ts");
                function findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {
                    if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(PDTValue)) {
                        return null;
                    }
                    var startPDT = fragments[0].programDateTime;
                    if (PDTValue < (startPDT || 0)) {
                        return null;
                    }
                    var endPDT = fragments[fragments.length - 1].endProgramDateTime;
                    if (PDTValue >= (endPDT || 0)) {
                        return null;
                    }
                    maxFragLookUpTolerance = maxFragLookUpTolerance || 0;
                    for (var seg = 0; seg < fragments.length; ++seg) {
                        var frag = fragments[seg];
                        if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {
                            return frag;
                        }
                    }
                    return null;
                }
                function findFragmentByPTS(fragPrevious, fragments, bufferEnd, maxFragLookUpTolerance) {
                    if (bufferEnd === void 0) {
                        bufferEnd = 0;
                    }
                    if (maxFragLookUpTolerance === void 0) {
                        maxFragLookUpTolerance = 0;
                    }
                    var fragNext = null;
                    if (fragPrevious) {
                        fragNext = fragments[fragPrevious.sn - fragments[0].sn + 1] || null;
                    } else if (bufferEnd === 0 && fragments[0].start === 0) {
                        fragNext = fragments[0];
                    }
                    if (fragNext && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0) {
                        return fragNext;
                    }
                    var foundFragment = _utils_binary_search__WEBPACK_IMPORTED_MODULE_1__["default"].search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));
                    if (foundFragment) {
                        return foundFragment;
                    }
                    return fragNext;
                }
                function fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, candidate) {
                    if (bufferEnd === void 0) {
                        bufferEnd = 0;
                    }
                    if (maxFragLookUpTolerance === void 0) {
                        maxFragLookUpTolerance = 0;
                    }
                    var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));
                    if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
                        return 1;
                    } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
                        return -1;
                    }
                    return 0;
                }
                function pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {
                    var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1e3;
                    var endProgramDateTime = candidate.endProgramDateTime || 0;
                    return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;
                }
                function findFragWithCC(fragments, cc) {
                    return _utils_binary_search__WEBPACK_IMPORTED_MODULE_1__["default"].search(fragments, function (candidate) {
                        if (candidate.cc < cc) {
                            return 1;
                        } else if (candidate.cc > cc) {
                            return -1;
                        } else {
                            return 0;
                        }
                    });
                }
            },
            "./src/controller/fragment-tracker.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "FragmentState", function () {
                    return FragmentState;
                });
                __webpack_require__.d(__webpack_exports__, "FragmentTracker", function () {
                    return FragmentTracker;
                });
                var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/events.ts");
                var _types_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/types/loader.ts");
                var FragmentState;
                (function (FragmentState) {
                    FragmentState["NOT_LOADED"] = "NOT_LOADED";
                    FragmentState["APPENDING"] = "APPENDING";
                    FragmentState["PARTIAL"] = "PARTIAL";
                    FragmentState["OK"] = "OK";
                })(FragmentState || (FragmentState = {}));
                var FragmentTracker = (function () {
                    function FragmentTracker(hls) {
                        this.activeFragment = null;
                        this.activeParts = null;
                        this.fragments = Object.create(null);
                        this.timeRanges = Object.create(null);
                        this.bufferPadding = 0.2;
                        this.hls = void 0;
                        this.hls = hls;
                        this._registerListeners();
                    }
                    var _proto = FragmentTracker.prototype;
                    _proto._registerListeners = function _registerListeners() {
                        var hls = this.hls;
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].BUFFER_APPENDED, this.onBufferAppended, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].FRAG_BUFFERED, this.onFragBuffered, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].FRAG_LOADED, this.onFragLoaded, this);
                    };
                    _proto._unregisterListeners = function _unregisterListeners() {
                        var hls = this.hls;
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].BUFFER_APPENDED, this.onBufferAppended, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].FRAG_BUFFERED, this.onFragBuffered, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].FRAG_LOADED, this.onFragLoaded, this);
                    };
                    _proto.destroy = function destroy() {
                        this._unregisterListeners();
                        this.fragments = this.timeRanges = null;
                    };
                    _proto.getAppendedFrag = function getAppendedFrag(position, levelType) {
                        if (levelType === _types_loader__WEBPACK_IMPORTED_MODULE_1__["PlaylistLevelType"].MAIN) {
                            var activeFragment = this.activeFragment,
                                activeParts = this.activeParts;
                            if (!activeFragment) {
                                return null;
                            }
                            if (activeParts) {
                                for (var i = activeParts.length; i--; ) {
                                    var activePart = activeParts[i];
                                    var appendedPTS = activePart ? activePart.end : activeFragment.appendedPTS;
                                    if (activePart.start <= position && appendedPTS !== undefined && position <= appendedPTS) {
                                        if (i > 9) {
                                            this.activeParts = activeParts.slice(i - 9);
                                        }
                                        return activePart;
                                    }
                                }
                            } else if (activeFragment.start <= position && activeFragment.appendedPTS !== undefined && position <= activeFragment.appendedPTS) {
                                return activeFragment;
                            }
                        }
                        return this.getBufferedFrag(position, levelType);
                    };
                    _proto.getBufferedFrag = function getBufferedFrag(position, levelType) {
                        var fragments = this.fragments;
                        var keys = Object.keys(fragments);
                        for (var i = keys.length; i--; ) {
                            var fragmentEntity = fragments[keys[i]];
                            if ((fragmentEntity === null || fragmentEntity === void 0 ? void 0 : fragmentEntity.body.type) === levelType && fragmentEntity.buffered) {
                                var frag = fragmentEntity.body;
                                if (frag.start <= position && position <= frag.end) {
                                    return frag;
                                }
                            }
                        }
                        return null;
                    };
                    _proto.detectEvictedFragments = function detectEvictedFragments(elementaryStream, timeRange, playlistType) {
                        var _this = this;
                        Object.keys(this.fragments).forEach(function (key) {
                            var fragmentEntity = _this.fragments[key];
                            if (!fragmentEntity) {
                                return;
                            }
                            if (!fragmentEntity.buffered) {
                                if (fragmentEntity.body.type === playlistType) {
                                    _this.removeFragment(fragmentEntity.body);
                                }
                                return;
                            }
                            var esData = fragmentEntity.range[elementaryStream];
                            if (!esData) {
                                return;
                            }
                            esData.time.some(function (time) {
                                var isNotBuffered = !_this.isTimeBuffered(time.startPTS, time.endPTS, timeRange);
                                if (isNotBuffered) {
                                    _this.removeFragment(fragmentEntity.body);
                                }
                                return isNotBuffered;
                            });
                        });
                    };
                    _proto.detectPartialFragments = function detectPartialFragments(data) {
                        var _this2 = this;
                        var timeRanges = this.timeRanges;
                        var frag = data.frag,
                            part = data.part;
                        if (!timeRanges || frag.sn === "initSegment") {
                            return;
                        }
                        var fragKey = getFragmentKey(frag);
                        var fragmentEntity = this.fragments[fragKey];
                        if (!fragmentEntity) {
                            return;
                        }
                        Object.keys(timeRanges).forEach(function (elementaryStream) {
                            var streamInfo = frag.elementaryStreams[elementaryStream];
                            if (!streamInfo) {
                                return;
                            }
                            var timeRange = timeRanges[elementaryStream];
                            var partial = part !== null || streamInfo.partial === true;
                            fragmentEntity.range[elementaryStream] = _this2.getBufferedTimes(frag, part, partial, timeRange);
                        });
                        fragmentEntity.loaded = null;
                        if (Object.keys(fragmentEntity.range).length) {
                            fragmentEntity.buffered = true;
                        } else {
                            this.removeFragment(fragmentEntity.body);
                        }
                    };
                    _proto.fragBuffered = function fragBuffered(frag) {
                        var fragKey = getFragmentKey(frag);
                        var fragmentEntity = this.fragments[fragKey];
                        if (fragmentEntity) {
                            fragmentEntity.loaded = null;
                            fragmentEntity.buffered = true;
                        }
                    };
                    _proto.getBufferedTimes = function getBufferedTimes(fragment, part, partial, timeRange) {
                        var buffered = { time: [], partial: partial };
                        var startPTS = part ? part.start : fragment.start;
                        var endPTS = part ? part.end : fragment.end;
                        var minEndPTS = fragment.minEndPTS || endPTS;
                        var maxStartPTS = fragment.maxStartPTS || startPTS;
                        for (var i = 0; i < timeRange.length; i++) {
                            var startTime = timeRange.start(i) - this.bufferPadding;
                            var endTime = timeRange.end(i) + this.bufferPadding;
                            if (maxStartPTS >= startTime && minEndPTS <= endTime) {
                                buffered.time.push({ startPTS: Math.max(startPTS, timeRange.start(i)), endPTS: Math.min(endPTS, timeRange.end(i)) });
                                break;
                            } else if (startPTS < endTime && endPTS > startTime) {
                                buffered.partial = true;
                                buffered.time.push({ startPTS: Math.max(startPTS, timeRange.start(i)), endPTS: Math.min(endPTS, timeRange.end(i)) });
                            } else if (endPTS <= startTime) {
                                break;
                            }
                        }
                        return buffered;
                    };
                    _proto.getPartialFragment = function getPartialFragment(time) {
                        var bestFragment = null;
                        var timePadding;
                        var startTime;
                        var endTime;
                        var bestOverlap = 0;
                        var bufferPadding = this.bufferPadding,
                            fragments = this.fragments;
                        Object.keys(fragments).forEach(function (key) {
                            var fragmentEntity = fragments[key];
                            if (!fragmentEntity) {
                                return;
                            }
                            if (isPartial(fragmentEntity)) {
                                startTime = fragmentEntity.body.start - bufferPadding;
                                endTime = fragmentEntity.body.end + bufferPadding;
                                if (time >= startTime && time <= endTime) {
                                    timePadding = Math.min(time - startTime, endTime - time);
                                    if (bestOverlap <= timePadding) {
                                        bestFragment = fragmentEntity.body;
                                        bestOverlap = timePadding;
                                    }
                                }
                            }
                        });
                        return bestFragment;
                    };
                    _proto.getState = function getState(fragment) {
                        var fragKey = getFragmentKey(fragment);
                        var fragmentEntity = this.fragments[fragKey];
                        if (fragmentEntity) {
                            if (!fragmentEntity.buffered) {
                                return FragmentState.APPENDING;
                            } else if (isPartial(fragmentEntity)) {
                                return FragmentState.PARTIAL;
                            } else {
                                return FragmentState.OK;
                            }
                        }
                        return FragmentState.NOT_LOADED;
                    };
                    _proto.isTimeBuffered = function isTimeBuffered(startPTS, endPTS, timeRange) {
                        var startTime;
                        var endTime;
                        for (var i = 0; i < timeRange.length; i++) {
                            startTime = timeRange.start(i) - this.bufferPadding;
                            endTime = timeRange.end(i) + this.bufferPadding;
                            if (startPTS >= startTime && endPTS <= endTime) {
                                return true;
                            }
                            if (endPTS <= startTime) {
                                return false;
                            }
                        }
                        return false;
                    };
                    _proto.onFragLoaded = function onFragLoaded(event, data) {
                        var frag = data.frag,
                            part = data.part;
                        if (frag.sn === "initSegment" || frag.bitrateTest || part) {
                            return;
                        }
                        var fragKey = getFragmentKey(frag);
                        this.fragments[fragKey] = { body: frag, loaded: data, buffered: false, range: Object.create(null) };
                    };
                    _proto.onBufferAppended = function onBufferAppended(event, data) {
                        var _this3 = this;
                        var frag = data.frag,
                            part = data.part,
                            timeRanges = data.timeRanges;
                        if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_1__["PlaylistLevelType"].MAIN) {
                            this.activeFragment = frag;
                            if (part) {
                                var activeParts = this.activeParts;
                                if (!activeParts) {
                                    this.activeParts = activeParts = [];
                                }
                                activeParts.push(part);
                            } else {
                                this.activeParts = null;
                            }
                        }
                        this.timeRanges = timeRanges;
                        Object.keys(timeRanges).forEach(function (elementaryStream) {
                            var timeRange = timeRanges[elementaryStream];
                            _this3.detectEvictedFragments(elementaryStream, timeRange);
                            if (!part) {
                                for (var i = 0; i < timeRange.length; i++) {
                                    frag.appendedPTS = Math.max(timeRange.end(i), frag.appendedPTS || 0);
                                }
                            }
                        });
                    };
                    _proto.onFragBuffered = function onFragBuffered(event, data) {
                        this.detectPartialFragments(data);
                    };
                    _proto.hasFragment = function hasFragment(fragment) {
                        var fragKey = getFragmentKey(fragment);
                        return !!this.fragments[fragKey];
                    };
                    _proto.removeFragmentsInRange = function removeFragmentsInRange(start, end, playlistType) {
                        var _this4 = this;
                        Object.keys(this.fragments).forEach(function (key) {
                            var fragmentEntity = _this4.fragments[key];
                            if (!fragmentEntity) {
                                return;
                            }
                            if (fragmentEntity.buffered) {
                                var frag = fragmentEntity.body;
                                if (frag.type === playlistType && frag.start < end && frag.end > start) {
                                    _this4.removeFragment(frag);
                                }
                            }
                        });
                    };
                    _proto.removeFragment = function removeFragment(fragment) {
                        var fragKey = getFragmentKey(fragment);
                        fragment.stats.loaded = 0;
                        fragment.clearElementaryStreamInfo();
                        delete this.fragments[fragKey];
                    };
                    _proto.removeAllFragments = function removeAllFragments() {
                        this.fragments = Object.create(null);
                        this.activeFragment = null;
                        this.activeParts = null;
                    };
                    return FragmentTracker;
                })();
                function isPartial(fragmentEntity) {
                    var _fragmentEntity$range, _fragmentEntity$range2;
                    return (
                        fragmentEntity.buffered &&
                        (((_fragmentEntity$range = fragmentEntity.range.video) === null || _fragmentEntity$range === void 0 ? void 0 : _fragmentEntity$range.partial) ||
                            ((_fragmentEntity$range2 = fragmentEntity.range.audio) === null || _fragmentEntity$range2 === void 0 ? void 0 : _fragmentEntity$range2.partial))
                    );
                }
                function getFragmentKey(fragment) {
                    return fragment.type + "_" + fragment.level + "_" + fragment.urlId + "_" + fragment.sn;
                }
            },
            "./src/controller/gap-controller.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "STALL_MINIMUM_DURATION_MS", function () {
                    return STALL_MINIMUM_DURATION_MS;
                });
                __webpack_require__.d(__webpack_exports__, "MAX_START_GAP_JUMP", function () {
                    return MAX_START_GAP_JUMP;
                });
                __webpack_require__.d(__webpack_exports__, "SKIP_BUFFER_HOLE_STEP_SECONDS", function () {
                    return SKIP_BUFFER_HOLE_STEP_SECONDS;
                });
                __webpack_require__.d(__webpack_exports__, "SKIP_BUFFER_RANGE_START", function () {
                    return SKIP_BUFFER_RANGE_START;
                });
                __webpack_require__.d(__webpack_exports__, "default", function () {
                    return GapController;
                });
                var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/buffer-helper.ts");
                var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/errors.ts");
                var _events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/events.ts");
                var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/utils/logger.ts");
                var STALL_MINIMUM_DURATION_MS = 250;
                var MAX_START_GAP_JUMP = 2;
                var SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;
                var SKIP_BUFFER_RANGE_START = 0.05;
                var GapController = (function () {
                    function GapController(config, media, fragmentTracker, hls) {
                        this.config = void 0;
                        this.media = null;
                        this.fragmentTracker = void 0;
                        this.hls = void 0;
                        this.nudgeRetry = 0;
                        this.stallReported = false;
                        this.stalled = null;
                        this.moved = false;
                        this.seeking = false;
                        this.config = config;
                        this.media = media;
                        this.fragmentTracker = fragmentTracker;
                        this.hls = hls;
                    }
                    var _proto = GapController.prototype;
                    _proto.destroy = function destroy() {
                        this.media = null;
                        this.hls = this.fragmentTracker = null;
                    };
                    _proto.poll = function poll(lastCurrentTime, activeFrag) {
                        var config = this.config,
                            media = this.media,
                            stalled = this.stalled;
                        if (media === null) {
                            return;
                        }
                        var currentTime = media.currentTime,
                            seeking = media.seeking;
                        var seeked = this.seeking && !seeking;
                        var beginSeek = !this.seeking && seeking;
                        this.seeking = seeking;
                        if (currentTime !== lastCurrentTime) {
                            this.moved = true;
                            if (stalled !== null) {
                                if (this.stallReported) {
                                    var _stalledDuration = self.performance.now() - stalled;
                                    _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].warn("playback not stuck anymore @" + currentTime + ", after " + Math.round(_stalledDuration) + "ms");
                                    this.stallReported = false;
                                }
                                this.stalled = null;
                                this.nudgeRetry = 0;
                            }
                            return;
                        }
                        if (beginSeek || seeked) {
                            this.stalled = null;
                        }
                        if ((media.paused && !seeking) || media.ended || media.playbackRate === 0 || !_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__["BufferHelper"].getBuffered(media).length) {
                            return;
                        }
                        var bufferInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__["BufferHelper"].bufferInfo(media, currentTime, 0);
                        var isBuffered = bufferInfo.len > 0;
                        var nextStart = bufferInfo.nextStart || 0;
                        if (!isBuffered && !nextStart) {
                            return;
                        }
                        if (seeking) {
                            var hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP;
                            var noBufferGap = !nextStart || (activeFrag && activeFrag.start <= currentTime) || (nextStart - currentTime > MAX_START_GAP_JUMP && !this.fragmentTracker.getPartialFragment(currentTime));
                            if (hasEnoughBuffer || noBufferGap) {
                                return;
                            }
                            this.moved = false;
                        }
                        if (!this.moved && this.stalled !== null) {
                            var _level$details;
                            var startJump = Math.max(nextStart, bufferInfo.start || 0) - currentTime;
                            var level = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null;
                            var isLive = level === null || level === void 0 ? void 0 : (_level$details = level.details) === null || _level$details === void 0 ? void 0 : _level$details.live;
                            var maxStartGapJump = isLive ? level.details.targetduration * 2 : MAX_START_GAP_JUMP;
                            if (startJump > 0 && startJump <= maxStartGapJump) {
                                this._trySkipBufferHole(null);
                                return;
                            }
                        }
                        var tnow = self.performance.now();
                        if (stalled === null) {
                            this.stalled = tnow;
                            return;
                        }
                        var stalledDuration = tnow - stalled;
                        if (!seeking && stalledDuration >= STALL_MINIMUM_DURATION_MS) {
                            this._reportStall(bufferInfo);
                            if (!this.media) {
                                return;
                            }
                        }
                        var bufferedWithHoles = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__["BufferHelper"].bufferInfo(media, currentTime, config.maxBufferHole);
                        this._tryFixBufferStall(bufferedWithHoles, stalledDuration);
                    };
                    _proto._tryFixBufferStall = function _tryFixBufferStall(bufferInfo, stalledDurationMs) {
                        var config = this.config,
                            fragmentTracker = this.fragmentTracker,
                            media = this.media;
                        if (media === null) {
                            return;
                        }
                        var currentTime = media.currentTime;
                        var partial = fragmentTracker.getPartialFragment(currentTime);
                        if (partial) {
                            var targetTime = this._trySkipBufferHole(partial);
                            if (targetTime || !this.media) {
                                return;
                            }
                        }
                        if (bufferInfo.len > config.maxBufferHole && stalledDurationMs > config.highBufferWatchdogPeriod * 1e3) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].warn("Trying to nudge playhead over buffer-hole");
                            this.stalled = null;
                            this._tryNudgeBuffer();
                        }
                    };
                    _proto._reportStall = function _reportStall(bufferInfo) {
                        var hls = this.hls,
                            media = this.media,
                            stallReported = this.stallReported;
                        if (!stallReported && media) {
                            this.stallReported = true;
                            _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].warn("Playback stalling at @" + media.currentTime + " due to low buffer (" + JSON.stringify(bufferInfo) + ")");
                            hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].ERROR, {
                                type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].MEDIA_ERROR,
                                details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].BUFFER_STALLED_ERROR,
                                fatal: false,
                                buffer: bufferInfo.len,
                            });
                        }
                    };
                    _proto._trySkipBufferHole = function _trySkipBufferHole(partial) {
                        var config = this.config,
                            hls = this.hls,
                            media = this.media;
                        if (media === null) {
                            return 0;
                        }
                        var currentTime = media.currentTime;
                        var lastEndTime = 0;
                        var buffered = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_0__["BufferHelper"].getBuffered(media);
                        for (var i = 0; i < buffered.length; i++) {
                            var startTime = buffered.start(i);
                            if (currentTime + config.maxBufferHole >= lastEndTime && currentTime < startTime) {
                                var targetTime = Math.max(startTime + SKIP_BUFFER_RANGE_START, media.currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);
                                _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].warn("skipping hole, adjusting currentTime from " + currentTime + " to " + targetTime);
                                this.moved = true;
                                this.stalled = null;
                                media.currentTime = targetTime;
                                if (partial) {
                                    hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].ERROR, {
                                        type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].MEDIA_ERROR,
                                        details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].BUFFER_SEEK_OVER_HOLE,
                                        fatal: false,
                                        reason: "fragment loaded with buffer holes, seeking from " + currentTime + " to " + targetTime,
                                        frag: partial,
                                    });
                                }
                                return targetTime;
                            }
                            lastEndTime = buffered.end(i);
                        }
                        return 0;
                    };
                    _proto._tryNudgeBuffer = function _tryNudgeBuffer() {
                        var config = this.config,
                            hls = this.hls,
                            media = this.media,
                            nudgeRetry = this.nudgeRetry;
                        if (media === null) {
                            return;
                        }
                        var currentTime = media.currentTime;
                        this.nudgeRetry++;
                        if (nudgeRetry < config.nudgeMaxRetry) {
                            var targetTime = currentTime + (nudgeRetry + 1) * config.nudgeOffset;
                            _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].warn("Nudging 'currentTime' from " + currentTime + " to " + targetTime);
                            media.currentTime = targetTime;
                            hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].ERROR, {
                                type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].MEDIA_ERROR,
                                details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].BUFFER_NUDGE_ON_STALL,
                                fatal: false,
                            });
                        } else {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].error("Playhead still not moving while enough data buffered @" + currentTime + " after " + config.nudgeMaxRetry + " nudges");
                            hls.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].ERROR, {
                                type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].MEDIA_ERROR,
                                details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].BUFFER_STALLED_ERROR,
                                fatal: true,
                            });
                        }
                    };
                    return GapController;
                })();
            },
            "./src/controller/id3-track-controller.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/polyfills/number.ts");
                var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/events.ts");
                var _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/texttrack-utils.ts");
                var _demux_id3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/demux/id3.ts");
                var _loader_date_range__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/loader/date-range.ts");
                var _types_demuxer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/types/demuxer.ts");
                var MIN_CUE_DURATION = 0.25;
                function getCueClass() {
                    return self.WebKitDataCue || self.VTTCue || self.TextTrackCue;
                }
                function dateRangeDateToTimelineSeconds(date, offset) {
                    return date.getTime() / 1e3 - offset;
                }
                function hexToArrayBuffer(str) {
                    return Uint8Array.from(
                        str
                            .replace(/^0x/, "")
                            .replace(/([\da-fA-F]{2}) ?/g, "0x$1 ")
                            .replace(/ +$/, "")
                            .split(" ")
                    ).buffer;
                }
                var ID3TrackController = (function () {
                    function ID3TrackController(hls) {
                        this.hls = void 0;
                        this.id3Track = null;
                        this.media = null;
                        this.dateRangeCuesAppended = {};
                        this.hls = hls;
                        this._registerListeners();
                    }
                    var _proto = ID3TrackController.prototype;
                    _proto.destroy = function destroy() {
                        this._unregisterListeners();
                        this.id3Track = null;
                        this.media = null;
                        this.dateRangeCuesAppended = {};
                        this.hls = null;
                    };
                    _proto._registerListeners = function _registerListeners() {
                        var hls = this.hls;
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_FLUSHING, this.onBufferFlushing, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVEL_UPDATED, this.onLevelUpdated, this);
                    };
                    _proto._unregisterListeners = function _unregisterListeners() {
                        var hls = this.hls;
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_FLUSHING, this.onBufferFlushing, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVEL_UPDATED, this.onLevelUpdated, this);
                    };
                    _proto.onMediaAttached = function onMediaAttached(event, data) {
                        this.media = data.media;
                    };
                    _proto.onMediaDetaching = function onMediaDetaching() {
                        if (!this.id3Track) {
                            return;
                        }
                        Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_2__["clearCurrentCues"])(this.id3Track);
                        this.id3Track = null;
                        this.media = null;
                        this.dateRangeCuesAppended = {};
                    };
                    _proto.onManifestLoading = function onManifestLoading() {
                        this.dateRangeCuesAppended = {};
                    };
                    _proto.createTrack = function createTrack(media) {
                        var track = this.getID3Track(media.textTracks);
                        track.mode = "hidden";
                        return track;
                    };
                    _proto.getID3Track = function getID3Track(textTracks) {
                        if (!this.media) {
                            return;
                        }
                        for (var i = 0; i < textTracks.length; i++) {
                            var textTrack = textTracks[i];
                            if (textTrack.kind === "metadata" && textTrack.label === "id3") {
                                Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_2__["sendAddTrackEvent"])(textTrack, this.media);
                                return textTrack;
                            }
                        }
                        return this.media.addTextTrack("metadata", "id3");
                    };
                    _proto.onFragParsingMetadata = function onFragParsingMetadata(event, data) {
                        if (!this.media) {
                            return;
                        }
                        var _this$hls$config = this.hls.config,
                            enableEmsgMetadataCues = _this$hls$config.enableEmsgMetadataCues,
                            enableID3MetadataCues = _this$hls$config.enableID3MetadataCues;
                        if (!enableEmsgMetadataCues && !enableID3MetadataCues) {
                            return;
                        }
                        var fragment = data.frag,
                            samples = data.samples,
                            details = data.details;
                        if (!this.id3Track) {
                            this.id3Track = this.createTrack(this.media);
                        }
                        var maxCueTime = details.edge || fragment.end;
                        var Cue = getCueClass();
                        var updateCueRanges = false;
                        var frameTypesAdded = {};
                        for (var i = 0; i < samples.length; i++) {
                            var type = samples[i].type;
                            if ((type === _types_demuxer__WEBPACK_IMPORTED_MODULE_5__["MetadataSchema"].emsg && !enableEmsgMetadataCues) || !enableID3MetadataCues) {
                                continue;
                            }
                            var frames = _demux_id3__WEBPACK_IMPORTED_MODULE_3__["getID3Frames"](samples[i].data);
                            if (frames) {
                                var startTime = samples[i].pts;
                                var endTime = maxCueTime;
                                var timeDiff = endTime - startTime;
                                if (timeDiff <= 0) {
                                    endTime = startTime + MIN_CUE_DURATION;
                                }
                                for (var j = 0; j < frames.length; j++) {
                                    var frame = frames[j];
                                    if (!_demux_id3__WEBPACK_IMPORTED_MODULE_3__["isTimeStampFrame"](frame)) {
                                        var cue = new Cue(startTime, endTime, "");
                                        cue.value = frame;
                                        if (type) {
                                            cue.type = type;
                                        }
                                        this.id3Track.addCue(cue);
                                        frameTypesAdded[frame.key] = null;
                                        updateCueRanges = true;
                                    }
                                }
                            }
                        }
                        if (updateCueRanges) {
                            this.updateId3CueEnds(frameTypesAdded);
                        }
                    };
                    _proto.updateId3CueEnds = function updateId3CueEnds(frameTypesAdded) {
                        var _this$id3Track;
                        var cues = (_this$id3Track = this.id3Track) === null || _this$id3Track === void 0 ? void 0 : _this$id3Track.cues;
                        if (cues) {
                            for (var i = cues.length; i--; ) {
                                var _cue$value;
                                var cue = cues[i];
                                var frameType = (_cue$value = cue.value) === null || _cue$value === void 0 ? void 0 : _cue$value.key;
                                if (frameType && frameType in frameTypesAdded) {
                                    var startTime = frameTypesAdded[frameType];
                                    if (startTime && cue.endTime !== startTime) {
                                        cue.endTime = startTime;
                                    }
                                    frameTypesAdded[frameType] = cue.startTime;
                                }
                            }
                        }
                    };
                    _proto.onBufferFlushing = function onBufferFlushing(event, _ref) {
                        var startOffset = _ref.startOffset,
                            endOffset = _ref.endOffset,
                            type = _ref.type;
                        var id3Track = this.id3Track,
                            hls = this.hls;
                        if (!hls) {
                            return;
                        }
                        var _hls$config = hls.config,
                            enableEmsgMetadataCues = _hls$config.enableEmsgMetadataCues,
                            enableID3MetadataCues = _hls$config.enableID3MetadataCues;
                        if (id3Track && (enableEmsgMetadataCues || enableID3MetadataCues)) {
                            var predicate;
                            if (type === "audio") {
                                predicate = function predicate(cue) {
                                    return cue.type === _types_demuxer__WEBPACK_IMPORTED_MODULE_5__["MetadataSchema"].audioId3 && enableID3MetadataCues;
                                };
                            } else if (type === "video") {
                                predicate = function predicate(cue) {
                                    return cue.type === _types_demuxer__WEBPACK_IMPORTED_MODULE_5__["MetadataSchema"].emsg && enableEmsgMetadataCues;
                                };
                            } else {
                                predicate = function predicate(cue) {
                                    return (
                                        (cue.type === _types_demuxer__WEBPACK_IMPORTED_MODULE_5__["MetadataSchema"].audioId3 && enableID3MetadataCues) ||
                                        (cue.type === _types_demuxer__WEBPACK_IMPORTED_MODULE_5__["MetadataSchema"].emsg && enableEmsgMetadataCues)
                                    );
                                };
                            }
                            Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_2__["removeCuesInRange"])(id3Track, startOffset, endOffset, predicate);
                        }
                    };
                    _proto.onLevelUpdated = function onLevelUpdated(event, _ref2) {
                        var _this = this;
                        var details = _ref2.details;
                        if (!this.media || !details.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) {
                            return;
                        }
                        var dateRangeCuesAppended = this.dateRangeCuesAppended,
                            id3Track = this.id3Track;
                        var dateRanges = details.dateRanges;
                        var ids = Object.keys(dateRanges);
                        if (id3Track) {
                            var idsToRemove = Object.keys(dateRangeCuesAppended).filter(function (id) {
                                return !ids.includes(id);
                            });
                            var _loop = function _loop(i) {
                                var id = idsToRemove[i];
                                Object.keys(dateRangeCuesAppended[id].cues).forEach(function (key) {
                                    id3Track.removeCue(dateRangeCuesAppended[id].cues[key]);
                                });
                                delete dateRangeCuesAppended[id];
                            };
                            for (var i = idsToRemove.length; i--; ) {
                                _loop(i);
                            }
                        }
                        var lastFragment = details.fragments[details.fragments.length - 1];
                        if (
                            ids.length === 0 ||
                            !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(lastFragment === null || lastFragment === void 0 ? void 0 : lastFragment.programDateTime)
                        ) {
                            return;
                        }
                        if (!this.id3Track) {
                            this.id3Track = this.createTrack(this.media);
                        }
                        var dateTimeOffset = lastFragment.programDateTime / 1e3 - lastFragment.start;
                        var maxCueTime = details.edge || lastFragment.end;
                        var Cue = getCueClass();
                        var _loop2 = function _loop2(_i) {
                            var id = ids[_i];
                            var dateRange = dateRanges[id];
                            var appendedDateRangeCues = dateRangeCuesAppended[id];
                            var cues = (appendedDateRangeCues === null || appendedDateRangeCues === void 0 ? void 0 : appendedDateRangeCues.cues) || {};
                            var durationKnown = (appendedDateRangeCues === null || appendedDateRangeCues === void 0 ? void 0 : appendedDateRangeCues.durationKnown) || false;
                            var startTime = dateRangeDateToTimelineSeconds(dateRange.startDate, dateTimeOffset);
                            var endTime = maxCueTime;
                            var endDate = dateRange.endDate;
                            if (endDate) {
                                endTime = dateRangeDateToTimelineSeconds(endDate, dateTimeOffset);
                                durationKnown = true;
                            } else if (dateRange.endOnNext && !durationKnown) {
                                var nextDateRangeWithSameClass = ids
                                    .reduce(function (filterMapArray, id) {
                                        var candidate = dateRanges[id];
                                        if (candidate.class === dateRange.class && candidate.id !== id && candidate.startDate > dateRange.startDate) {
                                            filterMapArray.push(candidate);
                                        }
                                        return filterMapArray;
                                    }, [])
                                    .sort(function (a, b) {
                                        return a.startDate.getTime() - b.startDate.getTime();
                                    })[0];
                                if (nextDateRangeWithSameClass) {
                                    endTime = dateRangeDateToTimelineSeconds(nextDateRangeWithSameClass.startDate, dateTimeOffset);
                                    durationKnown = true;
                                }
                            }
                            var attributes = Object.keys(dateRange.attr);
                            for (var j = 0; j < attributes.length; j++) {
                                var key = attributes[j];
                                if (
                                    key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__["DateRangeAttribute"].ID ||
                                    key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__["DateRangeAttribute"].CLASS ||
                                    key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__["DateRangeAttribute"].START_DATE ||
                                    key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__["DateRangeAttribute"].DURATION ||
                                    key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__["DateRangeAttribute"].END_DATE ||
                                    key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__["DateRangeAttribute"].END_ON_NEXT
                                ) {
                                    continue;
                                }
                                var cue = cues[key];
                                if (cue) {
                                    if (durationKnown && !appendedDateRangeCues.durationKnown) {
                                        cue.endTime = endTime;
                                    }
                                } else {
                                    var data = dateRange.attr[key];
                                    cue = new Cue(startTime, endTime, "");
                                    if (key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__["DateRangeAttribute"].SCTE35_OUT || key === _loader_date_range__WEBPACK_IMPORTED_MODULE_4__["DateRangeAttribute"].SCTE35_IN) {
                                        data = hexToArrayBuffer(data);
                                    }
                                    cue.value = { key: key, data: data };
                                    cue.type = _types_demuxer__WEBPACK_IMPORTED_MODULE_5__["MetadataSchema"].dateRange;
                                    _this.id3Track.addCue(cue);
                                    cues[key] = cue;
                                }
                            }
                            dateRangeCuesAppended[id] = { cues: cues, dateRange: dateRange, durationKnown: durationKnown };
                        };
                        for (var _i = 0; _i < ids.length; _i++) {
                            _loop2(_i);
                        }
                    };
                    return ID3TrackController;
                })();
                __webpack_exports__["default"] = ID3TrackController;
            },
            "./src/controller/latency-controller.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "default", function () {
                    return LatencyController;
                });
                var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/errors.ts");
                var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/events.ts");
                var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/logger.ts");
                function _defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    Object.defineProperty(Constructor, "prototype", { writable: false });
                    return Constructor;
                }
                var LatencyController = (function () {
                    function LatencyController(hls) {
                        var _this = this;
                        this.hls = void 0;
                        this.config = void 0;
                        this.media = null;
                        this.levelDetails = null;
                        this.currentTime = 0;
                        this.stallCount = 0;
                        this._latency = null;
                        this.timeupdateHandler = function () {
                            return _this.timeupdate();
                        };
                        this.hls = hls;
                        this.config = hls.config;
                        this.registerListeners();
                    }
                    var _proto = LatencyController.prototype;
                    _proto.destroy = function destroy() {
                        this.unregisterListeners();
                        this.onMediaDetaching();
                        this.levelDetails = null;
                        this.hls = this.timeupdateHandler = null;
                    };
                    _proto.registerListeners = function registerListeners() {
                        this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
                        this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
                        this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
                        this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVEL_UPDATED, this.onLevelUpdated, this);
                        this.hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, this.onError, this);
                    };
                    _proto.unregisterListeners = function unregisterListeners() {
                        this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_ATTACHED, this.onMediaAttached);
                        this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_DETACHING, this.onMediaDetaching);
                        this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_LOADING, this.onManifestLoading);
                        this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVEL_UPDATED, this.onLevelUpdated);
                        this.hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, this.onError);
                    };
                    _proto.onMediaAttached = function onMediaAttached(event, data) {
                        this.media = data.media;
                        this.media.addEventListener("timeupdate", this.timeupdateHandler);
                    };
                    _proto.onMediaDetaching = function onMediaDetaching() {
                        if (this.media) {
                            this.media.removeEventListener("timeupdate", this.timeupdateHandler);
                            this.media = null;
                        }
                    };
                    _proto.onManifestLoading = function onManifestLoading() {
                        this.levelDetails = null;
                        this._latency = null;
                        this.stallCount = 0;
                    };
                    _proto.onLevelUpdated = function onLevelUpdated(event, _ref) {
                        var details = _ref.details;
                        this.levelDetails = details;
                        if (details.advanced) {
                            this.timeupdate();
                        }
                        if (!details.live && this.media) {
                            this.media.removeEventListener("timeupdate", this.timeupdateHandler);
                        }
                    };
                    _proto.onError = function onError(event, data) {
                        if (data.details !== _errors__WEBPACK_IMPORTED_MODULE_0__["ErrorDetails"].BUFFER_STALLED_ERROR) {
                            return;
                        }
                        this.stallCount++;
                        _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn("[playback-rate-controller]: Stall detected, adjusting target latency");
                    };
                    _proto.timeupdate = function timeupdate() {
                        var media = this.media,
                            levelDetails = this.levelDetails;
                        if (!media || !levelDetails) {
                            return;
                        }
                        this.currentTime = media.currentTime;
                        var latency = this.computeLatency();
                        if (latency === null) {
                            return;
                        }
                        this._latency = latency;
                        var _this$config = this.config,
                            lowLatencyMode = _this$config.lowLatencyMode,
                            maxLiveSyncPlaybackRate = _this$config.maxLiveSyncPlaybackRate;
                        if (!lowLatencyMode || maxLiveSyncPlaybackRate === 1) {
                            return;
                        }
                        var targetLatency = this.targetLatency;
                        if (targetLatency === null) {
                            return;
                        }
                        var distanceFromTarget = latency - targetLatency;
                        var liveMinLatencyDuration = Math.min(this.maxLatency, targetLatency + levelDetails.targetduration);
                        var inLiveRange = distanceFromTarget < liveMinLatencyDuration;
                        if (levelDetails.live && inLiveRange && distanceFromTarget > 0.05 && this.forwardBufferLength > 1) {
                            var max = Math.min(2, Math.max(1, maxLiveSyncPlaybackRate));
                            var rate = Math.round((2 / (1 + Math.exp(-0.75 * distanceFromTarget - this.edgeStalled))) * 20) / 20;
                            media.playbackRate = Math.min(max, Math.max(1, rate));
                        } else if (media.playbackRate !== 1 && media.playbackRate !== 0) {
                            media.playbackRate = 1;
                        }
                    };
                    _proto.estimateLiveEdge = function estimateLiveEdge() {
                        var levelDetails = this.levelDetails;
                        if (levelDetails === null) {
                            return null;
                        }
                        return levelDetails.edge + levelDetails.age;
                    };
                    _proto.computeLatency = function computeLatency() {
                        var liveEdge = this.estimateLiveEdge();
                        if (liveEdge === null) {
                            return null;
                        }
                        return liveEdge - this.currentTime;
                    };
                    _createClass(LatencyController, [
                        {
                            key: "latency",
                            get: function get() {
                                return this._latency || 0;
                            },
                        },
                        {
                            key: "maxLatency",
                            get: function get() {
                                var config = this.config,
                                    levelDetails = this.levelDetails;
                                if (config.liveMaxLatencyDuration !== undefined) {
                                    return config.liveMaxLatencyDuration;
                                }
                                return levelDetails ? config.liveMaxLatencyDurationCount * levelDetails.targetduration : 0;
                            },
                        },
                        {
                            key: "targetLatency",
                            get: function get() {
                                var levelDetails = this.levelDetails;
                                if (levelDetails === null) {
                                    return null;
                                }
                                var holdBack = levelDetails.holdBack,
                                    partHoldBack = levelDetails.partHoldBack,
                                    targetduration = levelDetails.targetduration;
                                var _this$config2 = this.config,
                                    liveSyncDuration = _this$config2.liveSyncDuration,
                                    liveSyncDurationCount = _this$config2.liveSyncDurationCount,
                                    lowLatencyMode = _this$config2.lowLatencyMode;
                                var userConfig = this.hls.userConfig;
                                var targetLatency = lowLatencyMode ? partHoldBack || holdBack : holdBack;
                                if (userConfig.liveSyncDuration || userConfig.liveSyncDurationCount || targetLatency === 0) {
                                    targetLatency = liveSyncDuration !== undefined ? liveSyncDuration : liveSyncDurationCount * targetduration;
                                }
                                var maxLiveSyncOnStallIncrease = targetduration;
                                var liveSyncOnStallIncrease = 1;
                                return targetLatency + Math.min(this.stallCount * liveSyncOnStallIncrease, maxLiveSyncOnStallIncrease);
                            },
                        },
                        {
                            key: "liveSyncPosition",
                            get: function get() {
                                var liveEdge = this.estimateLiveEdge();
                                var targetLatency = this.targetLatency;
                                var levelDetails = this.levelDetails;
                                if (liveEdge === null || targetLatency === null || levelDetails === null) {
                                    return null;
                                }
                                var edge = levelDetails.edge;
                                var syncPosition = liveEdge - targetLatency - this.edgeStalled;
                                var min = edge - levelDetails.totalduration;
                                var max = edge - ((this.config.lowLatencyMode && levelDetails.partTarget) || levelDetails.targetduration);
                                return Math.min(Math.max(min, syncPosition), max);
                            },
                        },
                        {
                            key: "drift",
                            get: function get() {
                                var levelDetails = this.levelDetails;
                                if (levelDetails === null) {
                                    return 1;
                                }
                                return levelDetails.drift;
                            },
                        },
                        {
                            key: "edgeStalled",
                            get: function get() {
                                var levelDetails = this.levelDetails;
                                if (levelDetails === null) {
                                    return 0;
                                }
                                var maxLevelUpdateAge = ((this.config.lowLatencyMode && levelDetails.partTarget) || levelDetails.targetduration) * 3;
                                return Math.max(levelDetails.age - maxLevelUpdateAge, 0);
                            },
                        },
                        {
                            key: "forwardBufferLength",
                            get: function get() {
                                var media = this.media,
                                    levelDetails = this.levelDetails;
                                if (!media || !levelDetails) {
                                    return 0;
                                }
                                var bufferedRanges = media.buffered.length;
                                return (bufferedRanges ? media.buffered.end(bufferedRanges - 1) : levelDetails.edge) - this.currentTime;
                            },
                        },
                    ]);
                    return LatencyController;
                })();
            },
            "./src/controller/level-controller.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "default", function () {
                    return LevelController;
                });
                var _types_level__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/types/level.ts");
                var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/events.ts");
                var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/errors.ts");
                var _utils_codecs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/utils/codecs.ts");
                var _level_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/controller/level-helper.ts");
                var _base_playlist_controller__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/controller/base-playlist-controller.ts");
                var _types_loader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/types/loader.ts");
                function _extends() {
                    _extends = Object.assign
                        ? Object.assign.bind()
                        : function (target) {
                              for (var i = 1; i < arguments.length; i++) {
                                  var source = arguments[i];
                                  for (var key in source) {
                                      if (Object.prototype.hasOwnProperty.call(source, key)) {
                                          target[key] = source[key];
                                      }
                                  }
                              }
                              return target;
                          };
                    return _extends.apply(this, arguments);
                }
                function _defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    Object.defineProperty(Constructor, "prototype", { writable: false });
                    return Constructor;
                }
                function _inheritsLoose(subClass, superClass) {
                    subClass.prototype = Object.create(superClass.prototype);
                    subClass.prototype.constructor = subClass;
                    _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf
                        ? Object.setPrototypeOf.bind()
                        : function _setPrototypeOf(o, p) {
                              o.__proto__ = p;
                              return o;
                          };
                    return _setPrototypeOf(o, p);
                }
                var chromeOrFirefox = /chrome|firefox/.test(navigator.userAgent.toLowerCase());
                var LevelController = (function (_BasePlaylistControll) {
                    _inheritsLoose(LevelController, _BasePlaylistControll);
                    function LevelController(hls) {
                        var _this;
                        _this = _BasePlaylistControll.call(this, hls, "[level-controller]") || this;
                        _this._levels = [];
                        _this._firstLevel = -1;
                        _this._startLevel = void 0;
                        _this.currentLevelIndex = -1;
                        _this.manualLevelIndex = -1;
                        _this.onParsedComplete = void 0;
                        _this._registerListeners();
                        return _this;
                    }
                    var _proto = LevelController.prototype;
                    _proto._registerListeners = function _registerListeners() {
                        var hls = this.hls;
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_LOADED, this.onManifestLoaded, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVEL_LOADED, this.onLevelLoaded, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_LOADED, this.onFragLoaded, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, this.onError, this);
                    };
                    _proto._unregisterListeners = function _unregisterListeners() {
                        var hls = this.hls;
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_LOADED, this.onManifestLoaded, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVEL_LOADED, this.onLevelLoaded, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_LOADED, this.onFragLoaded, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, this.onError, this);
                    };
                    _proto.destroy = function destroy() {
                        this._unregisterListeners();
                        this.manualLevelIndex = -1;
                        this._levels.length = 0;
                        _BasePlaylistControll.prototype.destroy.call(this);
                    };
                    _proto.startLoad = function startLoad() {
                        var levels = this._levels;
                        levels.forEach(function (level) {
                            level.loadError = 0;
                        });
                        _BasePlaylistControll.prototype.startLoad.call(this);
                    };
                    _proto.onManifestLoaded = function onManifestLoaded(event, data) {
                        var levels = [];
                        var audioTracks = [];
                        var subtitleTracks = [];
                        var bitrateStart;
                        var levelSet = {};
                        var levelFromSet;
                        var resolutionFound = false;
                        var videoCodecFound = false;
                        var audioCodecFound = false;
                        data.levels.forEach(function (levelParsed) {
                            var attributes = levelParsed.attrs;
                            resolutionFound = resolutionFound || !!(levelParsed.width && levelParsed.height);
                            videoCodecFound = videoCodecFound || !!levelParsed.videoCodec;
                            audioCodecFound = audioCodecFound || !!levelParsed.audioCodec;
                            if (chromeOrFirefox && levelParsed.audioCodec && levelParsed.audioCodec.indexOf("mp4a.40.34") !== -1) {
                                levelParsed.audioCodec = undefined;
                            }
                            var levelKey = levelParsed.bitrate + "-" + levelParsed.attrs.RESOLUTION + "-" + levelParsed.attrs.CODECS;
                            levelFromSet = levelSet[levelKey];
                            if (!levelFromSet) {
                                levelFromSet = new _types_level__WEBPACK_IMPORTED_MODULE_0__["Level"](levelParsed);
                                levelSet[levelKey] = levelFromSet;
                                levels.push(levelFromSet);
                            } else {
                                levelFromSet.url.push(levelParsed.url);
                            }
                            if (attributes) {
                                if (attributes.AUDIO) {
                                    Object(_level_helper__WEBPACK_IMPORTED_MODULE_4__["addGroupId"])(levelFromSet, "audio", attributes.AUDIO);
                                }
                                if (attributes.SUBTITLES) {
                                    Object(_level_helper__WEBPACK_IMPORTED_MODULE_4__["addGroupId"])(levelFromSet, "text", attributes.SUBTITLES);
                                }
                            }
                        });
                        if ((resolutionFound || videoCodecFound) && audioCodecFound) {
                            levels = levels.filter(function (_ref) {
                                var videoCodec = _ref.videoCodec,
                                    width = _ref.width,
                                    height = _ref.height;
                                return !!videoCodec || !!(width && height);
                            });
                        }
                        levels = levels.filter(function (_ref2) {
                            var audioCodec = _ref2.audioCodec,
                                videoCodec = _ref2.videoCodec;
                            return (
                                (!audioCodec || Object(_utils_codecs__WEBPACK_IMPORTED_MODULE_3__["isCodecSupportedInMp4"])(audioCodec, "audio")) &&
                                (!videoCodec || Object(_utils_codecs__WEBPACK_IMPORTED_MODULE_3__["isCodecSupportedInMp4"])(videoCodec, "video"))
                            );
                        });
                        if (data.audioTracks) {
                            audioTracks = data.audioTracks.filter(function (track) {
                                return !track.audioCodec || Object(_utils_codecs__WEBPACK_IMPORTED_MODULE_3__["isCodecSupportedInMp4"])(track.audioCodec, "audio");
                            });
                            Object(_level_helper__WEBPACK_IMPORTED_MODULE_4__["assignTrackIdsByGroup"])(audioTracks);
                        }
                        if (data.subtitles) {
                            subtitleTracks = data.subtitles;
                            Object(_level_helper__WEBPACK_IMPORTED_MODULE_4__["assignTrackIdsByGroup"])(subtitleTracks);
                        }
                        if (levels.length > 0) {
                            bitrateStart = levels[0].bitrate;
                            levels.sort(function (a, b) {
                                return a.bitrate - b.bitrate;
                            });
                            this._levels = levels;
                            for (var i = 0; i < levels.length; i++) {
                                if (levels[i].bitrate === bitrateStart) {
                                    this._firstLevel = i;
                                    this.log("manifest loaded, " + levels.length + " level(s) found, first bitrate: " + bitrateStart);
                                    break;
                                }
                            }
                            var audioOnly = audioCodecFound && !videoCodecFound;
                            var edata = {
                                levels: levels,
                                audioTracks: audioTracks,
                                subtitleTracks: subtitleTracks,
                                firstLevel: this._firstLevel,
                                stats: data.stats,
                                audio: audioCodecFound,
                                video: videoCodecFound,
                                altAudio:
                                    !audioOnly &&
                                    audioTracks.some(function (t) {
                                        return !!t.url;
                                    }),
                            };
                            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_PARSED, edata);
                            if (this.hls.config.autoStartLoad || this.hls.forceStartLoad) {
                                this.hls.startLoad(this.hls.config.startPosition);
                            }
                        } else {
                            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, {
                                type: _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorTypes"].MEDIA_ERROR,
                                details: _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].MANIFEST_INCOMPATIBLE_CODECS_ERROR,
                                fatal: true,
                                url: data.url,
                                reason: "no level with compatible codecs found in manifest",
                            });
                        }
                    };
                    _proto.onError = function onError(event, data) {
                        var _data$level;
                        _BasePlaylistControll.prototype.onError.call(this, event, data);
                        if (data.fatal) {
                            return;
                        }
                        var context = data.context;
                        var level = this._levels[this.currentLevelIndex];
                        if (
                            context &&
                            ((context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].AUDIO_TRACK && level.audioGroupIds && context.groupId === level.audioGroupIds[level.urlId]) ||
                                (context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].SUBTITLE_TRACK && level.textGroupIds && context.groupId === level.textGroupIds[level.urlId]))
                        ) {
                            this.redundantFailover(this.currentLevelIndex);
                            return;
                        }
                        var levelError = false;
                        var levelSwitch = true;
                        var levelIndex;
                        switch (data.details) {
                            case _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].FRAG_LOAD_ERROR:
                            case _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].FRAG_LOAD_TIMEOUT:
                            case _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].KEY_LOAD_ERROR:
                            case _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].KEY_LOAD_TIMEOUT:
                                if (data.frag) {
                                    var variantLevelIndex = data.frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].MAIN ? data.frag.level : this.currentLevelIndex;
                                    var _level = this._levels[variantLevelIndex];
                                    if (_level) {
                                        _level.fragmentError++;
                                        if (_level.fragmentError > this.hls.config.fragLoadingMaxRetry) {
                                            levelIndex = variantLevelIndex;
                                        }
                                    } else {
                                        levelIndex = variantLevelIndex;
                                    }
                                }
                                break;
                            case _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].LEVEL_LOAD_ERROR:
                            case _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].LEVEL_LOAD_TIMEOUT:
                                if (context) {
                                    if (context.deliveryDirectives) {
                                        levelSwitch = false;
                                    }
                                    levelIndex = context.level;
                                }
                                levelError = true;
                                break;
                            case _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].REMUX_ALLOC_ERROR:
                                levelIndex = (_data$level = data.level) != null ? _data$level : this.currentLevelIndex;
                                levelError = true;
                                break;
                        }
                        if (levelIndex !== undefined) {
                            this.recoverLevel(data, levelIndex, levelError, levelSwitch);
                        }
                    };
                    _proto.recoverLevel = function recoverLevel(errorEvent, levelIndex, levelError, levelSwitch) {
                        var errorDetails = errorEvent.details;
                        var level = this._levels[levelIndex];
                        level.loadError++;
                        if (levelError) {
                            var retrying = this.retryLoadingOrFail(errorEvent);
                            if (retrying) {
                                errorEvent.levelRetry = true;
                            } else {
                                this.currentLevelIndex = -1;
                                return;
                            }
                        }
                        if (levelSwitch) {
                            var redundantLevels = level.url.length;
                            if (redundantLevels > 1 && level.loadError < redundantLevels) {
                                errorEvent.levelRetry = true;
                                this.redundantFailover(levelIndex);
                            } else if (this.manualLevelIndex === -1) {
                                var nextLevel = -1;
                                var levels = this._levels;
                                for (var i = levels.length; i--; ) {
                                    var candidate = (i + this.currentLevelIndex) % levels.length;
                                    if (candidate !== this.currentLevelIndex && levels[candidate].loadError === 0) {
                                        nextLevel = candidate;
                                        break;
                                    }
                                }
                                if (nextLevel > -1 && this.currentLevelIndex !== nextLevel) {
                                    this.warn(errorDetails + ": switch to " + nextLevel);
                                    errorEvent.levelRetry = true;
                                    this.hls.nextAutoLevel = nextLevel;
                                }
                            }
                        }
                    };
                    _proto.redundantFailover = function redundantFailover(levelIndex) {
                        var level = this._levels[levelIndex];
                        var redundantLevels = level.url.length;
                        if (redundantLevels > 1) {
                            var newUrlId = (level.urlId + 1) % redundantLevels;
                            this.warn("Switching to redundant URL-id " + newUrlId);
                            this._levels.forEach(function (level) {
                                level.urlId = newUrlId;
                            });
                            this.level = levelIndex;
                        }
                    };
                    _proto.onFragLoaded = function onFragLoaded(event, _ref3) {
                        var frag = _ref3.frag;
                        if (frag !== undefined && frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].MAIN) {
                            var level = this._levels[frag.level];
                            if (level !== undefined) {
                                level.fragmentError = 0;
                                level.loadError = 0;
                            }
                        }
                    };
                    _proto.onLevelLoaded = function onLevelLoaded(event, data) {
                        var _data$deliveryDirecti2;
                        var level = data.level,
                            details = data.details;
                        var curLevel = this._levels[level];
                        if (!curLevel) {
                            var _data$deliveryDirecti;
                            this.warn("Invalid level index " + level);
                            if ((_data$deliveryDirecti = data.deliveryDirectives) !== null && _data$deliveryDirecti !== void 0 && _data$deliveryDirecti.skip) {
                                details.deltaUpdateFailed = true;
                            }
                            return;
                        }
                        if (level === this.currentLevelIndex) {
                            if (curLevel.fragmentError === 0) {
                                curLevel.loadError = 0;
                                this.retryCount = 0;
                            }
                            this.playlistLoaded(level, data, curLevel.details);
                        } else if ((_data$deliveryDirecti2 = data.deliveryDirectives) !== null && _data$deliveryDirecti2 !== void 0 && _data$deliveryDirecti2.skip) {
                            details.deltaUpdateFailed = true;
                        }
                    };
                    _proto.onAudioTrackSwitched = function onAudioTrackSwitched(event, data) {
                        var currentLevel = this.hls.levels[this.currentLevelIndex];
                        if (!currentLevel) {
                            return;
                        }
                        if (currentLevel.audioGroupIds) {
                            var urlId = -1;
                            var audioGroupId = this.hls.audioTracks[data.id].groupId;
                            for (var i = 0; i < currentLevel.audioGroupIds.length; i++) {
                                if (currentLevel.audioGroupIds[i] === audioGroupId) {
                                    urlId = i;
                                    break;
                                }
                            }
                            if (urlId !== currentLevel.urlId) {
                                currentLevel.urlId = urlId;
                                this.startLoad();
                            }
                        }
                    };
                    _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {
                        var level = this.currentLevelIndex;
                        var currentLevel = this._levels[level];
                        if (this.canLoad && currentLevel && currentLevel.url.length > 0) {
                            var id = currentLevel.urlId;
                            var url = currentLevel.url[id];
                            if (hlsUrlParameters) {
                                try {
                                    url = hlsUrlParameters.addDirectives(url);
                                } catch (error) {
                                    this.warn("Could not construct new URL with HLS Delivery Directives: " + error);
                                }
                            }
                            this.log("Attempt loading level index " + level + (hlsUrlParameters ? " at sn " + hlsUrlParameters.msn + " part " + hlsUrlParameters.part : "") + " with URL-id " + id + " " + url);
                            this.clearTimer();
                            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVEL_LOADING, { url: url, level: level, id: id, deliveryDirectives: hlsUrlParameters || null });
                        }
                    };
                    _proto.removeLevel = function removeLevel(levelIndex, urlId) {
                        var filterLevelAndGroupByIdIndex = function filterLevelAndGroupByIdIndex(url, id) {
                            return id !== urlId;
                        };
                        var levels = this._levels
                            .filter(function (level, index) {
                                if (index !== levelIndex) {
                                    return true;
                                }
                                if (level.url.length > 1 && urlId !== undefined) {
                                    level.url = level.url.filter(filterLevelAndGroupByIdIndex);
                                    if (level.audioGroupIds) {
                                        level.audioGroupIds = level.audioGroupIds.filter(filterLevelAndGroupByIdIndex);
                                    }
                                    if (level.textGroupIds) {
                                        level.textGroupIds = level.textGroupIds.filter(filterLevelAndGroupByIdIndex);
                                    }
                                    level.urlId = 0;
                                    return true;
                                }
                                return false;
                            })
                            .map(function (level, index) {
                                var details = level.details;
                                if (details !== null && details !== void 0 && details.fragments) {
                                    details.fragments.forEach(function (fragment) {
                                        fragment.level = index;
                                    });
                                }
                                return level;
                            });
                        this._levels = levels;
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVELS_UPDATED, { levels: levels });
                    };
                    _createClass(LevelController, [
                        {
                            key: "levels",
                            get: function get() {
                                if (this._levels.length === 0) {
                                    return null;
                                }
                                return this._levels;
                            },
                        },
                        {
                            key: "level",
                            get: function get() {
                                return this.currentLevelIndex;
                            },
                            set: function set(newLevel) {
                                var _levels$newLevel;
                                var levels = this._levels;
                                if (levels.length === 0) {
                                    return;
                                }
                                if (this.currentLevelIndex === newLevel && (_levels$newLevel = levels[newLevel]) !== null && _levels$newLevel !== void 0 && _levels$newLevel.details) {
                                    return;
                                }
                                if (newLevel < 0 || newLevel >= levels.length) {
                                    var fatal = newLevel < 0;
                                    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, {
                                        type: _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorTypes"].OTHER_ERROR,
                                        details: _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].LEVEL_SWITCH_ERROR,
                                        level: newLevel,
                                        fatal: fatal,
                                        reason: "invalid level idx",
                                    });
                                    if (fatal) {
                                        return;
                                    }
                                    newLevel = Math.min(newLevel, levels.length - 1);
                                }
                                this.clearTimer();
                                var lastLevelIndex = this.currentLevelIndex;
                                var lastLevel = levels[lastLevelIndex];
                                var level = levels[newLevel];
                                this.log("switching to level " + newLevel + " from " + lastLevelIndex);
                                this.currentLevelIndex = newLevel;
                                var levelSwitchingData = _extends({}, level, { level: newLevel, maxBitrate: level.maxBitrate, uri: level.uri, urlId: level.urlId });
                                delete levelSwitchingData._urlId;
                                this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVEL_SWITCHING, levelSwitchingData);
                                var levelDetails = level.details;
                                if (!levelDetails || levelDetails.live) {
                                    var hlsUrlParameters = this.switchParams(level.uri, lastLevel === null || lastLevel === void 0 ? void 0 : lastLevel.details);
                                    this.loadPlaylist(hlsUrlParameters);
                                }
                            },
                        },
                        {
                            key: "manualLevel",
                            get: function get() {
                                return this.manualLevelIndex;
                            },
                            set: function set(newLevel) {
                                this.manualLevelIndex = newLevel;
                                if (this._startLevel === undefined) {
                                    this._startLevel = newLevel;
                                }
                                if (newLevel !== -1) {
                                    this.level = newLevel;
                                }
                            },
                        },
                        {
                            key: "firstLevel",
                            get: function get() {
                                return this._firstLevel;
                            },
                            set: function set(newLevel) {
                                this._firstLevel = newLevel;
                            },
                        },
                        {
                            key: "startLevel",
                            get: function get() {
                                if (this._startLevel === undefined) {
                                    var configStartLevel = this.hls.config.startLevel;
                                    if (configStartLevel !== undefined) {
                                        return configStartLevel;
                                    } else {
                                        return this._firstLevel;
                                    }
                                } else {
                                    return this._startLevel;
                                }
                            },
                            set: function set(newLevel) {
                                this._startLevel = newLevel;
                            },
                        },
                        {
                            key: "nextLoadLevel",
                            get: function get() {
                                if (this.manualLevelIndex !== -1) {
                                    return this.manualLevelIndex;
                                } else {
                                    return this.hls.nextAutoLevel;
                                }
                            },
                            set: function set(nextLevel) {
                                this.level = nextLevel;
                                if (this.manualLevelIndex === -1) {
                                    this.hls.nextAutoLevel = nextLevel;
                                }
                            },
                        },
                    ]);
                    return LevelController;
                })(_base_playlist_controller__WEBPACK_IMPORTED_MODULE_5__["default"]);
            },
            "./src/controller/level-helper.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "addGroupId", function () {
                    return addGroupId;
                });
                __webpack_require__.d(__webpack_exports__, "assignTrackIdsByGroup", function () {
                    return assignTrackIdsByGroup;
                });
                __webpack_require__.d(__webpack_exports__, "updatePTS", function () {
                    return updatePTS;
                });
                __webpack_require__.d(__webpack_exports__, "updateFragPTSDTS", function () {
                    return updateFragPTSDTS;
                });
                __webpack_require__.d(__webpack_exports__, "mergeDetails", function () {
                    return mergeDetails;
                });
                __webpack_require__.d(__webpack_exports__, "mapPartIntersection", function () {
                    return mapPartIntersection;
                });
                __webpack_require__.d(__webpack_exports__, "mapFragmentIntersection", function () {
                    return mapFragmentIntersection;
                });
                __webpack_require__.d(__webpack_exports__, "adjustSliding", function () {
                    return adjustSliding;
                });
                __webpack_require__.d(__webpack_exports__, "addSliding", function () {
                    return addSliding;
                });
                __webpack_require__.d(__webpack_exports__, "computeReloadInterval", function () {
                    return computeReloadInterval;
                });
                __webpack_require__.d(__webpack_exports__, "getFragmentWithSN", function () {
                    return getFragmentWithSN;
                });
                __webpack_require__.d(__webpack_exports__, "getPartWith", function () {
                    return getPartWith;
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/polyfills/number.ts");
                var _utils_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/logger.ts");
                var _loader_date_range__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/loader/date-range.ts");
                function _extends() {
                    _extends = Object.assign
                        ? Object.assign.bind()
                        : function (target) {
                              for (var i = 1; i < arguments.length; i++) {
                                  var source = arguments[i];
                                  for (var key in source) {
                                      if (Object.prototype.hasOwnProperty.call(source, key)) {
                                          target[key] = source[key];
                                      }
                                  }
                              }
                              return target;
                          };
                    return _extends.apply(this, arguments);
                }
                function addGroupId(level, type, id) {
                    switch (type) {
                        case "audio":
                            if (!level.audioGroupIds) {
                                level.audioGroupIds = [];
                            }
                            level.audioGroupIds.push(id);
                            break;
                        case "text":
                            if (!level.textGroupIds) {
                                level.textGroupIds = [];
                            }
                            level.textGroupIds.push(id);
                            break;
                    }
                }
                function assignTrackIdsByGroup(tracks) {
                    var groups = {};
                    tracks.forEach(function (track) {
                        var groupId = track.groupId || "";
                        track.id = groups[groupId] = groups[groupId] || 0;
                        groups[groupId]++;
                    });
                }
                function updatePTS(fragments, fromIdx, toIdx) {
                    var fragFrom = fragments[fromIdx];
                    var fragTo = fragments[toIdx];
                    updateFromToPTS(fragFrom, fragTo);
                }
                function updateFromToPTS(fragFrom, fragTo) {
                    var fragToPTS = fragTo.startPTS;
                    if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(fragToPTS)) {
                        var duration = 0;
                        var frag;
                        if (fragTo.sn > fragFrom.sn) {
                            duration = fragToPTS - fragFrom.start;
                            frag = fragFrom;
                        } else {
                            duration = fragFrom.start - fragToPTS;
                            frag = fragTo;
                        }
                        if (frag.duration !== duration) {
                            frag.duration = duration;
                        }
                    } else if (fragTo.sn > fragFrom.sn) {
                        var contiguous = fragFrom.cc === fragTo.cc;
                        if (contiguous && fragFrom.minEndPTS) {
                            fragTo.start = fragFrom.start + (fragFrom.minEndPTS - fragFrom.start);
                        } else {
                            fragTo.start = fragFrom.start + fragFrom.duration;
                        }
                    } else {
                        fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);
                    }
                }
                function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {
                    var parsedMediaDuration = endPTS - startPTS;
                    if (parsedMediaDuration <= 0) {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_1__["logger"].warn("Fragment should have a positive duration", frag);
                        endPTS = startPTS + frag.duration;
                        endDTS = startDTS + frag.duration;
                    }
                    var maxStartPTS = startPTS;
                    var minEndPTS = endPTS;
                    var fragStartPts = frag.startPTS;
                    var fragEndPts = frag.endPTS;
                    if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(fragStartPts)) {
                        var deltaPTS = Math.abs(fragStartPts - startPTS);
                        if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(frag.deltaPTS)) {
                            frag.deltaPTS = deltaPTS;
                        } else {
                            frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
                        }
                        maxStartPTS = Math.max(startPTS, fragStartPts);
                        startPTS = Math.min(startPTS, fragStartPts);
                        startDTS = Math.min(startDTS, frag.startDTS);
                        minEndPTS = Math.min(endPTS, fragEndPts);
                        endPTS = Math.max(endPTS, fragEndPts);
                        endDTS = Math.max(endDTS, frag.endDTS);
                    }
                    frag.duration = endPTS - startPTS;
                    var drift = startPTS - frag.start;
                    frag.appendedPTS = endPTS;
                    frag.start = frag.startPTS = startPTS;
                    frag.maxStartPTS = maxStartPTS;
                    frag.startDTS = startDTS;
                    frag.endPTS = endPTS;
                    frag.minEndPTS = minEndPTS;
                    frag.endDTS = endDTS;
                    var sn = frag.sn;
                    if (!details || sn < details.startSN || sn > details.endSN) {
                        return 0;
                    }
                    var i;
                    var fragIdx = sn - details.startSN;
                    var fragments = details.fragments;
                    fragments[fragIdx] = frag;
                    for (i = fragIdx; i > 0; i--) {
                        updateFromToPTS(fragments[i], fragments[i - 1]);
                    }
                    for (i = fragIdx; i < fragments.length - 1; i++) {
                        updateFromToPTS(fragments[i], fragments[i + 1]);
                    }
                    if (details.fragmentHint) {
                        updateFromToPTS(fragments[fragments.length - 1], details.fragmentHint);
                    }
                    details.PTSKnown = details.alignedSliding = true;
                    return drift;
                }
                function mergeDetails(oldDetails, newDetails) {
                    var currentInitSegment = null;
                    var oldFragments = oldDetails.fragments;
                    for (var i = oldFragments.length - 1; i >= 0; i--) {
                        var oldInit = oldFragments[i].initSegment;
                        if (oldInit) {
                            currentInitSegment = oldInit;
                            break;
                        }
                    }
                    if (oldDetails.fragmentHint) {
                        delete oldDetails.fragmentHint.endPTS;
                    }
                    var ccOffset = 0;
                    var PTSFrag;
                    mapFragmentIntersection(oldDetails, newDetails, function (oldFrag, newFrag) {
                        if (oldFrag.relurl) {
                            ccOffset = oldFrag.cc - newFrag.cc;
                        }
                        if (
                            Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(oldFrag.startPTS) &&
                            Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(oldFrag.endPTS)
                        ) {
                            newFrag.start = newFrag.startPTS = oldFrag.startPTS;
                            newFrag.startDTS = oldFrag.startDTS;
                            newFrag.appendedPTS = oldFrag.appendedPTS;
                            newFrag.maxStartPTS = oldFrag.maxStartPTS;
                            newFrag.endPTS = oldFrag.endPTS;
                            newFrag.endDTS = oldFrag.endDTS;
                            newFrag.minEndPTS = oldFrag.minEndPTS;
                            newFrag.duration = oldFrag.endPTS - oldFrag.startPTS;
                            if (newFrag.duration) {
                                PTSFrag = newFrag;
                            }
                            newDetails.PTSKnown = newDetails.alignedSliding = true;
                        }
                        newFrag.elementaryStreams = oldFrag.elementaryStreams;
                        newFrag.loader = oldFrag.loader;
                        newFrag.stats = oldFrag.stats;
                        newFrag.urlId = oldFrag.urlId;
                        if (oldFrag.initSegment) {
                            newFrag.initSegment = oldFrag.initSegment;
                            currentInitSegment = oldFrag.initSegment;
                        }
                    });
                    if (currentInitSegment) {
                        var fragmentsToCheck = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;
                        fragmentsToCheck.forEach(function (frag) {
                            var _currentInitSegment;
                            if (!frag.initSegment || frag.initSegment.relurl === ((_currentInitSegment = currentInitSegment) === null || _currentInitSegment === void 0 ? void 0 : _currentInitSegment.relurl)) {
                                frag.initSegment = currentInitSegment;
                            }
                        });
                    }
                    if (newDetails.skippedSegments) {
                        newDetails.deltaUpdateFailed = newDetails.fragments.some(function (frag) {
                            return !frag;
                        });
                        if (newDetails.deltaUpdateFailed) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_1__["logger"].warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
                            for (var _i = newDetails.skippedSegments; _i--; ) {
                                newDetails.fragments.shift();
                            }
                            newDetails.startSN = newDetails.fragments[0].sn;
                            newDetails.startCC = newDetails.fragments[0].cc;
                        } else if (newDetails.canSkipDateRanges) {
                            newDetails.dateRanges = mergeDateRanges(oldDetails.dateRanges, newDetails.dateRanges, newDetails.recentlyRemovedDateranges);
                        }
                    }
                    var newFragments = newDetails.fragments;
                    if (ccOffset) {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_1__["logger"].warn("discontinuity sliding from playlist, take drift into account");
                        for (var _i2 = 0; _i2 < newFragments.length; _i2++) {
                            newFragments[_i2].cc += ccOffset;
                        }
                    }
                    if (newDetails.skippedSegments) {
                        newDetails.startCC = newDetails.fragments[0].cc;
                    }
                    mapPartIntersection(oldDetails.partList, newDetails.partList, function (oldPart, newPart) {
                        newPart.elementaryStreams = oldPart.elementaryStreams;
                        newPart.stats = oldPart.stats;
                    });
                    if (PTSFrag) {
                        updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
                    } else {
                        adjustSliding(oldDetails, newDetails);
                    }
                    if (newFragments.length) {
                        newDetails.totalduration = newDetails.edge - newFragments[0].start;
                    }
                    newDetails.driftStartTime = oldDetails.driftStartTime;
                    newDetails.driftStart = oldDetails.driftStart;
                    var advancedDateTime = newDetails.advancedDateTime;
                    if (newDetails.advanced && advancedDateTime) {
                        var edge = newDetails.edge;
                        if (!newDetails.driftStart) {
                            newDetails.driftStartTime = advancedDateTime;
                            newDetails.driftStart = edge;
                        }
                        newDetails.driftEndTime = advancedDateTime;
                        newDetails.driftEnd = edge;
                    } else {
                        newDetails.driftEndTime = oldDetails.driftEndTime;
                        newDetails.driftEnd = oldDetails.driftEnd;
                        newDetails.advancedDateTime = oldDetails.advancedDateTime;
                    }
                }
                function mergeDateRanges(oldDateRanges, deltaDateRanges, recentlyRemovedDateranges) {
                    var dateRanges = _extends({}, oldDateRanges);
                    if (recentlyRemovedDateranges) {
                        recentlyRemovedDateranges.forEach(function (id) {
                            delete dateRanges[id];
                        });
                    }
                    Object.keys(deltaDateRanges).forEach(function (id) {
                        var dateRange = new _loader_date_range__WEBPACK_IMPORTED_MODULE_2__["DateRange"](deltaDateRanges[id].attr, dateRanges[id]);
                        if (dateRange.isValid) {
                            dateRanges[id] = dateRange;
                        } else {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_1__["logger"].warn('Ignoring invalid Playlist Delta Update DATERANGE tag: "' + JSON.stringify(deltaDateRanges[id].attr) + '"');
                        }
                    });
                    return dateRanges;
                }
                function mapPartIntersection(oldParts, newParts, intersectionFn) {
                    if (oldParts && newParts) {
                        var delta = 0;
                        for (var i = 0, len = oldParts.length; i <= len; i++) {
                            var _oldPart = oldParts[i];
                            var _newPart = newParts[i + delta];
                            if (_oldPart && _newPart && _oldPart.index === _newPart.index && _oldPart.fragment.sn === _newPart.fragment.sn) {
                                intersectionFn(_oldPart, _newPart);
                            } else {
                                delta--;
                            }
                        }
                    }
                }
                function mapFragmentIntersection(oldDetails, newDetails, intersectionFn) {
                    var skippedSegments = newDetails.skippedSegments;
                    var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN;
                    var end = (oldDetails.fragmentHint ? 1 : 0) + (skippedSegments ? newDetails.endSN : Math.min(oldDetails.endSN, newDetails.endSN)) - newDetails.startSN;
                    var delta = newDetails.startSN - oldDetails.startSN;
                    var newFrags = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;
                    var oldFrags = oldDetails.fragmentHint ? oldDetails.fragments.concat(oldDetails.fragmentHint) : oldDetails.fragments;
                    for (var i = start; i <= end; i++) {
                        var _oldFrag = oldFrags[delta + i];
                        var _newFrag = newFrags[i];
                        if (skippedSegments && !_newFrag && i < skippedSegments) {
                            _newFrag = newDetails.fragments[i] = _oldFrag;
                        }
                        if (_oldFrag && _newFrag) {
                            intersectionFn(_oldFrag, _newFrag);
                        }
                    }
                }
                function adjustSliding(oldDetails, newDetails) {
                    var delta = newDetails.startSN + newDetails.skippedSegments - oldDetails.startSN;
                    var oldFragments = oldDetails.fragments;
                    if (delta < 0 || delta >= oldFragments.length) {
                        return;
                    }
                    addSliding(newDetails, oldFragments[delta].start);
                }
                function addSliding(details, start) {
                    if (start) {
                        var fragments = details.fragments;
                        for (var i = details.skippedSegments; i < fragments.length; i++) {
                            fragments[i].start += start;
                        }
                        if (details.fragmentHint) {
                            details.fragmentHint.start += start;
                        }
                    }
                }
                function computeReloadInterval(newDetails, stats) {
                    var reloadInterval = 1e3 * newDetails.levelTargetDuration;
                    var reloadIntervalAfterMiss = reloadInterval / 2;
                    var timeSinceLastModified = newDetails.age;
                    var useLastModified = timeSinceLastModified > 0 && timeSinceLastModified < reloadInterval * 3;
                    var roundTrip = stats.loading.end - stats.loading.start;
                    var estimatedTimeUntilUpdate;
                    var availabilityDelay = newDetails.availabilityDelay;
                    if (newDetails.updated === false) {
                        if (useLastModified) {
                            var minRetry = 333 * newDetails.misses;
                            estimatedTimeUntilUpdate = Math.max(Math.min(reloadIntervalAfterMiss, roundTrip * 2), minRetry);
                            newDetails.availabilityDelay = (newDetails.availabilityDelay || 0) + estimatedTimeUntilUpdate;
                        } else {
                            estimatedTimeUntilUpdate = reloadIntervalAfterMiss;
                        }
                    } else if (useLastModified) {
                        availabilityDelay = Math.min(availabilityDelay || reloadInterval / 2, timeSinceLastModified);
                        newDetails.availabilityDelay = availabilityDelay;
                        estimatedTimeUntilUpdate = availabilityDelay + reloadInterval - timeSinceLastModified;
                    } else {
                        estimatedTimeUntilUpdate = reloadInterval - roundTrip;
                    }
                    return Math.round(estimatedTimeUntilUpdate);
                }
                function getFragmentWithSN(level, sn, fragCurrent) {
                    if (!level || !level.details) {
                        return null;
                    }
                    var levelDetails = level.details;
                    var fragment = levelDetails.fragments[sn - levelDetails.startSN];
                    if (fragment) {
                        return fragment;
                    }
                    fragment = levelDetails.fragmentHint;
                    if (fragment && fragment.sn === sn) {
                        return fragment;
                    }
                    if (sn < levelDetails.startSN && fragCurrent && fragCurrent.sn === sn) {
                        return fragCurrent;
                    }
                    return null;
                }
                function getPartWith(level, sn, partIndex) {
                    if (!level || !level.details) {
                        return null;
                    }
                    var partList = level.details.partList;
                    if (partList) {
                        for (var i = partList.length; i--; ) {
                            var part = partList[i];
                            if (part.index === partIndex && part.fragment.sn === sn) {
                                return part;
                            }
                        }
                    }
                    return null;
                }
            },
            "./src/controller/stream-controller.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "default", function () {
                    return StreamController;
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/polyfills/number.ts");
                var _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/controller/base-stream-controller.ts");
                var _is_supported__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/is-supported.ts");
                var _events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/events.ts");
                var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/utils/buffer-helper.ts");
                var _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/controller/fragment-tracker.ts");
                var _types_loader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/types/loader.ts");
                var _loader_fragment__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/loader/fragment.ts");
                var _demux_transmuxer_interface__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./src/demux/transmuxer-interface.ts");
                var _types_transmuxer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./src/types/transmuxer.ts");
                var _gap_controller__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./src/controller/gap-controller.ts");
                var _errors__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./src/errors.ts");
                function _defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    Object.defineProperty(Constructor, "prototype", { writable: false });
                    return Constructor;
                }
                function _inheritsLoose(subClass, superClass) {
                    subClass.prototype = Object.create(superClass.prototype);
                    subClass.prototype.constructor = subClass;
                    _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf
                        ? Object.setPrototypeOf.bind()
                        : function _setPrototypeOf(o, p) {
                              o.__proto__ = p;
                              return o;
                          };
                    return _setPrototypeOf(o, p);
                }
                var TICK_INTERVAL = 100;
                var StreamController = (function (_BaseStreamController) {
                    _inheritsLoose(StreamController, _BaseStreamController);
                    function StreamController(hls, fragmentTracker) {
                        var _this;
                        _this = _BaseStreamController.call(this, hls, fragmentTracker, "[stream-controller]") || this;
                        _this.audioCodecSwap = false;
                        _this.gapController = null;
                        _this.level = -1;
                        _this._forceStartLoad = false;
                        _this.altAudio = false;
                        _this.audioOnly = false;
                        _this.fragPlaying = null;
                        _this.onvplaying = null;
                        _this.onvseeked = null;
                        _this.fragLastKbps = 0;
                        _this.couldBacktrack = false;
                        _this.backtrackFragment = null;
                        _this.audioCodecSwitch = false;
                        _this.videoBuffer = null;
                        _this._registerListeners();
                        return _this;
                    }
                    var _proto = StreamController.prototype;
                    _proto._registerListeners = function _registerListeners() {
                        var hls = this.hls;
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].MANIFEST_PARSED, this.onManifestParsed, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].LEVEL_LOADING, this.onLevelLoading, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].LEVEL_LOADED, this.onLevelLoaded, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].ERROR, this.onError, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].BUFFER_CREATED, this.onBufferCreated, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].BUFFER_FLUSHED, this.onBufferFlushed, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].LEVELS_UPDATED, this.onLevelsUpdated, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].FRAG_BUFFERED, this.onFragBuffered, this);
                    };
                    _proto._unregisterListeners = function _unregisterListeners() {
                        var hls = this.hls;
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].MANIFEST_PARSED, this.onManifestParsed, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].LEVEL_LOADED, this.onLevelLoaded, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].ERROR, this.onError, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].BUFFER_CREATED, this.onBufferCreated, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].BUFFER_FLUSHED, this.onBufferFlushed, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].LEVELS_UPDATED, this.onLevelsUpdated, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].FRAG_BUFFERED, this.onFragBuffered, this);
                    };
                    _proto.onHandlerDestroying = function onHandlerDestroying() {
                        this._unregisterListeners();
                        this.onMediaDetaching();
                    };
                    _proto.startLoad = function startLoad(startPosition) {
                        if (this.levels) {
                            var lastCurrentTime = this.lastCurrentTime,
                                hls = this.hls;
                            this.stopLoad();
                            this.setInterval(TICK_INTERVAL);
                            this.level = -1;
                            this.fragLoadError = 0;
                            if (!this.startFragRequested) {
                                var startLevel = hls.startLevel;
                                if (startLevel === -1) {
                                    if (hls.config.testBandwidth && this.levels.length > 1) {
                                        startLevel = 0;
                                        this.bitrateTest = true;
                                    } else {
                                        startLevel = hls.nextAutoLevel;
                                    }
                                }
                                this.level = hls.nextLoadLevel = startLevel;
                                this.loadedmetadata = false;
                            }
                            if (lastCurrentTime > 0 && startPosition === -1) {
                                this.log("Override startPosition with lastCurrentTime @" + lastCurrentTime.toFixed(3));
                                startPosition = lastCurrentTime;
                            }
                            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
                            this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
                            this.tick();
                        } else {
                            this._forceStartLoad = true;
                            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].STOPPED;
                        }
                    };
                    _proto.stopLoad = function stopLoad() {
                        this._forceStartLoad = false;
                        _BaseStreamController.prototype.stopLoad.call(this);
                    };
                    _proto.doTick = function doTick() {
                        switch (this.state) {
                            case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE:
                                this.doTickIdle();
                                break;
                            case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_LEVEL: {
                                var _levels$level;
                                var levels = this.levels,
                                    level = this.level;
                                var details = levels === null || levels === void 0 ? void 0 : (_levels$level = levels[level]) === null || _levels$level === void 0 ? void 0 : _levels$level.details;
                                if (details && (!details.live || this.levelLastLoaded === this.level)) {
                                    if (this.waitForCdnTuneIn(details)) {
                                        break;
                                    }
                                    this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
                                    break;
                                }
                                break;
                            }
                            case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].FRAG_LOADING_WAITING_RETRY:
                                {
                                    var _this$media;
                                    var now = self.performance.now();
                                    var retryDate = this.retryDate;
                                    if (!retryDate || now >= retryDate || ((_this$media = this.media) !== null && _this$media !== void 0 && _this$media.seeking)) {
                                        this.log("retryDate reached, switch back to IDLE state");
                                        this.resetStartWhenNotLoaded(this.level);
                                        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
                                    }
                                }
                                break;
                            default:
                                break;
                        }
                        this.onTickEnd();
                    };
                    _proto.onTickEnd = function onTickEnd() {
                        _BaseStreamController.prototype.onTickEnd.call(this);
                        this.checkBuffer();
                        this.checkFragmentChanged();
                    };
                    _proto.doTickIdle = function doTickIdle() {
                        var _frag$decryptdata, _frag$decryptdata2;
                        var hls = this.hls,
                            levelLastLoaded = this.levelLastLoaded,
                            levels = this.levels,
                            media = this.media;
                        var config = hls.config,
                            level = hls.nextLoadLevel;
                        if (levelLastLoaded === null || (!media && (this.startFragRequested || !config.startFragPrefetch))) {
                            return;
                        }
                        if (this.altAudio && this.audioOnly) {
                            return;
                        }
                        if (!levels || !levels[level]) {
                            return;
                        }
                        var levelInfo = levels[level];
                        this.level = hls.nextLoadLevel = level;
                        var levelDetails = levelInfo.details;
                        if (!levelDetails || this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_LEVEL || (levelDetails.live && this.levelLastLoaded !== level)) {
                            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_LEVEL;
                            return;
                        }
                        var bufferInfo = this.getMainFwdBufferInfo();
                        if (bufferInfo === null) {
                            return;
                        }
                        var bufferLen = bufferInfo.len;
                        var maxBufLen = this.getMaxBufferLength(levelInfo.maxBitrate);
                        if (bufferLen >= maxBufLen) {
                            return;
                        }
                        if (this._streamEnded(bufferInfo, levelDetails)) {
                            var data = {};
                            if (this.altAudio) {
                                data.type = "video";
                            }
                            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].BUFFER_EOS, data);
                            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].ENDED;
                            return;
                        }
                        if (this.backtrackFragment && this.backtrackFragment.start > bufferInfo.end) {
                            this.backtrackFragment = null;
                        }
                        var targetBufferTime = this.backtrackFragment ? this.backtrackFragment.start : bufferInfo.end;
                        var frag = this.getNextFragment(targetBufferTime, levelDetails);
                        if (this.couldBacktrack && !this.fragPrevious && frag && frag.sn !== "initSegment" && this.fragmentTracker.getState(frag) !== _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__["FragmentState"].OK) {
                            var _this$backtrackFragme;
                            var backtrackSn = ((_this$backtrackFragme = this.backtrackFragment) != null ? _this$backtrackFragme : frag).sn;
                            var fragIdx = backtrackSn - levelDetails.startSN;
                            var backtrackFrag = levelDetails.fragments[fragIdx - 1];
                            if (backtrackFrag && frag.cc === backtrackFrag.cc) {
                                frag = backtrackFrag;
                                this.fragmentTracker.removeFragment(backtrackFrag);
                            }
                        } else if (this.backtrackFragment && bufferInfo.len) {
                            this.backtrackFragment = null;
                        }
                        if (frag && this.fragmentTracker.getState(frag) === _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__["FragmentState"].OK && this.nextLoadPosition > targetBufferTime) {
                            var type = this.audioOnly && !this.altAudio ? _loader_fragment__WEBPACK_IMPORTED_MODULE_7__["ElementaryStreamTypes"].AUDIO : _loader_fragment__WEBPACK_IMPORTED_MODULE_7__["ElementaryStreamTypes"].VIDEO;
                            if (media) {
                                this.afterBufferFlushed(media, type, _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].MAIN);
                            }
                            frag = this.getNextFragment(this.nextLoadPosition, levelDetails);
                        }
                        if (!frag) {
                            return;
                        }
                        if (frag.initSegment && !frag.initSegment.data && !this.bitrateTest) {
                            frag = frag.initSegment;
                        }
                        if (
                            ((_frag$decryptdata = frag.decryptdata) === null || _frag$decryptdata === void 0 ? void 0 : _frag$decryptdata.keyFormat) === "identity" &&
                            !((_frag$decryptdata2 = frag.decryptdata) !== null && _frag$decryptdata2 !== void 0 && _frag$decryptdata2.key)
                        ) {
                            this.loadKey(frag, levelDetails);
                        } else {
                            this.loadFragment(frag, levelDetails, targetBufferTime);
                        }
                    };
                    _proto.loadFragment = function loadFragment(frag, levelDetails, targetBufferTime) {
                        var _this$media2;
                        var fragState = this.fragmentTracker.getState(frag);
                        this.fragCurrent = frag;
                        if (fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__["FragmentState"].NOT_LOADED) {
                            if (frag.sn === "initSegment") {
                                this._loadInitSegment(frag);
                            } else if (this.bitrateTest) {
                                this.log("Fragment " + frag.sn + " of level " + frag.level + " is being downloaded to test bitrate and will not be buffered");
                                this._loadBitrateTestFrag(frag);
                            } else {
                                this.startFragRequested = true;
                                _BaseStreamController.prototype.loadFragment.call(this, frag, levelDetails, targetBufferTime);
                            }
                        } else if (fragState === _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__["FragmentState"].APPENDING) {
                            if (this.reduceMaxBufferLength(frag.duration)) {
                                this.fragmentTracker.removeFragment(frag);
                            }
                        } else if (((_this$media2 = this.media) === null || _this$media2 === void 0 ? void 0 : _this$media2.buffered.length) === 0) {
                            this.fragmentTracker.removeAllFragments();
                        }
                    };
                    _proto.getAppendedFrag = function getAppendedFrag(position) {
                        var fragOrPart = this.fragmentTracker.getAppendedFrag(position, _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].MAIN);
                        if (fragOrPart && "fragment" in fragOrPart) {
                            return fragOrPart.fragment;
                        }
                        return fragOrPart;
                    };
                    _proto.getBufferedFrag = function getBufferedFrag(position) {
                        return this.fragmentTracker.getBufferedFrag(position, _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].MAIN);
                    };
                    _proto.followingBufferedFrag = function followingBufferedFrag(frag) {
                        if (frag) {
                            return this.getBufferedFrag(frag.end + 0.5);
                        }
                        return null;
                    };
                    _proto.immediateLevelSwitch = function immediateLevelSwitch() {
                        this.abortCurrentFrag();
                        this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
                    };
                    _proto.nextLevelSwitch = function nextLevelSwitch() {
                        var levels = this.levels,
                            media = this.media;
                        if (media !== null && media !== void 0 && media.readyState) {
                            var fetchdelay;
                            var fragPlayingCurrent = this.getAppendedFrag(media.currentTime);
                            if (fragPlayingCurrent && fragPlayingCurrent.start > 1) {
                                this.flushMainBuffer(0, fragPlayingCurrent.start - 1);
                            }
                            if (!media.paused && levels) {
                                var nextLevelId = this.hls.nextLoadLevel;
                                var nextLevel = levels[nextLevelId];
                                var fragLastKbps = this.fragLastKbps;
                                if (fragLastKbps && this.fragCurrent) {
                                    fetchdelay = (this.fragCurrent.duration * nextLevel.maxBitrate) / (1e3 * fragLastKbps) + 1;
                                } else {
                                    fetchdelay = 0;
                                }
                            } else {
                                fetchdelay = 0;
                            }
                            var bufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);
                            if (bufferedFrag) {
                                var nextBufferedFrag = this.followingBufferedFrag(bufferedFrag);
                                if (nextBufferedFrag) {
                                    this.abortCurrentFrag();
                                    var maxStart = nextBufferedFrag.maxStartPTS ? nextBufferedFrag.maxStartPTS : nextBufferedFrag.start;
                                    var fragDuration = nextBufferedFrag.duration;
                                    var startPts = Math.max(bufferedFrag.end, maxStart + Math.min(Math.max(fragDuration - this.config.maxFragLookUpTolerance, fragDuration * 0.5), fragDuration * 0.75));
                                    this.flushMainBuffer(startPts, Number.POSITIVE_INFINITY);
                                }
                            }
                        }
                    };
                    _proto.abortCurrentFrag = function abortCurrentFrag() {
                        var fragCurrent = this.fragCurrent;
                        this.fragCurrent = null;
                        this.backtrackFragment = null;
                        if (fragCurrent !== null && fragCurrent !== void 0 && fragCurrent.loader) {
                            fragCurrent.loader.abort();
                        }
                        switch (this.state) {
                            case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].KEY_LOADING:
                            case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].FRAG_LOADING:
                            case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].FRAG_LOADING_WAITING_RETRY:
                            case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].PARSING:
                            case _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].PARSED:
                                this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
                                break;
                        }
                        this.nextLoadPosition = this.getLoadPosition();
                    };
                    _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset) {
                        _BaseStreamController.prototype.flushMainBuffer.call(this, startOffset, endOffset, this.altAudio ? "video" : null);
                    };
                    _proto.onMediaAttached = function onMediaAttached(event, data) {
                        _BaseStreamController.prototype.onMediaAttached.call(this, event, data);
                        var media = data.media;
                        this.onvplaying = this.onMediaPlaying.bind(this);
                        this.onvseeked = this.onMediaSeeked.bind(this);
                        media.addEventListener("playing", this.onvplaying);
                        media.addEventListener("seeked", this.onvseeked);
                        this.gapController = new _gap_controller__WEBPACK_IMPORTED_MODULE_10__["default"](this.config, media, this.fragmentTracker, this.hls);
                    };
                    _proto.onMediaDetaching = function onMediaDetaching() {
                        var media = this.media;
                        if (media && this.onvplaying && this.onvseeked) {
                            media.removeEventListener("playing", this.onvplaying);
                            media.removeEventListener("seeked", this.onvseeked);
                            this.onvplaying = this.onvseeked = null;
                            this.videoBuffer = null;
                        }
                        this.fragPlaying = null;
                        if (this.gapController) {
                            this.gapController.destroy();
                            this.gapController = null;
                        }
                        _BaseStreamController.prototype.onMediaDetaching.call(this);
                    };
                    _proto.onMediaPlaying = function onMediaPlaying() {
                        this.tick();
                    };
                    _proto.onMediaSeeked = function onMediaSeeked() {
                        var media = this.media;
                        var currentTime = media ? media.currentTime : null;
                        if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(currentTime)) {
                            this.log("Media seeked to " + currentTime.toFixed(3));
                        }
                        this.tick();
                    };
                    _proto.onManifestLoading = function onManifestLoading() {
                        this.log("Trigger BUFFER_RESET");
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].BUFFER_RESET, undefined);
                        this.fragmentTracker.removeAllFragments();
                        this.couldBacktrack = false;
                        this.startPosition = this.lastCurrentTime = 0;
                        this.fragPlaying = null;
                        this.backtrackFragment = null;
                    };
                    _proto.onManifestParsed = function onManifestParsed(event, data) {
                        var aac = false;
                        var heaac = false;
                        var codec;
                        data.levels.forEach(function (level) {
                            codec = level.audioCodec;
                            if (codec) {
                                if (codec.indexOf("mp4a.40.2") !== -1) {
                                    aac = true;
                                }
                                if (codec.indexOf("mp4a.40.5") !== -1) {
                                    heaac = true;
                                }
                            }
                        });
                        this.audioCodecSwitch = aac && heaac && !Object(_is_supported__WEBPACK_IMPORTED_MODULE_2__["changeTypeSupported"])();
                        if (this.audioCodecSwitch) {
                            this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC");
                        }
                        this.levels = data.levels;
                        this.startFragRequested = false;
                    };
                    _proto.onLevelLoading = function onLevelLoading(event, data) {
                        var levels = this.levels;
                        if (!levels || this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE) {
                            return;
                        }
                        var level = levels[data.level];
                        if (!level.details || (level.details.live && this.levelLastLoaded !== data.level) || this.waitForCdnTuneIn(level.details)) {
                            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_LEVEL;
                        }
                    };
                    _proto.onLevelLoaded = function onLevelLoaded(event, data) {
                        var _curLevel$details;
                        var levels = this.levels;
                        var newLevelId = data.level;
                        var newDetails = data.details;
                        var duration = newDetails.totalduration;
                        if (!levels) {
                            this.warn("Levels were reset while loading level " + newLevelId);
                            return;
                        }
                        this.log("Level " + newLevelId + " loaded [" + newDetails.startSN + "," + newDetails.endSN + "], cc [" + newDetails.startCC + ", " + newDetails.endCC + "] duration:" + duration);
                        var fragCurrent = this.fragCurrent;
                        if (
                            fragCurrent &&
                            (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].FRAG_LOADING || this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].FRAG_LOADING_WAITING_RETRY)
                        ) {
                            if (fragCurrent.level !== data.level && fragCurrent.loader) {
                                this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
                                this.backtrackFragment = null;
                                fragCurrent.loader.abort();
                            }
                        }
                        var curLevel = levels[newLevelId];
                        var sliding = 0;
                        if (newDetails.live || ((_curLevel$details = curLevel.details) !== null && _curLevel$details !== void 0 && _curLevel$details.live)) {
                            if (!newDetails.fragments[0]) {
                                newDetails.deltaUpdateFailed = true;
                            }
                            if (newDetails.deltaUpdateFailed) {
                                return;
                            }
                            sliding = this.alignPlaylists(newDetails, curLevel.details);
                        }
                        curLevel.details = newDetails;
                        this.levelLastLoaded = newLevelId;
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].LEVEL_UPDATED, { details: newDetails, level: newLevelId });
                        if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_LEVEL) {
                            if (this.waitForCdnTuneIn(newDetails)) {
                                return;
                            }
                            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
                        }
                        if (!this.startFragRequested) {
                            this.setStartPosition(newDetails, sliding);
                        } else if (newDetails.live) {
                            this.synchronizeToLiveEdge(newDetails);
                        }
                        this.tick();
                    };
                    _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(data) {
                        var _frag$initSegment;
                        var frag = data.frag,
                            part = data.part,
                            payload = data.payload;
                        var levels = this.levels;
                        if (!levels) {
                            this.warn("Levels were reset while fragment load was in progress. Fragment " + frag.sn + " of level " + frag.level + " will not be buffered");
                            return;
                        }
                        var currentLevel = levels[frag.level];
                        var details = currentLevel.details;
                        if (!details) {
                            this.warn("Dropping fragment " + frag.sn + " of level " + frag.level + " after level details were reset");
                            return;
                        }
                        var videoCodec = currentLevel.videoCodec;
                        var accurateTimeOffset = details.PTSKnown || !details.live;
                        var initSegmentData = (_frag$initSegment = frag.initSegment) === null || _frag$initSegment === void 0 ? void 0 : _frag$initSegment.data;
                        var audioCodec = this._getAudioCodec(currentLevel);
                        var transmuxer = (this.transmuxer =
                            this.transmuxer ||
                            new _demux_transmuxer_interface__WEBPACK_IMPORTED_MODULE_8__["default"](
                                this.hls,
                                _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].MAIN,
                                this._handleTransmuxComplete.bind(this),
                                this._handleTransmuxerFlush.bind(this)
                            ));
                        var partIndex = part ? part.index : -1;
                        var partial = partIndex !== -1;
                        var chunkMeta = new _types_transmuxer__WEBPACK_IMPORTED_MODULE_9__["ChunkMetadata"](frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);
                        var initPTS = this.initPTS[frag.cc];
                        transmuxer.push(payload, initSegmentData, audioCodec, videoCodec, frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);
                    };
                    _proto.onAudioTrackSwitching = function onAudioTrackSwitching(event, data) {
                        var fromAltAudio = this.altAudio;
                        var altAudio = !!data.url;
                        var trackId = data.id;
                        if (!altAudio) {
                            if (this.mediaBuffer !== this.media) {
                                this.log("Switching on main audio, use media.buffered to schedule main fragment loading");
                                this.mediaBuffer = this.media;
                                var fragCurrent = this.fragCurrent;
                                if (fragCurrent !== null && fragCurrent !== void 0 && fragCurrent.loader) {
                                    this.log("Switching to main audio track, cancel main fragment load");
                                    fragCurrent.loader.abort();
                                }
                                this.resetTransmuxer();
                                this.resetLoadingState();
                            } else if (this.audioOnly) {
                                this.resetTransmuxer();
                            }
                            var hls = this.hls;
                            if (fromAltAudio) {
                                hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: "audio" });
                            }
                            hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].AUDIO_TRACK_SWITCHED, { id: trackId });
                        }
                    };
                    _proto.onAudioTrackSwitched = function onAudioTrackSwitched(event, data) {
                        var trackId = data.id;
                        var altAudio = !!this.hls.audioTracks[trackId].url;
                        if (altAudio) {
                            var videoBuffer = this.videoBuffer;
                            if (videoBuffer && this.mediaBuffer !== videoBuffer) {
                                this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading");
                                this.mediaBuffer = videoBuffer;
                            }
                        }
                        this.altAudio = altAudio;
                        this.tick();
                    };
                    _proto.onBufferCreated = function onBufferCreated(event, data) {
                        var tracks = data.tracks;
                        var mediaTrack;
                        var name;
                        var alternate = false;
                        for (var type in tracks) {
                            var track = tracks[type];
                            if (track.id === "main") {
                                name = type;
                                mediaTrack = track;
                                if (type === "video") {
                                    var videoTrack = tracks[type];
                                    if (videoTrack) {
                                        this.videoBuffer = videoTrack.buffer;
                                    }
                                }
                            } else {
                                alternate = true;
                            }
                        }
                        if (alternate && mediaTrack) {
                            this.log("Alternate track found, use " + name + ".buffered to schedule main fragment loading");
                            this.mediaBuffer = mediaTrack.buffer;
                        } else {
                            this.mediaBuffer = this.media;
                        }
                    };
                    _proto.onFragBuffered = function onFragBuffered(event, data) {
                        var frag = data.frag,
                            part = data.part;
                        if (frag && frag.type !== _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].MAIN) {
                            return;
                        }
                        if (this.fragContextChanged(frag)) {
                            this.warn("Fragment " + frag.sn + (part ? " p: " + part.index : "") + " of level " + frag.level + " finished buffering, but was aborted. state: " + this.state);
                            if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].PARSED) {
                                this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
                            }
                            return;
                        }
                        var stats = part ? part.stats : frag.stats;
                        this.fragLastKbps = Math.round((8 * stats.total) / (stats.buffering.end - stats.loading.first));
                        if (frag.sn !== "initSegment") {
                            this.fragPrevious = frag;
                        }
                        this.fragBufferedComplete(frag, part);
                    };
                    _proto.onError = function onError(event, data) {
                        switch (data.details) {
                            case _errors__WEBPACK_IMPORTED_MODULE_11__["ErrorDetails"].FRAG_LOAD_ERROR:
                            case _errors__WEBPACK_IMPORTED_MODULE_11__["ErrorDetails"].FRAG_LOAD_TIMEOUT:
                            case _errors__WEBPACK_IMPORTED_MODULE_11__["ErrorDetails"].KEY_LOAD_ERROR:
                            case _errors__WEBPACK_IMPORTED_MODULE_11__["ErrorDetails"].KEY_LOAD_TIMEOUT:
                                this.onFragmentOrKeyLoadError(_types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].MAIN, data);
                                break;
                            case _errors__WEBPACK_IMPORTED_MODULE_11__["ErrorDetails"].LEVEL_LOAD_ERROR:
                            case _errors__WEBPACK_IMPORTED_MODULE_11__["ErrorDetails"].LEVEL_LOAD_TIMEOUT:
                                if (this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].ERROR) {
                                    if (data.fatal) {
                                        this.warn("" + data.details);
                                        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].ERROR;
                                    } else {
                                        if (!data.levelRetry && this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].WAITING_LEVEL) {
                                            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
                                        }
                                    }
                                }
                                break;
                            case _errors__WEBPACK_IMPORTED_MODULE_11__["ErrorDetails"].BUFFER_FULL_ERROR:
                                if (data.parent === "main" && (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].PARSING || this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].PARSED)) {
                                    var flushBuffer = true;
                                    var bufferedInfo = this.getFwdBufferInfo(this.media, _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].MAIN);
                                    if (bufferedInfo && bufferedInfo.len > 0.5) {
                                        flushBuffer = !this.reduceMaxBufferLength(bufferedInfo.len);
                                    }
                                    if (flushBuffer) {
                                        this.warn("buffer full error also media.currentTime is not buffered, flush main");
                                        this.immediateLevelSwitch();
                                    }
                                    this.resetLoadingState();
                                }
                                break;
                            default:
                                break;
                        }
                    };
                    _proto.checkBuffer = function checkBuffer() {
                        var media = this.media,
                            gapController = this.gapController;
                        if (!media || !gapController || !media.readyState) {
                            return;
                        }
                        if (this.loadedmetadata || !_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__["BufferHelper"].getBuffered(media).length) {
                            var activeFrag = this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE ? this.fragCurrent : null;
                            gapController.poll(this.lastCurrentTime, activeFrag);
                        }
                        this.lastCurrentTime = media.currentTime;
                    };
                    _proto.onFragLoadEmergencyAborted = function onFragLoadEmergencyAborted() {
                        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
                        if (!this.loadedmetadata) {
                            this.startFragRequested = false;
                            this.nextLoadPosition = this.startPosition;
                        }
                        this.tickImmediate();
                    };
                    _proto.onBufferFlushed = function onBufferFlushed(event, _ref) {
                        var type = _ref.type;
                        if (type !== _loader_fragment__WEBPACK_IMPORTED_MODULE_7__["ElementaryStreamTypes"].AUDIO || (this.audioOnly && !this.altAudio)) {
                            var media = (type === _loader_fragment__WEBPACK_IMPORTED_MODULE_7__["ElementaryStreamTypes"].VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
                            this.afterBufferFlushed(media, type, _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].MAIN);
                        }
                    };
                    _proto.onLevelsUpdated = function onLevelsUpdated(event, data) {
                        this.levels = data.levels;
                    };
                    _proto.swapAudioCodec = function swapAudioCodec() {
                        this.audioCodecSwap = !this.audioCodecSwap;
                    };
                    _proto.seekToStartPos = function seekToStartPos() {
                        var media = this.media;
                        if (!media) {
                            return;
                        }
                        var currentTime = media.currentTime;
                        var startPosition = this.startPosition;
                        if (startPosition >= 0 && currentTime < startPosition) {
                            if (media.seeking) {
                                this.log("could not seek to " + startPosition + ", already seeking at " + currentTime);
                                return;
                            }
                            var buffered = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__["BufferHelper"].getBuffered(media);
                            var bufferStart = buffered.length ? buffered.start(0) : 0;
                            var delta = bufferStart - startPosition;
                            if (delta > 0 && (delta < this.config.maxBufferHole || delta < this.config.maxFragLookUpTolerance)) {
                                this.log("adjusting start position by " + delta + " to match buffer start");
                                startPosition += delta;
                                this.startPosition = startPosition;
                            }
                            this.log("seek to target start position " + startPosition + " from current time " + currentTime);
                            media.currentTime = startPosition;
                        }
                    };
                    _proto._getAudioCodec = function _getAudioCodec(currentLevel) {
                        var audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;
                        if (this.audioCodecSwap && audioCodec) {
                            this.log("Swapping audio codec");
                            if (audioCodec.indexOf("mp4a.40.5") !== -1) {
                                audioCodec = "mp4a.40.2";
                            } else {
                                audioCodec = "mp4a.40.5";
                            }
                        }
                        return audioCodec;
                    };
                    _proto._loadBitrateTestFrag = function _loadBitrateTestFrag(frag) {
                        var _this2 = this;
                        frag.bitrateTest = true;
                        this._doFragLoad(frag).then(function (data) {
                            var hls = _this2.hls;
                            if (!data || hls.nextLoadLevel || _this2.fragContextChanged(frag)) {
                                return;
                            }
                            _this2.fragLoadError = 0;
                            _this2.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
                            _this2.startFragRequested = false;
                            _this2.bitrateTest = false;
                            var stats = frag.stats;
                            stats.parsing.start = stats.parsing.end = stats.buffering.start = stats.buffering.end = self.performance.now();
                            hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].FRAG_LOADED, data);
                            frag.bitrateTest = false;
                        });
                    };
                    _proto._handleTransmuxComplete = function _handleTransmuxComplete(transmuxResult) {
                        var _id3$samples;
                        var id = "main";
                        var hls = this.hls;
                        var remuxResult = transmuxResult.remuxResult,
                            chunkMeta = transmuxResult.chunkMeta;
                        var context = this.getCurrentContext(chunkMeta);
                        if (!context) {
                            this.warn("The loading context changed while buffering fragment " + chunkMeta.sn + " of level " + chunkMeta.level + ". This chunk will not be buffered.");
                            this.resetStartWhenNotLoaded(chunkMeta.level);
                            return;
                        }
                        var frag = context.frag,
                            part = context.part,
                            level = context.level;
                        var video = remuxResult.video,
                            text = remuxResult.text,
                            id3 = remuxResult.id3,
                            initSegment = remuxResult.initSegment;
                        var details = level.details;
                        var audio = this.altAudio ? undefined : remuxResult.audio;
                        if (this.fragContextChanged(frag)) {
                            return;
                        }
                        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].PARSING;
                        if (initSegment) {
                            if (initSegment.tracks) {
                                this._bufferInitSegment(level, initSegment.tracks, frag, chunkMeta);
                                hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].FRAG_PARSING_INIT_SEGMENT, { frag: frag, id: id, tracks: initSegment.tracks });
                            }
                            var initPTS = initSegment.initPTS;
                            var timescale = initSegment.timescale;
                            if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(initPTS)) {
                                this.initPTS[frag.cc] = initPTS;
                                hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].INIT_PTS_FOUND, { frag: frag, id: id, initPTS: initPTS, timescale: timescale });
                            }
                        }
                        if (video && remuxResult.independent !== false) {
                            if (details) {
                                var startPTS = video.startPTS,
                                    endPTS = video.endPTS,
                                    startDTS = video.startDTS,
                                    endDTS = video.endDTS;
                                if (part) {
                                    part.elementaryStreams[video.type] = { startPTS: startPTS, endPTS: endPTS, startDTS: startDTS, endDTS: endDTS };
                                } else {
                                    if (video.firstKeyFrame && video.independent) {
                                        this.couldBacktrack = true;
                                    }
                                    if (video.dropped && video.independent) {
                                        var bufferInfo = this.getMainFwdBufferInfo();
                                        var targetBufferTime = (bufferInfo ? bufferInfo.end : this.getLoadPosition()) + this.config.maxBufferHole;
                                        var startTime = video.firstKeyFramePTS ? video.firstKeyFramePTS : startPTS;
                                        if (targetBufferTime < startTime - this.config.maxBufferHole) {
                                            this.backtrack(frag);
                                            return;
                                        }
                                        frag.setElementaryStreamInfo(video.type, frag.start, endPTS, frag.start, endDTS, true);
                                    }
                                }
                                frag.setElementaryStreamInfo(video.type, startPTS, endPTS, startDTS, endDTS);
                                if (this.backtrackFragment) {
                                    this.backtrackFragment = frag;
                                }
                                this.bufferFragmentData(video, frag, part, chunkMeta);
                            }
                        } else if (remuxResult.independent === false) {
                            this.backtrack(frag);
                            return;
                        }
                        if (audio) {
                            var _startPTS = audio.startPTS,
                                _endPTS = audio.endPTS,
                                _startDTS = audio.startDTS,
                                _endDTS = audio.endDTS;
                            if (part) {
                                part.elementaryStreams[_loader_fragment__WEBPACK_IMPORTED_MODULE_7__["ElementaryStreamTypes"].AUDIO] = { startPTS: _startPTS, endPTS: _endPTS, startDTS: _startDTS, endDTS: _endDTS };
                            }
                            frag.setElementaryStreamInfo(_loader_fragment__WEBPACK_IMPORTED_MODULE_7__["ElementaryStreamTypes"].AUDIO, _startPTS, _endPTS, _startDTS, _endDTS);
                            this.bufferFragmentData(audio, frag, part, chunkMeta);
                        }
                        if (details && id3 !== null && id3 !== void 0 && (_id3$samples = id3.samples) !== null && _id3$samples !== void 0 && _id3$samples.length) {
                            var emittedID3 = { id: id, frag: frag, details: details, samples: id3.samples };
                            hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].FRAG_PARSING_METADATA, emittedID3);
                        }
                        if (details && text) {
                            var emittedText = { id: id, frag: frag, details: details, samples: text.samples };
                            hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].FRAG_PARSING_USERDATA, emittedText);
                        }
                    };
                    _proto._bufferInitSegment = function _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {
                        var _this3 = this;
                        if (this.state !== _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].PARSING) {
                            return;
                        }
                        this.audioOnly = !!tracks.audio && !tracks.video;
                        if (this.altAudio && !this.audioOnly) {
                            delete tracks.audio;
                        }
                        var audio = tracks.audio,
                            video = tracks.video,
                            audiovideo = tracks.audiovideo;
                        if (audio) {
                            var audioCodec = currentLevel.audioCodec;
                            var ua = navigator.userAgent.toLowerCase();
                            if (this.audioCodecSwitch) {
                                if (audioCodec) {
                                    if (audioCodec.indexOf("mp4a.40.5") !== -1) {
                                        audioCodec = "mp4a.40.2";
                                    } else {
                                        audioCodec = "mp4a.40.5";
                                    }
                                }
                                if (audio.metadata.channelCount !== 1 && ua.indexOf("firefox") === -1) {
                                    audioCodec = "mp4a.40.5";
                                }
                            }
                            if (ua.indexOf("android") !== -1 && audio.container !== "audio/mpeg") {
                                audioCodec = "mp4a.40.2";
                                this.log("Android: force audio codec to " + audioCodec);
                            }
                            if (currentLevel.audioCodec && currentLevel.audioCodec !== audioCodec) {
                                this.log('Swapping manifest audio codec "' + currentLevel.audioCodec + '" for "' + audioCodec + '"');
                            }
                            audio.levelCodec = audioCodec;
                            audio.id = "main";
                            this.log("Init audio buffer, container:" + audio.container + ", codecs[selected/level/parsed]=[" + (audioCodec || "") + "/" + (currentLevel.audioCodec || "") + "/" + audio.codec + "]");
                        }
                        if (video) {
                            video.levelCodec = currentLevel.videoCodec;
                            video.id = "main";
                            this.log("Init video buffer, container:" + video.container + ", codecs[level/parsed]=[" + (currentLevel.videoCodec || "") + "/" + video.codec + "]");
                        }
                        if (audiovideo) {
                            this.log("Init audiovideo buffer, container:" + audiovideo.container + ", codecs[level/parsed]=[" + (currentLevel.attrs.CODECS || "") + "/" + audiovideo.codec + "]");
                        }
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].BUFFER_CODECS, tracks);
                        Object.keys(tracks).forEach(function (trackName) {
                            var track = tracks[trackName];
                            var initSegment = track.initSegment;
                            if (initSegment !== null && initSegment !== void 0 && initSegment.byteLength) {
                                _this3.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].BUFFER_APPENDING, { type: trackName, data: initSegment, frag: frag, part: null, chunkMeta: chunkMeta, parent: frag.type });
                            }
                        });
                        this.tick();
                    };
                    _proto.getMainFwdBufferInfo = function getMainFwdBufferInfo() {
                        return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].MAIN);
                    };
                    _proto.backtrack = function backtrack(frag) {
                        this.couldBacktrack = true;
                        this.backtrackFragment = frag;
                        this.resetTransmuxer();
                        this.flushBufferGap(frag);
                        this.fragmentTracker.removeFragment(frag);
                        this.fragPrevious = null;
                        this.nextLoadPosition = frag.start;
                        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["State"].IDLE;
                    };
                    _proto.checkFragmentChanged = function checkFragmentChanged() {
                        var video = this.media;
                        var fragPlayingCurrent = null;
                        if (video && video.readyState > 1 && video.seeking === false) {
                            var currentTime = video.currentTime;
                            if (_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__["BufferHelper"].isBuffered(video, currentTime)) {
                                fragPlayingCurrent = this.getAppendedFrag(currentTime);
                            } else if (_utils_buffer_helper__WEBPACK_IMPORTED_MODULE_4__["BufferHelper"].isBuffered(video, currentTime + 0.1)) {
                                fragPlayingCurrent = this.getAppendedFrag(currentTime + 0.1);
                            }
                            if (fragPlayingCurrent) {
                                this.backtrackFragment = null;
                                var fragPlaying = this.fragPlaying;
                                var fragCurrentLevel = fragPlayingCurrent.level;
                                if (!fragPlaying || fragPlayingCurrent.sn !== fragPlaying.sn || fragPlaying.level !== fragCurrentLevel || fragPlayingCurrent.urlId !== fragPlaying.urlId) {
                                    this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].FRAG_CHANGED, { frag: fragPlayingCurrent });
                                    if (!fragPlaying || fragPlaying.level !== fragCurrentLevel) {
                                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].LEVEL_SWITCHED, { level: fragCurrentLevel });
                                    }
                                    this.fragPlaying = fragPlayingCurrent;
                                }
                            }
                        }
                    };
                    _createClass(StreamController, [
                        {
                            key: "nextLevel",
                            get: function get() {
                                var frag = this.nextBufferedFrag;
                                if (frag) {
                                    return frag.level;
                                }
                                return -1;
                            },
                        },
                        {
                            key: "currentFrag",
                            get: function get() {
                                var media = this.media;
                                if (media) {
                                    return this.fragPlaying || this.getAppendedFrag(media.currentTime);
                                }
                                return null;
                            },
                        },
                        {
                            key: "currentProgramDateTime",
                            get: function get() {
                                var media = this.media;
                                if (media) {
                                    var currentTime = media.currentTime;
                                    var frag = this.currentFrag;
                                    if (
                                        frag &&
                                        Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(currentTime) &&
                                        Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(frag.programDateTime)
                                    ) {
                                        var epocMs = frag.programDateTime + (currentTime - frag.start) * 1e3;
                                        return new Date(epocMs);
                                    }
                                }
                                return null;
                            },
                        },
                        {
                            key: "currentLevel",
                            get: function get() {
                                var frag = this.currentFrag;
                                if (frag) {
                                    return frag.level;
                                }
                                return -1;
                            },
                        },
                        {
                            key: "nextBufferedFrag",
                            get: function get() {
                                var frag = this.currentFrag;
                                if (frag) {
                                    return this.followingBufferedFrag(frag);
                                }
                                return null;
                            },
                        },
                        {
                            key: "forceStartLoad",
                            get: function get() {
                                return this._forceStartLoad;
                            },
                        },
                    ]);
                    return StreamController;
                })(_base_stream_controller__WEBPACK_IMPORTED_MODULE_1__["default"]);
            },
            "./src/controller/subtitle-stream-controller.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "SubtitleStreamController", function () {
                    return SubtitleStreamController;
                });
                var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/events.ts");
                var _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/buffer-helper.ts");
                var _fragment_finders__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/controller/fragment-finders.ts");
                var _utils_discontinuities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/utils/discontinuities.ts");
                var _level_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/controller/level-helper.ts");
                var _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/controller/fragment-tracker.ts");
                var _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/controller/base-stream-controller.ts");
                var _types_loader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/types/loader.ts");
                var _types_level__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./src/types/level.ts");
                function _defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    Object.defineProperty(Constructor, "prototype", { writable: false });
                    return Constructor;
                }
                function _inheritsLoose(subClass, superClass) {
                    subClass.prototype = Object.create(superClass.prototype);
                    subClass.prototype.constructor = subClass;
                    _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf
                        ? Object.setPrototypeOf.bind()
                        : function _setPrototypeOf(o, p) {
                              o.__proto__ = p;
                              return o;
                          };
                    return _setPrototypeOf(o, p);
                }
                var TICK_INTERVAL = 500;
                var SubtitleStreamController = (function (_BaseStreamController) {
                    _inheritsLoose(SubtitleStreamController, _BaseStreamController);
                    function SubtitleStreamController(hls, fragmentTracker) {
                        var _this;
                        _this = _BaseStreamController.call(this, hls, fragmentTracker, "[subtitle-stream-controller]") || this;
                        _this.levels = [];
                        _this.currentTrackId = -1;
                        _this.tracksBuffered = [];
                        _this.mainDetails = null;
                        _this._registerListeners();
                        return _this;
                    }
                    var _proto = SubtitleStreamController.prototype;
                    _proto.onHandlerDestroying = function onHandlerDestroying() {
                        this._unregisterListeners();
                        this.mainDetails = null;
                    };
                    _proto._registerListeners = function _registerListeners() {
                        var hls = this.hls;
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].LEVEL_LOADED, this.onLevelLoaded, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, this.onError, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].BUFFER_FLUSHING, this.onBufferFlushing, this);
                    };
                    _proto._unregisterListeners = function _unregisterListeners() {
                        var hls = this.hls;
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].LEVEL_LOADED, this.onLevelLoaded, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, this.onError, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].BUFFER_FLUSHING, this.onBufferFlushing, this);
                    };
                    _proto.startLoad = function startLoad() {
                        this.stopLoad();
                        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__["State"].IDLE;
                        this.setInterval(TICK_INTERVAL);
                        this.tick();
                    };
                    _proto.onManifestLoading = function onManifestLoading() {
                        this.mainDetails = null;
                        this.fragmentTracker.removeAllFragments();
                    };
                    _proto.onLevelLoaded = function onLevelLoaded(event, data) {
                        this.mainDetails = data.details;
                    };
                    _proto.onSubtitleFragProcessed = function onSubtitleFragProcessed(event, data) {
                        var frag = data.frag,
                            success = data.success;
                        this.fragPrevious = frag;
                        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__["State"].IDLE;
                        if (!success) {
                            return;
                        }
                        var buffered = this.tracksBuffered[this.currentTrackId];
                        if (!buffered) {
                            return;
                        }
                        var timeRange;
                        var fragStart = frag.start;
                        for (var i = 0; i < buffered.length; i++) {
                            if (fragStart >= buffered[i].start && fragStart <= buffered[i].end) {
                                timeRange = buffered[i];
                                break;
                            }
                        }
                        var fragEnd = frag.start + frag.duration;
                        if (timeRange) {
                            timeRange.end = fragEnd;
                        } else {
                            timeRange = { start: fragStart, end: fragEnd };
                            buffered.push(timeRange);
                        }
                        this.fragmentTracker.fragBuffered(frag);
                    };
                    _proto.onBufferFlushing = function onBufferFlushing(event, data) {
                        var startOffset = data.startOffset,
                            endOffset = data.endOffset;
                        if (startOffset === 0 && endOffset !== Number.POSITIVE_INFINITY) {
                            var currentTrackId = this.currentTrackId,
                                levels = this.levels;
                            if (!levels.length || !levels[currentTrackId] || !levels[currentTrackId].details) {
                                return;
                            }
                            var trackDetails = levels[currentTrackId].details;
                            var targetDuration = trackDetails.targetduration;
                            var endOffsetSubtitles = endOffset - targetDuration;
                            if (endOffsetSubtitles <= 0) {
                                return;
                            }
                            data.endOffsetSubtitles = Math.max(0, endOffsetSubtitles);
                            this.tracksBuffered.forEach(function (buffered) {
                                for (var i = 0; i < buffered.length; ) {
                                    if (buffered[i].end <= endOffsetSubtitles) {
                                        buffered.shift();
                                        continue;
                                    } else if (buffered[i].start < endOffsetSubtitles) {
                                        buffered[i].start = endOffsetSubtitles;
                                    } else {
                                        break;
                                    }
                                    i++;
                                }
                            });
                            this.fragmentTracker.removeFragmentsInRange(startOffset, endOffsetSubtitles, _types_loader__WEBPACK_IMPORTED_MODULE_7__["PlaylistLevelType"].SUBTITLE);
                        }
                    };
                    _proto.onError = function onError(event, data) {
                        var _this$fragCurrent;
                        var frag = data.frag;
                        if (!frag || frag.type !== _types_loader__WEBPACK_IMPORTED_MODULE_7__["PlaylistLevelType"].SUBTITLE) {
                            return;
                        }
                        if ((_this$fragCurrent = this.fragCurrent) !== null && _this$fragCurrent !== void 0 && _this$fragCurrent.loader) {
                            this.fragCurrent.loader.abort();
                        }
                        this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__["State"].IDLE;
                    };
                    _proto.onSubtitleTracksUpdated = function onSubtitleTracksUpdated(event, _ref) {
                        var _this2 = this;
                        var subtitleTracks = _ref.subtitleTracks;
                        this.tracksBuffered = [];
                        this.levels = subtitleTracks.map(function (mediaPlaylist) {
                            return new _types_level__WEBPACK_IMPORTED_MODULE_8__["Level"](mediaPlaylist);
                        });
                        this.fragmentTracker.removeAllFragments();
                        this.fragPrevious = null;
                        this.levels.forEach(function (level) {
                            _this2.tracksBuffered[level.id] = [];
                        });
                        this.mediaBuffer = null;
                    };
                    _proto.onSubtitleTrackSwitch = function onSubtitleTrackSwitch(event, data) {
                        this.currentTrackId = data.id;
                        if (!this.levels.length || this.currentTrackId === -1) {
                            this.clearInterval();
                            return;
                        }
                        var currentTrack = this.levels[this.currentTrackId];
                        if (currentTrack !== null && currentTrack !== void 0 && currentTrack.details) {
                            this.mediaBuffer = this.mediaBufferTimeRanges;
                        } else {
                            this.mediaBuffer = null;
                        }
                        if (currentTrack) {
                            this.setInterval(TICK_INTERVAL);
                        }
                    };
                    _proto.onSubtitleTrackLoaded = function onSubtitleTrackLoaded(event, data) {
                        var _track$details;
                        var newDetails = data.details,
                            trackId = data.id;
                        var currentTrackId = this.currentTrackId,
                            levels = this.levels;
                        if (!levels.length) {
                            return;
                        }
                        var track = levels[currentTrackId];
                        if (trackId >= levels.length || trackId !== currentTrackId || !track) {
                            return;
                        }
                        this.mediaBuffer = this.mediaBufferTimeRanges;
                        if (newDetails.live || ((_track$details = track.details) !== null && _track$details !== void 0 && _track$details.live)) {
                            var mainDetails = this.mainDetails;
                            if (newDetails.deltaUpdateFailed || !mainDetails) {
                                return;
                            }
                            var mainSlidingStartFragment = mainDetails.fragments[0];
                            if (!track.details) {
                                if (newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {
                                    Object(_utils_discontinuities__WEBPACK_IMPORTED_MODULE_3__["alignMediaPlaylistByPDT"])(newDetails, mainDetails);
                                } else if (mainSlidingStartFragment) {
                                    Object(_level_helper__WEBPACK_IMPORTED_MODULE_4__["addSliding"])(newDetails, mainSlidingStartFragment.start);
                                }
                            } else {
                                var sliding = this.alignPlaylists(newDetails, track.details);
                                if (sliding === 0 && mainSlidingStartFragment) {
                                    Object(_level_helper__WEBPACK_IMPORTED_MODULE_4__["addSliding"])(newDetails, mainSlidingStartFragment.start);
                                }
                            }
                        }
                        track.details = newDetails;
                        this.levelLastLoaded = trackId;
                        this.tick();
                        if (newDetails.live && !this.fragCurrent && this.media && this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__["State"].IDLE) {
                            var foundFrag = Object(_fragment_finders__WEBPACK_IMPORTED_MODULE_2__["findFragmentByPTS"])(null, newDetails.fragments, this.media.currentTime, 0);
                            if (!foundFrag) {
                                this.warn("Subtitle playlist not aligned with playback");
                                track.details = undefined;
                            }
                        }
                    };
                    _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedData) {
                        var frag = fragLoadedData.frag,
                            payload = fragLoadedData.payload;
                        var decryptData = frag.decryptdata;
                        var hls = this.hls;
                        if (this.fragContextChanged(frag)) {
                            return;
                        }
                        if (payload && payload.byteLength > 0 && decryptData && decryptData.key && decryptData.iv && decryptData.method === "AES-128") {
                            var startTime = performance.now();
                            this.decrypter.webCryptoDecrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).then(function (decryptedData) {
                                var endTime = performance.now();
                                hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].FRAG_DECRYPTED, { frag: frag, payload: decryptedData, stats: { tstart: startTime, tdecrypt: endTime } });
                            });
                        }
                    };
                    _proto.doTick = function doTick() {
                        if (!this.media) {
                            this.state = _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__["State"].IDLE;
                            return;
                        }
                        if (this.state === _base_stream_controller__WEBPACK_IMPORTED_MODULE_6__["State"].IDLE) {
                            var currentTrackId = this.currentTrackId,
                                levels = this.levels;
                            if (!levels.length || !levels[currentTrackId] || !levels[currentTrackId].details) {
                                return;
                            }
                            var trackDetails = levels[currentTrackId].details;
                            var targetDuration = trackDetails.targetduration;
                            var config = this.config,
                                media = this.media;
                            var bufferedInfo = _utils_buffer_helper__WEBPACK_IMPORTED_MODULE_1__["BufferHelper"].bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], media.currentTime - targetDuration, config.maxBufferHole);
                            var targetBufferTime = bufferedInfo.end,
                                bufferLen = bufferedInfo.len;
                            var maxBufLen = this.getMaxBufferLength() + targetDuration;
                            if (bufferLen > maxBufLen) {
                                return;
                            }
                            console.assert(trackDetails, "Subtitle track details are defined on idle subtitle stream controller tick");
                            var fragments = trackDetails.fragments;
                            var fragLen = fragments.length;
                            var end = trackDetails.edge;
                            var foundFrag;
                            var fragPrevious = this.fragPrevious;
                            if (targetBufferTime < end) {
                                var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
                                foundFrag = Object(_fragment_finders__WEBPACK_IMPORTED_MODULE_2__["findFragmentByPTS"])(fragPrevious, fragments, Math.max(fragments[0].start, targetBufferTime), maxFragLookUpTolerance);
                                if (!foundFrag && fragPrevious && fragPrevious.start < fragments[0].start) {
                                    foundFrag = fragments[0];
                                }
                            } else {
                                foundFrag = fragments[fragLen - 1];
                            }
                            foundFrag = this.mapToInitFragWhenRequired(foundFrag);
                            if (!foundFrag) {
                                return;
                            }
                            if (this.fragmentTracker.getState(foundFrag) !== _fragment_tracker__WEBPACK_IMPORTED_MODULE_5__["FragmentState"].NOT_LOADED) {
                                return;
                            }
                            if (foundFrag.encrypted) {
                                this.loadKey(foundFrag, trackDetails);
                            } else {
                                this.loadFragment(foundFrag, trackDetails, targetBufferTime);
                            }
                        }
                    };
                    _proto.loadFragment = function loadFragment(frag, levelDetails, targetBufferTime) {
                        this.fragCurrent = frag;
                        if (frag.sn === "initSegment") {
                            this._loadInitSegment(frag);
                        } else {
                            _BaseStreamController.prototype.loadFragment.call(this, frag, levelDetails, targetBufferTime);
                        }
                    };
                    _createClass(SubtitleStreamController, [
                        {
                            key: "mediaBufferTimeRanges",
                            get: function get() {
                                return new BufferableInstance(this.tracksBuffered[this.currentTrackId] || []);
                            },
                        },
                    ]);
                    return SubtitleStreamController;
                })(_base_stream_controller__WEBPACK_IMPORTED_MODULE_6__["default"]);
                var BufferableInstance = function BufferableInstance(timeranges) {
                    this.buffered = void 0;
                    var getRange = function getRange(name, index, length) {
                        index = index >>> 0;
                        if (index > length - 1) {
                            throw new DOMException("Failed to execute '" + name + "' on 'TimeRanges': The index provided (" + index + ") is greater than the maximum bound (" + length + ")");
                        }
                        return timeranges[index][name];
                    };
                    this.buffered = {
                        get length() {
                            return timeranges.length;
                        },
                        end: function end(index) {
                            return getRange("end", index, timeranges.length);
                        },
                        start: function start(index) {
                            return getRange("start", index, timeranges.length);
                        },
                    };
                };
            },
            "./src/controller/subtitle-track-controller.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/events.ts");
                var _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/texttrack-utils.ts");
                var _base_playlist_controller__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/controller/base-playlist-controller.ts");
                var _types_loader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/types/loader.ts");
                function _defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    Object.defineProperty(Constructor, "prototype", { writable: false });
                    return Constructor;
                }
                function _inheritsLoose(subClass, superClass) {
                    subClass.prototype = Object.create(superClass.prototype);
                    subClass.prototype.constructor = subClass;
                    _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf
                        ? Object.setPrototypeOf.bind()
                        : function _setPrototypeOf(o, p) {
                              o.__proto__ = p;
                              return o;
                          };
                    return _setPrototypeOf(o, p);
                }
                var SubtitleTrackController = (function (_BasePlaylistControll) {
                    _inheritsLoose(SubtitleTrackController, _BasePlaylistControll);
                    function SubtitleTrackController(hls) {
                        var _this;
                        _this = _BasePlaylistControll.call(this, hls, "[subtitle-track-controller]") || this;
                        _this.media = null;
                        _this.tracks = [];
                        _this.groupId = null;
                        _this.tracksInGroup = [];
                        _this.trackId = -1;
                        _this.selectDefaultTrack = true;
                        _this.queuedDefaultTrack = -1;
                        _this.trackChangeListener = function () {
                            return _this.onTextTracksChanged();
                        };
                        _this.asyncPollTrackChange = function () {
                            return _this.pollTrackChange(0);
                        };
                        _this.useTextTrackPolling = false;
                        _this.subtitlePollingInterval = -1;
                        _this._subtitleDisplay = true;
                        _this.registerListeners();
                        return _this;
                    }
                    var _proto = SubtitleTrackController.prototype;
                    _proto.destroy = function destroy() {
                        this.unregisterListeners();
                        this.tracks.length = 0;
                        this.tracksInGroup.length = 0;
                        this.trackChangeListener = this.asyncPollTrackChange = null;
                        _BasePlaylistControll.prototype.destroy.call(this);
                    };
                    _proto.registerListeners = function registerListeners() {
                        var hls = this.hls;
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MANIFEST_PARSED, this.onManifestParsed, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].LEVEL_LOADING, this.onLevelLoading, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].LEVEL_SWITCHING, this.onLevelSwitching, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, this.onError, this);
                    };
                    _proto.unregisterListeners = function unregisterListeners() {
                        var hls = this.hls;
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_ATTACHED, this.onMediaAttached, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].MANIFEST_PARSED, this.onManifestParsed, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].LEVEL_LOADING, this.onLevelLoading, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].LEVEL_SWITCHING, this.onLevelSwitching, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, this.onError, this);
                    };
                    _proto.onMediaAttached = function onMediaAttached(event, data) {
                        this.media = data.media;
                        if (!this.media) {
                            return;
                        }
                        if (this.queuedDefaultTrack > -1) {
                            this.subtitleTrack = this.queuedDefaultTrack;
                            this.queuedDefaultTrack = -1;
                        }
                        this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks);
                        if (this.useTextTrackPolling) {
                            this.pollTrackChange(500);
                        } else {
                            this.media.textTracks.addEventListener("change", this.asyncPollTrackChange);
                        }
                    };
                    _proto.pollTrackChange = function pollTrackChange(timeout) {
                        self.clearInterval(this.subtitlePollingInterval);
                        this.subtitlePollingInterval = self.setInterval(this.trackChangeListener, timeout);
                    };
                    _proto.onMediaDetaching = function onMediaDetaching() {
                        if (!this.media) {
                            return;
                        }
                        self.clearInterval(this.subtitlePollingInterval);
                        if (!this.useTextTrackPolling) {
                            this.media.textTracks.removeEventListener("change", this.asyncPollTrackChange);
                        }
                        if (this.trackId > -1) {
                            this.queuedDefaultTrack = this.trackId;
                        }
                        var textTracks = filterSubtitleTracks(this.media.textTracks);
                        textTracks.forEach(function (track) {
                            Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_1__["clearCurrentCues"])(track);
                        });
                        this.subtitleTrack = -1;
                        this.media = null;
                    };
                    _proto.onManifestLoading = function onManifestLoading() {
                        this.tracks = [];
                        this.groupId = null;
                        this.tracksInGroup = [];
                        this.trackId = -1;
                        this.selectDefaultTrack = true;
                    };
                    _proto.onManifestParsed = function onManifestParsed(event, data) {
                        this.tracks = data.subtitleTracks;
                    };
                    _proto.onSubtitleTrackLoaded = function onSubtitleTrackLoaded(event, data) {
                        var id = data.id,
                            details = data.details;
                        var trackId = this.trackId;
                        var currentTrack = this.tracksInGroup[trackId];
                        if (!currentTrack) {
                            this.warn("Invalid subtitle track id " + id);
                            return;
                        }
                        var curDetails = currentTrack.details;
                        currentTrack.details = data.details;
                        this.log("subtitle track " + id + " loaded [" + details.startSN + "-" + details.endSN + "]");
                        if (id === this.trackId) {
                            this.retryCount = 0;
                            this.playlistLoaded(id, data, curDetails);
                        }
                    };
                    _proto.onLevelLoading = function onLevelLoading(event, data) {
                        this.switchLevel(data.level);
                    };
                    _proto.onLevelSwitching = function onLevelSwitching(event, data) {
                        this.switchLevel(data.level);
                    };
                    _proto.switchLevel = function switchLevel(levelIndex) {
                        var levelInfo = this.hls.levels[levelIndex];
                        if (!(levelInfo !== null && levelInfo !== void 0 && levelInfo.textGroupIds)) {
                            return;
                        }
                        var textGroupId = levelInfo.textGroupIds[levelInfo.urlId];
                        if (this.groupId !== textGroupId) {
                            var lastTrack = this.tracksInGroup ? this.tracksInGroup[this.trackId] : undefined;
                            var subtitleTracks = this.tracks.filter(function (track) {
                                return !textGroupId || track.groupId === textGroupId;
                            });
                            this.tracksInGroup = subtitleTracks;
                            var initialTrackId = this.findTrackId(lastTrack === null || lastTrack === void 0 ? void 0 : lastTrack.name) || this.findTrackId();
                            this.groupId = textGroupId;
                            var subtitleTracksUpdated = { subtitleTracks: subtitleTracks };
                            this.log("Updating subtitle tracks, " + subtitleTracks.length + ' track(s) found in "' + textGroupId + '" group-id');
                            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_TRACKS_UPDATED, subtitleTracksUpdated);
                            if (initialTrackId !== -1) {
                                this.setSubtitleTrack(initialTrackId, lastTrack);
                            }
                        }
                    };
                    _proto.findTrackId = function findTrackId(name) {
                        var textTracks = this.tracksInGroup;
                        for (var i = 0; i < textTracks.length; i++) {
                            var track = textTracks[i];
                            if (!this.selectDefaultTrack || track.default) {
                                if (!name || name === track.name) {
                                    return track.id;
                                }
                            }
                        }
                        return -1;
                    };
                    _proto.onError = function onError(event, data) {
                        _BasePlaylistControll.prototype.onError.call(this, event, data);
                        if (data.fatal || !data.context) {
                            return;
                        }
                        if (data.context.type === _types_loader__WEBPACK_IMPORTED_MODULE_3__["PlaylistContextType"].SUBTITLE_TRACK && data.context.id === this.trackId && data.context.groupId === this.groupId) {
                            this.retryLoadingOrFail(data);
                        }
                    };
                    _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {
                        var currentTrack = this.tracksInGroup[this.trackId];
                        if (this.shouldLoadTrack(currentTrack)) {
                            var id = currentTrack.id;
                            var groupId = currentTrack.groupId;
                            var url = currentTrack.url;
                            if (hlsUrlParameters) {
                                try {
                                    url = hlsUrlParameters.addDirectives(url);
                                } catch (error) {
                                    this.warn("Could not construct new URL with HLS Delivery Directives: " + error);
                                }
                            }
                            this.log("Loading subtitle playlist for id " + id);
                            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_TRACK_LOADING, { url: url, id: id, groupId: groupId, deliveryDirectives: hlsUrlParameters || null });
                        }
                    };
                    _proto.toggleTrackModes = function toggleTrackModes(newId) {
                        var _this2 = this;
                        var media = this.media,
                            trackId = this.trackId;
                        if (!media) {
                            return;
                        }
                        var textTracks = filterSubtitleTracks(media.textTracks);
                        var groupTracks = textTracks.filter(function (track) {
                            return track.groupId === _this2.groupId;
                        });
                        if (newId === -1) {
                            [].slice.call(textTracks).forEach(function (track) {
                                track.mode = "disabled";
                            });
                        } else {
                            var oldTrack = groupTracks[trackId];
                            if (oldTrack) {
                                oldTrack.mode = "disabled";
                            }
                        }
                        var nextTrack = groupTracks[newId];
                        if (nextTrack) {
                            nextTrack.mode = this.subtitleDisplay ? "showing" : "hidden";
                        }
                    };
                    _proto.setSubtitleTrack = function setSubtitleTrack(newId, lastTrack) {
                        var _tracks$newId;
                        var tracks = this.tracksInGroup;
                        if (!this.media) {
                            this.queuedDefaultTrack = newId;
                            return;
                        }
                        if (this.trackId !== newId) {
                            this.toggleTrackModes(newId);
                        }
                        if ((this.trackId === newId && (newId === -1 || ((_tracks$newId = tracks[newId]) !== null && _tracks$newId !== void 0 && _tracks$newId.details))) || newId < -1 || newId >= tracks.length) {
                            return;
                        }
                        this.clearTimer();
                        var track = tracks[newId];
                        this.log("Switching to subtitle track " + newId);
                        this.trackId = newId;
                        if (track) {
                            var id = track.id,
                                _track$groupId = track.groupId,
                                groupId = _track$groupId === void 0 ? "" : _track$groupId,
                                name = track.name,
                                type = track.type,
                                url = track.url;
                            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_TRACK_SWITCH, { id: id, groupId: groupId, name: name, type: type, url: url });
                            var hlsUrlParameters = this.switchParams(track.url, lastTrack === null || lastTrack === void 0 ? void 0 : lastTrack.details);
                            this.loadPlaylist(hlsUrlParameters);
                        } else {
                            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].SUBTITLE_TRACK_SWITCH, { id: newId });
                        }
                    };
                    _proto.onTextTracksChanged = function onTextTracksChanged() {
                        if (!this.useTextTrackPolling) {
                            self.clearInterval(this.subtitlePollingInterval);
                        }
                        if (!this.media || !this.hls.config.renderTextTracksNatively) {
                            return;
                        }
                        var trackId = -1;
                        var tracks = filterSubtitleTracks(this.media.textTracks);
                        for (var id = 0; id < tracks.length; id++) {
                            if (tracks[id].mode === "hidden") {
                                trackId = id;
                            } else if (tracks[id].mode === "showing") {
                                trackId = id;
                                break;
                            }
                        }
                        if (this.subtitleTrack !== trackId) {
                            this.subtitleTrack = trackId;
                        }
                    };
                    _createClass(SubtitleTrackController, [
                        {
                            key: "subtitleDisplay",
                            get: function get() {
                                return this._subtitleDisplay;
                            },
                            set: function set(value) {
                                this._subtitleDisplay = value;
                                if (this.trackId > -1) {
                                    this.toggleTrackModes(this.trackId);
                                }
                            },
                        },
                        {
                            key: "subtitleTracks",
                            get: function get() {
                                return this.tracksInGroup;
                            },
                        },
                        {
                            key: "subtitleTrack",
                            get: function get() {
                                return this.trackId;
                            },
                            set: function set(newId) {
                                this.selectDefaultTrack = false;
                                var lastTrack = this.tracksInGroup ? this.tracksInGroup[this.trackId] : undefined;
                                this.setSubtitleTrack(newId, lastTrack);
                            },
                        },
                    ]);
                    return SubtitleTrackController;
                })(_base_playlist_controller__WEBPACK_IMPORTED_MODULE_2__["default"]);
                function filterSubtitleTracks(textTrackList) {
                    var tracks = [];
                    for (var i = 0; i < textTrackList.length; i++) {
                        var track = textTrackList[i];
                        if (track.kind === "subtitles" && track.label) {
                            tracks.push(textTrackList[i]);
                        }
                    }
                    return tracks;
                }
                __webpack_exports__["default"] = SubtitleTrackController;
            },
            "./src/controller/timeline-controller.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "TimelineController", function () {
                    return TimelineController;
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/polyfills/number.ts");
                var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/events.ts");
                var _utils_cea_608_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/cea-608-parser.ts");
                var _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/utils/output-filter.ts");
                var _utils_webvtt_parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/utils/webvtt-parser.ts");
                var _utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/utils/texttrack-utils.ts");
                var _utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/utils/imsc1-ttml-parser.ts");
                var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/utils/mp4-tools.ts");
                var _types_loader__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./src/types/loader.ts");
                var _utils_logger__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./src/utils/logger.ts");
                var TimelineController = (function () {
                    function TimelineController(hls) {
                        this.hls = void 0;
                        this.media = null;
                        this.config = void 0;
                        this.enabled = true;
                        this.Cues = void 0;
                        this.textTracks = [];
                        this.tracks = [];
                        this.initPTS = [];
                        this.timescale = [];
                        this.unparsedVttFrags = [];
                        this.captionsTracks = {};
                        this.nonNativeCaptionsTracks = {};
                        this.cea608Parser1 = void 0;
                        this.cea608Parser2 = void 0;
                        this.lastSn = -1;
                        this.lastPartIndex = -1;
                        this.prevCC = -1;
                        this.vttCCs = newVTTCCs();
                        this.captionsProperties = void 0;
                        this.hls = hls;
                        this.config = hls.config;
                        this.Cues = hls.config.cueHandler;
                        this.captionsProperties = {
                            textTrack1: { label: this.config.captionsTextTrack1Label, languageCode: this.config.captionsTextTrack1LanguageCode },
                            textTrack2: { label: this.config.captionsTextTrack2Label, languageCode: this.config.captionsTextTrack2LanguageCode },
                            textTrack3: { label: this.config.captionsTextTrack3Label, languageCode: this.config.captionsTextTrack3LanguageCode },
                            textTrack4: { label: this.config.captionsTextTrack4Label, languageCode: this.config.captionsTextTrack4LanguageCode },
                        };
                        if (this.config.enableCEA708Captions) {
                            var channel1 = new _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__["default"](this, "textTrack1");
                            var channel2 = new _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__["default"](this, "textTrack2");
                            var channel3 = new _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__["default"](this, "textTrack3");
                            var channel4 = new _utils_output_filter__WEBPACK_IMPORTED_MODULE_3__["default"](this, "textTrack4");
                            this.cea608Parser1 = new _utils_cea_608_parser__WEBPACK_IMPORTED_MODULE_2__["default"](1, channel1, channel2);
                            this.cea608Parser2 = new _utils_cea_608_parser__WEBPACK_IMPORTED_MODULE_2__["default"](3, channel3, channel4);
                        }
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_ATTACHING, this.onMediaAttaching, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_LOADED, this.onManifestLoaded, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_LOADING, this.onFragLoading, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_LOADED, this.onFragLoaded, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_DECRYPTED, this.onFragDecrypted, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].INIT_PTS_FOUND, this.onInitPtsFound, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_FLUSHING, this.onBufferFlushing, this);
                    }
                    var _proto = TimelineController.prototype;
                    _proto.destroy = function destroy() {
                        var hls = this.hls;
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_ATTACHING, this.onMediaAttaching, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MEDIA_DETACHING, this.onMediaDetaching, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_LOADED, this.onManifestLoaded, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_LOADING, this.onFragLoading, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_LOADED, this.onFragLoaded, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_DECRYPTED, this.onFragDecrypted, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].INIT_PTS_FOUND, this.onInitPtsFound, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].BUFFER_FLUSHING, this.onBufferFlushing, this);
                        this.hls = this.config = this.cea608Parser1 = this.cea608Parser2 = null;
                    };
                    _proto.addCues = function addCues(trackName, startTime, endTime, screen, cueRanges) {
                        var merged = false;
                        for (var i = cueRanges.length; i--; ) {
                            var cueRange = cueRanges[i];
                            var overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);
                            if (overlap >= 0) {
                                cueRange[0] = Math.min(cueRange[0], startTime);
                                cueRange[1] = Math.max(cueRange[1], endTime);
                                merged = true;
                                if (overlap / (endTime - startTime) > 0.5) {
                                    return;
                                }
                            }
                        }
                        if (!merged) {
                            cueRanges.push([startTime, endTime]);
                        }
                        if (this.config.renderTextTracksNatively) {
                            var track = this.captionsTracks[trackName];
                            this.Cues.newCue(track, startTime, endTime, screen);
                        } else {
                            var cues = this.Cues.newCue(null, startTime, endTime, screen);
                            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].CUES_PARSED, { type: "captions", cues: cues, track: trackName });
                        }
                    };
                    _proto.onInitPtsFound = function onInitPtsFound(event, _ref) {
                        var _this = this;
                        var frag = _ref.frag,
                            id = _ref.id,
                            initPTS = _ref.initPTS,
                            timescale = _ref.timescale;
                        var unparsedVttFrags = this.unparsedVttFrags;
                        if (id === "main") {
                            this.initPTS[frag.cc] = initPTS;
                            this.timescale[frag.cc] = timescale;
                        }
                        if (unparsedVttFrags.length) {
                            this.unparsedVttFrags = [];
                            unparsedVttFrags.forEach(function (frag) {
                                _this.onFragLoaded(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_LOADED, frag);
                            });
                        }
                    };
                    _proto.getExistingTrack = function getExistingTrack(trackName) {
                        var media = this.media;
                        if (media) {
                            for (var i = 0; i < media.textTracks.length; i++) {
                                var textTrack = media.textTracks[i];
                                if (textTrack[trackName]) {
                                    return textTrack;
                                }
                            }
                        }
                        return null;
                    };
                    _proto.createCaptionsTrack = function createCaptionsTrack(trackName) {
                        if (this.config.renderTextTracksNatively) {
                            this.createNativeTrack(trackName);
                        } else {
                            this.createNonNativeTrack(trackName);
                        }
                    };
                    _proto.createNativeTrack = function createNativeTrack(trackName) {
                        if (this.captionsTracks[trackName]) {
                            return;
                        }
                        var captionsProperties = this.captionsProperties,
                            captionsTracks = this.captionsTracks,
                            media = this.media;
                        var _captionsProperties$t = captionsProperties[trackName],
                            label = _captionsProperties$t.label,
                            languageCode = _captionsProperties$t.languageCode;
                        var existingTrack = this.getExistingTrack(trackName);
                        if (!existingTrack) {
                            var textTrack = this.createTextTrack("captions", label, languageCode);
                            if (textTrack) {
                                textTrack[trackName] = true;
                                captionsTracks[trackName] = textTrack;
                            }
                        } else {
                            captionsTracks[trackName] = existingTrack;
                            Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__["clearCurrentCues"])(captionsTracks[trackName]);
                            Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__["sendAddTrackEvent"])(captionsTracks[trackName], media);
                        }
                    };
                    _proto.createNonNativeTrack = function createNonNativeTrack(trackName) {
                        if (this.nonNativeCaptionsTracks[trackName]) {
                            return;
                        }
                        var trackProperties = this.captionsProperties[trackName];
                        if (!trackProperties) {
                            return;
                        }
                        var label = trackProperties.label;
                        var track = { _id: trackName, label: label, kind: "captions", default: trackProperties.media ? !!trackProperties.media.default : false, closedCaptions: trackProperties.media };
                        this.nonNativeCaptionsTracks[trackName] = track;
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].NON_NATIVE_TEXT_TRACKS_FOUND, { tracks: [track] });
                    };
                    _proto.createTextTrack = function createTextTrack(kind, label, lang) {
                        var media = this.media;
                        if (!media) {
                            return;
                        }
                        return media.addTextTrack(kind, label, lang);
                    };
                    _proto.onMediaAttaching = function onMediaAttaching(event, data) {
                        this.media = data.media;
                        this._cleanTracks();
                    };
                    _proto.onMediaDetaching = function onMediaDetaching() {
                        var captionsTracks = this.captionsTracks;
                        Object.keys(captionsTracks).forEach(function (trackName) {
                            Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__["clearCurrentCues"])(captionsTracks[trackName]);
                            delete captionsTracks[trackName];
                        });
                        this.nonNativeCaptionsTracks = {};
                    };
                    _proto.onManifestLoading = function onManifestLoading() {
                        this.lastSn = -1;
                        this.lastPartIndex = -1;
                        this.prevCC = -1;
                        this.vttCCs = newVTTCCs();
                        this._cleanTracks();
                        this.tracks = [];
                        this.captionsTracks = {};
                        this.nonNativeCaptionsTracks = {};
                        this.textTracks = [];
                        this.unparsedVttFrags = this.unparsedVttFrags || [];
                        this.initPTS = [];
                        this.timescale = [];
                        if (this.cea608Parser1 && this.cea608Parser2) {
                            this.cea608Parser1.reset();
                            this.cea608Parser2.reset();
                        }
                    };
                    _proto._cleanTracks = function _cleanTracks() {
                        var media = this.media;
                        if (!media) {
                            return;
                        }
                        var textTracks = media.textTracks;
                        if (textTracks) {
                            for (var i = 0; i < textTracks.length; i++) {
                                Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__["clearCurrentCues"])(textTracks[i]);
                            }
                        }
                    };
                    _proto.onSubtitleTracksUpdated = function onSubtitleTracksUpdated(event, data) {
                        var _this2 = this;
                        this.textTracks = [];
                        var tracks = data.subtitleTracks || [];
                        var hasIMSC1 = tracks.some(function (track) {
                            return track.textCodec === _utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__["IMSC1_CODEC"];
                        });
                        if (this.config.enableWebVTT || (hasIMSC1 && this.config.enableIMSC1)) {
                            var sameTracks = this.tracks && tracks && this.tracks.length === tracks.length;
                            this.tracks = tracks || [];
                            if (this.config.renderTextTracksNatively) {
                                var inUseTracks = this.media ? this.media.textTracks : [];
                                this.tracks.forEach(function (track, index) {
                                    var textTrack;
                                    if (index < inUseTracks.length) {
                                        var inUseTrack = null;
                                        for (var i = 0; i < inUseTracks.length; i++) {
                                            if (canReuseVttTextTrack(inUseTracks[i], track)) {
                                                inUseTrack = inUseTracks[i];
                                                break;
                                            }
                                        }
                                        if (inUseTrack) {
                                            textTrack = inUseTrack;
                                        }
                                    }
                                    if (textTrack) {
                                        Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__["clearCurrentCues"])(textTrack);
                                    } else {
                                        var textTrackKind = _this2._captionsOrSubtitlesFromCharacteristics(track);
                                        textTrack = _this2.createTextTrack(textTrackKind, track.name, track.lang);
                                        if (textTrack) {
                                            textTrack.mode = "disabled";
                                        }
                                    }
                                    if (textTrack) {
                                        textTrack.groupId = track.groupId;
                                        _this2.textTracks.push(textTrack);
                                    }
                                });
                            } else if (!sameTracks && this.tracks && this.tracks.length) {
                                var tracksList = this.tracks.map(function (track) {
                                    return { label: track.name, kind: track.type.toLowerCase(), default: track.default, subtitleTrack: track };
                                });
                                this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].NON_NATIVE_TEXT_TRACKS_FOUND, { tracks: tracksList });
                            }
                        }
                    };
                    _proto._captionsOrSubtitlesFromCharacteristics = function _captionsOrSubtitlesFromCharacteristics(track) {
                        var _track$attrs;
                        if ((_track$attrs = track.attrs) !== null && _track$attrs !== void 0 && _track$attrs.CHARACTERISTICS) {
                            var transcribesSpokenDialog = /transcribes-spoken-dialog/gi.test(track.attrs.CHARACTERISTICS);
                            var describesMusicAndSound = /describes-music-and-sound/gi.test(track.attrs.CHARACTERISTICS);
                            if (transcribesSpokenDialog && describesMusicAndSound) {
                                return "captions";
                            }
                        }
                        return "subtitles";
                    };
                    _proto.onManifestLoaded = function onManifestLoaded(event, data) {
                        var _this3 = this;
                        if (this.config.enableCEA708Captions && data.captions) {
                            data.captions.forEach(function (captionsTrack) {
                                var instreamIdMatch = /(?:CC|SERVICE)([1-4])/.exec(captionsTrack.instreamId);
                                if (!instreamIdMatch) {
                                    return;
                                }
                                var trackName = "textTrack" + instreamIdMatch[1];
                                var trackProperties = _this3.captionsProperties[trackName];
                                if (!trackProperties) {
                                    return;
                                }
                                trackProperties.label = captionsTrack.name;
                                if (captionsTrack.lang) {
                                    trackProperties.languageCode = captionsTrack.lang;
                                }
                                trackProperties.media = captionsTrack;
                            });
                        }
                    };
                    _proto.closedCaptionsForLevel = function closedCaptionsForLevel(frag) {
                        var level = this.hls.levels[frag.level];
                        return level === null || level === void 0 ? void 0 : level.attrs["CLOSED-CAPTIONS"];
                    };
                    _proto.onFragLoading = function onFragLoading(event, data) {
                        var cea608Parser1 = this.cea608Parser1,
                            cea608Parser2 = this.cea608Parser2,
                            lastSn = this.lastSn,
                            lastPartIndex = this.lastPartIndex;
                        if (!this.enabled || !(cea608Parser1 && cea608Parser2)) {
                            return;
                        }
                        if (data.frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_8__["PlaylistLevelType"].MAIN) {
                            var _data$part$index, _data$part;
                            var sn = data.frag.sn;
                            var partIndex = (_data$part$index = data === null || data === void 0 ? void 0 : (_data$part = data.part) === null || _data$part === void 0 ? void 0 : _data$part.index) != null ? _data$part$index : -1;
                            if (!(sn === lastSn + 1 || (sn === lastSn && partIndex === lastPartIndex + 1))) {
                                cea608Parser1.reset();
                                cea608Parser2.reset();
                            }
                            this.lastSn = sn;
                            this.lastPartIndex = partIndex;
                        }
                    };
                    _proto.onFragLoaded = function onFragLoaded(event, data) {
                        var frag = data.frag,
                            payload = data.payload;
                        var initPTS = this.initPTS,
                            unparsedVttFrags = this.unparsedVttFrags;
                        if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_8__["PlaylistLevelType"].SUBTITLE) {
                            if (payload.byteLength) {
                                if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(initPTS[frag.cc])) {
                                    unparsedVttFrags.push(data);
                                    if (initPTS.length) {
                                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag, error: new Error("Missing initial subtitle PTS") });
                                    }
                                    return;
                                }
                                var decryptData = frag.decryptdata;
                                var decrypted = "stats" in data;
                                if (decryptData == null || decryptData.key == null || decryptData.method !== "AES-128" || decrypted) {
                                    var trackPlaylistMedia = this.tracks[frag.level];
                                    var vttCCs = this.vttCCs;
                                    if (!vttCCs[frag.cc]) {
                                        vttCCs[frag.cc] = { start: frag.start, prevCC: this.prevCC, new: true };
                                        this.prevCC = frag.cc;
                                    }
                                    if (trackPlaylistMedia && trackPlaylistMedia.textCodec === _utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__["IMSC1_CODEC"]) {
                                        this._parseIMSC1(frag, payload);
                                    } else {
                                        this._parseVTTs(frag, payload, vttCCs);
                                    }
                                }
                            } else {
                                this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag, error: new Error("Empty subtitle payload") });
                            }
                        }
                    };
                    _proto._parseIMSC1 = function _parseIMSC1(frag, payload) {
                        var _this4 = this;
                        var hls = this.hls;
                        Object(_utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__["parseIMSC1"])(
                            payload,
                            this.initPTS[frag.cc],
                            this.timescale[frag.cc],
                            function (cues) {
                                _this4._appendCues(cues, frag.level);
                                hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].SUBTITLE_FRAG_PROCESSED, { success: true, frag: frag });
                            },
                            function (error) {
                                _utils_logger__WEBPACK_IMPORTED_MODULE_9__["logger"].log("Failed to parse IMSC1: " + error);
                                hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag, error: error });
                            }
                        );
                    };
                    _proto._parseVTTs = function _parseVTTs(frag, payload, vttCCs) {
                        var _frag$initSegment,
                            _this5 = this;
                        var hls = this.hls;
                        var payloadWebVTT =
                            (_frag$initSegment = frag.initSegment) !== null && _frag$initSegment !== void 0 && _frag$initSegment.data
                                ? Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_7__["appendUint8Array"])(frag.initSegment.data, new Uint8Array(payload))
                                : payload;
                        Object(_utils_webvtt_parser__WEBPACK_IMPORTED_MODULE_4__["parseWebVTT"])(
                            payloadWebVTT,
                            this.initPTS[frag.cc],
                            this.timescale[frag.cc],
                            vttCCs,
                            frag.cc,
                            frag.start,
                            function (cues) {
                                _this5._appendCues(cues, frag.level);
                                hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].SUBTITLE_FRAG_PROCESSED, { success: true, frag: frag });
                            },
                            function (error) {
                                _this5._fallbackToIMSC1(frag, payload);
                                _utils_logger__WEBPACK_IMPORTED_MODULE_9__["logger"].log("Failed to parse VTT cue: " + error);
                                hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag, error: error });
                            }
                        );
                    };
                    _proto._fallbackToIMSC1 = function _fallbackToIMSC1(frag, payload) {
                        var _this6 = this;
                        var trackPlaylistMedia = this.tracks[frag.level];
                        if (!trackPlaylistMedia.textCodec) {
                            Object(_utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__["parseIMSC1"])(
                                payload,
                                this.initPTS[frag.cc],
                                this.timescale[frag.cc],
                                function () {
                                    trackPlaylistMedia.textCodec = _utils_imsc1_ttml_parser__WEBPACK_IMPORTED_MODULE_6__["IMSC1_CODEC"];
                                    _this6._parseIMSC1(frag, payload);
                                },
                                function () {
                                    trackPlaylistMedia.textCodec = "wvtt";
                                }
                            );
                        }
                    };
                    _proto._appendCues = function _appendCues(cues, fragLevel) {
                        var hls = this.hls;
                        if (this.config.renderTextTracksNatively) {
                            var textTrack = this.textTracks[fragLevel];
                            if (!textTrack || textTrack.mode === "disabled") {
                                return;
                            }
                            cues.forEach(function (cue) {
                                return Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__["addCueToTrack"])(textTrack, cue);
                            });
                        } else {
                            var currentTrack = this.tracks[fragLevel];
                            if (!currentTrack) {
                                return;
                            }
                            var track = currentTrack.default ? "default" : "subtitles" + fragLevel;
                            hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].CUES_PARSED, { type: "subtitles", cues: cues, track: track });
                        }
                    };
                    _proto.onFragDecrypted = function onFragDecrypted(event, data) {
                        var frag = data.frag;
                        if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_8__["PlaylistLevelType"].SUBTITLE) {
                            if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(this.initPTS[frag.cc])) {
                                this.unparsedVttFrags.push(data);
                                return;
                            }
                            this.onFragLoaded(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_LOADED, data);
                        }
                    };
                    _proto.onSubtitleTracksCleared = function onSubtitleTracksCleared() {
                        this.tracks = [];
                        this.captionsTracks = {};
                    };
                    _proto.onFragParsingUserdata = function onFragParsingUserdata(event, data) {
                        var cea608Parser1 = this.cea608Parser1,
                            cea608Parser2 = this.cea608Parser2;
                        if (!this.enabled || !(cea608Parser1 && cea608Parser2)) {
                            return;
                        }
                        var frag = data.frag,
                            samples = data.samples;
                        if (frag.type === _types_loader__WEBPACK_IMPORTED_MODULE_8__["PlaylistLevelType"].MAIN && this.closedCaptionsForLevel(frag) === "NONE") {
                            return;
                        }
                        for (var i = 0; i < samples.length; i++) {
                            var ccBytes = samples[i].bytes;
                            if (ccBytes) {
                                var ccdatas = this.extractCea608Data(ccBytes);
                                cea608Parser1.addData(samples[i].pts, ccdatas[0]);
                                cea608Parser2.addData(samples[i].pts, ccdatas[1]);
                            }
                        }
                    };
                    _proto.onBufferFlushing = function onBufferFlushing(event, _ref2) {
                        var startOffset = _ref2.startOffset,
                            endOffset = _ref2.endOffset,
                            endOffsetSubtitles = _ref2.endOffsetSubtitles,
                            type = _ref2.type;
                        var media = this.media;
                        if (!media || media.currentTime < endOffset) {
                            return;
                        }
                        if (!type || type === "video") {
                            var captionsTracks = this.captionsTracks;
                            Object.keys(captionsTracks).forEach(function (trackName) {
                                return Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__["removeCuesInRange"])(captionsTracks[trackName], startOffset, endOffset);
                            });
                        }
                        if (this.config.renderTextTracksNatively) {
                            if (startOffset === 0 && endOffsetSubtitles !== undefined) {
                                var textTracks = this.textTracks;
                                Object.keys(textTracks).forEach(function (trackName) {
                                    return Object(_utils_texttrack_utils__WEBPACK_IMPORTED_MODULE_5__["removeCuesInRange"])(textTracks[trackName], startOffset, endOffsetSubtitles);
                                });
                            }
                        }
                    };
                    _proto.extractCea608Data = function extractCea608Data(byteArray) {
                        var actualCCBytes = [[], []];
                        var count = byteArray[0] & 31;
                        var position = 2;
                        for (var j = 0; j < count; j++) {
                            var tmpByte = byteArray[position++];
                            var ccbyte1 = 127 & byteArray[position++];
                            var ccbyte2 = 127 & byteArray[position++];
                            if (ccbyte1 === 0 && ccbyte2 === 0) {
                                continue;
                            }
                            var ccValid = (4 & tmpByte) !== 0;
                            if (ccValid) {
                                var ccType = 3 & tmpByte;
                                if (0 === ccType || 1 === ccType) {
                                    actualCCBytes[ccType].push(ccbyte1);
                                    actualCCBytes[ccType].push(ccbyte2);
                                }
                            }
                        }
                        return actualCCBytes;
                    };
                    return TimelineController;
                })();
                function canReuseVttTextTrack(inUseTrack, manifestTrack) {
                    return inUseTrack && inUseTrack.label === manifestTrack.name && !(inUseTrack.textTrack1 || inUseTrack.textTrack2);
                }
                function intersection(x1, x2, y1, y2) {
                    return Math.min(x2, y2) - Math.max(x1, y1);
                }
                function newVTTCCs() {
                    return { ccOffset: 0, presentationOffset: 0, 0: { start: 0, prevCC: -1, new: true } };
                }
            },
            "./src/crypt/aes-crypto.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "default", function () {
                    return AESCrypto;
                });
                var AESCrypto = (function () {
                    function AESCrypto(subtle, iv) {
                        this.subtle = void 0;
                        this.aesIV = void 0;
                        this.subtle = subtle;
                        this.aesIV = iv;
                    }
                    var _proto = AESCrypto.prototype;
                    _proto.decrypt = function decrypt(data, key) {
                        return this.subtle.decrypt({ name: "AES-CBC", iv: this.aesIV }, key, data);
                    };
                    return AESCrypto;
                })();
            },
            "./src/crypt/aes-decryptor.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "removePadding", function () {
                    return removePadding;
                });
                __webpack_require__.d(__webpack_exports__, "default", function () {
                    return AESDecryptor;
                });
                var _utils_typed_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/typed-array.ts");
                function removePadding(array) {
                    var outputBytes = array.byteLength;
                    var paddingBytes = outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);
                    if (paddingBytes) {
                        return Object(_utils_typed_array__WEBPACK_IMPORTED_MODULE_0__["sliceUint8"])(array, 0, outputBytes - paddingBytes);
                    }
                    return array;
                }
                var AESDecryptor = (function () {
                    function AESDecryptor() {
                        this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
                        this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
                        this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
                        this.sBox = new Uint32Array(256);
                        this.invSBox = new Uint32Array(256);
                        this.key = new Uint32Array(0);
                        this.ksRows = 0;
                        this.keySize = 0;
                        this.keySchedule = void 0;
                        this.invKeySchedule = void 0;
                        this.initTable();
                    }
                    var _proto = AESDecryptor.prototype;
                    _proto.uint8ArrayToUint32Array_ = function uint8ArrayToUint32Array_(arrayBuffer) {
                        var view = new DataView(arrayBuffer);
                        var newArray = new Uint32Array(4);
                        for (var i = 0; i < 4; i++) {
                            newArray[i] = view.getUint32(i * 4);
                        }
                        return newArray;
                    };
                    _proto.initTable = function initTable() {
                        var sBox = this.sBox;
                        var invSBox = this.invSBox;
                        var subMix = this.subMix;
                        var subMix0 = subMix[0];
                        var subMix1 = subMix[1];
                        var subMix2 = subMix[2];
                        var subMix3 = subMix[3];
                        var invSubMix = this.invSubMix;
                        var invSubMix0 = invSubMix[0];
                        var invSubMix1 = invSubMix[1];
                        var invSubMix2 = invSubMix[2];
                        var invSubMix3 = invSubMix[3];
                        var d = new Uint32Array(256);
                        var x = 0;
                        var xi = 0;
                        var i = 0;
                        for (i = 0; i < 256; i++) {
                            if (i < 128) {
                                d[i] = i << 1;
                            } else {
                                d[i] = (i << 1) ^ 283;
                            }
                        }
                        for (i = 0; i < 256; i++) {
                            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
                            sx = (sx >>> 8) ^ (sx & 255) ^ 99;
                            sBox[x] = sx;
                            invSBox[sx] = x;
                            var x2 = d[x];
                            var x4 = d[x2];
                            var x8 = d[x4];
                            var t = (d[sx] * 257) ^ (sx * 16843008);
                            subMix0[x] = (t << 24) | (t >>> 8);
                            subMix1[x] = (t << 16) | (t >>> 16);
                            subMix2[x] = (t << 8) | (t >>> 24);
                            subMix3[x] = t;
                            t = (x8 * 16843009) ^ (x4 * 65537) ^ (x2 * 257) ^ (x * 16843008);
                            invSubMix0[sx] = (t << 24) | (t >>> 8);
                            invSubMix1[sx] = (t << 16) | (t >>> 16);
                            invSubMix2[sx] = (t << 8) | (t >>> 24);
                            invSubMix3[sx] = t;
                            if (!x) {
                                x = xi = 1;
                            } else {
                                x = x2 ^ d[d[d[x8 ^ x2]]];
                                xi ^= d[d[xi]];
                            }
                        }
                    };
                    _proto.expandKey = function expandKey(keyBuffer) {
                        var key = this.uint8ArrayToUint32Array_(keyBuffer);
                        var sameKey = true;
                        var offset = 0;
                        while (offset < key.length && sameKey) {
                            sameKey = key[offset] === this.key[offset];
                            offset++;
                        }
                        if (sameKey) {
                            return;
                        }
                        this.key = key;
                        var keySize = (this.keySize = key.length);
                        if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
                            throw new Error("Invalid aes key size=" + keySize);
                        }
                        var ksRows = (this.ksRows = (keySize + 6 + 1) * 4);
                        var ksRow;
                        var invKsRow;
                        var keySchedule = (this.keySchedule = new Uint32Array(ksRows));
                        var invKeySchedule = (this.invKeySchedule = new Uint32Array(ksRows));
                        var sbox = this.sBox;
                        var rcon = this.rcon;
                        var invSubMix = this.invSubMix;
                        var invSubMix0 = invSubMix[0];
                        var invSubMix1 = invSubMix[1];
                        var invSubMix2 = invSubMix[2];
                        var invSubMix3 = invSubMix[3];
                        var prev;
                        var t;
                        for (ksRow = 0; ksRow < ksRows; ksRow++) {
                            if (ksRow < keySize) {
                                prev = keySchedule[ksRow] = key[ksRow];
                                continue;
                            }
                            t = prev;
                            if (ksRow % keySize === 0) {
                                t = (t << 8) | (t >>> 24);
                                t = (sbox[t >>> 24] << 24) | (sbox[(t >>> 16) & 255] << 16) | (sbox[(t >>> 8) & 255] << 8) | sbox[t & 255];
                                t ^= rcon[(ksRow / keySize) | 0] << 24;
                            } else if (keySize > 6 && ksRow % keySize === 4) {
                                t = (sbox[t >>> 24] << 24) | (sbox[(t >>> 16) & 255] << 16) | (sbox[(t >>> 8) & 255] << 8) | sbox[t & 255];
                            }
                            keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
                        }
                        for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                            ksRow = ksRows - invKsRow;
                            if (invKsRow & 3) {
                                t = keySchedule[ksRow];
                            } else {
                                t = keySchedule[ksRow - 4];
                            }
                            if (invKsRow < 4 || ksRow <= 4) {
                                invKeySchedule[invKsRow] = t;
                            } else {
                                invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[(t >>> 16) & 255]] ^ invSubMix2[sbox[(t >>> 8) & 255]] ^ invSubMix3[sbox[t & 255]];
                            }
                            invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
                        }
                    };
                    _proto.networkToHostOrderSwap = function networkToHostOrderSwap(word) {
                        return (word << 24) | ((word & 65280) << 8) | ((word & 16711680) >> 8) | (word >>> 24);
                    };
                    _proto.decrypt = function decrypt(inputArrayBuffer, offset, aesIV) {
                        var nRounds = this.keySize + 6;
                        var invKeySchedule = this.invKeySchedule;
                        var invSBOX = this.invSBox;
                        var invSubMix = this.invSubMix;
                        var invSubMix0 = invSubMix[0];
                        var invSubMix1 = invSubMix[1];
                        var invSubMix2 = invSubMix[2];
                        var invSubMix3 = invSubMix[3];
                        var initVector = this.uint8ArrayToUint32Array_(aesIV);
                        var initVector0 = initVector[0];
                        var initVector1 = initVector[1];
                        var initVector2 = initVector[2];
                        var initVector3 = initVector[3];
                        var inputInt32 = new Int32Array(inputArrayBuffer);
                        var outputInt32 = new Int32Array(inputInt32.length);
                        var t0, t1, t2, t3;
                        var s0, s1, s2, s3;
                        var inputWords0, inputWords1, inputWords2, inputWords3;
                        var ksRow, i;
                        var swapWord = this.networkToHostOrderSwap;
                        while (offset < inputInt32.length) {
                            inputWords0 = swapWord(inputInt32[offset]);
                            inputWords1 = swapWord(inputInt32[offset + 1]);
                            inputWords2 = swapWord(inputInt32[offset + 2]);
                            inputWords3 = swapWord(inputInt32[offset + 3]);
                            s0 = inputWords0 ^ invKeySchedule[0];
                            s1 = inputWords3 ^ invKeySchedule[1];
                            s2 = inputWords2 ^ invKeySchedule[2];
                            s3 = inputWords1 ^ invKeySchedule[3];
                            ksRow = 4;
                            for (i = 1; i < nRounds; i++) {
                                t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[(s1 >> 16) & 255] ^ invSubMix2[(s2 >> 8) & 255] ^ invSubMix3[s3 & 255] ^ invKeySchedule[ksRow];
                                t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[(s2 >> 16) & 255] ^ invSubMix2[(s3 >> 8) & 255] ^ invSubMix3[s0 & 255] ^ invKeySchedule[ksRow + 1];
                                t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[(s3 >> 16) & 255] ^ invSubMix2[(s0 >> 8) & 255] ^ invSubMix3[s1 & 255] ^ invKeySchedule[ksRow + 2];
                                t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[(s0 >> 16) & 255] ^ invSubMix2[(s1 >> 8) & 255] ^ invSubMix3[s2 & 255] ^ invKeySchedule[ksRow + 3];
                                s0 = t0;
                                s1 = t1;
                                s2 = t2;
                                s3 = t3;
                                ksRow = ksRow + 4;
                            }
                            t0 = (invSBOX[s0 >>> 24] << 24) ^ (invSBOX[(s1 >> 16) & 255] << 16) ^ (invSBOX[(s2 >> 8) & 255] << 8) ^ invSBOX[s3 & 255] ^ invKeySchedule[ksRow];
                            t1 = (invSBOX[s1 >>> 24] << 24) ^ (invSBOX[(s2 >> 16) & 255] << 16) ^ (invSBOX[(s3 >> 8) & 255] << 8) ^ invSBOX[s0 & 255] ^ invKeySchedule[ksRow + 1];
                            t2 = (invSBOX[s2 >>> 24] << 24) ^ (invSBOX[(s3 >> 16) & 255] << 16) ^ (invSBOX[(s0 >> 8) & 255] << 8) ^ invSBOX[s1 & 255] ^ invKeySchedule[ksRow + 2];
                            t3 = (invSBOX[s3 >>> 24] << 24) ^ (invSBOX[(s0 >> 16) & 255] << 16) ^ (invSBOX[(s1 >> 8) & 255] << 8) ^ invSBOX[s2 & 255] ^ invKeySchedule[ksRow + 3];
                            outputInt32[offset] = swapWord(t0 ^ initVector0);
                            outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
                            outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
                            outputInt32[offset + 3] = swapWord(t1 ^ initVector3);
                            initVector0 = inputWords0;
                            initVector1 = inputWords1;
                            initVector2 = inputWords2;
                            initVector3 = inputWords3;
                            offset = offset + 4;
                        }
                        return outputInt32.buffer;
                    };
                    return AESDecryptor;
                })();
            },
            "./src/crypt/decrypter.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "default", function () {
                    return Decrypter;
                });
                var _aes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/crypt/aes-crypto.ts");
                var _fast_aes_key__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/crypt/fast-aes-key.ts");
                var _aes_decryptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/crypt/aes-decryptor.ts");
                var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/utils/logger.ts");
                var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/utils/mp4-tools.ts");
                var _utils_typed_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/utils/typed-array.ts");
                var CHUNK_SIZE = 16;
                var Decrypter = (function () {
                    function Decrypter(observer, config, _temp) {
                        var _ref = _temp === void 0 ? {} : _temp,
                            _ref$removePKCS7Paddi = _ref.removePKCS7Padding,
                            removePKCS7Padding = _ref$removePKCS7Paddi === void 0 ? true : _ref$removePKCS7Paddi;
                        this.logEnabled = true;
                        this.observer = void 0;
                        this.config = void 0;
                        this.removePKCS7Padding = void 0;
                        this.subtle = null;
                        this.softwareDecrypter = null;
                        this.key = null;
                        this.fastAesKey = null;
                        this.remainderData = null;
                        this.currentIV = null;
                        this.currentResult = null;
                        this.observer = observer;
                        this.config = config;
                        this.removePKCS7Padding = removePKCS7Padding;
                        if (removePKCS7Padding) {
                            try {
                                var browserCrypto = self.crypto;
                                if (browserCrypto) {
                                    this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
                                }
                            } catch (e) {}
                        }
                        if (this.subtle === null) {
                            this.config.enableSoftwareAES = true;
                        }
                    }
                    var _proto = Decrypter.prototype;
                    _proto.destroy = function destroy() {
                        this.observer = null;
                    };
                    _proto.isSync = function isSync() {
                        return this.config.enableSoftwareAES;
                    };
                    _proto.flush = function flush() {
                        var currentResult = this.currentResult;
                        if (!currentResult) {
                            this.reset();
                            return;
                        }
                        var data = new Uint8Array(currentResult);
                        this.reset();
                        if (this.removePKCS7Padding) {
                            return Object(_aes_decryptor__WEBPACK_IMPORTED_MODULE_2__["removePadding"])(data);
                        }
                        return data;
                    };
                    _proto.reset = function reset() {
                        this.currentResult = null;
                        this.currentIV = null;
                        this.remainderData = null;
                        if (this.softwareDecrypter) {
                            this.softwareDecrypter = null;
                        }
                    };
                    _proto.decrypt = function decrypt(data, key, iv, callback) {
                        if (this.config.enableSoftwareAES) {
                            this.softwareDecrypt(new Uint8Array(data), key, iv);
                            var decryptResult = this.flush();
                            if (decryptResult) {
                                callback(decryptResult.buffer);
                            }
                        } else {
                            this.webCryptoDecrypt(new Uint8Array(data), key, iv).then(callback);
                        }
                    };
                    _proto.softwareDecrypt = function softwareDecrypt(data, key, iv) {
                        var currentIV = this.currentIV,
                            currentResult = this.currentResult,
                            remainderData = this.remainderData;
                        this.logOnce("JS AES decrypt");
                        if (remainderData) {
                            data = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__["appendUint8Array"])(remainderData, data);
                            this.remainderData = null;
                        }
                        var currentChunk = this.getValidChunk(data);
                        if (!currentChunk.length) {
                            return null;
                        }
                        if (currentIV) {
                            iv = currentIV;
                        }
                        var softwareDecrypter = this.softwareDecrypter;
                        if (!softwareDecrypter) {
                            softwareDecrypter = this.softwareDecrypter = new _aes_decryptor__WEBPACK_IMPORTED_MODULE_2__["default"]();
                        }
                        softwareDecrypter.expandKey(key);
                        var result = currentResult;
                        this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);
                        this.currentIV = Object(_utils_typed_array__WEBPACK_IMPORTED_MODULE_5__["sliceUint8"])(currentChunk, -16).buffer;
                        if (!result) {
                            return null;
                        }
                        return result;
                    };
                    _proto.webCryptoDecrypt = function webCryptoDecrypt(data, key, iv) {
                        var _this = this;
                        var subtle = this.subtle;
                        if (this.key !== key || !this.fastAesKey) {
                            this.key = key;
                            this.fastAesKey = new _fast_aes_key__WEBPACK_IMPORTED_MODULE_1__["default"](subtle, key);
                        }
                        return this.fastAesKey
                            .expandKey()
                            .then(function (aesKey) {
                                if (!subtle) {
                                    return Promise.reject(new Error("web crypto not initialized"));
                                }
                                var crypto = new _aes_crypto__WEBPACK_IMPORTED_MODULE_0__["default"](subtle, iv);
                                return crypto.decrypt(data.buffer, aesKey);
                            })
                            .catch(function (err) {
                                return _this.onWebCryptoError(err, data, key, iv);
                            });
                    };
                    _proto.onWebCryptoError = function onWebCryptoError(err, data, key, iv) {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].warn("[decrypter.ts]: WebCrypto Error, disable WebCrypto API:", err);
                        this.config.enableSoftwareAES = true;
                        this.logEnabled = true;
                        return this.softwareDecrypt(data, key, iv);
                    };
                    _proto.getValidChunk = function getValidChunk(data) {
                        var currentChunk = data;
                        var splitPoint = data.length - (data.length % CHUNK_SIZE);
                        if (splitPoint !== data.length) {
                            currentChunk = Object(_utils_typed_array__WEBPACK_IMPORTED_MODULE_5__["sliceUint8"])(data, 0, splitPoint);
                            this.remainderData = Object(_utils_typed_array__WEBPACK_IMPORTED_MODULE_5__["sliceUint8"])(data, splitPoint);
                        }
                        return currentChunk;
                    };
                    _proto.logOnce = function logOnce(msg) {
                        if (!this.logEnabled) {
                            return;
                        }
                        _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].log("[decrypter.ts]: " + msg);
                        this.logEnabled = false;
                    };
                    return Decrypter;
                })();
            },
            "./src/crypt/fast-aes-key.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "default", function () {
                    return FastAESKey;
                });
                var FastAESKey = (function () {
                    function FastAESKey(subtle, key) {
                        this.subtle = void 0;
                        this.key = void 0;
                        this.subtle = subtle;
                        this.key = key;
                    }
                    var _proto = FastAESKey.prototype;
                    _proto.expandKey = function expandKey() {
                        return this.subtle.importKey("raw", this.key, { name: "AES-CBC" }, false, ["encrypt", "decrypt"]);
                    };
                    return FastAESKey;
                })();
            },
            "./src/demux/aacdemuxer.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _base_audio_demuxer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/demux/base-audio-demuxer.ts");
                var _adts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/demux/adts.ts");
                var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/logger.ts");
                var _demux_id3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/demux/id3.ts");
                function _inheritsLoose(subClass, superClass) {
                    subClass.prototype = Object.create(superClass.prototype);
                    subClass.prototype.constructor = subClass;
                    _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf
                        ? Object.setPrototypeOf.bind()
                        : function _setPrototypeOf(o, p) {
                              o.__proto__ = p;
                              return o;
                          };
                    return _setPrototypeOf(o, p);
                }
                var AACDemuxer = (function (_BaseAudioDemuxer) {
                    _inheritsLoose(AACDemuxer, _BaseAudioDemuxer);
                    function AACDemuxer(observer, config) {
                        var _this;
                        _this = _BaseAudioDemuxer.call(this) || this;
                        _this.observer = void 0;
                        _this.config = void 0;
                        _this.observer = observer;
                        _this.config = config;
                        return _this;
                    }
                    var _proto = AACDemuxer.prototype;
                    _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
                        _BaseAudioDemuxer.prototype.resetInitSegment.call(this, initSegment, audioCodec, videoCodec, trackDuration);
                        this._audioTrack = { container: "audio/adts", type: "audio", id: 2, pid: -1, sequenceNumber: 0, segmentCodec: "aac", samples: [], manifestCodec: audioCodec, duration: trackDuration, inputTimeScale: 9e4, dropped: 0 };
                    };
                    AACDemuxer.probe = function probe(data) {
                        if (!data) {
                            return false;
                        }
                        var id3Data = _demux_id3__WEBPACK_IMPORTED_MODULE_3__["getID3Data"](data, 0) || [];
                        var offset = id3Data.length;
                        for (var length = data.length; offset < length; offset++) {
                            if (_adts__WEBPACK_IMPORTED_MODULE_1__["probe"](data, offset)) {
                                _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("ADTS sync word found !");
                                return true;
                            }
                        }
                        return false;
                    };
                    _proto.canParse = function canParse(data, offset) {
                        return _adts__WEBPACK_IMPORTED_MODULE_1__["canParse"](data, offset);
                    };
                    _proto.appendFrame = function appendFrame(track, data, offset) {
                        _adts__WEBPACK_IMPORTED_MODULE_1__["initTrackConfig"](track, this.observer, data, offset, track.manifestCodec);
                        var frame = _adts__WEBPACK_IMPORTED_MODULE_1__["appendFrame"](track, data, offset, this.basePTS, this.frameIndex);
                        if (frame && frame.missing === 0) {
                            return frame;
                        }
                    };
                    return AACDemuxer;
                })(_base_audio_demuxer__WEBPACK_IMPORTED_MODULE_0__["default"]);
                __webpack_exports__["default"] = AACDemuxer;
            },
            "./src/demux/adts.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "getAudioConfig", function () {
                    return getAudioConfig;
                });
                __webpack_require__.d(__webpack_exports__, "isHeaderPattern", function () {
                    return isHeaderPattern;
                });
                __webpack_require__.d(__webpack_exports__, "getHeaderLength", function () {
                    return getHeaderLength;
                });
                __webpack_require__.d(__webpack_exports__, "getFullFrameLength", function () {
                    return getFullFrameLength;
                });
                __webpack_require__.d(__webpack_exports__, "canGetFrameLength", function () {
                    return canGetFrameLength;
                });
                __webpack_require__.d(__webpack_exports__, "isHeader", function () {
                    return isHeader;
                });
                __webpack_require__.d(__webpack_exports__, "canParse", function () {
                    return canParse;
                });
                __webpack_require__.d(__webpack_exports__, "probe", function () {
                    return probe;
                });
                __webpack_require__.d(__webpack_exports__, "initTrackConfig", function () {
                    return initTrackConfig;
                });
                __webpack_require__.d(__webpack_exports__, "getFrameDuration", function () {
                    return getFrameDuration;
                });
                __webpack_require__.d(__webpack_exports__, "parseFrameHeader", function () {
                    return parseFrameHeader;
                });
                __webpack_require__.d(__webpack_exports__, "appendFrame", function () {
                    return appendFrame;
                });
                var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/logger.ts");
                var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/errors.ts");
                var _events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/events.ts");
                function getAudioConfig(observer, data, offset, audioCodec) {
                    var adtsObjectType;
                    var adtsExtensionSamplingIndex;
                    var adtsChannelConfig;
                    var config;
                    var userAgent = navigator.userAgent.toLowerCase();
                    var manifestCodec = audioCodec;
                    var adtsSamplingRates = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
                    adtsObjectType = ((data[offset + 2] & 192) >>> 6) + 1;
                    var adtsSamplingIndex = (data[offset + 2] & 60) >>> 2;
                    if (adtsSamplingIndex > adtsSamplingRates.length - 1) {
                        observer.trigger(_events__WEBPACK_IMPORTED_MODULE_2__["Events"].ERROR, {
                            type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].MEDIA_ERROR,
                            details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].FRAG_PARSING_ERROR,
                            fatal: true,
                            reason: "invalid ADTS sampling index:" + adtsSamplingIndex,
                        });
                        return;
                    }
                    adtsChannelConfig = (data[offset + 2] & 1) << 2;
                    adtsChannelConfig |= (data[offset + 3] & 192) >>> 6;
                    _utils_logger__WEBPACK_IMPORTED_MODULE_0__["logger"].log("manifest codec:" + audioCodec + ", ADTS type:" + adtsObjectType + ", samplingIndex:" + adtsSamplingIndex);
                    if (/firefox/i.test(userAgent)) {
                        if (adtsSamplingIndex >= 6) {
                            adtsObjectType = 5;
                            config = new Array(4);
                            adtsExtensionSamplingIndex = adtsSamplingIndex - 3;
                        } else {
                            adtsObjectType = 2;
                            config = new Array(2);
                            adtsExtensionSamplingIndex = adtsSamplingIndex;
                        }
                    } else if (userAgent.indexOf("android") !== -1) {
                        adtsObjectType = 2;
                        config = new Array(2);
                        adtsExtensionSamplingIndex = adtsSamplingIndex;
                    } else {
                        adtsObjectType = 5;
                        config = new Array(4);
                        if ((audioCodec && (audioCodec.indexOf("mp4a.40.29") !== -1 || audioCodec.indexOf("mp4a.40.5") !== -1)) || (!audioCodec && adtsSamplingIndex >= 6)) {
                            adtsExtensionSamplingIndex = adtsSamplingIndex - 3;
                        } else {
                            if ((audioCodec && audioCodec.indexOf("mp4a.40.2") !== -1 && ((adtsSamplingIndex >= 6 && adtsChannelConfig === 1) || /vivaldi/i.test(userAgent))) || (!audioCodec && adtsChannelConfig === 1)) {
                                adtsObjectType = 2;
                                config = new Array(2);
                            }
                            adtsExtensionSamplingIndex = adtsSamplingIndex;
                        }
                    }
                    config[0] = adtsObjectType << 3;
                    config[0] |= (adtsSamplingIndex & 14) >> 1;
                    config[1] |= (adtsSamplingIndex & 1) << 7;
                    config[1] |= adtsChannelConfig << 3;
                    if (adtsObjectType === 5) {
                        config[1] |= (adtsExtensionSamplingIndex & 14) >> 1;
                        config[2] = (adtsExtensionSamplingIndex & 1) << 7;
                        config[2] |= 2 << 2;
                        config[3] = 0;
                    }
                    return { config: config, samplerate: adtsSamplingRates[adtsSamplingIndex], channelCount: adtsChannelConfig, codec: "mp4a.40." + adtsObjectType, manifestCodec: manifestCodec };
                }
                function isHeaderPattern(data, offset) {
                    return data[offset] === 255 && (data[offset + 1] & 246) === 240;
                }
                function getHeaderLength(data, offset) {
                    return data[offset + 1] & 1 ? 7 : 9;
                }
                function getFullFrameLength(data, offset) {
                    return ((data[offset + 3] & 3) << 11) | (data[offset + 4] << 3) | ((data[offset + 5] & 224) >>> 5);
                }
                function canGetFrameLength(data, offset) {
                    return offset + 5 < data.length;
                }
                function isHeader(data, offset) {
                    return offset + 1 < data.length && isHeaderPattern(data, offset);
                }
                function canParse(data, offset) {
                    return canGetFrameLength(data, offset) && isHeaderPattern(data, offset) && getFullFrameLength(data, offset) <= data.length - offset;
                }
                function probe(data, offset) {
                    if (isHeader(data, offset)) {
                        var headerLength = getHeaderLength(data, offset);
                        if (offset + headerLength >= data.length) {
                            return false;
                        }
                        var frameLength = getFullFrameLength(data, offset);
                        if (frameLength <= headerLength) {
                            return false;
                        }
                        var newOffset = offset + frameLength;
                        return newOffset === data.length || isHeader(data, newOffset);
                    }
                    return false;
                }
                function initTrackConfig(track, observer, data, offset, audioCodec) {
                    if (!track.samplerate) {
                        var config = getAudioConfig(observer, data, offset, audioCodec);
                        if (!config) {
                            return;
                        }
                        track.config = config.config;
                        track.samplerate = config.samplerate;
                        track.channelCount = config.channelCount;
                        track.codec = config.codec;
                        track.manifestCodec = config.manifestCodec;
                        _utils_logger__WEBPACK_IMPORTED_MODULE_0__["logger"].log("parsed codec:" + track.codec + ", rate:" + config.samplerate + ", channels:" + config.channelCount);
                    }
                }
                function getFrameDuration(samplerate) {
                    return (1024 * 9e4) / samplerate;
                }
                function parseFrameHeader(data, offset) {
                    var headerLength = getHeaderLength(data, offset);
                    if (offset + headerLength <= data.length) {
                        var frameLength = getFullFrameLength(data, offset) - headerLength;
                        if (frameLength > 0) {
                            return { headerLength: headerLength, frameLength: frameLength };
                        }
                    }
                }
                function appendFrame(track, data, offset, pts, frameIndex) {
                    var frameDuration = getFrameDuration(track.samplerate);
                    var stamp = pts + frameIndex * frameDuration;
                    var header = parseFrameHeader(data, offset);
                    var unit;
                    if (header) {
                        var frameLength = header.frameLength,
                            headerLength = header.headerLength;
                        var _length = headerLength + frameLength;
                        var missing = Math.max(0, offset + _length - data.length);
                        if (missing) {
                            unit = new Uint8Array(_length - headerLength);
                            unit.set(data.subarray(offset + headerLength, data.length), 0);
                        } else {
                            unit = data.subarray(offset + headerLength, offset + _length);
                        }
                        var _sample = { unit: unit, pts: stamp };
                        if (!missing) {
                            track.samples.push(_sample);
                        }
                        return { sample: _sample, length: _length, missing: missing };
                    }
                    var length = data.length - offset;
                    unit = new Uint8Array(length);
                    unit.set(data.subarray(offset, data.length), 0);
                    var sample = { unit: unit, pts: stamp };
                    return { sample: sample, length: length, missing: -1 };
                }
            },
            "./src/demux/base-audio-demuxer.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "initPTSFn", function () {
                    return initPTSFn;
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/polyfills/number.ts");
                var _demux_id3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/demux/id3.ts");
                var _types_demuxer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/types/demuxer.ts");
                var _dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/demux/dummy-demuxed-track.ts");
                var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/utils/mp4-tools.ts");
                var _utils_typed_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/utils/typed-array.ts");
                var BaseAudioDemuxer = (function () {
                    function BaseAudioDemuxer() {
                        this._audioTrack = void 0;
                        this._id3Track = void 0;
                        this.frameIndex = 0;
                        this.cachedData = null;
                        this.basePTS = null;
                        this.initPTS = null;
                    }
                    var _proto = BaseAudioDemuxer.prototype;
                    _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
                        this._id3Track = { type: "id3", id: 3, pid: -1, inputTimeScale: 9e4, sequenceNumber: 0, samples: [], dropped: 0 };
                    };
                    _proto.resetTimeStamp = function resetTimeStamp(deaultTimestamp) {
                        this.initPTS = deaultTimestamp;
                        this.resetContiguity();
                    };
                    _proto.resetContiguity = function resetContiguity() {
                        this.basePTS = null;
                        this.frameIndex = 0;
                    };
                    _proto.canParse = function canParse(data, offset) {
                        return false;
                    };
                    _proto.appendFrame = function appendFrame(track, data, offset) {};
                    _proto.demux = function demux(data, timeOffset) {
                        if (this.cachedData) {
                            data = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__["appendUint8Array"])(this.cachedData, data);
                            this.cachedData = null;
                        }
                        var id3Data = _demux_id3__WEBPACK_IMPORTED_MODULE_1__["getID3Data"](data, 0);
                        var offset = id3Data ? id3Data.length : 0;
                        var lastDataIndex;
                        var pts;
                        var track = this._audioTrack;
                        var id3Track = this._id3Track;
                        var timestamp = id3Data ? _demux_id3__WEBPACK_IMPORTED_MODULE_1__["getTimeStamp"](id3Data) : undefined;
                        var length = data.length;
                        if (this.basePTS === null || (this.frameIndex === 0 && Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(timestamp))) {
                            this.basePTS = initPTSFn(timestamp, timeOffset, this.initPTS);
                        }
                        if (id3Data && id3Data.length > 0) {
                            id3Track.samples.push({ pts: this.basePTS, dts: this.basePTS, data: id3Data, type: _types_demuxer__WEBPACK_IMPORTED_MODULE_2__["MetadataSchema"].audioId3 });
                        }
                        pts = this.basePTS;
                        while (offset < length) {
                            if (this.canParse(data, offset)) {
                                var frame = this.appendFrame(track, data, offset);
                                if (frame) {
                                    this.frameIndex++;
                                    pts = frame.sample.pts;
                                    offset += frame.length;
                                    lastDataIndex = offset;
                                } else {
                                    offset = length;
                                }
                            } else if (_demux_id3__WEBPACK_IMPORTED_MODULE_1__["canParse"](data, offset)) {
                                id3Data = _demux_id3__WEBPACK_IMPORTED_MODULE_1__["getID3Data"](data, offset);
                                id3Track.samples.push({ pts: pts, dts: pts, data: id3Data, type: _types_demuxer__WEBPACK_IMPORTED_MODULE_2__["MetadataSchema"].audioId3 });
                                offset += id3Data.length;
                                lastDataIndex = offset;
                            } else {
                                offset++;
                            }
                            if (offset === length && lastDataIndex !== length) {
                                var partialData = Object(_utils_typed_array__WEBPACK_IMPORTED_MODULE_5__["sliceUint8"])(data, lastDataIndex);
                                if (this.cachedData) {
                                    this.cachedData = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__["appendUint8Array"])(this.cachedData, partialData);
                                } else {
                                    this.cachedData = partialData;
                                }
                            }
                        }
                        return {
                            audioTrack: track,
                            videoTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__["dummyTrack"])(),
                            id3Track: id3Track,
                            textTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__["dummyTrack"])(),
                        };
                    };
                    _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {
                        return Promise.reject(new Error("[" + this + "] This demuxer does not support Sample-AES decryption"));
                    };
                    _proto.flush = function flush(timeOffset) {
                        var cachedData = this.cachedData;
                        if (cachedData) {
                            this.cachedData = null;
                            this.demux(cachedData, 0);
                        }
                        return {
                            audioTrack: this._audioTrack,
                            videoTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__["dummyTrack"])(),
                            id3Track: this._id3Track,
                            textTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__["dummyTrack"])(),
                        };
                    };
                    _proto.destroy = function destroy() {};
                    return BaseAudioDemuxer;
                })();
                var initPTSFn = function initPTSFn(timestamp, timeOffset, initPTS) {
                    if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(timestamp)) {
                        return timestamp * 90;
                    }
                    return timeOffset * 9e4 + (initPTS || 0);
                };
                __webpack_exports__["default"] = BaseAudioDemuxer;
            },
            "./src/demux/chunk-cache.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "default", function () {
                    return ChunkCache;
                });
                var ChunkCache = (function () {
                    function ChunkCache() {
                        this.chunks = [];
                        this.dataLength = 0;
                    }
                    var _proto = ChunkCache.prototype;
                    _proto.push = function push(chunk) {
                        this.chunks.push(chunk);
                        this.dataLength += chunk.length;
                    };
                    _proto.flush = function flush() {
                        var chunks = this.chunks,
                            dataLength = this.dataLength;
                        var result;
                        if (!chunks.length) {
                            return new Uint8Array(0);
                        } else if (chunks.length === 1) {
                            result = chunks[0];
                        } else {
                            result = concatUint8Arrays(chunks, dataLength);
                        }
                        this.reset();
                        return result;
                    };
                    _proto.reset = function reset() {
                        this.chunks.length = 0;
                        this.dataLength = 0;
                    };
                    return ChunkCache;
                })();
                function concatUint8Arrays(chunks, dataLength) {
                    var result = new Uint8Array(dataLength);
                    var offset = 0;
                    for (var i = 0; i < chunks.length; i++) {
                        var chunk = chunks[i];
                        result.set(chunk, offset);
                        offset += chunk.length;
                    }
                    return result;
                }
            },
            "./src/demux/dummy-demuxed-track.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "dummyTrack", function () {
                    return dummyTrack;
                });
                function dummyTrack(type, inputTimeScale) {
                    if (type === void 0) {
                        type = "";
                    }
                    if (inputTimeScale === void 0) {
                        inputTimeScale = 9e4;
                    }
                    return { type: type, id: -1, pid: -1, inputTimeScale: inputTimeScale, sequenceNumber: -1, samples: [], dropped: 0 };
                }
            },
            "./src/demux/exp-golomb.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/logger.ts");
                var ExpGolomb = (function () {
                    function ExpGolomb(data) {
                        this.data = void 0;
                        this.bytesAvailable = void 0;
                        this.word = void 0;
                        this.bitsAvailable = void 0;
                        this.data = data;
                        this.bytesAvailable = data.byteLength;
                        this.word = 0;
                        this.bitsAvailable = 0;
                    }
                    var _proto = ExpGolomb.prototype;
                    _proto.loadWord = function loadWord() {
                        var data = this.data;
                        var bytesAvailable = this.bytesAvailable;
                        var position = data.byteLength - bytesAvailable;
                        var workingBytes = new Uint8Array(4);
                        var availableBytes = Math.min(4, bytesAvailable);
                        if (availableBytes === 0) {
                            throw new Error("no bytes available");
                        }
                        workingBytes.set(data.subarray(position, position + availableBytes));
                        this.word = new DataView(workingBytes.buffer).getUint32(0);
                        this.bitsAvailable = availableBytes * 8;
                        this.bytesAvailable -= availableBytes;
                    };
                    _proto.skipBits = function skipBits(count) {
                        var skipBytes;
                        if (this.bitsAvailable > count) {
                            this.word <<= count;
                            this.bitsAvailable -= count;
                        } else {
                            count -= this.bitsAvailable;
                            skipBytes = count >> 3;
                            count -= skipBytes >> 3;
                            this.bytesAvailable -= skipBytes;
                            this.loadWord();
                            this.word <<= count;
                            this.bitsAvailable -= count;
                        }
                    };
                    _proto.readBits = function readBits(size) {
                        var bits = Math.min(this.bitsAvailable, size);
                        var valu = this.word >>> (32 - bits);
                        if (size > 32) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_0__["logger"].error("Cannot read more than 32 bits at a time");
                        }
                        this.bitsAvailable -= bits;
                        if (this.bitsAvailable > 0) {
                            this.word <<= bits;
                        } else if (this.bytesAvailable > 0) {
                            this.loadWord();
                        }
                        bits = size - bits;
                        if (bits > 0 && this.bitsAvailable) {
                            return (valu << bits) | this.readBits(bits);
                        } else {
                            return valu;
                        }
                    };
                    _proto.skipLZ = function skipLZ() {
                        var leadingZeroCount;
                        for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
                            if ((this.word & (2147483648 >>> leadingZeroCount)) !== 0) {
                                this.word <<= leadingZeroCount;
                                this.bitsAvailable -= leadingZeroCount;
                                return leadingZeroCount;
                            }
                        }
                        this.loadWord();
                        return leadingZeroCount + this.skipLZ();
                    };
                    _proto.skipUEG = function skipUEG() {
                        this.skipBits(1 + this.skipLZ());
                    };
                    _proto.skipEG = function skipEG() {
                        this.skipBits(1 + this.skipLZ());
                    };
                    _proto.readUEG = function readUEG() {
                        var clz = this.skipLZ();
                        return this.readBits(clz + 1) - 1;
                    };
                    _proto.readEG = function readEG() {
                        var valu = this.readUEG();
                        if (1 & valu) {
                            return (1 + valu) >>> 1;
                        } else {
                            return -1 * (valu >>> 1);
                        }
                    };
                    _proto.readBoolean = function readBoolean() {
                        return this.readBits(1) === 1;
                    };
                    _proto.readUByte = function readUByte() {
                        return this.readBits(8);
                    };
                    _proto.readUShort = function readUShort() {
                        return this.readBits(16);
                    };
                    _proto.readUInt = function readUInt() {
                        return this.readBits(32);
                    };
                    _proto.skipScalingList = function skipScalingList(count) {
                        var lastScale = 8;
                        var nextScale = 8;
                        var deltaScale;
                        for (var j = 0; j < count; j++) {
                            if (nextScale !== 0) {
                                deltaScale = this.readEG();
                                nextScale = (lastScale + deltaScale + 256) % 256;
                            }
                            lastScale = nextScale === 0 ? lastScale : nextScale;
                        }
                    };
                    _proto.readSPS = function readSPS() {
                        var frameCropLeftOffset = 0;
                        var frameCropRightOffset = 0;
                        var frameCropTopOffset = 0;
                        var frameCropBottomOffset = 0;
                        var numRefFramesInPicOrderCntCycle;
                        var scalingListCount;
                        var i;
                        var readUByte = this.readUByte.bind(this);
                        var readBits = this.readBits.bind(this);
                        var readUEG = this.readUEG.bind(this);
                        var readBoolean = this.readBoolean.bind(this);
                        var skipBits = this.skipBits.bind(this);
                        var skipEG = this.skipEG.bind(this);
                        var skipUEG = this.skipUEG.bind(this);
                        var skipScalingList = this.skipScalingList.bind(this);
                        readUByte();
                        var profileIdc = readUByte();
                        readBits(5);
                        skipBits(3);
                        readUByte();
                        skipUEG();
                        if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {
                            var chromaFormatIdc = readUEG();
                            if (chromaFormatIdc === 3) {
                                skipBits(1);
                            }
                            skipUEG();
                            skipUEG();
                            skipBits(1);
                            if (readBoolean()) {
                                scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
                                for (i = 0; i < scalingListCount; i++) {
                                    if (readBoolean()) {
                                        if (i < 6) {
                                            skipScalingList(16);
                                        } else {
                                            skipScalingList(64);
                                        }
                                    }
                                }
                            }
                        }
                        skipUEG();
                        var picOrderCntType = readUEG();
                        if (picOrderCntType === 0) {
                            readUEG();
                        } else if (picOrderCntType === 1) {
                            skipBits(1);
                            skipEG();
                            skipEG();
                            numRefFramesInPicOrderCntCycle = readUEG();
                            for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
                                skipEG();
                            }
                        }
                        skipUEG();
                        skipBits(1);
                        var picWidthInMbsMinus1 = readUEG();
                        var picHeightInMapUnitsMinus1 = readUEG();
                        var frameMbsOnlyFlag = readBits(1);
                        if (frameMbsOnlyFlag === 0) {
                            skipBits(1);
                        }
                        skipBits(1);
                        if (readBoolean()) {
                            frameCropLeftOffset = readUEG();
                            frameCropRightOffset = readUEG();
                            frameCropTopOffset = readUEG();
                            frameCropBottomOffset = readUEG();
                        }
                        var pixelRatio = [1, 1];
                        if (readBoolean()) {
                            if (readBoolean()) {
                                var aspectRatioIdc = readUByte();
                                switch (aspectRatioIdc) {
                                    case 1:
                                        pixelRatio = [1, 1];
                                        break;
                                    case 2:
                                        pixelRatio = [12, 11];
                                        break;
                                    case 3:
                                        pixelRatio = [10, 11];
                                        break;
                                    case 4:
                                        pixelRatio = [16, 11];
                                        break;
                                    case 5:
                                        pixelRatio = [40, 33];
                                        break;
                                    case 6:
                                        pixelRatio = [24, 11];
                                        break;
                                    case 7:
                                        pixelRatio = [20, 11];
                                        break;
                                    case 8:
                                        pixelRatio = [32, 11];
                                        break;
                                    case 9:
                                        pixelRatio = [80, 33];
                                        break;
                                    case 10:
                                        pixelRatio = [18, 11];
                                        break;
                                    case 11:
                                        pixelRatio = [15, 11];
                                        break;
                                    case 12:
                                        pixelRatio = [64, 33];
                                        break;
                                    case 13:
                                        pixelRatio = [160, 99];
                                        break;
                                    case 14:
                                        pixelRatio = [4, 3];
                                        break;
                                    case 15:
                                        pixelRatio = [3, 2];
                                        break;
                                    case 16:
                                        pixelRatio = [2, 1];
                                        break;
                                    case 255: {
                                        pixelRatio = [(readUByte() << 8) | readUByte(), (readUByte() << 8) | readUByte()];
                                        break;
                                    }
                                }
                            }
                        }
                        return {
                            width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),
                            height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),
                            pixelRatio: pixelRatio,
                        };
                    };
                    _proto.readSliceType = function readSliceType() {
                        this.readUByte();
                        this.readUEG();
                        return this.readUEG();
                    };
                    return ExpGolomb;
                })();
                __webpack_exports__["default"] = ExpGolomb;
            },
            "./src/demux/id3.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "isHeader", function () {
                    return isHeader;
                });
                __webpack_require__.d(__webpack_exports__, "isFooter", function () {
                    return isFooter;
                });
                __webpack_require__.d(__webpack_exports__, "getID3Data", function () {
                    return getID3Data;
                });
                __webpack_require__.d(__webpack_exports__, "canParse", function () {
                    return canParse;
                });
                __webpack_require__.d(__webpack_exports__, "getTimeStamp", function () {
                    return getTimeStamp;
                });
                __webpack_require__.d(__webpack_exports__, "isTimeStampFrame", function () {
                    return isTimeStampFrame;
                });
                __webpack_require__.d(__webpack_exports__, "getID3Frames", function () {
                    return getID3Frames;
                });
                __webpack_require__.d(__webpack_exports__, "decodeFrame", function () {
                    return decodeFrame;
                });
                __webpack_require__.d(__webpack_exports__, "utf8ArrayToStr", function () {
                    return utf8ArrayToStr;
                });
                __webpack_require__.d(__webpack_exports__, "testables", function () {
                    return testables;
                });
                var isHeader = function isHeader(data, offset) {
                    if (offset + 10 <= data.length) {
                        if (data[offset] === 73 && data[offset + 1] === 68 && data[offset + 2] === 51) {
                            if (data[offset + 3] < 255 && data[offset + 4] < 255) {
                                if (data[offset + 6] < 128 && data[offset + 7] < 128 && data[offset + 8] < 128 && data[offset + 9] < 128) {
                                    return true;
                                }
                            }
                        }
                    }
                    return false;
                };
                var isFooter = function isFooter(data, offset) {
                    if (offset + 10 <= data.length) {
                        if (data[offset] === 51 && data[offset + 1] === 68 && data[offset + 2] === 73) {
                            if (data[offset + 3] < 255 && data[offset + 4] < 255) {
                                if (data[offset + 6] < 128 && data[offset + 7] < 128 && data[offset + 8] < 128 && data[offset + 9] < 128) {
                                    return true;
                                }
                            }
                        }
                    }
                    return false;
                };
                var getID3Data = function getID3Data(data, offset) {
                    var front = offset;
                    var length = 0;
                    while (isHeader(data, offset)) {
                        length += 10;
                        var size = readSize(data, offset + 6);
                        length += size;
                        if (isFooter(data, offset + 10)) {
                            length += 10;
                        }
                        offset += length;
                    }
                    if (length > 0) {
                        return data.subarray(front, front + length);
                    }
                    return undefined;
                };
                var readSize = function readSize(data, offset) {
                    var size = 0;
                    size = (data[offset] & 127) << 21;
                    size |= (data[offset + 1] & 127) << 14;
                    size |= (data[offset + 2] & 127) << 7;
                    size |= data[offset + 3] & 127;
                    return size;
                };
                var canParse = function canParse(data, offset) {
                    return isHeader(data, offset) && readSize(data, offset + 6) + 10 <= data.length - offset;
                };
                var getTimeStamp = function getTimeStamp(data) {
                    var frames = getID3Frames(data);
                    for (var i = 0; i < frames.length; i++) {
                        var frame = frames[i];
                        if (isTimeStampFrame(frame)) {
                            return readTimeStamp(frame);
                        }
                    }
                    return undefined;
                };
                var isTimeStampFrame = function isTimeStampFrame(frame) {
                    return frame && frame.key === "PRIV" && frame.info === "com.apple.streaming.transportStreamTimestamp";
                };
                var getFrameData = function getFrameData(data) {
                    var type = String.fromCharCode(data[0], data[1], data[2], data[3]);
                    var size = readSize(data, 4);
                    var offset = 10;
                    return { type: type, size: size, data: data.subarray(offset, offset + size) };
                };
                var getID3Frames = function getID3Frames(id3Data) {
                    var offset = 0;
                    var frames = [];
                    while (isHeader(id3Data, offset)) {
                        var size = readSize(id3Data, offset + 6);
                        offset += 10;
                        var end = offset + size;
                        while (offset + 8 < end) {
                            var frameData = getFrameData(id3Data.subarray(offset));
                            var frame = decodeFrame(frameData);
                            if (frame) {
                                frames.push(frame);
                            }
                            offset += frameData.size + 10;
                        }
                        if (isFooter(id3Data, offset)) {
                            offset += 10;
                        }
                    }
                    return frames;
                };
                var decodeFrame = function decodeFrame(frame) {
                    if (frame.type === "PRIV") {
                        return decodePrivFrame(frame);
                    } else if (frame.type[0] === "W") {
                        return decodeURLFrame(frame);
                    }
                    return decodeTextFrame(frame);
                };
                var decodePrivFrame = function decodePrivFrame(frame) {
                    if (frame.size < 2) {
                        return undefined;
                    }
                    var owner = utf8ArrayToStr(frame.data, true);
                    var privateData = new Uint8Array(frame.data.subarray(owner.length + 1));
                    return { key: frame.type, info: owner, data: privateData.buffer };
                };
                var decodeTextFrame = function decodeTextFrame(frame) {
                    if (frame.size < 2) {
                        return undefined;
                    }
                    if (frame.type === "TXXX") {
                        var index = 1;
                        var description = utf8ArrayToStr(frame.data.subarray(index), true);
                        index += description.length + 1;
                        var value = utf8ArrayToStr(frame.data.subarray(index));
                        return { key: frame.type, info: description, data: value };
                    }
                    var text = utf8ArrayToStr(frame.data.subarray(1));
                    return { key: frame.type, data: text };
                };
                var decodeURLFrame = function decodeURLFrame(frame) {
                    if (frame.type === "WXXX") {
                        if (frame.size < 2) {
                            return undefined;
                        }
                        var index = 1;
                        var description = utf8ArrayToStr(frame.data.subarray(index), true);
                        index += description.length + 1;
                        var value = utf8ArrayToStr(frame.data.subarray(index));
                        return { key: frame.type, info: description, data: value };
                    }
                    var url = utf8ArrayToStr(frame.data);
                    return { key: frame.type, data: url };
                };
                var readTimeStamp = function readTimeStamp(timeStampFrame) {
                    if (timeStampFrame.data.byteLength === 8) {
                        var data = new Uint8Array(timeStampFrame.data);
                        var pts33Bit = data[3] & 1;
                        var timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];
                        timestamp /= 45;
                        if (pts33Bit) {
                            timestamp += 47721858.84;
                        }
                        return Math.round(timestamp);
                    }
                    return undefined;
                };
                var utf8ArrayToStr = function utf8ArrayToStr(array, exitOnNull) {
                    if (exitOnNull === void 0) {
                        exitOnNull = false;
                    }
                    var decoder = getTextDecoder();
                    if (decoder) {
                        var decoded = decoder.decode(array);
                        if (exitOnNull) {
                            var idx = decoded.indexOf("\0");
                            return idx !== -1 ? decoded.substring(0, idx) : decoded;
                        }
                        return decoded.replace(/\0/g, "");
                    }
                    var len = array.length;
                    var c;
                    var char2;
                    var char3;
                    var out = "";
                    var i = 0;
                    while (i < len) {
                        c = array[i++];
                        if (c === 0 && exitOnNull) {
                            return out;
                        } else if (c === 0 || c === 3) {
                            continue;
                        }
                        switch (c >> 4) {
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                                out += String.fromCharCode(c);
                                break;
                            case 12:
                            case 13:
                                char2 = array[i++];
                                out += String.fromCharCode(((c & 31) << 6) | (char2 & 63));
                                break;
                            case 14:
                                char2 = array[i++];
                                char3 = array[i++];
                                out += String.fromCharCode(((c & 15) << 12) | ((char2 & 63) << 6) | ((char3 & 63) << 0));
                                break;
                            default:
                        }
                    }
                    return out;
                };
                var testables = { decodeTextFrame: decodeTextFrame };
                var decoder;
                function getTextDecoder() {
                    if (!decoder && typeof self.TextDecoder !== "undefined") {
                        decoder = new self.TextDecoder("utf-8");
                    }
                    return decoder;
                }
            },
            "./src/demux/mp3demuxer.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _base_audio_demuxer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/demux/base-audio-demuxer.ts");
                var _demux_id3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/demux/id3.ts");
                var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/logger.ts");
                var _mpegaudio__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/demux/mpegaudio.ts");
                function _inheritsLoose(subClass, superClass) {
                    subClass.prototype = Object.create(superClass.prototype);
                    subClass.prototype.constructor = subClass;
                    _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf
                        ? Object.setPrototypeOf.bind()
                        : function _setPrototypeOf(o, p) {
                              o.__proto__ = p;
                              return o;
                          };
                    return _setPrototypeOf(o, p);
                }
                var MP3Demuxer = (function (_BaseAudioDemuxer) {
                    _inheritsLoose(MP3Demuxer, _BaseAudioDemuxer);
                    function MP3Demuxer() {
                        return _BaseAudioDemuxer.apply(this, arguments) || this;
                    }
                    var _proto = MP3Demuxer.prototype;
                    _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
                        _BaseAudioDemuxer.prototype.resetInitSegment.call(this, initSegment, audioCodec, videoCodec, trackDuration);
                        this._audioTrack = { container: "audio/mpeg", type: "audio", id: 2, pid: -1, sequenceNumber: 0, segmentCodec: "mp3", samples: [], manifestCodec: audioCodec, duration: trackDuration, inputTimeScale: 9e4, dropped: 0 };
                    };
                    MP3Demuxer.probe = function probe(data) {
                        if (!data) {
                            return false;
                        }
                        var id3Data = _demux_id3__WEBPACK_IMPORTED_MODULE_1__["getID3Data"](data, 0) || [];
                        var offset = id3Data.length;
                        for (var length = data.length; offset < length; offset++) {
                            if (_mpegaudio__WEBPACK_IMPORTED_MODULE_3__["probe"](data, offset)) {
                                _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].log("MPEG Audio sync word found !");
                                return true;
                            }
                        }
                        return false;
                    };
                    _proto.canParse = function canParse(data, offset) {
                        return _mpegaudio__WEBPACK_IMPORTED_MODULE_3__["canParse"](data, offset);
                    };
                    _proto.appendFrame = function appendFrame(track, data, offset) {
                        if (this.basePTS === null) {
                            return;
                        }
                        return _mpegaudio__WEBPACK_IMPORTED_MODULE_3__["appendFrame"](track, data, offset, this.basePTS, this.frameIndex);
                    };
                    return MP3Demuxer;
                })(_base_audio_demuxer__WEBPACK_IMPORTED_MODULE_0__["default"]);
                __webpack_exports__["default"] = MP3Demuxer;
            },
            "./src/demux/mp4demuxer.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/polyfills/number.ts");
                var _types_demuxer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/types/demuxer.ts");
                var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/mp4-tools.ts");
                var _dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/demux/dummy-demuxed-track.ts");
                var emsgSchemePattern = /\/emsg[-/]ID3/i;
                var MP4Demuxer = (function () {
                    function MP4Demuxer(observer, config) {
                        this.remainderData = null;
                        this.timeOffset = 0;
                        this.config = void 0;
                        this.videoTrack = void 0;
                        this.audioTrack = void 0;
                        this.id3Track = void 0;
                        this.txtTrack = void 0;
                        this.config = config;
                    }
                    var _proto = MP4Demuxer.prototype;
                    _proto.resetTimeStamp = function resetTimeStamp() {};
                    _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
                        var initData = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__["parseInitSegment"])(initSegment);
                        var videoTrack = (this.videoTrack = Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__["dummyTrack"])("video", 1));
                        var audioTrack = (this.audioTrack = Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__["dummyTrack"])("audio", 1));
                        var captionTrack = (this.txtTrack = Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__["dummyTrack"])("text", 1));
                        this.id3Track = Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__["dummyTrack"])("id3", 1);
                        this.timeOffset = 0;
                        if (initData.video) {
                            var _initData$video = initData.video,
                                id = _initData$video.id,
                                timescale = _initData$video.timescale,
                                codec = _initData$video.codec;
                            videoTrack.id = id;
                            videoTrack.timescale = captionTrack.timescale = timescale;
                            videoTrack.codec = codec;
                        }
                        if (initData.audio) {
                            var _initData$audio = initData.audio,
                                _id = _initData$audio.id,
                                _timescale = _initData$audio.timescale,
                                _codec = _initData$audio.codec;
                            audioTrack.id = _id;
                            audioTrack.timescale = _timescale;
                            audioTrack.codec = _codec;
                        }
                        captionTrack.id = _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__["RemuxerTrackIdConfig"].text;
                        videoTrack.sampleDuration = 0;
                        videoTrack.duration = audioTrack.duration = trackDuration;
                    };
                    _proto.resetContiguity = function resetContiguity() {};
                    MP4Demuxer.probe = function probe(data) {
                        data = data.length > 16384 ? data.subarray(0, 16384) : data;
                        return Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__["findBox"])(data, ["moof"]).length > 0;
                    };
                    _proto.demux = function demux(data, timeOffset) {
                        this.timeOffset = timeOffset;
                        var videoSamples = data;
                        var videoTrack = this.videoTrack;
                        var textTrack = this.txtTrack;
                        if (this.config.progressive) {
                            if (this.remainderData) {
                                videoSamples = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__["appendUint8Array"])(this.remainderData, data);
                            }
                            var segmentedData = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__["segmentValidRange"])(videoSamples);
                            this.remainderData = segmentedData.remainder;
                            videoTrack.samples = segmentedData.valid || new Uint8Array();
                        } else {
                            videoTrack.samples = videoSamples;
                        }
                        var id3Track = this.extractID3Track(videoTrack, timeOffset);
                        textTrack.samples = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__["parseSamples"])(timeOffset, videoTrack);
                        return { videoTrack: videoTrack, audioTrack: this.audioTrack, id3Track: id3Track, textTrack: this.txtTrack };
                    };
                    _proto.flush = function flush() {
                        var timeOffset = this.timeOffset;
                        var videoTrack = this.videoTrack;
                        var textTrack = this.txtTrack;
                        videoTrack.samples = this.remainderData || new Uint8Array();
                        this.remainderData = null;
                        var id3Track = this.extractID3Track(videoTrack, this.timeOffset);
                        textTrack.samples = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__["parseSamples"])(timeOffset, videoTrack);
                        return {
                            videoTrack: videoTrack,
                            audioTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__["dummyTrack"])(),
                            id3Track: id3Track,
                            textTrack: Object(_dummy_demuxed_track__WEBPACK_IMPORTED_MODULE_3__["dummyTrack"])(),
                        };
                    };
                    _proto.extractID3Track = function extractID3Track(videoTrack, timeOffset) {
                        var id3Track = this.id3Track;
                        if (videoTrack.samples.length) {
                            var emsgs = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__["findBox"])(videoTrack.samples, ["emsg"]);
                            if (emsgs) {
                                emsgs.forEach(function (data) {
                                    var emsgInfo = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__["parseEmsg"])(data);
                                    if (emsgSchemePattern.test(emsgInfo.schemeIdUri)) {
                                        var pts = Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(emsgInfo.presentationTime)
                                            ? emsgInfo.presentationTime / emsgInfo.timeScale
                                            : timeOffset + emsgInfo.presentationTimeDelta / emsgInfo.timeScale;
                                        var payload = emsgInfo.payload;
                                        id3Track.samples.push({ data: payload, len: payload.byteLength, dts: pts, pts: pts, type: _types_demuxer__WEBPACK_IMPORTED_MODULE_1__["MetadataSchema"].emsg });
                                    }
                                });
                            }
                        }
                        return id3Track;
                    };
                    _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {
                        return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"));
                    };
                    _proto.destroy = function destroy() {};
                    return MP4Demuxer;
                })();
                __webpack_exports__["default"] = MP4Demuxer;
            },
            "./src/demux/mpegaudio.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "appendFrame", function () {
                    return appendFrame;
                });
                __webpack_require__.d(__webpack_exports__, "parseHeader", function () {
                    return parseHeader;
                });
                __webpack_require__.d(__webpack_exports__, "isHeaderPattern", function () {
                    return isHeaderPattern;
                });
                __webpack_require__.d(__webpack_exports__, "isHeader", function () {
                    return isHeader;
                });
                __webpack_require__.d(__webpack_exports__, "canParse", function () {
                    return canParse;
                });
                __webpack_require__.d(__webpack_exports__, "probe", function () {
                    return probe;
                });
                var chromeVersion = null;
                var BitratesMap = [
                    32,
                    64,
                    96,
                    128,
                    160,
                    192,
                    224,
                    256,
                    288,
                    320,
                    352,
                    384,
                    416,
                    448,
                    32,
                    48,
                    56,
                    64,
                    80,
                    96,
                    112,
                    128,
                    160,
                    192,
                    224,
                    256,
                    320,
                    384,
                    32,
                    40,
                    48,
                    56,
                    64,
                    80,
                    96,
                    112,
                    128,
                    160,
                    192,
                    224,
                    256,
                    320,
                    32,
                    48,
                    56,
                    64,
                    80,
                    96,
                    112,
                    128,
                    144,
                    160,
                    176,
                    192,
                    224,
                    256,
                    8,
                    16,
                    24,
                    32,
                    40,
                    48,
                    56,
                    64,
                    80,
                    96,
                    112,
                    128,
                    144,
                    160,
                ];
                var SamplingRateMap = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3];
                var SamplesCoefficients = [
                    [0, 72, 144, 12],
                    [0, 0, 0, 0],
                    [0, 72, 144, 12],
                    [0, 144, 144, 12],
                ];
                var BytesInSlot = [0, 1, 1, 4];
                function appendFrame(track, data, offset, pts, frameIndex) {
                    if (offset + 24 > data.length) {
                        return;
                    }
                    var header = parseHeader(data, offset);
                    if (header && offset + header.frameLength <= data.length) {
                        var frameDuration = (header.samplesPerFrame * 9e4) / header.sampleRate;
                        var stamp = pts + frameIndex * frameDuration;
                        var sample = { unit: data.subarray(offset, offset + header.frameLength), pts: stamp, dts: stamp };
                        track.config = [];
                        track.channelCount = header.channelCount;
                        track.samplerate = header.sampleRate;
                        track.samples.push(sample);
                        return { sample: sample, length: header.frameLength, missing: 0 };
                    }
                }
                function parseHeader(data, offset) {
                    var mpegVersion = (data[offset + 1] >> 3) & 3;
                    var mpegLayer = (data[offset + 1] >> 1) & 3;
                    var bitRateIndex = (data[offset + 2] >> 4) & 15;
                    var sampleRateIndex = (data[offset + 2] >> 2) & 3;
                    if (mpegVersion !== 1 && bitRateIndex !== 0 && bitRateIndex !== 15 && sampleRateIndex !== 3) {
                        var paddingBit = (data[offset + 2] >> 1) & 1;
                        var channelMode = data[offset + 3] >> 6;
                        var columnInBitrates = mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;
                        var bitRate = BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1e3;
                        var columnInSampleRates = mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;
                        var sampleRate = SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];
                        var channelCount = channelMode === 3 ? 1 : 2;
                        var sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];
                        var bytesInSlot = BytesInSlot[mpegLayer];
                        var samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;
                        var frameLength = Math.floor((sampleCoefficient * bitRate) / sampleRate + paddingBit) * bytesInSlot;
                        if (chromeVersion === null) {
                            var userAgent = navigator.userAgent || "";
                            var result = userAgent.match(/Chrome\/(\d+)/i);
                            chromeVersion = result ? parseInt(result[1]) : 0;
                        }
                        var needChromeFix = !!chromeVersion && chromeVersion <= 87;
                        if (needChromeFix && mpegLayer === 2 && bitRate >= 224e3 && channelMode === 0) {
                            data[offset + 3] = data[offset + 3] | 128;
                        }
                        return { sampleRate: sampleRate, channelCount: channelCount, frameLength: frameLength, samplesPerFrame: samplesPerFrame };
                    }
                }
                function isHeaderPattern(data, offset) {
                    return data[offset] === 255 && (data[offset + 1] & 224) === 224 && (data[offset + 1] & 6) !== 0;
                }
                function isHeader(data, offset) {
                    return offset + 1 < data.length && isHeaderPattern(data, offset);
                }
                function canParse(data, offset) {
                    var headerSize = 4;
                    return isHeaderPattern(data, offset) && headerSize <= data.length - offset;
                }
                function probe(data, offset) {
                    if (offset + 1 < data.length && isHeaderPattern(data, offset)) {
                        var headerLength = 4;
                        var header = parseHeader(data, offset);
                        var frameLength = headerLength;
                        if (header !== null && header !== void 0 && header.frameLength) {
                            frameLength = header.frameLength;
                        }
                        var newOffset = offset + frameLength;
                        return newOffset === data.length || isHeader(data, newOffset);
                    }
                    return false;
                }
            },
            "./src/demux/sample-aes.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _crypt_decrypter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/crypt/decrypter.ts");
                var _tsdemuxer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/demux/tsdemuxer.ts");
                var SampleAesDecrypter = (function () {
                    function SampleAesDecrypter(observer, config, keyData) {
                        this.keyData = void 0;
                        this.decrypter = void 0;
                        this.keyData = keyData;
                        this.decrypter = new _crypt_decrypter__WEBPACK_IMPORTED_MODULE_0__["default"](observer, config, { removePKCS7Padding: false });
                    }
                    var _proto = SampleAesDecrypter.prototype;
                    _proto.decryptBuffer = function decryptBuffer(encryptedData, callback) {
                        this.decrypter.decrypt(encryptedData, this.keyData.key.buffer, this.keyData.iv.buffer, callback);
                    };
                    _proto.decryptAacSample = function decryptAacSample(samples, sampleIndex, callback, sync) {
                        var curUnit = samples[sampleIndex].unit;
                        if (curUnit.length <= 16) {
                            return;
                        }
                        var encryptedData = curUnit.subarray(16, curUnit.length - (curUnit.length % 16));
                        var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);
                        var localthis = this;
                        this.decryptBuffer(encryptedBuffer, function (decryptedBuffer) {
                            var decryptedData = new Uint8Array(decryptedBuffer);
                            curUnit.set(decryptedData, 16);
                            if (!sync) {
                                localthis.decryptAacSamples(samples, sampleIndex + 1, callback);
                            }
                        });
                    };
                    _proto.decryptAacSamples = function decryptAacSamples(samples, sampleIndex, callback) {
                        for (; ; sampleIndex++) {
                            if (sampleIndex >= samples.length) {
                                callback();
                                return;
                            }
                            if (samples[sampleIndex].unit.length < 32) {
                                continue;
                            }
                            var sync = this.decrypter.isSync();
                            this.decryptAacSample(samples, sampleIndex, callback, sync);
                            if (!sync) {
                                return;
                            }
                        }
                    };
                    _proto.getAvcEncryptedData = function getAvcEncryptedData(decodedData) {
                        var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;
                        var encryptedData = new Int8Array(encryptedDataLen);
                        var outputPos = 0;
                        for (var inputPos = 32; inputPos < decodedData.length - 16; inputPos += 160, outputPos += 16) {
                            encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);
                        }
                        return encryptedData;
                    };
                    _proto.getAvcDecryptedUnit = function getAvcDecryptedUnit(decodedData, decryptedData) {
                        var uint8DecryptedData = new Uint8Array(decryptedData);
                        var inputPos = 0;
                        for (var outputPos = 32; outputPos < decodedData.length - 16; outputPos += 160, inputPos += 16) {
                            decodedData.set(uint8DecryptedData.subarray(inputPos, inputPos + 16), outputPos);
                        }
                        return decodedData;
                    };
                    _proto.decryptAvcSample = function decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync) {
                        var decodedData = Object(_tsdemuxer__WEBPACK_IMPORTED_MODULE_1__["discardEPB"])(curUnit.data);
                        var encryptedData = this.getAvcEncryptedData(decodedData);
                        var localthis = this;
                        this.decryptBuffer(encryptedData.buffer, function (decryptedBuffer) {
                            curUnit.data = localthis.getAvcDecryptedUnit(decodedData, decryptedBuffer);
                            if (!sync) {
                                localthis.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);
                            }
                        });
                    };
                    _proto.decryptAvcSamples = function decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {
                        if (samples instanceof Uint8Array) {
                            throw new Error("Cannot decrypt samples of type Uint8Array");
                        }
                        for (; ; sampleIndex++, unitIndex = 0) {
                            if (sampleIndex >= samples.length) {
                                callback();
                                return;
                            }
                            var curUnits = samples[sampleIndex].units;
                            for (; ; unitIndex++) {
                                if (unitIndex >= curUnits.length) {
                                    break;
                                }
                                var curUnit = curUnits[unitIndex];
                                if (curUnit.data.length <= 48 || (curUnit.type !== 1 && curUnit.type !== 5)) {
                                    continue;
                                }
                                var sync = this.decrypter.isSync();
                                this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync);
                                if (!sync) {
                                    return;
                                }
                            }
                        }
                    };
                    return SampleAesDecrypter;
                })();
                __webpack_exports__["default"] = SampleAesDecrypter;
            },
            "./src/demux/transmuxer-interface.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "default", function () {
                    return TransmuxerInterface;
                });
                var webworkify_webpack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/webworkify-webpack/index.js");
                var webworkify_webpack__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(webworkify_webpack__WEBPACK_IMPORTED_MODULE_0__);
                var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/events.ts");
                var _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/demux/transmuxer.ts");
                var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/utils/logger.ts");
                var _errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/errors.ts");
                var _utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/utils/mediasource-helper.ts");
                var eventemitter3__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./node_modules/eventemitter3/index.js");
                var eventemitter3__WEBPACK_IMPORTED_MODULE_6___default = __webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_6__);
                var MediaSource = Object(_utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_5__["getMediaSource"])() || {
                    isTypeSupported: function isTypeSupported() {
                        return false;
                    },
                };
                var TransmuxerInterface = (function () {
                    function TransmuxerInterface(hls, id, onTransmuxComplete, onFlush) {
                        var _this = this;
                        this.hls = void 0;
                        this.id = void 0;
                        this.observer = void 0;
                        this.frag = null;
                        this.part = null;
                        this.worker = void 0;
                        this.onwmsg = void 0;
                        this.transmuxer = null;
                        this.onTransmuxComplete = void 0;
                        this.onFlush = void 0;
                        this.hls = hls;
                        this.id = id;
                        this.onTransmuxComplete = onTransmuxComplete;
                        this.onFlush = onFlush;
                        var config = hls.config;
                        var forwardMessage = function forwardMessage(ev, data) {
                            data = data || {};
                            data.frag = _this.frag;
                            data.id = _this.id;
                            hls.trigger(ev, data);
                        };
                        this.observer = new eventemitter3__WEBPACK_IMPORTED_MODULE_6__["EventEmitter"]();
                        this.observer.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_DECRYPTED, forwardMessage);
                        this.observer.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, forwardMessage);
                        var typeSupported = { mp4: MediaSource.isTypeSupported("video/mp4"), mpeg: MediaSource.isTypeSupported("audio/mpeg"), mp3: MediaSource.isTypeSupported('audio/mp4; codecs="mp3"') };
                        var vendor = navigator.vendor;
                        if (config.enableWorker && typeof Worker !== "undefined") {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].log("demuxing in webworker");
                            var worker;
                            try {
                                worker = this.worker = webworkify_webpack__WEBPACK_IMPORTED_MODULE_0__("./src/demux/transmuxer-worker.ts");
                                this.onwmsg = this.onWorkerMessage.bind(this);
                                worker.addEventListener("message", this.onwmsg);
                                worker.onerror = function (event) {
                                    hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, {
                                        type: _errors__WEBPACK_IMPORTED_MODULE_4__["ErrorTypes"].OTHER_ERROR,
                                        details: _errors__WEBPACK_IMPORTED_MODULE_4__["ErrorDetails"].INTERNAL_EXCEPTION,
                                        fatal: true,
                                        event: "demuxerWorker",
                                        error: new Error(event.message + "  (" + event.filename + ":" + event.lineno + ")"),
                                    });
                                };
                                worker.postMessage({ cmd: "init", typeSupported: typeSupported, vendor: vendor, id: id, config: JSON.stringify(config) });
                            } catch (err) {
                                _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].warn("Error in worker:", err);
                                _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].error("Error while initializing DemuxerWorker, fallback to inline");
                                if (worker) {
                                    self.URL.revokeObjectURL(worker.objectURL);
                                }
                                this.transmuxer = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__["default"](this.observer, typeSupported, config, vendor, id);
                                this.worker = null;
                            }
                        } else {
                            this.transmuxer = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__["default"](this.observer, typeSupported, config, vendor, id);
                        }
                    }
                    var _proto = TransmuxerInterface.prototype;
                    _proto.destroy = function destroy() {
                        var w = this.worker;
                        if (w) {
                            w.removeEventListener("message", this.onwmsg);
                            w.terminate();
                            this.worker = null;
                            this.onwmsg = undefined;
                        } else {
                            var transmuxer = this.transmuxer;
                            if (transmuxer) {
                                transmuxer.destroy();
                                this.transmuxer = null;
                            }
                        }
                        var observer = this.observer;
                        if (observer) {
                            observer.removeAllListeners();
                        }
                        this.frag = null;
                        this.observer = null;
                        this.hls = null;
                    };
                    _proto.push = function push(data, initSegmentData, audioCodec, videoCodec, frag, part, duration, accurateTimeOffset, chunkMeta, defaultInitPTS) {
                        var _frag$initSegment,
                            _lastFrag$initSegment,
                            _this2 = this;
                        chunkMeta.transmuxing.start = self.performance.now();
                        var transmuxer = this.transmuxer,
                            worker = this.worker;
                        var timeOffset = part ? part.start : frag.start;
                        var decryptdata = frag.decryptdata;
                        var lastFrag = this.frag;
                        var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);
                        var trackSwitch = !(lastFrag && chunkMeta.level === lastFrag.level);
                        var snDiff = lastFrag ? chunkMeta.sn - lastFrag.sn : -1;
                        var partDiff = this.part ? chunkMeta.part - this.part.index : -1;
                        var progressive = snDiff === 0 && chunkMeta.id > 1 && chunkMeta.id === (lastFrag === null || lastFrag === void 0 ? void 0 : lastFrag.stats.chunkCount);
                        var contiguous = !trackSwitch && (snDiff === 1 || (snDiff === 0 && (partDiff === 1 || (progressive && partDiff <= 0))));
                        var now = self.performance.now();
                        if (trackSwitch || snDiff || frag.stats.parsing.start === 0) {
                            frag.stats.parsing.start = now;
                        }
                        if (part && (partDiff || !contiguous)) {
                            part.stats.parsing.start = now;
                        }
                        var initSegmentChange = !(
                            lastFrag &&
                            ((_frag$initSegment = frag.initSegment) === null || _frag$initSegment === void 0 ? void 0 : _frag$initSegment.url) ===
                                ((_lastFrag$initSegment = lastFrag.initSegment) === null || _lastFrag$initSegment === void 0 ? void 0 : _lastFrag$initSegment.url)
                        );
                        var state = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__["TransmuxState"](discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange);
                        if (!contiguous || discontinuity || initSegmentChange) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].log(
                                "[transmuxer-interface, " +
                                    frag.type +
                                    "]: Starting new transmux session for sn: " +
                                    chunkMeta.sn +
                                    " p: " +
                                    chunkMeta.part +
                                    " level: " +
                                    chunkMeta.level +
                                    " id: " +
                                    chunkMeta.id +
                                    "\n        discontinuity: " +
                                    discontinuity +
                                    "\n        trackSwitch: " +
                                    trackSwitch +
                                    "\n        contiguous: " +
                                    contiguous +
                                    "\n        accurateTimeOffset: " +
                                    accurateTimeOffset +
                                    "\n        timeOffset: " +
                                    timeOffset +
                                    "\n        initSegmentChange: " +
                                    initSegmentChange
                            );
                            var config = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__["TransmuxConfig"](audioCodec, videoCodec, initSegmentData, duration, defaultInitPTS);
                            this.configureTransmuxer(config);
                        }
                        this.frag = frag;
                        this.part = part;
                        if (worker) {
                            worker.postMessage({ cmd: "demux", data: data, decryptdata: decryptdata, chunkMeta: chunkMeta, state: state }, data instanceof ArrayBuffer ? [data] : []);
                        } else if (transmuxer) {
                            var _transmuxResult = transmuxer.push(data, decryptdata, chunkMeta, state);
                            if (Object(_demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__["isPromise"])(_transmuxResult)) {
                                _transmuxResult.then(function (data) {
                                    _this2.handleTransmuxComplete(data);
                                });
                            } else {
                                this.handleTransmuxComplete(_transmuxResult);
                            }
                        }
                    };
                    _proto.flush = function flush(chunkMeta) {
                        var _this3 = this;
                        chunkMeta.transmuxing.start = self.performance.now();
                        var transmuxer = this.transmuxer,
                            worker = this.worker;
                        if (worker) {
                            worker.postMessage({ cmd: "flush", chunkMeta: chunkMeta });
                        } else if (transmuxer) {
                            var _transmuxResult2 = transmuxer.flush(chunkMeta);
                            if (Object(_demux_transmuxer__WEBPACK_IMPORTED_MODULE_2__["isPromise"])(_transmuxResult2)) {
                                _transmuxResult2.then(function (data) {
                                    _this3.handleFlushResult(data, chunkMeta);
                                });
                            } else {
                                this.handleFlushResult(_transmuxResult2, chunkMeta);
                            }
                        }
                    };
                    _proto.handleFlushResult = function handleFlushResult(results, chunkMeta) {
                        var _this4 = this;
                        results.forEach(function (result) {
                            _this4.handleTransmuxComplete(result);
                        });
                        this.onFlush(chunkMeta);
                    };
                    _proto.onWorkerMessage = function onWorkerMessage(ev) {
                        var data = ev.data;
                        var hls = this.hls;
                        switch (data.event) {
                            case "init": {
                                self.URL.revokeObjectURL(this.worker.objectURL);
                                break;
                            }
                            case "transmuxComplete": {
                                this.handleTransmuxComplete(data.data);
                                break;
                            }
                            case "flush": {
                                this.onFlush(data.data);
                                break;
                            }
                            case "workerLog":
                                if (_utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"][data.data.logType]) {
                                    _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"][data.data.logType](data.data.message);
                                }
                                break;
                            default: {
                                data.data = data.data || {};
                                data.data.frag = this.frag;
                                data.data.id = this.id;
                                hls.trigger(data.event, data.data);
                                break;
                            }
                        }
                    };
                    _proto.configureTransmuxer = function configureTransmuxer(config) {
                        var worker = this.worker,
                            transmuxer = this.transmuxer;
                        if (worker) {
                            worker.postMessage({ cmd: "configure", config: config });
                        } else if (transmuxer) {
                            transmuxer.configure(config);
                        }
                    };
                    _proto.handleTransmuxComplete = function handleTransmuxComplete(result) {
                        result.chunkMeta.transmuxing.end = self.performance.now();
                        this.onTransmuxComplete(result);
                    };
                    return TransmuxerInterface;
                })();
            },
            "./src/demux/transmuxer-worker.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "default", function () {
                    return TransmuxerWorker;
                });
                var _demux_transmuxer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/demux/transmuxer.ts");
                var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/events.ts");
                var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/logger.ts");
                var eventemitter3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./node_modules/eventemitter3/index.js");
                var eventemitter3__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_3__);
                function TransmuxerWorker(self) {
                    var observer = new eventemitter3__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    var forwardMessage = function forwardMessage(ev, data) {
                        self.postMessage({ event: ev, data: data });
                    };
                    observer.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].FRAG_DECRYPTED, forwardMessage);
                    observer.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, forwardMessage);
                    var forwardWorkerLogs = function forwardWorkerLogs() {
                        var _loop = function _loop(logFn) {
                            var func = function func(message) {
                                forwardMessage("workerLog", { logType: logFn, message: message });
                            };
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"][logFn] = func;
                        };
                        for (var logFn in _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"]) {
                            _loop(logFn);
                        }
                    };
                    self.addEventListener("message", function (ev) {
                        var data = ev.data;
                        switch (data.cmd) {
                            case "init": {
                                var config = JSON.parse(data.config);
                                self.transmuxer = new _demux_transmuxer__WEBPACK_IMPORTED_MODULE_0__["default"](observer, data.typeSupported, config, data.vendor, data.id);
                                Object(_utils_logger__WEBPACK_IMPORTED_MODULE_2__["enableLogs"])(config.debug);
                                forwardWorkerLogs();
                                forwardMessage("init", null);
                                break;
                            }
                            case "configure": {
                                self.transmuxer.configure(data.config);
                                break;
                            }
                            case "demux": {
                                var transmuxResult = self.transmuxer.push(data.data, data.decryptdata, data.chunkMeta, data.state);
                                if (Object(_demux_transmuxer__WEBPACK_IMPORTED_MODULE_0__["isPromise"])(transmuxResult)) {
                                    transmuxResult.then(function (data) {
                                        emitTransmuxComplete(self, data);
                                    });
                                } else {
                                    emitTransmuxComplete(self, transmuxResult);
                                }
                                break;
                            }
                            case "flush": {
                                var id = data.chunkMeta;
                                var _transmuxResult = self.transmuxer.flush(id);
                                if (Object(_demux_transmuxer__WEBPACK_IMPORTED_MODULE_0__["isPromise"])(_transmuxResult)) {
                                    _transmuxResult.then(function (results) {
                                        handleFlushResult(self, results, id);
                                    });
                                } else {
                                    handleFlushResult(self, _transmuxResult, id);
                                }
                                break;
                            }
                            default:
                                break;
                        }
                    });
                }
                function emitTransmuxComplete(self, transmuxResult) {
                    if (isEmptyResult(transmuxResult.remuxResult)) {
                        return false;
                    }
                    var transferable = [];
                    var _transmuxResult$remux = transmuxResult.remuxResult,
                        audio = _transmuxResult$remux.audio,
                        video = _transmuxResult$remux.video;
                    if (audio) {
                        addToTransferable(transferable, audio);
                    }
                    if (video) {
                        addToTransferable(transferable, video);
                    }
                    self.postMessage({ event: "transmuxComplete", data: transmuxResult }, transferable);
                    return true;
                }
                function addToTransferable(transferable, track) {
                    if (track.data1) {
                        transferable.push(track.data1.buffer);
                    }
                    if (track.data2) {
                        transferable.push(track.data2.buffer);
                    }
                }
                function handleFlushResult(self, results, chunkMeta) {
                    var parsed = results.reduce(function (parsed, result) {
                        return emitTransmuxComplete(self, result) || parsed;
                    }, false);
                    if (!parsed) {
                        self.postMessage({ event: "transmuxComplete", data: results[0] });
                    }
                    self.postMessage({ event: "flush", data: chunkMeta });
                }
                function isEmptyResult(remuxResult) {
                    return !remuxResult.audio && !remuxResult.video && !remuxResult.text && !remuxResult.id3 && !remuxResult.initSegment;
                }
            },
            "./src/demux/transmuxer.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "default", function () {
                    return Transmuxer;
                });
                __webpack_require__.d(__webpack_exports__, "isPromise", function () {
                    return isPromise;
                });
                __webpack_require__.d(__webpack_exports__, "TransmuxConfig", function () {
                    return TransmuxConfig;
                });
                __webpack_require__.d(__webpack_exports__, "TransmuxState", function () {
                    return TransmuxState;
                });
                var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/events.ts");
                var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/errors.ts");
                var _crypt_decrypter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/crypt/decrypter.ts");
                var _demux_aacdemuxer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/demux/aacdemuxer.ts");
                var _demux_mp4demuxer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/demux/mp4demuxer.ts");
                var _demux_tsdemuxer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/demux/tsdemuxer.ts");
                var _demux_mp3demuxer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/demux/mp3demuxer.ts");
                var _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/remux/mp4-remuxer.ts");
                var _remux_passthrough_remuxer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./src/remux/passthrough-remuxer.ts");
                var _utils_logger__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./src/utils/logger.ts");
                var now;
                try {
                    now = self.performance.now.bind(self.performance);
                } catch (err) {
                    _utils_logger__WEBPACK_IMPORTED_MODULE_9__["logger"].debug("Unable to use Performance API on this environment");
                    now = self.Date.now;
                }
                var muxConfig = [
                    { demux: _demux_tsdemuxer__WEBPACK_IMPORTED_MODULE_5__["default"], remux: _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_7__["default"] },
                    { demux: _demux_mp4demuxer__WEBPACK_IMPORTED_MODULE_4__["default"], remux: _remux_passthrough_remuxer__WEBPACK_IMPORTED_MODULE_8__["default"] },
                    { demux: _demux_aacdemuxer__WEBPACK_IMPORTED_MODULE_3__["default"], remux: _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_7__["default"] },
                    { demux: _demux_mp3demuxer__WEBPACK_IMPORTED_MODULE_6__["default"], remux: _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_7__["default"] },
                ];
                var Transmuxer = (function () {
                    function Transmuxer(observer, typeSupported, config, vendor, id) {
                        this.observer = void 0;
                        this.typeSupported = void 0;
                        this.config = void 0;
                        this.vendor = void 0;
                        this.id = void 0;
                        this.demuxer = void 0;
                        this.remuxer = void 0;
                        this.decrypter = void 0;
                        this.probe = void 0;
                        this.decryptionPromise = null;
                        this.transmuxConfig = void 0;
                        this.currentTransmuxState = void 0;
                        this.observer = observer;
                        this.typeSupported = typeSupported;
                        this.config = config;
                        this.vendor = vendor;
                        this.id = id;
                    }
                    var _proto = Transmuxer.prototype;
                    _proto.configure = function configure(transmuxConfig) {
                        this.transmuxConfig = transmuxConfig;
                        if (this.decrypter) {
                            this.decrypter.reset();
                        }
                    };
                    _proto.push = function push(data, decryptdata, chunkMeta, state) {
                        var _this = this;
                        var stats = chunkMeta.transmuxing;
                        stats.executeStart = now();
                        var uintData = new Uint8Array(data);
                        var config = this.config,
                            currentTransmuxState = this.currentTransmuxState,
                            transmuxConfig = this.transmuxConfig;
                        if (state) {
                            this.currentTransmuxState = state;
                        }
                        var _ref = state || currentTransmuxState,
                            contiguous = _ref.contiguous,
                            discontinuity = _ref.discontinuity,
                            trackSwitch = _ref.trackSwitch,
                            accurateTimeOffset = _ref.accurateTimeOffset,
                            timeOffset = _ref.timeOffset,
                            initSegmentChange = _ref.initSegmentChange;
                        var audioCodec = transmuxConfig.audioCodec,
                            videoCodec = transmuxConfig.videoCodec,
                            defaultInitPts = transmuxConfig.defaultInitPts,
                            duration = transmuxConfig.duration,
                            initSegmentData = transmuxConfig.initSegmentData;
                        if (discontinuity || trackSwitch || initSegmentChange) {
                            this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration);
                        }
                        if (discontinuity || initSegmentChange) {
                            this.resetInitialTimestamp(defaultInitPts);
                        }
                        if (!contiguous) {
                            this.resetContiguity();
                        }
                        var keyData = getEncryptionType(uintData, decryptdata);
                        if (keyData && keyData.method === "AES-128") {
                            var decrypter = this.getDecrypter();
                            if (config.enableSoftwareAES) {
                                var decryptedData = decrypter.softwareDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer);
                                if (!decryptedData) {
                                    stats.executeEnd = now();
                                    return emptyResult(chunkMeta);
                                }
                                uintData = new Uint8Array(decryptedData);
                            } else {
                                this.decryptionPromise = decrypter.webCryptoDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer).then(function (decryptedData) {
                                    var result = _this.push(decryptedData, null, chunkMeta);
                                    _this.decryptionPromise = null;
                                    return result;
                                });
                                return this.decryptionPromise;
                            }
                        }
                        if (this.needsProbing(uintData, discontinuity, trackSwitch)) {
                            this.configureTransmuxer(uintData, transmuxConfig);
                        }
                        var result = this.transmux(uintData, keyData, timeOffset, accurateTimeOffset, chunkMeta);
                        var currentState = this.currentTransmuxState;
                        currentState.contiguous = true;
                        currentState.discontinuity = false;
                        currentState.trackSwitch = false;
                        stats.executeEnd = now();
                        return result;
                    };
                    _proto.flush = function flush(chunkMeta) {
                        var _this2 = this;
                        var stats = chunkMeta.transmuxing;
                        stats.executeStart = now();
                        var decrypter = this.decrypter,
                            currentTransmuxState = this.currentTransmuxState,
                            decryptionPromise = this.decryptionPromise;
                        if (decryptionPromise) {
                            return decryptionPromise.then(function () {
                                return _this2.flush(chunkMeta);
                            });
                        }
                        var transmuxResults = [];
                        var timeOffset = currentTransmuxState.timeOffset;
                        if (decrypter) {
                            var decryptedData = decrypter.flush();
                            if (decryptedData) {
                                transmuxResults.push(this.push(decryptedData, null, chunkMeta));
                            }
                        }
                        var demuxer = this.demuxer,
                            remuxer = this.remuxer;
                        if (!demuxer || !remuxer) {
                            this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, _events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, {
                                type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].MEDIA_ERROR,
                                details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].FRAG_PARSING_ERROR,
                                fatal: true,
                                reason: "no demux matching with content found",
                            });
                            stats.executeEnd = now();
                            return [emptyResult(chunkMeta)];
                        }
                        var demuxResultOrPromise = demuxer.flush(timeOffset);
                        if (isPromise(demuxResultOrPromise)) {
                            return demuxResultOrPromise.then(function (demuxResult) {
                                _this2.flushRemux(transmuxResults, demuxResult, chunkMeta);
                                return transmuxResults;
                            });
                        }
                        this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);
                        return transmuxResults;
                    };
                    _proto.flushRemux = function flushRemux(transmuxResults, demuxResult, chunkMeta) {
                        var audioTrack = demuxResult.audioTrack,
                            videoTrack = demuxResult.videoTrack,
                            id3Track = demuxResult.id3Track,
                            textTrack = demuxResult.textTrack;
                        var _this$currentTransmux = this.currentTransmuxState,
                            accurateTimeOffset = _this$currentTransmux.accurateTimeOffset,
                            timeOffset = _this$currentTransmux.timeOffset;
                        _utils_logger__WEBPACK_IMPORTED_MODULE_9__["logger"].log("[transmuxer.ts]: Flushed fragment " + chunkMeta.sn + (chunkMeta.part > -1 ? " p: " + chunkMeta.part : "") + " of level " + chunkMeta.level);
                        var remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, true, this.id);
                        transmuxResults.push({ remuxResult: remuxResult, chunkMeta: chunkMeta });
                        chunkMeta.transmuxing.executeEnd = now();
                    };
                    _proto.resetInitialTimestamp = function resetInitialTimestamp(defaultInitPts) {
                        var demuxer = this.demuxer,
                            remuxer = this.remuxer;
                        if (!demuxer || !remuxer) {
                            return;
                        }
                        demuxer.resetTimeStamp(defaultInitPts);
                        remuxer.resetTimeStamp(defaultInitPts);
                    };
                    _proto.resetContiguity = function resetContiguity() {
                        var demuxer = this.demuxer,
                            remuxer = this.remuxer;
                        if (!demuxer || !remuxer) {
                            return;
                        }
                        demuxer.resetContiguity();
                        remuxer.resetNextTimestamp();
                    };
                    _proto.resetInitSegment = function resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration) {
                        var demuxer = this.demuxer,
                            remuxer = this.remuxer;
                        if (!demuxer || !remuxer) {
                            return;
                        }
                        demuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration);
                        remuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec);
                    };
                    _proto.destroy = function destroy() {
                        if (this.demuxer) {
                            this.demuxer.destroy();
                            this.demuxer = undefined;
                        }
                        if (this.remuxer) {
                            this.remuxer.destroy();
                            this.remuxer = undefined;
                        }
                    };
                    _proto.transmux = function transmux(data, keyData, timeOffset, accurateTimeOffset, chunkMeta) {
                        var result;
                        if (keyData && keyData.method === "SAMPLE-AES") {
                            result = this.transmuxSampleAes(data, keyData, timeOffset, accurateTimeOffset, chunkMeta);
                        } else {
                            result = this.transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta);
                        }
                        return result;
                    };
                    _proto.transmuxUnencrypted = function transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta) {
                        var _demux = this.demuxer.demux(data, timeOffset, false, !this.config.progressive),
                            audioTrack = _demux.audioTrack,
                            videoTrack = _demux.videoTrack,
                            id3Track = _demux.id3Track,
                            textTrack = _demux.textTrack;
                        var remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, false, this.id);
                        return { remuxResult: remuxResult, chunkMeta: chunkMeta };
                    };
                    _proto.transmuxSampleAes = function transmuxSampleAes(data, decryptData, timeOffset, accurateTimeOffset, chunkMeta) {
                        var _this3 = this;
                        return this.demuxer.demuxSampleAes(data, decryptData, timeOffset).then(function (demuxResult) {
                            var remuxResult = _this3.remuxer.remux(demuxResult.audioTrack, demuxResult.videoTrack, demuxResult.id3Track, demuxResult.textTrack, timeOffset, accurateTimeOffset, false, _this3.id);
                            return { remuxResult: remuxResult, chunkMeta: chunkMeta };
                        });
                    };
                    _proto.configureTransmuxer = function configureTransmuxer(data, transmuxConfig) {
                        var config = this.config,
                            observer = this.observer,
                            typeSupported = this.typeSupported,
                            vendor = this.vendor;
                        var audioCodec = transmuxConfig.audioCodec,
                            defaultInitPts = transmuxConfig.defaultInitPts,
                            duration = transmuxConfig.duration,
                            initSegmentData = transmuxConfig.initSegmentData,
                            videoCodec = transmuxConfig.videoCodec;
                        var mux;
                        for (var i = 0, len = muxConfig.length; i < len; i++) {
                            if (muxConfig[i].demux.probe(data)) {
                                mux = muxConfig[i];
                                break;
                            }
                        }
                        if (!mux) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_9__["logger"].warn("Failed to find demuxer by probing frag, treating as mp4 passthrough");
                            mux = { demux: _demux_mp4demuxer__WEBPACK_IMPORTED_MODULE_4__["default"], remux: _remux_passthrough_remuxer__WEBPACK_IMPORTED_MODULE_8__["default"] };
                        }
                        var demuxer = this.demuxer;
                        var remuxer = this.remuxer;
                        var Remuxer = mux.remux;
                        var Demuxer = mux.demux;
                        if (!remuxer || !(remuxer instanceof Remuxer)) {
                            this.remuxer = new Remuxer(observer, config, typeSupported, vendor);
                        }
                        if (!demuxer || !(demuxer instanceof Demuxer)) {
                            this.demuxer = new Demuxer(observer, config, typeSupported);
                            this.probe = Demuxer.probe;
                        }
                        this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration);
                        this.resetInitialTimestamp(defaultInitPts);
                    };
                    _proto.needsProbing = function needsProbing(data, discontinuity, trackSwitch) {
                        return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;
                    };
                    _proto.getDecrypter = function getDecrypter() {
                        var decrypter = this.decrypter;
                        if (!decrypter) {
                            decrypter = this.decrypter = new _crypt_decrypter__WEBPACK_IMPORTED_MODULE_2__["default"](this.observer, this.config);
                        }
                        return decrypter;
                    };
                    return Transmuxer;
                })();
                function getEncryptionType(data, decryptData) {
                    var encryptionType = null;
                    if (data.byteLength > 0 && decryptData != null && decryptData.key != null && decryptData.iv !== null && decryptData.method != null) {
                        encryptionType = decryptData;
                    }
                    return encryptionType;
                }
                var emptyResult = function emptyResult(chunkMeta) {
                    return { remuxResult: {}, chunkMeta: chunkMeta };
                };
                function isPromise(p) {
                    return "then" in p && p.then instanceof Function;
                }
                var TransmuxConfig = function TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPts) {
                    this.audioCodec = void 0;
                    this.videoCodec = void 0;
                    this.initSegmentData = void 0;
                    this.duration = void 0;
                    this.defaultInitPts = void 0;
                    this.audioCodec = audioCodec;
                    this.videoCodec = videoCodec;
                    this.initSegmentData = initSegmentData;
                    this.duration = duration;
                    this.defaultInitPts = defaultInitPts;
                };
                var TransmuxState = function TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange) {
                    this.discontinuity = void 0;
                    this.contiguous = void 0;
                    this.accurateTimeOffset = void 0;
                    this.trackSwitch = void 0;
                    this.timeOffset = void 0;
                    this.initSegmentChange = void 0;
                    this.discontinuity = discontinuity;
                    this.contiguous = contiguous;
                    this.accurateTimeOffset = accurateTimeOffset;
                    this.trackSwitch = trackSwitch;
                    this.timeOffset = timeOffset;
                    this.initSegmentChange = initSegmentChange;
                };
            },
            "./src/demux/tsdemuxer.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "discardEPB", function () {
                    return discardEPB;
                });
                var _adts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/demux/adts.ts");
                var _mpegaudio__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/demux/mpegaudio.ts");
                var _exp_golomb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/demux/exp-golomb.ts");
                var _sample_aes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/demux/sample-aes.ts");
                var _events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/events.ts");
                var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/utils/mp4-tools.ts");
                var _utils_logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/utils/logger.ts");
                var _errors__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/errors.ts");
                var _types_demuxer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./src/types/demuxer.ts");
                function _extends() {
                    _extends = Object.assign
                        ? Object.assign.bind()
                        : function (target) {
                              for (var i = 1; i < arguments.length; i++) {
                                  var source = arguments[i];
                                  for (var key in source) {
                                      if (Object.prototype.hasOwnProperty.call(source, key)) {
                                          target[key] = source[key];
                                      }
                                  }
                              }
                              return target;
                          };
                    return _extends.apply(this, arguments);
                }
                var TSDemuxer = (function () {
                    function TSDemuxer(observer, config, typeSupported) {
                        this.observer = void 0;
                        this.config = void 0;
                        this.typeSupported = void 0;
                        this.sampleAes = null;
                        this.pmtParsed = false;
                        this.audioCodec = void 0;
                        this.videoCodec = void 0;
                        this._duration = 0;
                        this._pmtId = -1;
                        this._avcTrack = void 0;
                        this._audioTrack = void 0;
                        this._id3Track = void 0;
                        this._txtTrack = void 0;
                        this.aacOverFlow = null;
                        this.avcSample = null;
                        this.remainderData = null;
                        this.observer = observer;
                        this.config = config;
                        this.typeSupported = typeSupported;
                    }
                    TSDemuxer.probe = function probe(data) {
                        return data[0] === 71 && data[188] === 71;
                    };
                    TSDemuxer.createTrack = function createTrack(type, duration) {
                        return {
                            container: type === "video" || type === "audio" ? "video/mp2t" : undefined,
                            type: type,
                            id: _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_5__["RemuxerTrackIdConfig"][type],
                            pid: -1,
                            inputTimeScale: 9e4,
                            sequenceNumber: 0,
                            samples: [],
                            dropped: 0,
                            duration: type === "audio" ? duration : undefined,
                        };
                    };
                    var _proto = TSDemuxer.prototype;
                    _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
                        this.pmtParsed = false;
                        this._pmtId = -1;
                        this._avcTrack = TSDemuxer.createTrack("video");
                        this._audioTrack = TSDemuxer.createTrack("audio", trackDuration);
                        this._id3Track = TSDemuxer.createTrack("id3");
                        this._txtTrack = TSDemuxer.createTrack("text");
                        this._audioTrack.segmentCodec = "aac";
                        this.aacOverFlow = null;
                        this.avcSample = null;
                        this.remainderData = null;
                        this.audioCodec = audioCodec;
                        this.videoCodec = videoCodec;
                        this._duration = trackDuration;
                    };
                    _proto.resetTimeStamp = function resetTimeStamp() {};
                    _proto.resetContiguity = function resetContiguity() {
                        var _audioTrack = this._audioTrack,
                            _avcTrack = this._avcTrack,
                            _id3Track = this._id3Track;
                        if (_audioTrack) {
                            _audioTrack.pesData = null;
                        }
                        if (_avcTrack) {
                            _avcTrack.pesData = null;
                        }
                        if (_id3Track) {
                            _id3Track.pesData = null;
                        }
                        this.aacOverFlow = null;
                    };
                    _proto.demux = function demux(data, timeOffset, isSampleAes, flush) {
                        if (isSampleAes === void 0) {
                            isSampleAes = false;
                        }
                        if (flush === void 0) {
                            flush = false;
                        }
                        if (!isSampleAes) {
                            this.sampleAes = null;
                        }
                        var pes;
                        var videoTrack = this._avcTrack;
                        var audioTrack = this._audioTrack;
                        var id3Track = this._id3Track;
                        var textTrack = this._txtTrack;
                        var avcId = videoTrack.pid;
                        var avcData = videoTrack.pesData;
                        var audioId = audioTrack.pid;
                        var id3Id = id3Track.pid;
                        var audioData = audioTrack.pesData;
                        var id3Data = id3Track.pesData;
                        var unknownPID = null;
                        var pmtParsed = this.pmtParsed;
                        var pmtId = this._pmtId;
                        var len = data.length;
                        if (this.remainderData) {
                            data = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_5__["appendUint8Array"])(this.remainderData, data);
                            len = data.length;
                            this.remainderData = null;
                        }
                        if (len < 188 && !flush) {
                            this.remainderData = data;
                            return { audioTrack: audioTrack, videoTrack: videoTrack, id3Track: id3Track, textTrack: textTrack };
                        }
                        len -= len % 188;
                        if (len < data.byteLength && !flush) {
                            this.remainderData = new Uint8Array(data.buffer, len, data.buffer.byteLength - len);
                        }
                        var tsPacketErrors = 0;
                        for (var start = 0; start < len; start += 188) {
                            if (data[start] === 71) {
                                var stt = !!(data[start + 1] & 64);
                                var pid = ((data[start + 1] & 31) << 8) + data[start + 2];
                                var atf = (data[start + 3] & 48) >> 4;
                                var offset = void 0;
                                if (atf > 1) {
                                    offset = start + 5 + data[start + 4];
                                    if (offset === start + 188) {
                                        continue;
                                    }
                                } else {
                                    offset = start + 4;
                                }
                                switch (pid) {
                                    case avcId:
                                        if (stt) {
                                            if (avcData && (pes = parsePES(avcData))) {
                                                this.parseAVCPES(videoTrack, textTrack, pes, false);
                                            }
                                            avcData = { data: [], size: 0 };
                                        }
                                        if (avcData) {
                                            avcData.data.push(data.subarray(offset, start + 188));
                                            avcData.size += start + 188 - offset;
                                        }
                                        break;
                                    case audioId:
                                        if (stt) {
                                            if (audioData && (pes = parsePES(audioData))) {
                                                switch (audioTrack.segmentCodec) {
                                                    case "aac":
                                                        this.parseAACPES(audioTrack, pes);
                                                        break;
                                                    case "mp3":
                                                        this.parseMPEGPES(audioTrack, pes);
                                                        break;
                                                }
                                            }
                                            audioData = { data: [], size: 0 };
                                        }
                                        if (audioData) {
                                            audioData.data.push(data.subarray(offset, start + 188));
                                            audioData.size += start + 188 - offset;
                                        }
                                        break;
                                    case id3Id:
                                        if (stt) {
                                            if (id3Data && (pes = parsePES(id3Data))) {
                                                this.parseID3PES(id3Track, pes);
                                            }
                                            id3Data = { data: [], size: 0 };
                                        }
                                        if (id3Data) {
                                            id3Data.data.push(data.subarray(offset, start + 188));
                                            id3Data.size += start + 188 - offset;
                                        }
                                        break;
                                    case 0:
                                        if (stt) {
                                            offset += data[offset] + 1;
                                        }
                                        pmtId = this._pmtId = parsePAT(data, offset);
                                        break;
                                    case pmtId: {
                                        if (stt) {
                                            offset += data[offset] + 1;
                                        }
                                        var parsedPIDs = parsePMT(data, offset, this.typeSupported, isSampleAes);
                                        avcId = parsedPIDs.avc;
                                        if (avcId > 0) {
                                            videoTrack.pid = avcId;
                                        }
                                        audioId = parsedPIDs.audio;
                                        if (audioId > 0) {
                                            audioTrack.pid = audioId;
                                            audioTrack.segmentCodec = parsedPIDs.segmentCodec;
                                        }
                                        id3Id = parsedPIDs.id3;
                                        if (id3Id > 0) {
                                            id3Track.pid = id3Id;
                                        }
                                        if (unknownPID !== null && !pmtParsed) {
                                            _utils_logger__WEBPACK_IMPORTED_MODULE_6__["logger"].log("unknown PID '" + unknownPID + "' in TS found");
                                            unknownPID = null;
                                        }
                                        pmtParsed = this.pmtParsed = true;
                                        break;
                                    }
                                    case 17:
                                    case 8191:
                                        break;
                                    default:
                                        unknownPID = pid;
                                        break;
                                }
                            } else {
                                tsPacketErrors++;
                            }
                        }
                        if (tsPacketErrors > 0) {
                            this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_4__["Events"].ERROR, _events__WEBPACK_IMPORTED_MODULE_4__["Events"].ERROR, {
                                type: _errors__WEBPACK_IMPORTED_MODULE_7__["ErrorTypes"].MEDIA_ERROR,
                                details: _errors__WEBPACK_IMPORTED_MODULE_7__["ErrorDetails"].FRAG_PARSING_ERROR,
                                fatal: false,
                                reason: "Found " + tsPacketErrors + " TS packet/s that do not start with 0x47",
                            });
                        }
                        videoTrack.pesData = avcData;
                        audioTrack.pesData = audioData;
                        id3Track.pesData = id3Data;
                        var demuxResult = { audioTrack: audioTrack, videoTrack: videoTrack, id3Track: id3Track, textTrack: textTrack };
                        if (flush) {
                            this.extractRemainingSamples(demuxResult);
                        }
                        return demuxResult;
                    };
                    _proto.flush = function flush() {
                        var remainderData = this.remainderData;
                        this.remainderData = null;
                        var result;
                        if (remainderData) {
                            result = this.demux(remainderData, -1, false, true);
                        } else {
                            result = { videoTrack: this._avcTrack, audioTrack: this._audioTrack, id3Track: this._id3Track, textTrack: this._txtTrack };
                        }
                        this.extractRemainingSamples(result);
                        if (this.sampleAes) {
                            return this.decrypt(result, this.sampleAes);
                        }
                        return result;
                    };
                    _proto.extractRemainingSamples = function extractRemainingSamples(demuxResult) {
                        var audioTrack = demuxResult.audioTrack,
                            videoTrack = demuxResult.videoTrack,
                            id3Track = demuxResult.id3Track,
                            textTrack = demuxResult.textTrack;
                        var avcData = videoTrack.pesData;
                        var audioData = audioTrack.pesData;
                        var id3Data = id3Track.pesData;
                        var pes;
                        if (avcData && (pes = parsePES(avcData))) {
                            this.parseAVCPES(videoTrack, textTrack, pes, true);
                            videoTrack.pesData = null;
                        } else {
                            videoTrack.pesData = avcData;
                        }
                        if (audioData && (pes = parsePES(audioData))) {
                            switch (audioTrack.segmentCodec) {
                                case "aac":
                                    this.parseAACPES(audioTrack, pes);
                                    break;
                                case "mp3":
                                    this.parseMPEGPES(audioTrack, pes);
                                    break;
                            }
                            audioTrack.pesData = null;
                        } else {
                            if (audioData !== null && audioData !== void 0 && audioData.size) {
                                _utils_logger__WEBPACK_IMPORTED_MODULE_6__["logger"].log("last AAC PES packet truncated,might overlap between fragments");
                            }
                            audioTrack.pesData = audioData;
                        }
                        if (id3Data && (pes = parsePES(id3Data))) {
                            this.parseID3PES(id3Track, pes);
                            id3Track.pesData = null;
                        } else {
                            id3Track.pesData = id3Data;
                        }
                    };
                    _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {
                        var demuxResult = this.demux(data, timeOffset, true, !this.config.progressive);
                        var sampleAes = (this.sampleAes = new _sample_aes__WEBPACK_IMPORTED_MODULE_3__["default"](this.observer, this.config, keyData));
                        return this.decrypt(demuxResult, sampleAes);
                    };
                    _proto.decrypt = function decrypt(demuxResult, sampleAes) {
                        return new Promise(function (resolve) {
                            var audioTrack = demuxResult.audioTrack,
                                videoTrack = demuxResult.videoTrack;
                            if (audioTrack.samples && audioTrack.segmentCodec === "aac") {
                                sampleAes.decryptAacSamples(audioTrack.samples, 0, function () {
                                    if (videoTrack.samples) {
                                        sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {
                                            resolve(demuxResult);
                                        });
                                    } else {
                                        resolve(demuxResult);
                                    }
                                });
                            } else if (videoTrack.samples) {
                                sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {
                                    resolve(demuxResult);
                                });
                            }
                        });
                    };
                    _proto.destroy = function destroy() {
                        this._duration = 0;
                    };
                    _proto.parseAVCPES = function parseAVCPES(track, textTrack, pes, last) {
                        var _this = this;
                        var units = this.parseAVCNALu(track, pes.data);
                        var debug = false;
                        var avcSample = this.avcSample;
                        var push;
                        var spsfound = false;
                        pes.data = null;
                        if (avcSample && units.length && !track.audFound) {
                            pushAccessUnit(avcSample, track);
                            avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, "");
                        }
                        units.forEach(function (unit) {
                            switch (unit.type) {
                                case 1: {
                                    push = true;
                                    if (!avcSample) {
                                        avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, "");
                                    }
                                    if (debug) {
                                        avcSample.debug += "NDR ";
                                    }
                                    avcSample.frame = true;
                                    var data = unit.data;
                                    if (spsfound && data.length > 4) {
                                        var sliceType = new _exp_golomb__WEBPACK_IMPORTED_MODULE_2__["default"](data).readSliceType();
                                        if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {
                                            avcSample.key = true;
                                        }
                                    }
                                    break;
                                }
                                case 5:
                                    push = true;
                                    if (!avcSample) {
                                        avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, "");
                                    }
                                    if (debug) {
                                        avcSample.debug += "IDR ";
                                    }
                                    avcSample.key = true;
                                    avcSample.frame = true;
                                    break;
                                case 6: {
                                    push = true;
                                    if (debug && avcSample) {
                                        avcSample.debug += "SEI ";
                                    }
                                    Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_5__["parseSEIMessageFromNALu"])(discardEPB(unit.data), pes.pts, textTrack.samples);
                                    break;
                                }
                                case 7:
                                    push = true;
                                    spsfound = true;
                                    if (debug && avcSample) {
                                        avcSample.debug += "SPS ";
                                    }
                                    if (!track.sps) {
                                        var expGolombDecoder = new _exp_golomb__WEBPACK_IMPORTED_MODULE_2__["default"](unit.data);
                                        var config = expGolombDecoder.readSPS();
                                        track.width = config.width;
                                        track.height = config.height;
                                        track.pixelRatio = config.pixelRatio;
                                        track.sps = [unit.data];
                                        track.duration = _this._duration;
                                        var codecarray = unit.data.subarray(1, 4);
                                        var codecstring = "avc1.";
                                        for (var i = 0; i < 3; i++) {
                                            var h = codecarray[i].toString(16);
                                            if (h.length < 2) {
                                                h = "0" + h;
                                            }
                                            codecstring += h;
                                        }
                                        track.codec = codecstring;
                                    }
                                    break;
                                case 8:
                                    push = true;
                                    if (debug && avcSample) {
                                        avcSample.debug += "PPS ";
                                    }
                                    if (!track.pps) {
                                        track.pps = [unit.data];
                                    }
                                    break;
                                case 9:
                                    push = false;
                                    track.audFound = true;
                                    if (avcSample) {
                                        pushAccessUnit(avcSample, track);
                                    }
                                    avcSample = _this.avcSample = createAVCSample(false, pes.pts, pes.dts, debug ? "AUD " : "");
                                    break;
                                case 12:
                                    push = true;
                                    break;
                                default:
                                    push = false;
                                    if (avcSample) {
                                        avcSample.debug += "unknown NAL " + unit.type + " ";
                                    }
                                    break;
                            }
                            if (avcSample && push) {
                                var _units = avcSample.units;
                                _units.push(unit);
                            }
                        });
                        if (last && avcSample) {
                            pushAccessUnit(avcSample, track);
                            this.avcSample = null;
                        }
                    };
                    _proto.getLastNalUnit = function getLastNalUnit(samples) {
                        var _avcSample;
                        var avcSample = this.avcSample;
                        var lastUnit;
                        if (!avcSample || avcSample.units.length === 0) {
                            avcSample = samples[samples.length - 1];
                        }
                        if ((_avcSample = avcSample) !== null && _avcSample !== void 0 && _avcSample.units) {
                            var units = avcSample.units;
                            lastUnit = units[units.length - 1];
                        }
                        return lastUnit;
                    };
                    _proto.parseAVCNALu = function parseAVCNALu(track, array) {
                        var len = array.byteLength;
                        var state = track.naluState || 0;
                        var lastState = state;
                        var units = [];
                        var i = 0;
                        var value;
                        var overflow;
                        var unitType;
                        var lastUnitStart = -1;
                        var lastUnitType = 0;
                        if (state === -1) {
                            lastUnitStart = 0;
                            lastUnitType = array[0] & 31;
                            state = 0;
                            i = 1;
                        }
                        while (i < len) {
                            value = array[i++];
                            if (!state) {
                                state = value ? 0 : 1;
                                continue;
                            }
                            if (state === 1) {
                                state = value ? 0 : 2;
                                continue;
                            }
                            if (!value) {
                                state = 3;
                            } else if (value === 1) {
                                if (lastUnitStart >= 0) {
                                    var unit = { data: array.subarray(lastUnitStart, i - state - 1), type: lastUnitType };
                                    units.push(unit);
                                } else {
                                    var lastUnit = this.getLastNalUnit(track.samples);
                                    if (lastUnit) {
                                        if (lastState && i <= 4 - lastState) {
                                            if (lastUnit.state) {
                                                lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
                                            }
                                        }
                                        overflow = i - state - 1;
                                        if (overflow > 0) {
                                            var tmp = new Uint8Array(lastUnit.data.byteLength + overflow);
                                            tmp.set(lastUnit.data, 0);
                                            tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);
                                            lastUnit.data = tmp;
                                            lastUnit.state = 0;
                                        }
                                    }
                                }
                                if (i < len) {
                                    unitType = array[i] & 31;
                                    lastUnitStart = i;
                                    lastUnitType = unitType;
                                    state = 0;
                                } else {
                                    state = -1;
                                }
                            } else {
                                state = 0;
                            }
                        }
                        if (lastUnitStart >= 0 && state >= 0) {
                            var _unit = { data: array.subarray(lastUnitStart, len), type: lastUnitType, state: state };
                            units.push(_unit);
                        }
                        if (units.length === 0) {
                            var _lastUnit = this.getLastNalUnit(track.samples);
                            if (_lastUnit) {
                                var _tmp = new Uint8Array(_lastUnit.data.byteLength + array.byteLength);
                                _tmp.set(_lastUnit.data, 0);
                                _tmp.set(array, _lastUnit.data.byteLength);
                                _lastUnit.data = _tmp;
                            }
                        }
                        track.naluState = state;
                        return units;
                    };
                    _proto.parseAACPES = function parseAACPES(track, pes) {
                        var startOffset = 0;
                        var aacOverFlow = this.aacOverFlow;
                        var data = pes.data;
                        if (aacOverFlow) {
                            this.aacOverFlow = null;
                            var frameMissingBytes = aacOverFlow.missing;
                            var sampleLength = aacOverFlow.sample.unit.byteLength;
                            if (frameMissingBytes === -1) {
                                var tmp = new Uint8Array(sampleLength + data.byteLength);
                                tmp.set(aacOverFlow.sample.unit, 0);
                                tmp.set(data, sampleLength);
                                data = tmp;
                            } else {
                                var frameOverflowBytes = sampleLength - frameMissingBytes;
                                aacOverFlow.sample.unit.set(data.subarray(0, frameMissingBytes), frameOverflowBytes);
                                track.samples.push(aacOverFlow.sample);
                                startOffset = aacOverFlow.missing;
                            }
                        }
                        var offset;
                        var len;
                        for (offset = startOffset, len = data.length; offset < len - 1; offset++) {
                            if (_adts__WEBPACK_IMPORTED_MODULE_0__["isHeader"](data, offset)) {
                                break;
                            }
                        }
                        if (offset !== startOffset) {
                            var reason;
                            var fatal;
                            if (offset < len - 1) {
                                reason = "AAC PES did not start with ADTS header,offset:" + offset;
                                fatal = false;
                            } else {
                                reason = "no ADTS header found in AAC PES";
                                fatal = true;
                            }
                            _utils_logger__WEBPACK_IMPORTED_MODULE_6__["logger"].warn("parsing error:" + reason);
                            this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_4__["Events"].ERROR, _events__WEBPACK_IMPORTED_MODULE_4__["Events"].ERROR, {
                                type: _errors__WEBPACK_IMPORTED_MODULE_7__["ErrorTypes"].MEDIA_ERROR,
                                details: _errors__WEBPACK_IMPORTED_MODULE_7__["ErrorDetails"].FRAG_PARSING_ERROR,
                                fatal: fatal,
                                reason: reason,
                            });
                            if (fatal) {
                                return;
                            }
                        }
                        _adts__WEBPACK_IMPORTED_MODULE_0__["initTrackConfig"](track, this.observer, data, offset, this.audioCodec);
                        var pts;
                        if (pes.pts !== undefined) {
                            pts = pes.pts;
                        } else if (aacOverFlow) {
                            var frameDuration = _adts__WEBPACK_IMPORTED_MODULE_0__["getFrameDuration"](track.samplerate);
                            pts = aacOverFlow.sample.pts + frameDuration;
                        } else {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_6__["logger"].warn("[tsdemuxer]: AAC PES unknown PTS");
                            return;
                        }
                        var frameIndex = 0;
                        var frame;
                        while (offset < len) {
                            frame = _adts__WEBPACK_IMPORTED_MODULE_0__["appendFrame"](track, data, offset, pts, frameIndex);
                            offset += frame.length;
                            if (!frame.missing) {
                                frameIndex++;
                                for (; offset < len - 1; offset++) {
                                    if (_adts__WEBPACK_IMPORTED_MODULE_0__["isHeader"](data, offset)) {
                                        break;
                                    }
                                }
                            } else {
                                this.aacOverFlow = frame;
                                break;
                            }
                        }
                    };
                    _proto.parseMPEGPES = function parseMPEGPES(track, pes) {
                        var data = pes.data;
                        var length = data.length;
                        var frameIndex = 0;
                        var offset = 0;
                        var pts = pes.pts;
                        if (pts === undefined) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_6__["logger"].warn("[tsdemuxer]: MPEG PES unknown PTS");
                            return;
                        }
                        while (offset < length) {
                            if (_mpegaudio__WEBPACK_IMPORTED_MODULE_1__["isHeader"](data, offset)) {
                                var frame = _mpegaudio__WEBPACK_IMPORTED_MODULE_1__["appendFrame"](track, data, offset, pts, frameIndex);
                                if (frame) {
                                    offset += frame.length;
                                    frameIndex++;
                                } else {
                                    break;
                                }
                            } else {
                                offset++;
                            }
                        }
                    };
                    _proto.parseID3PES = function parseID3PES(id3Track, pes) {
                        if (pes.pts === undefined) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_6__["logger"].warn("[tsdemuxer]: ID3 PES unknown PTS");
                            return;
                        }
                        var id3Sample = _extends({}, pes, { type: this._avcTrack ? _types_demuxer__WEBPACK_IMPORTED_MODULE_8__["MetadataSchema"].emsg : _types_demuxer__WEBPACK_IMPORTED_MODULE_8__["MetadataSchema"].audioId3 });
                        id3Track.samples.push(id3Sample);
                    };
                    return TSDemuxer;
                })();
                function createAVCSample(key, pts, dts, debug) {
                    return { key: key, frame: false, pts: pts, dts: dts, units: [], debug: debug, length: 0 };
                }
                function parsePAT(data, offset) {
                    return ((data[offset + 10] & 31) << 8) | data[offset + 11];
                }
                function parsePMT(data, offset, typeSupported, isSampleAes) {
                    var result = { audio: -1, avc: -1, id3: -1, segmentCodec: "aac" };
                    var sectionLength = ((data[offset + 1] & 15) << 8) | data[offset + 2];
                    var tableEnd = offset + 3 + sectionLength - 4;
                    var programInfoLength = ((data[offset + 10] & 15) << 8) | data[offset + 11];
                    offset += 12 + programInfoLength;
                    while (offset < tableEnd) {
                        var pid = ((data[offset + 1] & 31) << 8) | data[offset + 2];
                        switch (data[offset]) {
                            case 207:
                                if (!isSampleAes) {
                                    _utils_logger__WEBPACK_IMPORTED_MODULE_6__["logger"].log("ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream");
                                    break;
                                }
                            case 15:
                                if (result.audio === -1) {
                                    result.audio = pid;
                                }
                                break;
                            case 21:
                                if (result.id3 === -1) {
                                    result.id3 = pid;
                                }
                                break;
                            case 219:
                                if (!isSampleAes) {
                                    _utils_logger__WEBPACK_IMPORTED_MODULE_6__["logger"].log("H.264 with AES-128-CBC slice encryption found in unencrypted stream");
                                    break;
                                }
                            case 27:
                                if (result.avc === -1) {
                                    result.avc = pid;
                                }
                                break;
                            case 3:
                            case 4:
                                if (typeSupported.mpeg !== true && typeSupported.mp3 !== true) {
                                    _utils_logger__WEBPACK_IMPORTED_MODULE_6__["logger"].log("MPEG audio found, not supported in this browser");
                                } else if (result.audio === -1) {
                                    result.audio = pid;
                                    result.segmentCodec = "mp3";
                                }
                                break;
                            case 36:
                                _utils_logger__WEBPACK_IMPORTED_MODULE_6__["logger"].warn("Unsupported HEVC stream type found");
                                break;
                            default:
                                break;
                        }
                        offset += (((data[offset + 3] & 15) << 8) | data[offset + 4]) + 5;
                    }
                    return result;
                }
                function parsePES(stream) {
                    var i = 0;
                    var frag;
                    var pesLen;
                    var pesHdrLen;
                    var pesPts;
                    var pesDts;
                    var data = stream.data;
                    if (!stream || stream.size === 0) {
                        return null;
                    }
                    while (data[0].length < 19 && data.length > 1) {
                        var newData = new Uint8Array(data[0].length + data[1].length);
                        newData.set(data[0]);
                        newData.set(data[1], data[0].length);
                        data[0] = newData;
                        data.splice(1, 1);
                    }
                    frag = data[0];
                    var pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
                    if (pesPrefix === 1) {
                        pesLen = (frag[4] << 8) + frag[5];
                        if (pesLen && pesLen > stream.size - 6) {
                            return null;
                        }
                        var pesFlags = frag[7];
                        if (pesFlags & 192) {
                            pesPts = (frag[9] & 14) * 536870912 + (frag[10] & 255) * 4194304 + (frag[11] & 254) * 16384 + (frag[12] & 255) * 128 + (frag[13] & 254) / 2;
                            if (pesFlags & 64) {
                                pesDts = (frag[14] & 14) * 536870912 + (frag[15] & 255) * 4194304 + (frag[16] & 254) * 16384 + (frag[17] & 255) * 128 + (frag[18] & 254) / 2;
                                if (pesPts - pesDts > 60 * 9e4) {
                                    _utils_logger__WEBPACK_IMPORTED_MODULE_6__["logger"].warn(Math.round((pesPts - pesDts) / 9e4) + "s delta between PTS and DTS, align them");
                                    pesPts = pesDts;
                                }
                            } else {
                                pesDts = pesPts;
                            }
                        }
                        pesHdrLen = frag[8];
                        var payloadStartOffset = pesHdrLen + 9;
                        if (stream.size <= payloadStartOffset) {
                            return null;
                        }
                        stream.size -= payloadStartOffset;
                        var pesData = new Uint8Array(stream.size);
                        for (var j = 0, dataLen = data.length; j < dataLen; j++) {
                            frag = data[j];
                            var len = frag.byteLength;
                            if (payloadStartOffset) {
                                if (payloadStartOffset > len) {
                                    payloadStartOffset -= len;
                                    continue;
                                } else {
                                    frag = frag.subarray(payloadStartOffset);
                                    len -= payloadStartOffset;
                                    payloadStartOffset = 0;
                                }
                            }
                            pesData.set(frag, i);
                            i += len;
                        }
                        if (pesLen) {
                            pesLen -= pesHdrLen + 3;
                        }
                        return { data: pesData, pts: pesPts, dts: pesDts, len: pesLen };
                    }
                    return null;
                }
                function pushAccessUnit(avcSample, avcTrack) {
                    if (avcSample.units.length && avcSample.frame) {
                        if (avcSample.pts === undefined) {
                            var samples = avcTrack.samples;
                            var nbSamples = samples.length;
                            if (nbSamples) {
                                var lastSample = samples[nbSamples - 1];
                                avcSample.pts = lastSample.pts;
                                avcSample.dts = lastSample.dts;
                            } else {
                                avcTrack.dropped++;
                                return;
                            }
                        }
                        avcTrack.samples.push(avcSample);
                    }
                    if (avcSample.debug.length) {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_6__["logger"].log(avcSample.pts + "/" + avcSample.dts + ":" + avcSample.debug);
                    }
                }
                function discardEPB(data) {
                    var length = data.byteLength;
                    var EPBPositions = [];
                    var i = 1;
                    while (i < length - 2) {
                        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 3) {
                            EPBPositions.push(i + 2);
                            i += 2;
                        } else {
                            i++;
                        }
                    }
                    if (EPBPositions.length === 0) {
                        return data;
                    }
                    var newLength = length - EPBPositions.length;
                    var newData = new Uint8Array(newLength);
                    var sourceIndex = 0;
                    for (i = 0; i < newLength; sourceIndex++, i++) {
                        if (sourceIndex === EPBPositions[0]) {
                            sourceIndex++;
                            EPBPositions.shift();
                        }
                        newData[i] = data[sourceIndex];
                    }
                    return newData;
                }
                __webpack_exports__["default"] = TSDemuxer;
            },
            "./src/errors.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "ErrorTypes", function () {
                    return ErrorTypes;
                });
                __webpack_require__.d(__webpack_exports__, "ErrorDetails", function () {
                    return ErrorDetails;
                });
                var ErrorTypes;
                (function (ErrorTypes) {
                    ErrorTypes["NETWORK_ERROR"] = "networkError";
                    ErrorTypes["MEDIA_ERROR"] = "mediaError";
                    ErrorTypes["KEY_SYSTEM_ERROR"] = "keySystemError";
                    ErrorTypes["MUX_ERROR"] = "muxError";
                    ErrorTypes["OTHER_ERROR"] = "otherError";
                })(ErrorTypes || (ErrorTypes = {}));
                var ErrorDetails;
                (function (ErrorDetails) {
                    ErrorDetails["KEY_SYSTEM_NO_KEYS"] = "keySystemNoKeys";
                    ErrorDetails["KEY_SYSTEM_NO_ACCESS"] = "keySystemNoAccess";
                    ErrorDetails["KEY_SYSTEM_NO_SESSION"] = "keySystemNoSession";
                    ErrorDetails["KEY_SYSTEM_LICENSE_REQUEST_FAILED"] = "keySystemLicenseRequestFailed";
                    ErrorDetails["KEY_SYSTEM_NO_INIT_DATA"] = "keySystemNoInitData";
                    ErrorDetails["MANIFEST_LOAD_ERROR"] = "manifestLoadError";
                    ErrorDetails["MANIFEST_LOAD_TIMEOUT"] = "manifestLoadTimeOut";
                    ErrorDetails["MANIFEST_PARSING_ERROR"] = "manifestParsingError";
                    ErrorDetails["MANIFEST_INCOMPATIBLE_CODECS_ERROR"] = "manifestIncompatibleCodecsError";
                    ErrorDetails["LEVEL_EMPTY_ERROR"] = "levelEmptyError";
                    ErrorDetails["LEVEL_LOAD_ERROR"] = "levelLoadError";
                    ErrorDetails["LEVEL_LOAD_TIMEOUT"] = "levelLoadTimeOut";
                    ErrorDetails["LEVEL_SWITCH_ERROR"] = "levelSwitchError";
                    ErrorDetails["AUDIO_TRACK_LOAD_ERROR"] = "audioTrackLoadError";
                    ErrorDetails["AUDIO_TRACK_LOAD_TIMEOUT"] = "audioTrackLoadTimeOut";
                    ErrorDetails["SUBTITLE_LOAD_ERROR"] = "subtitleTrackLoadError";
                    ErrorDetails["SUBTITLE_TRACK_LOAD_TIMEOUT"] = "subtitleTrackLoadTimeOut";
                    ErrorDetails["FRAG_LOAD_ERROR"] = "fragLoadError";
                    ErrorDetails["FRAG_LOAD_TIMEOUT"] = "fragLoadTimeOut";
                    ErrorDetails["FRAG_DECRYPT_ERROR"] = "fragDecryptError";
                    ErrorDetails["FRAG_PARSING_ERROR"] = "fragParsingError";
                    ErrorDetails["REMUX_ALLOC_ERROR"] = "remuxAllocError";
                    ErrorDetails["KEY_LOAD_ERROR"] = "keyLoadError";
                    ErrorDetails["KEY_LOAD_TIMEOUT"] = "keyLoadTimeOut";
                    ErrorDetails["BUFFER_ADD_CODEC_ERROR"] = "bufferAddCodecError";
                    ErrorDetails["BUFFER_INCOMPATIBLE_CODECS_ERROR"] = "bufferIncompatibleCodecsError";
                    ErrorDetails["BUFFER_APPEND_ERROR"] = "bufferAppendError";
                    ErrorDetails["BUFFER_APPENDING_ERROR"] = "bufferAppendingError";
                    ErrorDetails["BUFFER_STALLED_ERROR"] = "bufferStalledError";
                    ErrorDetails["BUFFER_FULL_ERROR"] = "bufferFullError";
                    ErrorDetails["BUFFER_SEEK_OVER_HOLE"] = "bufferSeekOverHole";
                    ErrorDetails["BUFFER_NUDGE_ON_STALL"] = "bufferNudgeOnStall";
                    ErrorDetails["INTERNAL_EXCEPTION"] = "internalException";
                    ErrorDetails["INTERNAL_ABORTED"] = "aborted";
                    ErrorDetails["UNKNOWN"] = "unknown";
                })(ErrorDetails || (ErrorDetails = {}));
            },
            "./src/events.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "Events", function () {
                    return Events;
                });
                var Events;
                (function (Events) {
                    Events["MEDIA_ATTACHING"] = "hlsMediaAttaching";
                    Events["MEDIA_ATTACHED"] = "hlsMediaAttached";
                    Events["MEDIA_DETACHING"] = "hlsMediaDetaching";
                    Events["MEDIA_DETACHED"] = "hlsMediaDetached";
                    Events["BUFFER_RESET"] = "hlsBufferReset";
                    Events["BUFFER_CODECS"] = "hlsBufferCodecs";
                    Events["BUFFER_CREATED"] = "hlsBufferCreated";
                    Events["BUFFER_APPENDING"] = "hlsBufferAppending";
                    Events["BUFFER_APPENDED"] = "hlsBufferAppended";
                    Events["BUFFER_EOS"] = "hlsBufferEos";
                    Events["BUFFER_FLUSHING"] = "hlsBufferFlushing";
                    Events["BUFFER_FLUSHED"] = "hlsBufferFlushed";
                    Events["MANIFEST_LOADING"] = "hlsManifestLoading";
                    Events["MANIFEST_LOADED"] = "hlsManifestLoaded";
                    Events["MANIFEST_PARSED"] = "hlsManifestParsed";
                    Events["LEVEL_SWITCHING"] = "hlsLevelSwitching";
                    Events["LEVEL_SWITCHED"] = "hlsLevelSwitched";
                    Events["LEVEL_LOADING"] = "hlsLevelLoading";
                    Events["LEVEL_LOADED"] = "hlsLevelLoaded";
                    Events["LEVEL_UPDATED"] = "hlsLevelUpdated";
                    Events["LEVEL_PTS_UPDATED"] = "hlsLevelPtsUpdated";
                    Events["LEVELS_UPDATED"] = "hlsLevelsUpdated";
                    Events["AUDIO_TRACKS_UPDATED"] = "hlsAudioTracksUpdated";
                    Events["AUDIO_TRACK_SWITCHING"] = "hlsAudioTrackSwitching";
                    Events["AUDIO_TRACK_SWITCHED"] = "hlsAudioTrackSwitched";
                    Events["AUDIO_TRACK_LOADING"] = "hlsAudioTrackLoading";
                    Events["AUDIO_TRACK_LOADED"] = "hlsAudioTrackLoaded";
                    Events["SUBTITLE_TRACKS_UPDATED"] = "hlsSubtitleTracksUpdated";
                    Events["SUBTITLE_TRACKS_CLEARED"] = "hlsSubtitleTracksCleared";
                    Events["SUBTITLE_TRACK_SWITCH"] = "hlsSubtitleTrackSwitch";
                    Events["SUBTITLE_TRACK_LOADING"] = "hlsSubtitleTrackLoading";
                    Events["SUBTITLE_TRACK_LOADED"] = "hlsSubtitleTrackLoaded";
                    Events["SUBTITLE_FRAG_PROCESSED"] = "hlsSubtitleFragProcessed";
                    Events["CUES_PARSED"] = "hlsCuesParsed";
                    Events["NON_NATIVE_TEXT_TRACKS_FOUND"] = "hlsNonNativeTextTracksFound";
                    Events["INIT_PTS_FOUND"] = "hlsInitPtsFound";
                    Events["FRAG_LOADING"] = "hlsFragLoading";
                    Events["FRAG_LOAD_EMERGENCY_ABORTED"] = "hlsFragLoadEmergencyAborted";
                    Events["FRAG_LOADED"] = "hlsFragLoaded";
                    Events["FRAG_DECRYPTED"] = "hlsFragDecrypted";
                    Events["FRAG_PARSING_INIT_SEGMENT"] = "hlsFragParsingInitSegment";
                    Events["FRAG_PARSING_USERDATA"] = "hlsFragParsingUserdata";
                    Events["FRAG_PARSING_METADATA"] = "hlsFragParsingMetadata";
                    Events["FRAG_PARSED"] = "hlsFragParsed";
                    Events["FRAG_BUFFERED"] = "hlsFragBuffered";
                    Events["FRAG_CHANGED"] = "hlsFragChanged";
                    Events["FPS_DROP"] = "hlsFpsDrop";
                    Events["FPS_DROP_LEVEL_CAPPING"] = "hlsFpsDropLevelCapping";
                    Events["ERROR"] = "hlsError";
                    Events["DESTROYING"] = "hlsDestroying";
                    Events["KEY_LOADING"] = "hlsKeyLoading";
                    Events["KEY_LOADED"] = "hlsKeyLoaded";
                    Events["LIVE_BACK_BUFFER_REACHED"] = "hlsLiveBackBufferReached";
                    Events["BACK_BUFFER_REACHED"] = "hlsBackBufferReached";
                })(Events || (Events = {}));
            },
            "./src/hls.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "default", function () {
                    return Hls;
                });
                var url_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/url-toolkit/src/url-toolkit.js");
                var url_toolkit__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(url_toolkit__WEBPACK_IMPORTED_MODULE_0__);
                var _loader_playlist_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/loader/playlist-loader.ts");
                var _loader_key_loader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/loader/key-loader.ts");
                var _controller_id3_track_controller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/controller/id3-track-controller.ts");
                var _controller_latency_controller__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/controller/latency-controller.ts");
                var _controller_level_controller__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/controller/level-controller.ts");
                var _controller_fragment_tracker__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/controller/fragment-tracker.ts");
                var _controller_stream_controller__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/controller/stream-controller.ts");
                var _is_supported__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./src/is-supported.ts");
                var _utils_logger__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("./src/utils/logger.ts");
                var _config__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("./src/config.ts");
                var eventemitter3__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("./node_modules/eventemitter3/index.js");
                var eventemitter3__WEBPACK_IMPORTED_MODULE_11___default = __webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_11__);
                var _events__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("./src/events.ts");
                var _errors__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("./src/errors.ts");
                function _defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    Object.defineProperty(Constructor, "prototype", { writable: false });
                    return Constructor;
                }
                var Hls = (function () {
                    Hls.isSupported = function isSupported() {
                        return Object(_is_supported__WEBPACK_IMPORTED_MODULE_8__["isSupported"])();
                    };
                    function Hls(userConfig) {
                        if (userConfig === void 0) {
                            userConfig = {};
                        }
                        this.config = void 0;
                        this.userConfig = void 0;
                        this.coreComponents = void 0;
                        this.networkControllers = void 0;
                        this._emitter = new eventemitter3__WEBPACK_IMPORTED_MODULE_11__["EventEmitter"]();
                        this._autoLevelCapping = void 0;
                        this.abrController = void 0;
                        this.bufferController = void 0;
                        this.capLevelController = void 0;
                        this.latencyController = void 0;
                        this.levelController = void 0;
                        this.streamController = void 0;
                        this.audioTrackController = void 0;
                        this.subtitleTrackController = void 0;
                        this.emeController = void 0;
                        this.cmcdController = void 0;
                        this._media = null;
                        this.url = null;
                        var config = (this.config = Object(_config__WEBPACK_IMPORTED_MODULE_10__["mergeConfig"])(Hls.DefaultConfig, userConfig));
                        this.userConfig = userConfig;
                        Object(_utils_logger__WEBPACK_IMPORTED_MODULE_9__["enableLogs"])(config.debug);
                        this._autoLevelCapping = -1;
                        if (config.progressive) {
                            Object(_config__WEBPACK_IMPORTED_MODULE_10__["enableStreamingMode"])(config);
                        }
                        var ConfigAbrController = config.abrController,
                            ConfigBufferController = config.bufferController,
                            ConfigCapLevelController = config.capLevelController,
                            ConfigFpsController = config.fpsController;
                        var abrController = (this.abrController = new ConfigAbrController(this));
                        var bufferController = (this.bufferController = new ConfigBufferController(this));
                        var capLevelController = (this.capLevelController = new ConfigCapLevelController(this));
                        var fpsController = new ConfigFpsController(this);
                        var playListLoader = new _loader_playlist_loader__WEBPACK_IMPORTED_MODULE_1__["default"](this);
                        var keyLoader = new _loader_key_loader__WEBPACK_IMPORTED_MODULE_2__["default"](this);
                        var id3TrackController = new _controller_id3_track_controller__WEBPACK_IMPORTED_MODULE_3__["default"](this);
                        var levelController = (this.levelController = new _controller_level_controller__WEBPACK_IMPORTED_MODULE_5__["default"](this));
                        var fragmentTracker = new _controller_fragment_tracker__WEBPACK_IMPORTED_MODULE_6__["FragmentTracker"](this);
                        var streamController = (this.streamController = new _controller_stream_controller__WEBPACK_IMPORTED_MODULE_7__["default"](this, fragmentTracker));
                        capLevelController.setStreamController(streamController);
                        fpsController.setStreamController(streamController);
                        var networkControllers = [playListLoader, keyLoader, levelController, streamController];
                        this.networkControllers = networkControllers;
                        var coreComponents = [abrController, bufferController, capLevelController, fpsController, id3TrackController, fragmentTracker];
                        this.audioTrackController = this.createController(config.audioTrackController, null, networkControllers);
                        this.createController(config.audioStreamController, fragmentTracker, networkControllers);
                        this.subtitleTrackController = this.createController(config.subtitleTrackController, null, networkControllers);
                        this.createController(config.subtitleStreamController, fragmentTracker, networkControllers);
                        this.createController(config.timelineController, null, coreComponents);
                        this.emeController = this.createController(config.emeController, null, coreComponents);
                        this.cmcdController = this.createController(config.cmcdController, null, coreComponents);
                        this.latencyController = this.createController(_controller_latency_controller__WEBPACK_IMPORTED_MODULE_4__["default"], null, coreComponents);
                        this.coreComponents = coreComponents;
                    }
                    var _proto = Hls.prototype;
                    _proto.createController = function createController(ControllerClass, fragmentTracker, components) {
                        if (ControllerClass) {
                            var controllerInstance = fragmentTracker ? new ControllerClass(this, fragmentTracker) : new ControllerClass(this);
                            if (components) {
                                components.push(controllerInstance);
                            }
                            return controllerInstance;
                        }
                        return null;
                    };
                    _proto.on = function on(event, listener, context) {
                        if (context === void 0) {
                            context = this;
                        }
                        this._emitter.on(event, listener, context);
                    };
                    _proto.once = function once(event, listener, context) {
                        if (context === void 0) {
                            context = this;
                        }
                        this._emitter.once(event, listener, context);
                    };
                    _proto.removeAllListeners = function removeAllListeners(event) {
                        this._emitter.removeAllListeners(event);
                    };
                    _proto.off = function off(event, listener, context, once) {
                        if (context === void 0) {
                            context = this;
                        }
                        this._emitter.off(event, listener, context, once);
                    };
                    _proto.listeners = function listeners(event) {
                        return this._emitter.listeners(event);
                    };
                    _proto.emit = function emit(event, name, eventObject) {
                        return this._emitter.emit(event, name, eventObject);
                    };
                    _proto.trigger = function trigger(event, eventObject) {
                        if (this.config.debug) {
                            return this.emit(event, event, eventObject);
                        } else {
                            try {
                                return this.emit(event, event, eventObject);
                            } catch (e) {
                                _utils_logger__WEBPACK_IMPORTED_MODULE_9__["logger"].error("An internal error happened while handling event " + event + '. Error message: "' + e.message + '". Here is a stacktrace:', e);
                                this.trigger(_events__WEBPACK_IMPORTED_MODULE_12__["Events"].ERROR, {
                                    type: _errors__WEBPACK_IMPORTED_MODULE_13__["ErrorTypes"].OTHER_ERROR,
                                    details: _errors__WEBPACK_IMPORTED_MODULE_13__["ErrorDetails"].INTERNAL_EXCEPTION,
                                    fatal: false,
                                    event: event,
                                    error: e,
                                });
                            }
                        }
                        return false;
                    };
                    _proto.listenerCount = function listenerCount(event) {
                        return this._emitter.listenerCount(event);
                    };
                    _proto.destroy = function destroy() {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_9__["logger"].log("destroy");
                        this.trigger(_events__WEBPACK_IMPORTED_MODULE_12__["Events"].DESTROYING, undefined);
                        this.detachMedia();
                        this.removeAllListeners();
                        this._autoLevelCapping = -1;
                        this.url = null;
                        this.networkControllers.forEach(function (component) {
                            return component.destroy();
                        });
                        this.networkControllers.length = 0;
                        this.coreComponents.forEach(function (component) {
                            return component.destroy();
                        });
                        this.coreComponents.length = 0;
                    };
                    _proto.attachMedia = function attachMedia(media) {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_9__["logger"].log("attachMedia");
                        this._media = media;
                        this.trigger(_events__WEBPACK_IMPORTED_MODULE_12__["Events"].MEDIA_ATTACHING, { media: media });
                    };
                    _proto.detachMedia = function detachMedia() {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_9__["logger"].log("detachMedia");
                        this.trigger(_events__WEBPACK_IMPORTED_MODULE_12__["Events"].MEDIA_DETACHING, undefined);
                        this._media = null;
                    };
                    _proto.loadSource = function loadSource(url) {
                        this.stopLoad();
                        var media = this.media;
                        var loadedSource = this.url;
                        var loadingSource = (this.url = url_toolkit__WEBPACK_IMPORTED_MODULE_0__["buildAbsoluteURL"](self.location.href, url, { alwaysNormalize: true }));
                        _utils_logger__WEBPACK_IMPORTED_MODULE_9__["logger"].log("loadSource:" + loadingSource);
                        if (media && loadedSource && loadedSource !== loadingSource && this.bufferController.hasSourceTypes()) {
                            this.detachMedia();
                            this.attachMedia(media);
                        }
                        this.trigger(_events__WEBPACK_IMPORTED_MODULE_12__["Events"].MANIFEST_LOADING, { url: url });
                    };
                    _proto.startLoad = function startLoad(startPosition) {
                        if (startPosition === void 0) {
                            startPosition = -1;
                        }
                        _utils_logger__WEBPACK_IMPORTED_MODULE_9__["logger"].log("startLoad(" + startPosition + ")");
                        this.networkControllers.forEach(function (controller) {
                            controller.startLoad(startPosition);
                        });
                    };
                    _proto.stopLoad = function stopLoad() {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_9__["logger"].log("stopLoad");
                        this.networkControllers.forEach(function (controller) {
                            controller.stopLoad();
                        });
                    };
                    _proto.swapAudioCodec = function swapAudioCodec() {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_9__["logger"].log("swapAudioCodec");
                        this.streamController.swapAudioCodec();
                    };
                    _proto.recoverMediaError = function recoverMediaError() {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_9__["logger"].log("recoverMediaError");
                        var media = this._media;
                        this.detachMedia();
                        if (media) {
                            this.attachMedia(media);
                        }
                    };
                    _proto.removeLevel = function removeLevel(levelIndex, urlId) {
                        if (urlId === void 0) {
                            urlId = 0;
                        }
                        this.levelController.removeLevel(levelIndex, urlId);
                    };
                    _createClass(
                        Hls,
                        [
                            {
                                key: "levels",
                                get: function get() {
                                    var levels = this.levelController.levels;
                                    return levels ? levels : [];
                                },
                            },
                            {
                                key: "currentLevel",
                                get: function get() {
                                    return this.streamController.currentLevel;
                                },
                                set: function set(newLevel) {
                                    _utils_logger__WEBPACK_IMPORTED_MODULE_9__["logger"].log("set currentLevel:" + newLevel);
                                    this.loadLevel = newLevel;
                                    this.abrController.clearTimer();
                                    this.streamController.immediateLevelSwitch();
                                },
                            },
                            {
                                key: "nextLevel",
                                get: function get() {
                                    return this.streamController.nextLevel;
                                },
                                set: function set(newLevel) {
                                    _utils_logger__WEBPACK_IMPORTED_MODULE_9__["logger"].log("set nextLevel:" + newLevel);
                                    this.levelController.manualLevel = newLevel;
                                    this.streamController.nextLevelSwitch();
                                },
                            },
                            {
                                key: "loadLevel",
                                get: function get() {
                                    return this.levelController.level;
                                },
                                set: function set(newLevel) {
                                    _utils_logger__WEBPACK_IMPORTED_MODULE_9__["logger"].log("set loadLevel:" + newLevel);
                                    this.levelController.manualLevel = newLevel;
                                },
                            },
                            {
                                key: "nextLoadLevel",
                                get: function get() {
                                    return this.levelController.nextLoadLevel;
                                },
                                set: function set(level) {
                                    this.levelController.nextLoadLevel = level;
                                },
                            },
                            {
                                key: "firstLevel",
                                get: function get() {
                                    return Math.max(this.levelController.firstLevel, this.minAutoLevel);
                                },
                                set: function set(newLevel) {
                                    _utils_logger__WEBPACK_IMPORTED_MODULE_9__["logger"].log("set firstLevel:" + newLevel);
                                    this.levelController.firstLevel = newLevel;
                                },
                            },
                            {
                                key: "startLevel",
                                get: function get() {
                                    return this.levelController.startLevel;
                                },
                                set: function set(newLevel) {
                                    _utils_logger__WEBPACK_IMPORTED_MODULE_9__["logger"].log("set startLevel:" + newLevel);
                                    if (newLevel !== -1) {
                                        newLevel = Math.max(newLevel, this.minAutoLevel);
                                    }
                                    this.levelController.startLevel = newLevel;
                                },
                            },
                            {
                                key: "capLevelToPlayerSize",
                                get: function get() {
                                    return this.config.capLevelToPlayerSize;
                                },
                                set: function set(shouldStartCapping) {
                                    var newCapLevelToPlayerSize = !!shouldStartCapping;
                                    if (newCapLevelToPlayerSize !== this.config.capLevelToPlayerSize) {
                                        if (newCapLevelToPlayerSize) {
                                            this.capLevelController.startCapping();
                                        } else {
                                            this.capLevelController.stopCapping();
                                            this.autoLevelCapping = -1;
                                            this.streamController.nextLevelSwitch();
                                        }
                                        this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;
                                    }
                                },
                            },
                            {
                                key: "autoLevelCapping",
                                get: function get() {
                                    return this._autoLevelCapping;
                                },
                                set: function set(newLevel) {
                                    if (this._autoLevelCapping !== newLevel) {
                                        _utils_logger__WEBPACK_IMPORTED_MODULE_9__["logger"].log("set autoLevelCapping:" + newLevel);
                                        this._autoLevelCapping = newLevel;
                                    }
                                },
                            },
                            {
                                key: "bandwidthEstimate",
                                get: function get() {
                                    var bwEstimator = this.abrController.bwEstimator;
                                    if (!bwEstimator) {
                                        return NaN;
                                    }
                                    return bwEstimator.getEstimate();
                                },
                            },
                            {
                                key: "autoLevelEnabled",
                                get: function get() {
                                    return this.levelController.manualLevel === -1;
                                },
                            },
                            {
                                key: "manualLevel",
                                get: function get() {
                                    return this.levelController.manualLevel;
                                },
                            },
                            {
                                key: "minAutoLevel",
                                get: function get() {
                                    var levels = this.levels,
                                        minAutoBitrate = this.config.minAutoBitrate;
                                    if (!levels) return 0;
                                    var len = levels.length;
                                    for (var i = 0; i < len; i++) {
                                        if (levels[i].maxBitrate >= minAutoBitrate) {
                                            return i;
                                        }
                                    }
                                    return 0;
                                },
                            },
                            {
                                key: "maxAutoLevel",
                                get: function get() {
                                    var levels = this.levels,
                                        autoLevelCapping = this.autoLevelCapping;
                                    var maxAutoLevel;
                                    if (autoLevelCapping === -1 && levels && levels.length) {
                                        maxAutoLevel = levels.length - 1;
                                    } else {
                                        maxAutoLevel = autoLevelCapping;
                                    }
                                    return maxAutoLevel;
                                },
                            },
                            {
                                key: "nextAutoLevel",
                                get: function get() {
                                    return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel);
                                },
                                set: function set(nextLevel) {
                                    this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, nextLevel);
                                },
                            },
                            {
                                key: "playingDate",
                                get: function get() {
                                    return this.streamController.currentProgramDateTime;
                                },
                            },
                            {
                                key: "mainForwardBufferInfo",
                                get: function get() {
                                    return this.streamController.getMainFwdBufferInfo();
                                },
                            },
                            {
                                key: "audioTracks",
                                get: function get() {
                                    var audioTrackController = this.audioTrackController;
                                    return audioTrackController ? audioTrackController.audioTracks : [];
                                },
                            },
                            {
                                key: "audioTrack",
                                get: function get() {
                                    var audioTrackController = this.audioTrackController;
                                    return audioTrackController ? audioTrackController.audioTrack : -1;
                                },
                                set: function set(audioTrackId) {
                                    var audioTrackController = this.audioTrackController;
                                    if (audioTrackController) {
                                        audioTrackController.audioTrack = audioTrackId;
                                    }
                                },
                            },
                            {
                                key: "subtitleTracks",
                                get: function get() {
                                    var subtitleTrackController = this.subtitleTrackController;
                                    return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];
                                },
                            },
                            {
                                key: "subtitleTrack",
                                get: function get() {
                                    var subtitleTrackController = this.subtitleTrackController;
                                    return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;
                                },
                                set: function set(subtitleTrackId) {
                                    var subtitleTrackController = this.subtitleTrackController;
                                    if (subtitleTrackController) {
                                        subtitleTrackController.subtitleTrack = subtitleTrackId;
                                    }
                                },
                            },
                            {
                                key: "media",
                                get: function get() {
                                    return this._media;
                                },
                            },
                            {
                                key: "subtitleDisplay",
                                get: function get() {
                                    var subtitleTrackController = this.subtitleTrackController;
                                    return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;
                                },
                                set: function set(value) {
                                    var subtitleTrackController = this.subtitleTrackController;
                                    if (subtitleTrackController) {
                                        subtitleTrackController.subtitleDisplay = value;
                                    }
                                },
                            },
                            {
                                key: "lowLatencyMode",
                                get: function get() {
                                    return this.config.lowLatencyMode;
                                },
                                set: function set(mode) {
                                    this.config.lowLatencyMode = mode;
                                },
                            },
                            {
                                key: "liveSyncPosition",
                                get: function get() {
                                    return this.latencyController.liveSyncPosition;
                                },
                            },
                            {
                                key: "latency",
                                get: function get() {
                                    return this.latencyController.latency;
                                },
                            },
                            {
                                key: "maxLatency",
                                get: function get() {
                                    return this.latencyController.maxLatency;
                                },
                            },
                            {
                                key: "targetLatency",
                                get: function get() {
                                    return this.latencyController.targetLatency;
                                },
                            },
                            {
                                key: "drift",
                                get: function get() {
                                    return this.latencyController.drift;
                                },
                            },
                            {
                                key: "forceStartLoad",
                                get: function get() {
                                    return this.streamController.forceStartLoad;
                                },
                            },
                        ],
                        [
                            {
                                key: "version",
                                get: function get() {
                                    return "1.2.4";
                                },
                            },
                            {
                                key: "Events",
                                get: function get() {
                                    return _events__WEBPACK_IMPORTED_MODULE_12__["Events"];
                                },
                            },
                            {
                                key: "ErrorTypes",
                                get: function get() {
                                    return _errors__WEBPACK_IMPORTED_MODULE_13__["ErrorTypes"];
                                },
                            },
                            {
                                key: "ErrorDetails",
                                get: function get() {
                                    return _errors__WEBPACK_IMPORTED_MODULE_13__["ErrorDetails"];
                                },
                            },
                            {
                                key: "DefaultConfig",
                                get: function get() {
                                    if (!Hls.defaultConfig) {
                                        return _config__WEBPACK_IMPORTED_MODULE_10__["hlsDefaultConfig"];
                                    }
                                    return Hls.defaultConfig;
                                },
                                set: function set(defaultConfig) {
                                    Hls.defaultConfig = defaultConfig;
                                },
                            },
                        ]
                    );
                    return Hls;
                })();
                Hls.defaultConfig = void 0;
            },
            "./src/is-supported.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "isSupported", function () {
                    return isSupported;
                });
                __webpack_require__.d(__webpack_exports__, "changeTypeSupported", function () {
                    return changeTypeSupported;
                });
                var _utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/mediasource-helper.ts");
                function getSourceBuffer() {
                    return self.SourceBuffer || self.WebKitSourceBuffer;
                }
                function isSupported() {
                    var mediaSource = Object(_utils_mediasource_helper__WEBPACK_IMPORTED_MODULE_0__["getMediaSource"])();
                    if (!mediaSource) {
                        return false;
                    }
                    var sourceBuffer = getSourceBuffer();
                    var isTypeSupported = mediaSource && typeof mediaSource.isTypeSupported === "function" && mediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
                    var sourceBufferValidAPI = !sourceBuffer || (sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === "function" && typeof sourceBuffer.prototype.remove === "function");
                    return !!isTypeSupported && !!sourceBufferValidAPI;
                }
                function changeTypeSupported() {
                    var _sourceBuffer$prototy;
                    var sourceBuffer = getSourceBuffer();
                    return (
                        typeof (sourceBuffer === null || sourceBuffer === void 0 ? void 0 : (_sourceBuffer$prototy = sourceBuffer.prototype) === null || _sourceBuffer$prototy === void 0 ? void 0 : _sourceBuffer$prototy.changeType) ===
                        "function"
                    );
                }
            },
            "./src/loader/date-range.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "DateRangeAttribute", function () {
                    return DateRangeAttribute;
                });
                __webpack_require__.d(__webpack_exports__, "DateRange", function () {
                    return DateRange;
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/polyfills/number.ts");
                var _utils_attr_list__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/attr-list.ts");
                var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/logger.ts");
                function _extends() {
                    _extends = Object.assign
                        ? Object.assign.bind()
                        : function (target) {
                              for (var i = 1; i < arguments.length; i++) {
                                  var source = arguments[i];
                                  for (var key in source) {
                                      if (Object.prototype.hasOwnProperty.call(source, key)) {
                                          target[key] = source[key];
                                      }
                                  }
                              }
                              return target;
                          };
                    return _extends.apply(this, arguments);
                }
                function _defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    Object.defineProperty(Constructor, "prototype", { writable: false });
                    return Constructor;
                }
                var DateRangeAttribute;
                (function (DateRangeAttribute) {
                    DateRangeAttribute["ID"] = "ID";
                    DateRangeAttribute["CLASS"] = "CLASS";
                    DateRangeAttribute["START_DATE"] = "START-DATE";
                    DateRangeAttribute["DURATION"] = "DURATION";
                    DateRangeAttribute["END_DATE"] = "END-DATE";
                    DateRangeAttribute["END_ON_NEXT"] = "END-ON-NEXT";
                    DateRangeAttribute["PLANNED_DURATION"] = "PLANNED-DURATION";
                    DateRangeAttribute["SCTE35_OUT"] = "SCTE35-OUT";
                    DateRangeAttribute["SCTE35_IN"] = "SCTE35-IN";
                })(DateRangeAttribute || (DateRangeAttribute = {}));
                var DateRange = (function () {
                    function DateRange(dateRangeAttr, dateRangeWithSameId) {
                        this.attr = void 0;
                        this._startDate = void 0;
                        this._endDate = void 0;
                        this._badValueForSameId = void 0;
                        if (dateRangeWithSameId) {
                            var previousAttr = dateRangeWithSameId.attr;
                            for (var key in previousAttr) {
                                if (Object.prototype.hasOwnProperty.call(dateRangeAttr, key) && dateRangeAttr[key] !== previousAttr[key]) {
                                    _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn('DATERANGE tag attribute: "' + key + '" does not match for tags with ID: "' + dateRangeAttr.ID + '"');
                                    this._badValueForSameId = key;
                                    break;
                                }
                            }
                            dateRangeAttr = _extends(new _utils_attr_list__WEBPACK_IMPORTED_MODULE_1__["AttrList"]({}), previousAttr, dateRangeAttr);
                        }
                        this.attr = dateRangeAttr;
                        this._startDate = new Date(dateRangeAttr[DateRangeAttribute.START_DATE]);
                        if (DateRangeAttribute.END_DATE in this.attr) {
                            var endDate = new Date(this.attr[DateRangeAttribute.END_DATE]);
                            if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(endDate.getTime())) {
                                this._endDate = endDate;
                            }
                        }
                    }
                    _createClass(DateRange, [
                        {
                            key: "id",
                            get: function get() {
                                return this.attr.ID;
                            },
                        },
                        {
                            key: "class",
                            get: function get() {
                                return this.attr.CLASS;
                            },
                        },
                        {
                            key: "startDate",
                            get: function get() {
                                return this._startDate;
                            },
                        },
                        {
                            key: "endDate",
                            get: function get() {
                                if (this._endDate) {
                                    return this._endDate;
                                }
                                var duration = this.duration;
                                if (duration !== null) {
                                    return new Date(this._startDate.getTime() + duration * 1e3);
                                }
                                return null;
                            },
                        },
                        {
                            key: "duration",
                            get: function get() {
                                if (DateRangeAttribute.DURATION in this.attr) {
                                    var duration = this.attr.decimalFloatingPoint(DateRangeAttribute.DURATION);
                                    if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(duration)) {
                                        return duration;
                                    }
                                } else if (this._endDate) {
                                    return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;
                                }
                                return null;
                            },
                        },
                        {
                            key: "plannedDuration",
                            get: function get() {
                                if (DateRangeAttribute.PLANNED_DURATION in this.attr) {
                                    return this.attr.decimalFloatingPoint(DateRangeAttribute.PLANNED_DURATION);
                                }
                                return null;
                            },
                        },
                        {
                            key: "endOnNext",
                            get: function get() {
                                return this.attr.bool(DateRangeAttribute.END_ON_NEXT);
                            },
                        },
                        {
                            key: "isValid",
                            get: function get() {
                                return (
                                    !!this.id &&
                                    !this._badValueForSameId &&
                                    Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(this.startDate.getTime()) &&
                                    (this.duration === null || this.duration >= 0) &&
                                    (!this.endOnNext || !!this.class)
                                );
                            },
                        },
                    ]);
                    return DateRange;
                })();
            },
            "./src/loader/fragment-loader.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "default", function () {
                    return FragmentLoader;
                });
                __webpack_require__.d(__webpack_exports__, "LoadError", function () {
                    return LoadError;
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/polyfills/number.ts");
                var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/errors.ts");
                function _inheritsLoose(subClass, superClass) {
                    subClass.prototype = Object.create(superClass.prototype);
                    subClass.prototype.constructor = subClass;
                    _setPrototypeOf(subClass, superClass);
                }
                function _wrapNativeSuper(Class) {
                    var _cache = typeof Map === "function" ? new Map() : undefined;
                    _wrapNativeSuper = function _wrapNativeSuper(Class) {
                        if (Class === null || !_isNativeFunction(Class)) return Class;
                        if (typeof Class !== "function") {
                            throw new TypeError("Super expression must either be null or a function");
                        }
                        if (typeof _cache !== "undefined") {
                            if (_cache.has(Class)) return _cache.get(Class);
                            _cache.set(Class, Wrapper);
                        }
                        function Wrapper() {
                            return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                        }
                        Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
                        return _setPrototypeOf(Wrapper, Class);
                    };
                    return _wrapNativeSuper(Class);
                }
                function _construct(Parent, args, Class) {
                    if (_isNativeReflectConstruct()) {
                        _construct = Reflect.construct.bind();
                    } else {
                        _construct = function _construct(Parent, args, Class) {
                            var a = [null];
                            a.push.apply(a, args);
                            var Constructor = Function.bind.apply(Parent, a);
                            var instance = new Constructor();
                            if (Class) _setPrototypeOf(instance, Class.prototype);
                            return instance;
                        };
                    }
                    return _construct.apply(null, arguments);
                }
                function _isNativeReflectConstruct() {
                    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if (typeof Proxy === "function") return true;
                    try {
                        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
                        return true;
                    } catch (e) {
                        return false;
                    }
                }
                function _isNativeFunction(fn) {
                    return Function.toString.call(fn).indexOf("[native code]") !== -1;
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf
                        ? Object.setPrototypeOf.bind()
                        : function _setPrototypeOf(o, p) {
                              o.__proto__ = p;
                              return o;
                          };
                    return _setPrototypeOf(o, p);
                }
                function _getPrototypeOf(o) {
                    _getPrototypeOf = Object.setPrototypeOf
                        ? Object.getPrototypeOf.bind()
                        : function _getPrototypeOf(o) {
                              return o.__proto__ || Object.getPrototypeOf(o);
                          };
                    return _getPrototypeOf(o);
                }
                var MIN_CHUNK_SIZE = Math.pow(2, 17);
                var FragmentLoader = (function () {
                    function FragmentLoader(config) {
                        this.config = void 0;
                        this.loader = null;
                        this.partLoadTimeout = -1;
                        this.config = config;
                    }
                    var _proto = FragmentLoader.prototype;
                    _proto.destroy = function destroy() {
                        if (this.loader) {
                            this.loader.destroy();
                            this.loader = null;
                        }
                    };
                    _proto.abort = function abort() {
                        if (this.loader) {
                            this.loader.abort();
                        }
                    };
                    _proto.load = function load(frag, _onProgress) {
                        var _this = this;
                        var url = frag.url;
                        if (!url) {
                            return Promise.reject(
                                new LoadError(
                                    { type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].NETWORK_ERROR, details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].FRAG_LOAD_ERROR, fatal: false, frag: frag, networkDetails: null },
                                    "Fragment does not have a " + (url ? "part list" : "url")
                                )
                            );
                        }
                        this.abort();
                        var config = this.config;
                        var FragmentILoader = config.fLoader;
                        var DefaultILoader = config.loader;
                        return new Promise(function (resolve, reject) {
                            if (_this.loader) {
                                _this.loader.destroy();
                            }
                            var loader = (_this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config));
                            var loaderContext = createLoaderContext(frag);
                            var loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: 0, retryDelay: 0, maxRetryDelay: config.fragLoadingMaxRetryTimeout, highWaterMark: frag.sn === "initSegment" ? Infinity : MIN_CHUNK_SIZE };
                            frag.stats = loader.stats;
                            loader.load(loaderContext, loaderConfig, {
                                onSuccess: function onSuccess(response, stats, context, networkDetails) {
                                    _this.resetLoader(frag, loader);
                                    resolve({ frag: frag, part: null, payload: response.data, networkDetails: networkDetails });
                                },
                                onError: function onError(response, context, networkDetails) {
                                    _this.resetLoader(frag, loader);
                                    reject(
                                        new LoadError({
                                            type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].NETWORK_ERROR,
                                            details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].FRAG_LOAD_ERROR,
                                            fatal: false,
                                            frag: frag,
                                            response: response,
                                            networkDetails: networkDetails,
                                        })
                                    );
                                },
                                onAbort: function onAbort(stats, context, networkDetails) {
                                    _this.resetLoader(frag, loader);
                                    reject(
                                        new LoadError({
                                            type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].NETWORK_ERROR,
                                            details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].INTERNAL_ABORTED,
                                            fatal: false,
                                            frag: frag,
                                            networkDetails: networkDetails,
                                        })
                                    );
                                },
                                onTimeout: function onTimeout(response, context, networkDetails) {
                                    _this.resetLoader(frag, loader);
                                    reject(
                                        new LoadError({
                                            type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].NETWORK_ERROR,
                                            details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].FRAG_LOAD_TIMEOUT,
                                            fatal: false,
                                            frag: frag,
                                            networkDetails: networkDetails,
                                        })
                                    );
                                },
                                onProgress: function onProgress(stats, context, data, networkDetails) {
                                    if (_onProgress) {
                                        _onProgress({ frag: frag, part: null, payload: data, networkDetails: networkDetails });
                                    }
                                },
                            });
                        });
                    };
                    _proto.loadPart = function loadPart(frag, part, onProgress) {
                        var _this2 = this;
                        this.abort();
                        var config = this.config;
                        var FragmentILoader = config.fLoader;
                        var DefaultILoader = config.loader;
                        return new Promise(function (resolve, reject) {
                            if (_this2.loader) {
                                _this2.loader.destroy();
                            }
                            var loader = (_this2.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config));
                            var loaderContext = createLoaderContext(frag, part);
                            var loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: 0, retryDelay: 0, maxRetryDelay: config.fragLoadingMaxRetryTimeout, highWaterMark: MIN_CHUNK_SIZE };
                            part.stats = loader.stats;
                            loader.load(loaderContext, loaderConfig, {
                                onSuccess: function onSuccess(response, stats, context, networkDetails) {
                                    _this2.resetLoader(frag, loader);
                                    _this2.updateStatsFromPart(frag, part);
                                    var partLoadedData = { frag: frag, part: part, payload: response.data, networkDetails: networkDetails };
                                    onProgress(partLoadedData);
                                    resolve(partLoadedData);
                                },
                                onError: function onError(response, context, networkDetails) {
                                    _this2.resetLoader(frag, loader);
                                    reject(
                                        new LoadError({
                                            type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].NETWORK_ERROR,
                                            details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].FRAG_LOAD_ERROR,
                                            fatal: false,
                                            frag: frag,
                                            part: part,
                                            response: response,
                                            networkDetails: networkDetails,
                                        })
                                    );
                                },
                                onAbort: function onAbort(stats, context, networkDetails) {
                                    frag.stats.aborted = part.stats.aborted;
                                    _this2.resetLoader(frag, loader);
                                    reject(
                                        new LoadError({
                                            type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].NETWORK_ERROR,
                                            details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].INTERNAL_ABORTED,
                                            fatal: false,
                                            frag: frag,
                                            part: part,
                                            networkDetails: networkDetails,
                                        })
                                    );
                                },
                                onTimeout: function onTimeout(response, context, networkDetails) {
                                    _this2.resetLoader(frag, loader);
                                    reject(
                                        new LoadError({
                                            type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].NETWORK_ERROR,
                                            details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].FRAG_LOAD_TIMEOUT,
                                            fatal: false,
                                            frag: frag,
                                            part: part,
                                            networkDetails: networkDetails,
                                        })
                                    );
                                },
                            });
                        });
                    };
                    _proto.updateStatsFromPart = function updateStatsFromPart(frag, part) {
                        var fragStats = frag.stats;
                        var partStats = part.stats;
                        var partTotal = partStats.total;
                        fragStats.loaded += partStats.loaded;
                        if (partTotal) {
                            var estTotalParts = Math.round(frag.duration / part.duration);
                            var estLoadedParts = Math.min(Math.round(fragStats.loaded / partTotal), estTotalParts);
                            var estRemainingParts = estTotalParts - estLoadedParts;
                            var estRemainingBytes = estRemainingParts * Math.round(fragStats.loaded / estLoadedParts);
                            fragStats.total = fragStats.loaded + estRemainingBytes;
                        } else {
                            fragStats.total = Math.max(fragStats.loaded, fragStats.total);
                        }
                        var fragLoading = fragStats.loading;
                        var partLoading = partStats.loading;
                        if (fragLoading.start) {
                            fragLoading.first += partLoading.first - partLoading.start;
                        } else {
                            fragLoading.start = partLoading.start;
                            fragLoading.first = partLoading.first;
                        }
                        fragLoading.end = partLoading.end;
                    };
                    _proto.resetLoader = function resetLoader(frag, loader) {
                        frag.loader = null;
                        if (this.loader === loader) {
                            self.clearTimeout(this.partLoadTimeout);
                            this.loader = null;
                        }
                        loader.destroy();
                    };
                    return FragmentLoader;
                })();
                function createLoaderContext(frag, part) {
                    if (part === void 0) {
                        part = null;
                    }
                    var segment = part || frag;
                    var loaderContext = { frag: frag, part: part, responseType: "arraybuffer", url: segment.url, headers: {}, rangeStart: 0, rangeEnd: 0 };
                    var start = segment.byteRangeStartOffset;
                    var end = segment.byteRangeEndOffset;
                    if (
                        Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(start) &&
                        Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(end)
                    ) {
                        loaderContext.rangeStart = start;
                        loaderContext.rangeEnd = end;
                    }
                    return loaderContext;
                }
                var LoadError = (function (_Error) {
                    _inheritsLoose(LoadError, _Error);
                    function LoadError(data) {
                        var _this3;
                        for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                            params[_key - 1] = arguments[_key];
                        }
                        _this3 = _Error.call.apply(_Error, [this].concat(params)) || this;
                        _this3.data = void 0;
                        _this3.data = data;
                        return _this3;
                    }
                    return LoadError;
                })(_wrapNativeSuper(Error));
            },
            "./src/loader/fragment.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "ElementaryStreamTypes", function () {
                    return ElementaryStreamTypes;
                });
                __webpack_require__.d(__webpack_exports__, "BaseSegment", function () {
                    return BaseSegment;
                });
                __webpack_require__.d(__webpack_exports__, "Fragment", function () {
                    return Fragment;
                });
                __webpack_require__.d(__webpack_exports__, "Part", function () {
                    return Part;
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/polyfills/number.ts");
                var url_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/url-toolkit/src/url-toolkit.js");
                var url_toolkit__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(url_toolkit__WEBPACK_IMPORTED_MODULE_1__);
                var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/logger.ts");
                var _level_key__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/loader/level-key.ts");
                var _load_stats__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/loader/load-stats.ts");
                function _inheritsLoose(subClass, superClass) {
                    subClass.prototype = Object.create(superClass.prototype);
                    subClass.prototype.constructor = subClass;
                    _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf
                        ? Object.setPrototypeOf.bind()
                        : function _setPrototypeOf(o, p) {
                              o.__proto__ = p;
                              return o;
                          };
                    return _setPrototypeOf(o, p);
                }
                function _defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    Object.defineProperty(Constructor, "prototype", { writable: false });
                    return Constructor;
                }
                var ElementaryStreamTypes;
                (function (ElementaryStreamTypes) {
                    ElementaryStreamTypes["AUDIO"] = "audio";
                    ElementaryStreamTypes["VIDEO"] = "video";
                    ElementaryStreamTypes["AUDIOVIDEO"] = "audiovideo";
                })(ElementaryStreamTypes || (ElementaryStreamTypes = {}));
                var BaseSegment = (function () {
                    function BaseSegment(baseurl) {
                        var _this$elementaryStrea;
                        this._byteRange = null;
                        this._url = null;
                        this.baseurl = void 0;
                        this.relurl = void 0;
                        this.elementaryStreams =
                            ((_this$elementaryStrea = {}),
                            (_this$elementaryStrea[ElementaryStreamTypes.AUDIO] = null),
                            (_this$elementaryStrea[ElementaryStreamTypes.VIDEO] = null),
                            (_this$elementaryStrea[ElementaryStreamTypes.AUDIOVIDEO] = null),
                            _this$elementaryStrea);
                        this.baseurl = baseurl;
                    }
                    var _proto = BaseSegment.prototype;
                    _proto.setByteRange = function setByteRange(value, previous) {
                        var params = value.split("@", 2);
                        var byteRange = [];
                        if (params.length === 1) {
                            byteRange[0] = previous ? previous.byteRangeEndOffset : 0;
                        } else {
                            byteRange[0] = parseInt(params[1]);
                        }
                        byteRange[1] = parseInt(params[0]) + byteRange[0];
                        this._byteRange = byteRange;
                    };
                    _createClass(BaseSegment, [
                        {
                            key: "byteRange",
                            get: function get() {
                                if (!this._byteRange) {
                                    return [];
                                }
                                return this._byteRange;
                            },
                        },
                        {
                            key: "byteRangeStartOffset",
                            get: function get() {
                                return this.byteRange[0];
                            },
                        },
                        {
                            key: "byteRangeEndOffset",
                            get: function get() {
                                return this.byteRange[1];
                            },
                        },
                        {
                            key: "url",
                            get: function get() {
                                if (!this._url && this.baseurl && this.relurl) {
                                    this._url = Object(url_toolkit__WEBPACK_IMPORTED_MODULE_1__["buildAbsoluteURL"])(this.baseurl, this.relurl, { alwaysNormalize: true });
                                }
                                return this._url || "";
                            },
                            set: function set(value) {
                                this._url = value;
                            },
                        },
                    ]);
                    return BaseSegment;
                })();
                var Fragment = (function (_BaseSegment) {
                    _inheritsLoose(Fragment, _BaseSegment);
                    function Fragment(type, baseurl) {
                        var _this;
                        _this = _BaseSegment.call(this, baseurl) || this;
                        _this._decryptdata = null;
                        _this.rawProgramDateTime = null;
                        _this.programDateTime = null;
                        _this.tagList = [];
                        _this.duration = 0;
                        _this.sn = 0;
                        _this.levelkey = void 0;
                        _this.type = void 0;
                        _this.loader = null;
                        _this.level = -1;
                        _this.cc = 0;
                        _this.startPTS = void 0;
                        _this.endPTS = void 0;
                        _this.appendedPTS = void 0;
                        _this.startDTS = void 0;
                        _this.endDTS = void 0;
                        _this.start = 0;
                        _this.deltaPTS = void 0;
                        _this.maxStartPTS = void 0;
                        _this.minEndPTS = void 0;
                        _this.stats = new _load_stats__WEBPACK_IMPORTED_MODULE_4__["LoadStats"]();
                        _this.urlId = 0;
                        _this.data = void 0;
                        _this.bitrateTest = false;
                        _this.title = null;
                        _this.initSegment = null;
                        _this.type = type;
                        return _this;
                    }
                    var _proto2 = Fragment.prototype;
                    _proto2.createInitializationVector = function createInitializationVector(segmentNumber) {
                        var uint8View = new Uint8Array(16);
                        for (var i = 12; i < 16; i++) {
                            uint8View[i] = (segmentNumber >> (8 * (15 - i))) & 255;
                        }
                        return uint8View;
                    };
                    _proto2.setDecryptDataFromLevelKey = function setDecryptDataFromLevelKey(levelkey, segmentNumber) {
                        var decryptdata = levelkey;
                        if ((levelkey === null || levelkey === void 0 ? void 0 : levelkey.method) === "AES-128" && levelkey.uri && !levelkey.iv) {
                            decryptdata = _level_key__WEBPACK_IMPORTED_MODULE_3__["LevelKey"].fromURI(levelkey.uri);
                            decryptdata.method = levelkey.method;
                            decryptdata.iv = this.createInitializationVector(segmentNumber);
                            decryptdata.keyFormat = "identity";
                        }
                        return decryptdata;
                    };
                    _proto2.setElementaryStreamInfo = function setElementaryStreamInfo(type, startPTS, endPTS, startDTS, endDTS, partial) {
                        if (partial === void 0) {
                            partial = false;
                        }
                        var elementaryStreams = this.elementaryStreams;
                        var info = elementaryStreams[type];
                        if (!info) {
                            elementaryStreams[type] = { startPTS: startPTS, endPTS: endPTS, startDTS: startDTS, endDTS: endDTS, partial: partial };
                            return;
                        }
                        info.startPTS = Math.min(info.startPTS, startPTS);
                        info.endPTS = Math.max(info.endPTS, endPTS);
                        info.startDTS = Math.min(info.startDTS, startDTS);
                        info.endDTS = Math.max(info.endDTS, endDTS);
                    };
                    _proto2.clearElementaryStreamInfo = function clearElementaryStreamInfo() {
                        var elementaryStreams = this.elementaryStreams;
                        elementaryStreams[ElementaryStreamTypes.AUDIO] = null;
                        elementaryStreams[ElementaryStreamTypes.VIDEO] = null;
                        elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;
                    };
                    _createClass(Fragment, [
                        {
                            key: "decryptdata",
                            get: function get() {
                                if (!this.levelkey && !this._decryptdata) {
                                    return null;
                                }
                                if (!this._decryptdata && this.levelkey) {
                                    var sn = this.sn;
                                    if (typeof sn !== "number") {
                                        if (this.levelkey && this.levelkey.method === "AES-128" && !this.levelkey.iv) {
                                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn('missing IV for initialization segment with method="' + this.levelkey.method + '" - compliance issue');
                                        }
                                        sn = 0;
                                    }
                                    this._decryptdata = this.setDecryptDataFromLevelKey(this.levelkey, sn);
                                }
                                return this._decryptdata;
                            },
                        },
                        {
                            key: "end",
                            get: function get() {
                                return this.start + this.duration;
                            },
                        },
                        {
                            key: "endProgramDateTime",
                            get: function get() {
                                if (this.programDateTime === null) {
                                    return null;
                                }
                                if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(this.programDateTime)) {
                                    return null;
                                }
                                var duration = !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(this.duration) ? 0 : this.duration;
                                return this.programDateTime + duration * 1e3;
                            },
                        },
                        {
                            key: "encrypted",
                            get: function get() {
                                var _this$decryptdata;
                                if ((_this$decryptdata = this.decryptdata) !== null && _this$decryptdata !== void 0 && _this$decryptdata.keyFormat && this.decryptdata.uri) {
                                    return true;
                                }
                                return false;
                            },
                        },
                    ]);
                    return Fragment;
                })(BaseSegment);
                var Part = (function (_BaseSegment2) {
                    _inheritsLoose(Part, _BaseSegment2);
                    function Part(partAttrs, frag, baseurl, index, previous) {
                        var _this2;
                        _this2 = _BaseSegment2.call(this, baseurl) || this;
                        _this2.fragOffset = 0;
                        _this2.duration = 0;
                        _this2.gap = false;
                        _this2.independent = false;
                        _this2.relurl = void 0;
                        _this2.fragment = void 0;
                        _this2.index = void 0;
                        _this2.stats = new _load_stats__WEBPACK_IMPORTED_MODULE_4__["LoadStats"]();
                        _this2.duration = partAttrs.decimalFloatingPoint("DURATION");
                        _this2.gap = partAttrs.bool("GAP");
                        _this2.independent = partAttrs.bool("INDEPENDENT");
                        _this2.relurl = partAttrs.enumeratedString("URI");
                        _this2.fragment = frag;
                        _this2.index = index;
                        var byteRange = partAttrs.enumeratedString("BYTERANGE");
                        if (byteRange) {
                            _this2.setByteRange(byteRange, previous);
                        }
                        if (previous) {
                            _this2.fragOffset = previous.fragOffset + previous.duration;
                        }
                        return _this2;
                    }
                    _createClass(Part, [
                        {
                            key: "start",
                            get: function get() {
                                return this.fragment.start + this.fragOffset;
                            },
                        },
                        {
                            key: "end",
                            get: function get() {
                                return this.start + this.duration;
                            },
                        },
                        {
                            key: "loaded",
                            get: function get() {
                                var elementaryStreams = this.elementaryStreams;
                                return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);
                            },
                        },
                    ]);
                    return Part;
                })(BaseSegment);
            },
            "./src/loader/key-loader.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "default", function () {
                    return KeyLoader;
                });
                var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/events.ts");
                var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/errors.ts");
                var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/logger.ts");
                var KeyLoader = (function () {
                    function KeyLoader(hls) {
                        this.hls = void 0;
                        this.loaders = {};
                        this.decryptkey = null;
                        this.decrypturl = null;
                        this.hls = hls;
                        this.registerListeners();
                    }
                    var _proto = KeyLoader.prototype;
                    _proto.startLoad = function startLoad(startPosition) {};
                    _proto.stopLoad = function stopLoad() {
                        this.destroyInternalLoaders();
                    };
                    _proto.registerListeners = function registerListeners() {
                        this.hls.on(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].KEY_LOADING, this.onKeyLoading, this);
                    };
                    _proto.unregisterListeners = function unregisterListeners() {
                        this.hls.off(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].KEY_LOADING, this.onKeyLoading);
                    };
                    _proto.destroyInternalLoaders = function destroyInternalLoaders() {
                        for (var loaderName in this.loaders) {
                            var loader = this.loaders[loaderName];
                            if (loader) {
                                loader.destroy();
                            }
                        }
                        this.loaders = {};
                    };
                    _proto.destroy = function destroy() {
                        this.unregisterListeners();
                        this.destroyInternalLoaders();
                    };
                    _proto.onKeyLoading = function onKeyLoading(event, data) {
                        var frag = data.frag;
                        var type = frag.type;
                        var loader = this.loaders[type];
                        if (!frag.decryptdata) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn("Missing decryption data on fragment in onKeyLoading");
                            return;
                        }
                        var uri = frag.decryptdata.uri;
                        if (uri !== this.decrypturl || this.decryptkey === null) {
                            var config = this.hls.config;
                            if (loader) {
                                _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn("abort previous key loader for type:" + type);
                                loader.abort();
                            }
                            if (!uri) {
                                _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].warn("key uri is falsy");
                                return;
                            }
                            var Loader = config.loader;
                            var fragLoader = (frag.loader = this.loaders[type] = new Loader(config));
                            this.decrypturl = uri;
                            this.decryptkey = null;
                            var loaderContext = { url: uri, frag: frag, responseType: "arraybuffer" };
                            var loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: 0, retryDelay: config.fragLoadingRetryDelay, maxRetryDelay: config.fragLoadingMaxRetryTimeout, highWaterMark: 0 };
                            var loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
                            fragLoader.load(loaderContext, loaderConfig, loaderCallbacks);
                        } else if (this.decryptkey) {
                            frag.decryptdata.key = this.decryptkey;
                            this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].KEY_LOADED, { frag: frag });
                        }
                    };
                    _proto.loadsuccess = function loadsuccess(response, stats, context) {
                        var frag = context.frag;
                        if (!frag.decryptdata) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_2__["logger"].error("after key load, decryptdata unset");
                            return;
                        }
                        this.decryptkey = frag.decryptdata.key = new Uint8Array(response.data);
                        frag.loader = null;
                        delete this.loaders[frag.type];
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].KEY_LOADED, { frag: frag });
                    };
                    _proto.loaderror = function loaderror(response, context) {
                        var frag = context.frag;
                        var loader = frag.loader;
                        if (loader) {
                            loader.abort();
                        }
                        delete this.loaders[frag.type];
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, {
                            type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].NETWORK_ERROR,
                            details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].KEY_LOAD_ERROR,
                            fatal: false,
                            frag: frag,
                            response: response,
                        });
                    };
                    _proto.loadtimeout = function loadtimeout(stats, context) {
                        var frag = context.frag;
                        var loader = frag.loader;
                        if (loader) {
                            loader.abort();
                        }
                        delete this.loaders[frag.type];
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_0__["Events"].ERROR, {
                            type: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorTypes"].NETWORK_ERROR,
                            details: _errors__WEBPACK_IMPORTED_MODULE_1__["ErrorDetails"].KEY_LOAD_TIMEOUT,
                            fatal: false,
                            frag: frag,
                        });
                    };
                    return KeyLoader;
                })();
            },
            "./src/loader/level-details.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "LevelDetails", function () {
                    return LevelDetails;
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/polyfills/number.ts");
                function _defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    Object.defineProperty(Constructor, "prototype", { writable: false });
                    return Constructor;
                }
                var DEFAULT_TARGET_DURATION = 10;
                var LevelDetails = (function () {
                    function LevelDetails(baseUrl) {
                        this.PTSKnown = false;
                        this.alignedSliding = false;
                        this.averagetargetduration = void 0;
                        this.endCC = 0;
                        this.endSN = 0;
                        this.fragments = void 0;
                        this.fragmentHint = void 0;
                        this.partList = null;
                        this.dateRanges = void 0;
                        this.live = true;
                        this.ageHeader = 0;
                        this.advancedDateTime = void 0;
                        this.updated = true;
                        this.advanced = true;
                        this.availabilityDelay = void 0;
                        this.misses = 0;
                        this.needSidxRanges = false;
                        this.startCC = 0;
                        this.startSN = 0;
                        this.startTimeOffset = null;
                        this.targetduration = 0;
                        this.totalduration = 0;
                        this.type = null;
                        this.url = void 0;
                        this.m3u8 = "";
                        this.version = null;
                        this.canBlockReload = false;
                        this.canSkipUntil = 0;
                        this.canSkipDateRanges = false;
                        this.skippedSegments = 0;
                        this.recentlyRemovedDateranges = void 0;
                        this.partHoldBack = 0;
                        this.holdBack = 0;
                        this.partTarget = 0;
                        this.preloadHint = void 0;
                        this.renditionReports = void 0;
                        this.tuneInGoal = 0;
                        this.deltaUpdateFailed = void 0;
                        this.driftStartTime = 0;
                        this.driftEndTime = 0;
                        this.driftStart = 0;
                        this.driftEnd = 0;
                        this.fragments = [];
                        this.dateRanges = {};
                        this.url = baseUrl;
                    }
                    var _proto = LevelDetails.prototype;
                    _proto.reloaded = function reloaded(previous) {
                        if (!previous) {
                            this.advanced = true;
                            this.updated = true;
                            return;
                        }
                        var partSnDiff = this.lastPartSn - previous.lastPartSn;
                        var partIndexDiff = this.lastPartIndex - previous.lastPartIndex;
                        this.updated = this.endSN !== previous.endSN || !!partIndexDiff || !!partSnDiff;
                        this.advanced = this.endSN > previous.endSN || partSnDiff > 0 || (partSnDiff === 0 && partIndexDiff > 0);
                        if (this.updated || this.advanced) {
                            this.misses = Math.floor(previous.misses * 0.6);
                        } else {
                            this.misses = previous.misses + 1;
                        }
                        this.availabilityDelay = previous.availabilityDelay;
                    };
                    _createClass(LevelDetails, [
                        {
                            key: "hasProgramDateTime",
                            get: function get() {
                                if (this.fragments.length) {
                                    return Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(this.fragments[this.fragments.length - 1].programDateTime);
                                }
                                return false;
                            },
                        },
                        {
                            key: "levelTargetDuration",
                            get: function get() {
                                return this.averagetargetduration || this.targetduration || DEFAULT_TARGET_DURATION;
                            },
                        },
                        {
                            key: "drift",
                            get: function get() {
                                var runTime = this.driftEndTime - this.driftStartTime;
                                if (runTime > 0) {
                                    var runDuration = this.driftEnd - this.driftStart;
                                    return (runDuration * 1e3) / runTime;
                                }
                                return 1;
                            },
                        },
                        {
                            key: "edge",
                            get: function get() {
                                return this.partEnd || this.fragmentEnd;
                            },
                        },
                        {
                            key: "partEnd",
                            get: function get() {
                                var _this$partList;
                                if ((_this$partList = this.partList) !== null && _this$partList !== void 0 && _this$partList.length) {
                                    return this.partList[this.partList.length - 1].end;
                                }
                                return this.fragmentEnd;
                            },
                        },
                        {
                            key: "fragmentEnd",
                            get: function get() {
                                var _this$fragments;
                                if ((_this$fragments = this.fragments) !== null && _this$fragments !== void 0 && _this$fragments.length) {
                                    return this.fragments[this.fragments.length - 1].end;
                                }
                                return 0;
                            },
                        },
                        {
                            key: "age",
                            get: function get() {
                                if (this.advancedDateTime) {
                                    return Math.max(Date.now() - this.advancedDateTime, 0) / 1e3;
                                }
                                return 0;
                            },
                        },
                        {
                            key: "lastPartIndex",
                            get: function get() {
                                var _this$partList2;
                                if ((_this$partList2 = this.partList) !== null && _this$partList2 !== void 0 && _this$partList2.length) {
                                    return this.partList[this.partList.length - 1].index;
                                }
                                return -1;
                            },
                        },
                        {
                            key: "lastPartSn",
                            get: function get() {
                                var _this$partList3;
                                if ((_this$partList3 = this.partList) !== null && _this$partList3 !== void 0 && _this$partList3.length) {
                                    return this.partList[this.partList.length - 1].fragment.sn;
                                }
                                return this.endSN;
                            },
                        },
                    ]);
                    return LevelDetails;
                })();
            },
            "./src/loader/level-key.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "LevelKey", function () {
                    return LevelKey;
                });
                var url_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/url-toolkit/src/url-toolkit.js");
                var url_toolkit__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(url_toolkit__WEBPACK_IMPORTED_MODULE_0__);
                function _defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    Object.defineProperty(Constructor, "prototype", { writable: false });
                    return Constructor;
                }
                var LevelKey = (function () {
                    LevelKey.fromURL = function fromURL(baseUrl, relativeUrl) {
                        return new LevelKey(baseUrl, relativeUrl);
                    };
                    LevelKey.fromURI = function fromURI(uri) {
                        return new LevelKey(uri);
                    };
                    function LevelKey(absoluteOrBaseURI, relativeURL) {
                        this._uri = null;
                        this.method = null;
                        this.keyFormat = null;
                        this.keyFormatVersions = null;
                        this.keyID = null;
                        this.key = null;
                        this.iv = null;
                        if (relativeURL) {
                            this._uri = Object(url_toolkit__WEBPACK_IMPORTED_MODULE_0__["buildAbsoluteURL"])(absoluteOrBaseURI, relativeURL, { alwaysNormalize: true });
                        } else {
                            this._uri = absoluteOrBaseURI;
                        }
                    }
                    _createClass(LevelKey, [
                        {
                            key: "uri",
                            get: function get() {
                                return this._uri;
                            },
                        },
                    ]);
                    return LevelKey;
                })();
            },
            "./src/loader/load-stats.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "LoadStats", function () {
                    return LoadStats;
                });
                var LoadStats = function LoadStats() {
                    this.aborted = false;
                    this.loaded = 0;
                    this.retry = 0;
                    this.total = 0;
                    this.chunkCount = 0;
                    this.bwEstimate = 0;
                    this.loading = { start: 0, first: 0, end: 0 };
                    this.parsing = { start: 0, end: 0 };
                    this.buffering = { start: 0, first: 0, end: 0 };
                };
            },
            "./src/loader/m3u8-parser.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "default", function () {
                    return M3U8Parser;
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/polyfills/number.ts");
                var url_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/url-toolkit/src/url-toolkit.js");
                var url_toolkit__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(url_toolkit__WEBPACK_IMPORTED_MODULE_1__);
                var _date_range__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/loader/date-range.ts");
                var _fragment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/loader/fragment.ts");
                var _level_details__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/loader/level-details.ts");
                var _level_key__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/loader/level-key.ts");
                var _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/utils/attr-list.ts");
                var _utils_logger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/utils/logger.ts");
                var _utils_codecs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("./src/utils/codecs.ts");
                var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-SESSION-DATA:([^\r\n]*)[\r\n]+/g;
                var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;
                var LEVEL_PLAYLIST_REGEX_FAST = new RegExp(
                    [/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, /(?!#) *(\S[\S ]*)/.source, /#EXT-X-BYTERANGE:*(.+)/.source, /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, /#.*/.source].join("|"),
                    "g"
                );
                var LEVEL_PLAYLIST_REGEX_SLOW = new RegExp(
                    [
                        /#(EXTM3U)/.source,
                        /#EXT-X-(DATERANGE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source,
                        /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source,
                        /#EXT-X-(DISCONTINUITY|ENDLIST|GAP)/.source,
                        /(#)([^:]*):(.*)/.source,
                        /(#)(.*)(?:.*)\r?\n?/.source,
                    ].join("|")
                );
                var MP4_REGEX_SUFFIX = /\.(mp4|m4s|m4v|m4a)$/i;
                function isMP4Url(url) {
                    var _URLToolkit$parseURL$, _URLToolkit$parseURL;
                    return MP4_REGEX_SUFFIX.test(
                        (_URLToolkit$parseURL$ = (_URLToolkit$parseURL = url_toolkit__WEBPACK_IMPORTED_MODULE_1__["parseURL"](url)) === null || _URLToolkit$parseURL === void 0 ? void 0 : _URLToolkit$parseURL.path) != null
                            ? _URLToolkit$parseURL$
                            : ""
                    );
                }
                var M3U8Parser = (function () {
                    function M3U8Parser() {}
                    M3U8Parser.findGroup = function findGroup(groups, mediaGroupId) {
                        for (var i = 0; i < groups.length; i++) {
                            var group = groups[i];
                            if (group.id === mediaGroupId) {
                                return group;
                            }
                        }
                    };
                    M3U8Parser.convertAVC1ToAVCOTI = function convertAVC1ToAVCOTI(codec) {
                        var avcdata = codec.split(".");
                        if (avcdata.length > 2) {
                            var result = avcdata.shift() + ".";
                            result += parseInt(avcdata.shift()).toString(16);
                            result += ("000" + parseInt(avcdata.shift()).toString(16)).slice(-4);
                            return result;
                        }
                        return codec;
                    };
                    M3U8Parser.resolve = function resolve(url, baseUrl) {
                        return url_toolkit__WEBPACK_IMPORTED_MODULE_1__["buildAbsoluteURL"](baseUrl, url, { alwaysNormalize: true });
                    };
                    M3U8Parser.parseMasterPlaylist = function parseMasterPlaylist(string, baseurl) {
                        var levels = [];
                        var levelsWithKnownCodecs = [];
                        var sessionData = {};
                        var hasSessionData = false;
                        MASTER_PLAYLIST_REGEX.lastIndex = 0;
                        var result;
                        while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {
                            if (result[1]) {
                                var _level$unknownCodecs;
                                var attrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__["AttrList"](result[1]);
                                var level = { attrs: attrs, bitrate: attrs.decimalInteger("AVERAGE-BANDWIDTH") || attrs.decimalInteger("BANDWIDTH"), name: attrs.NAME, url: M3U8Parser.resolve(result[2], baseurl) };
                                var resolution = attrs.decimalResolution("RESOLUTION");
                                if (resolution) {
                                    level.width = resolution.width;
                                    level.height = resolution.height;
                                }
                                setCodecs(
                                    (attrs.CODECS || "").split(/[ ,]+/).filter(function (c) {
                                        return c;
                                    }),
                                    level
                                );
                                if (level.videoCodec && level.videoCodec.indexOf("avc1") !== -1) {
                                    level.videoCodec = M3U8Parser.convertAVC1ToAVCOTI(level.videoCodec);
                                }
                                if (!((_level$unknownCodecs = level.unknownCodecs) !== null && _level$unknownCodecs !== void 0 && _level$unknownCodecs.length)) {
                                    levelsWithKnownCodecs.push(level);
                                }
                                levels.push(level);
                            } else if (result[3]) {
                                var sessionAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__["AttrList"](result[3]);
                                if (sessionAttrs["DATA-ID"]) {
                                    hasSessionData = true;
                                    sessionData[sessionAttrs["DATA-ID"]] = sessionAttrs;
                                }
                            }
                        }
                        var stripUnknownCodecLevels = levelsWithKnownCodecs.length > 0 && levelsWithKnownCodecs.length < levels.length;
                        return { levels: stripUnknownCodecLevels ? levelsWithKnownCodecs : levels, sessionData: hasSessionData ? sessionData : null };
                    };
                    M3U8Parser.parseMasterPlaylistMedia = function parseMasterPlaylistMedia(string, baseurl, type, groups) {
                        if (groups === void 0) {
                            groups = [];
                        }
                        var result;
                        var medias = [];
                        var id = 0;
                        MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;
                        while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {
                            var attrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__["AttrList"](result[1]);
                            if (attrs.TYPE === type) {
                                var media = {
                                    attrs: attrs,
                                    bitrate: 0,
                                    id: id++,
                                    groupId: attrs["GROUP-ID"],
                                    instreamId: attrs["INSTREAM-ID"],
                                    name: attrs.NAME || attrs.LANGUAGE || "",
                                    type: type,
                                    default: attrs.bool("DEFAULT"),
                                    autoselect: attrs.bool("AUTOSELECT"),
                                    forced: attrs.bool("FORCED"),
                                    lang: attrs.LANGUAGE,
                                    url: attrs.URI ? M3U8Parser.resolve(attrs.URI, baseurl) : "",
                                };
                                if (groups.length) {
                                    var groupCodec = M3U8Parser.findGroup(groups, media.groupId) || groups[0];
                                    assignCodec(media, groupCodec, "audioCodec");
                                    assignCodec(media, groupCodec, "textCodec");
                                }
                                medias.push(media);
                            }
                        }
                        return medias;
                    };
                    M3U8Parser.parseLevelPlaylist = function parseLevelPlaylist(string, baseurl, id, type, levelUrlId) {
                        var level = new _level_details__WEBPACK_IMPORTED_MODULE_4__["LevelDetails"](baseurl);
                        var fragments = level.fragments;
                        var currentInitSegment = null;
                        var currentSN = 0;
                        var currentPart = 0;
                        var totalduration = 0;
                        var discontinuityCounter = 0;
                        var prevFrag = null;
                        var frag = new _fragment__WEBPACK_IMPORTED_MODULE_3__["Fragment"](type, baseurl);
                        var result;
                        var i;
                        var levelkey;
                        var firstPdtIndex = -1;
                        var createNextFrag = false;
                        LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;
                        level.m3u8 = string;
                        while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {
                            if (createNextFrag) {
                                createNextFrag = false;
                                frag = new _fragment__WEBPACK_IMPORTED_MODULE_3__["Fragment"](type, baseurl);
                                frag.start = totalduration;
                                frag.sn = currentSN;
                                frag.cc = discontinuityCounter;
                                frag.level = id;
                                if (currentInitSegment) {
                                    frag.initSegment = currentInitSegment;
                                    frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;
                                    currentInitSegment.rawProgramDateTime = null;
                                }
                            }
                            var duration = result[1];
                            if (duration) {
                                frag.duration = parseFloat(duration);
                                var title = (" " + result[2]).slice(1);
                                frag.title = title || null;
                                frag.tagList.push(title ? ["INF", duration, title] : ["INF", duration]);
                            } else if (result[3]) {
                                if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(frag.duration)) {
                                    frag.start = totalduration;
                                    if (levelkey) {
                                        frag.levelkey = levelkey;
                                    }
                                    frag.sn = currentSN;
                                    frag.level = id;
                                    frag.cc = discontinuityCounter;
                                    frag.urlId = levelUrlId;
                                    fragments.push(frag);
                                    frag.relurl = (" " + result[3]).slice(1);
                                    assignProgramDateTime(frag, prevFrag);
                                    prevFrag = frag;
                                    totalduration += frag.duration;
                                    currentSN++;
                                    currentPart = 0;
                                    createNextFrag = true;
                                }
                            } else if (result[4]) {
                                var data = (" " + result[4]).slice(1);
                                if (prevFrag) {
                                    frag.setByteRange(data, prevFrag);
                                } else {
                                    frag.setByteRange(data);
                                }
                            } else if (result[5]) {
                                frag.rawProgramDateTime = (" " + result[5]).slice(1);
                                frag.tagList.push(["PROGRAM-DATE-TIME", frag.rawProgramDateTime]);
                                if (firstPdtIndex === -1) {
                                    firstPdtIndex = fragments.length;
                                }
                            } else {
                                result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);
                                if (!result) {
                                    _utils_logger__WEBPACK_IMPORTED_MODULE_7__["logger"].warn("No matches on slow regex match for level playlist!");
                                    continue;
                                }
                                for (i = 1; i < result.length; i++) {
                                    if (typeof result[i] !== "undefined") {
                                        break;
                                    }
                                }
                                var tag = (" " + result[i]).slice(1);
                                var value1 = (" " + result[i + 1]).slice(1);
                                var value2 = result[i + 2] ? (" " + result[i + 2]).slice(1) : "";
                                switch (tag) {
                                    case "PLAYLIST-TYPE":
                                        level.type = value1.toUpperCase();
                                        break;
                                    case "MEDIA-SEQUENCE":
                                        currentSN = level.startSN = parseInt(value1);
                                        break;
                                    case "SKIP": {
                                        var skipAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__["AttrList"](value1);
                                        var skippedSegments = skipAttrs.decimalInteger("SKIPPED-SEGMENTS");
                                        if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(skippedSegments)) {
                                            level.skippedSegments = skippedSegments;
                                            for (var _i = skippedSegments; _i--; ) {
                                                fragments.unshift(null);
                                            }
                                            currentSN += skippedSegments;
                                        }
                                        var recentlyRemovedDateranges = skipAttrs.enumeratedString("RECENTLY-REMOVED-DATERANGES");
                                        if (recentlyRemovedDateranges) {
                                            level.recentlyRemovedDateranges = recentlyRemovedDateranges.split("\t");
                                        }
                                        break;
                                    }
                                    case "TARGETDURATION":
                                        level.targetduration = parseFloat(value1);
                                        break;
                                    case "VERSION":
                                        level.version = parseInt(value1);
                                        break;
                                    case "EXTM3U":
                                        break;
                                    case "ENDLIST":
                                        level.live = false;
                                        break;
                                    case "#":
                                        if (value1 || value2) {
                                            frag.tagList.push(value2 ? [value1, value2] : [value1]);
                                        }
                                        break;
                                    case "DISCONTINUITY":
                                        discontinuityCounter++;
                                        frag.tagList.push(["DIS"]);
                                        break;
                                    case "GAP":
                                        frag.tagList.push([tag]);
                                        break;
                                    case "BITRATE":
                                        frag.tagList.push([tag, value1]);
                                        break;
                                    case "DATERANGE": {
                                        var dateRangeAttr = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__["AttrList"](value1);
                                        var dateRange = new _date_range__WEBPACK_IMPORTED_MODULE_2__["DateRange"](dateRangeAttr, level.dateRanges[dateRangeAttr.ID]);
                                        if (dateRange.isValid || level.skippedSegments) {
                                            level.dateRanges[dateRange.id] = dateRange;
                                        } else {
                                            _utils_logger__WEBPACK_IMPORTED_MODULE_7__["logger"].warn('Ignoring invalid DATERANGE tag: "' + value1 + '"');
                                        }
                                        frag.tagList.push(["EXT-X-DATERANGE", value1]);
                                        break;
                                    }
                                    case "DISCONTINUITY-SEQUENCE":
                                        discontinuityCounter = parseInt(value1);
                                        break;
                                    case "KEY": {
                                        var _keyAttrs$enumeratedS;
                                        var keyAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__["AttrList"](value1);
                                        var decryptmethod = keyAttrs.enumeratedString("METHOD");
                                        var decrypturi = keyAttrs.URI;
                                        var decryptiv = keyAttrs.hexadecimalInteger("IV");
                                        var decryptkeyformatversions = keyAttrs.enumeratedString("KEYFORMATVERSIONS");
                                        var decryptkeyid = keyAttrs.enumeratedString("KEYID");
                                        var decryptkeyformat = (_keyAttrs$enumeratedS = keyAttrs.enumeratedString("KEYFORMAT")) != null ? _keyAttrs$enumeratedS : "identity";
                                        var unsupportedKnownKeyformatsInManifest = ["com.apple.streamingkeydelivery", "com.microsoft.playready", "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed", "com.widevine"];
                                        if (unsupportedKnownKeyformatsInManifest.indexOf(decryptkeyformat) > -1) {
                                            _utils_logger__WEBPACK_IMPORTED_MODULE_7__["logger"].warn("Keyformat " + decryptkeyformat + " is not supported from the manifest");
                                            continue;
                                        } else if (decryptkeyformat !== "identity") {
                                            continue;
                                        }
                                        if (decryptmethod) {
                                            levelkey = _level_key__WEBPACK_IMPORTED_MODULE_5__["LevelKey"].fromURL(baseurl, decrypturi);
                                            if (decrypturi && ["AES-128", "SAMPLE-AES", "SAMPLE-AES-CENC"].indexOf(decryptmethod) >= 0) {
                                                levelkey.method = decryptmethod;
                                                levelkey.keyFormat = decryptkeyformat;
                                                if (decryptkeyid) {
                                                    levelkey.keyID = decryptkeyid;
                                                }
                                                if (decryptkeyformatversions) {
                                                    levelkey.keyFormatVersions = decryptkeyformatversions;
                                                }
                                                levelkey.iv = decryptiv;
                                            }
                                        }
                                        break;
                                    }
                                    case "START": {
                                        var startAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__["AttrList"](value1);
                                        var startTimeOffset = startAttrs.decimalFloatingPoint("TIME-OFFSET");
                                        if (Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(startTimeOffset)) {
                                            level.startTimeOffset = startTimeOffset;
                                        }
                                        break;
                                    }
                                    case "MAP": {
                                        var mapAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__["AttrList"](value1);
                                        if (frag.duration) {
                                            var init = new _fragment__WEBPACK_IMPORTED_MODULE_3__["Fragment"](type, baseurl);
                                            setInitSegment(init, mapAttrs, id, levelkey);
                                            currentInitSegment = init;
                                            frag.initSegment = currentInitSegment;
                                            if (currentInitSegment.rawProgramDateTime && !frag.rawProgramDateTime) {
                                                frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;
                                            }
                                        } else {
                                            setInitSegment(frag, mapAttrs, id, levelkey);
                                            currentInitSegment = frag;
                                            createNextFrag = true;
                                        }
                                        break;
                                    }
                                    case "SERVER-CONTROL": {
                                        var serverControlAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__["AttrList"](value1);
                                        level.canBlockReload = serverControlAttrs.bool("CAN-BLOCK-RELOAD");
                                        level.canSkipUntil = serverControlAttrs.optionalFloat("CAN-SKIP-UNTIL", 0);
                                        level.canSkipDateRanges = level.canSkipUntil > 0 && serverControlAttrs.bool("CAN-SKIP-DATERANGES");
                                        level.partHoldBack = serverControlAttrs.optionalFloat("PART-HOLD-BACK", 0);
                                        level.holdBack = serverControlAttrs.optionalFloat("HOLD-BACK", 0);
                                        break;
                                    }
                                    case "PART-INF": {
                                        var partInfAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__["AttrList"](value1);
                                        level.partTarget = partInfAttrs.decimalFloatingPoint("PART-TARGET");
                                        break;
                                    }
                                    case "PART": {
                                        var partList = level.partList;
                                        if (!partList) {
                                            partList = level.partList = [];
                                        }
                                        var previousFragmentPart = currentPart > 0 ? partList[partList.length - 1] : undefined;
                                        var index = currentPart++;
                                        var part = new _fragment__WEBPACK_IMPORTED_MODULE_3__["Part"](new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__["AttrList"](value1), frag, baseurl, index, previousFragmentPart);
                                        partList.push(part);
                                        frag.duration += part.duration;
                                        break;
                                    }
                                    case "PRELOAD-HINT": {
                                        var preloadHintAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__["AttrList"](value1);
                                        level.preloadHint = preloadHintAttrs;
                                        break;
                                    }
                                    case "RENDITION-REPORT": {
                                        var renditionReportAttrs = new _utils_attr_list__WEBPACK_IMPORTED_MODULE_6__["AttrList"](value1);
                                        level.renditionReports = level.renditionReports || [];
                                        level.renditionReports.push(renditionReportAttrs);
                                        break;
                                    }
                                    default:
                                        _utils_logger__WEBPACK_IMPORTED_MODULE_7__["logger"].warn("line parsed but not handled: " + result);
                                        break;
                                }
                            }
                        }
                        if (prevFrag && !prevFrag.relurl) {
                            fragments.pop();
                            totalduration -= prevFrag.duration;
                            if (level.partList) {
                                level.fragmentHint = prevFrag;
                            }
                        } else if (level.partList) {
                            assignProgramDateTime(frag, prevFrag);
                            frag.cc = discontinuityCounter;
                            level.fragmentHint = frag;
                        }
                        var fragmentLength = fragments.length;
                        var firstFragment = fragments[0];
                        var lastFragment = fragments[fragmentLength - 1];
                        totalduration += level.skippedSegments * level.targetduration;
                        if (totalduration > 0 && fragmentLength && lastFragment) {
                            level.averagetargetduration = totalduration / fragmentLength;
                            var lastSn = lastFragment.sn;
                            level.endSN = lastSn !== "initSegment" ? lastSn : 0;
                            if (firstFragment) {
                                level.startCC = firstFragment.cc;
                                if (!firstFragment.initSegment) {
                                    if (
                                        level.fragments.every(function (frag) {
                                            return frag.relurl && isMP4Url(frag.relurl);
                                        })
                                    ) {
                                        _utils_logger__WEBPACK_IMPORTED_MODULE_7__["logger"].warn("MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX");
                                        frag = new _fragment__WEBPACK_IMPORTED_MODULE_3__["Fragment"](type, baseurl);
                                        frag.relurl = lastFragment.relurl;
                                        frag.level = id;
                                        frag.sn = "initSegment";
                                        firstFragment.initSegment = frag;
                                        level.needSidxRanges = true;
                                    }
                                }
                            }
                        } else {
                            level.endSN = 0;
                            level.startCC = 0;
                        }
                        if (level.fragmentHint) {
                            totalduration += level.fragmentHint.duration;
                        }
                        level.totalduration = totalduration;
                        level.endCC = discontinuityCounter;
                        if (firstPdtIndex > 0) {
                            backfillProgramDateTimes(fragments, firstPdtIndex);
                        }
                        return level;
                    };
                    return M3U8Parser;
                })();
                function setCodecs(codecs, level) {
                    ["video", "audio", "text"].forEach(function (type) {
                        var filtered = codecs.filter(function (codec) {
                            return Object(_utils_codecs__WEBPACK_IMPORTED_MODULE_8__["isCodecType"])(codec, type);
                        });
                        if (filtered.length) {
                            var preferred = filtered.filter(function (codec) {
                                return codec.lastIndexOf("avc1", 0) === 0 || codec.lastIndexOf("mp4a", 0) === 0;
                            });
                            level[type + "Codec"] = preferred.length > 0 ? preferred[0] : filtered[0];
                            codecs = codecs.filter(function (codec) {
                                return filtered.indexOf(codec) === -1;
                            });
                        }
                    });
                    level.unknownCodecs = codecs;
                }
                function assignCodec(media, groupItem, codecProperty) {
                    var codecValue = groupItem[codecProperty];
                    if (codecValue) {
                        media[codecProperty] = codecValue;
                    }
                }
                function backfillProgramDateTimes(fragments, firstPdtIndex) {
                    var fragPrev = fragments[firstPdtIndex];
                    for (var i = firstPdtIndex; i--; ) {
                        var frag = fragments[i];
                        if (!frag) {
                            return;
                        }
                        frag.programDateTime = fragPrev.programDateTime - frag.duration * 1e3;
                        fragPrev = frag;
                    }
                }
                function assignProgramDateTime(frag, prevFrag) {
                    if (frag.rawProgramDateTime) {
                        frag.programDateTime = Date.parse(frag.rawProgramDateTime);
                    } else if (prevFrag !== null && prevFrag !== void 0 && prevFrag.programDateTime) {
                        frag.programDateTime = prevFrag.endProgramDateTime;
                    }
                    if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(frag.programDateTime)) {
                        frag.programDateTime = null;
                        frag.rawProgramDateTime = null;
                    }
                }
                function setInitSegment(frag, mapAttrs, id, levelkey) {
                    frag.relurl = mapAttrs.URI;
                    if (mapAttrs.BYTERANGE) {
                        frag.setByteRange(mapAttrs.BYTERANGE);
                    }
                    frag.level = id;
                    frag.sn = "initSegment";
                    if (levelkey) {
                        frag.levelkey = levelkey;
                    }
                    frag.initSegment = null;
                }
            },
            "./src/loader/playlist-loader.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/polyfills/number.ts");
                var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/events.ts");
                var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/errors.ts");
                var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/utils/logger.ts");
                var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/utils/mp4-tools.ts");
                var _m3u8_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/loader/m3u8-parser.ts");
                var _types_loader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/types/loader.ts");
                var _utils_attr_list__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/utils/attr-list.ts");
                function mapContextToLevelType(context) {
                    var type = context.type;
                    switch (type) {
                        case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].AUDIO_TRACK:
                            return _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].AUDIO;
                        case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].SUBTITLE_TRACK:
                            return _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].SUBTITLE;
                        default:
                            return _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].MAIN;
                    }
                }
                function getResponseUrl(response, context) {
                    var url = response.url;
                    if (url === undefined || url.indexOf("data:") === 0) {
                        url = context.url;
                    }
                    return url;
                }
                var PlaylistLoader = (function () {
                    function PlaylistLoader(hls) {
                        this.hls = void 0;
                        this.loaders = Object.create(null);
                        this.hls = hls;
                        this.registerListeners();
                    }
                    var _proto = PlaylistLoader.prototype;
                    _proto.startLoad = function startLoad(startPosition) {};
                    _proto.stopLoad = function stopLoad() {
                        this.destroyInternalLoaders();
                    };
                    _proto.registerListeners = function registerListeners() {
                        var hls = this.hls;
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVEL_LOADING, this.onLevelLoading, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);
                        hls.on(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
                    };
                    _proto.unregisterListeners = function unregisterListeners() {
                        var hls = this.hls;
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_LOADING, this.onManifestLoading, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVEL_LOADING, this.onLevelLoading, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);
                        hls.off(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
                    };
                    _proto.createInternalLoader = function createInternalLoader(context) {
                        var config = this.hls.config;
                        var PLoader = config.pLoader;
                        var Loader = config.loader;
                        var InternalLoader = PLoader || Loader;
                        var loader = new InternalLoader(config);
                        context.loader = loader;
                        this.loaders[context.type] = loader;
                        return loader;
                    };
                    _proto.getInternalLoader = function getInternalLoader(context) {
                        return this.loaders[context.type];
                    };
                    _proto.resetInternalLoader = function resetInternalLoader(contextType) {
                        if (this.loaders[contextType]) {
                            delete this.loaders[contextType];
                        }
                    };
                    _proto.destroyInternalLoaders = function destroyInternalLoaders() {
                        for (var contextType in this.loaders) {
                            var loader = this.loaders[contextType];
                            if (loader) {
                                loader.destroy();
                            }
                            this.resetInternalLoader(contextType);
                        }
                    };
                    _proto.destroy = function destroy() {
                        this.unregisterListeners();
                        this.destroyInternalLoaders();
                    };
                    _proto.onManifestLoading = function onManifestLoading(event, data) {
                        var url = data.url;
                        this.load({ id: null, groupId: null, level: 0, responseType: "text", type: _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].MANIFEST, url: url, deliveryDirectives: null });
                    };
                    _proto.onLevelLoading = function onLevelLoading(event, data) {
                        var id = data.id,
                            level = data.level,
                            url = data.url,
                            deliveryDirectives = data.deliveryDirectives;
                        this.load({ id: id, groupId: null, level: level, responseType: "text", type: _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].LEVEL, url: url, deliveryDirectives: deliveryDirectives });
                    };
                    _proto.onAudioTrackLoading = function onAudioTrackLoading(event, data) {
                        var id = data.id,
                            groupId = data.groupId,
                            url = data.url,
                            deliveryDirectives = data.deliveryDirectives;
                        this.load({ id: id, groupId: groupId, level: null, responseType: "text", type: _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].AUDIO_TRACK, url: url, deliveryDirectives: deliveryDirectives });
                    };
                    _proto.onSubtitleTrackLoading = function onSubtitleTrackLoading(event, data) {
                        var id = data.id,
                            groupId = data.groupId,
                            url = data.url,
                            deliveryDirectives = data.deliveryDirectives;
                        this.load({ id: id, groupId: groupId, level: null, responseType: "text", type: _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].SUBTITLE_TRACK, url: url, deliveryDirectives: deliveryDirectives });
                    };
                    _proto.load = function load(context) {
                        var _context$deliveryDire;
                        var config = this.hls.config;
                        var loader = this.getInternalLoader(context);
                        if (loader) {
                            var loaderContext = loader.context;
                            if (loaderContext && loaderContext.url === context.url) {
                                _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].trace("[playlist-loader]: playlist request ongoing");
                                return;
                            }
                            _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].log("[playlist-loader]: aborting previous loader for type: " + context.type);
                            loader.abort();
                        }
                        var maxRetry;
                        var timeout;
                        var retryDelay;
                        var maxRetryDelay;
                        switch (context.type) {
                            case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].MANIFEST:
                                maxRetry = config.manifestLoadingMaxRetry;
                                timeout = config.manifestLoadingTimeOut;
                                retryDelay = config.manifestLoadingRetryDelay;
                                maxRetryDelay = config.manifestLoadingMaxRetryTimeout;
                                break;
                            case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].LEVEL:
                            case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].AUDIO_TRACK:
                            case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].SUBTITLE_TRACK:
                                maxRetry = 0;
                                timeout = config.levelLoadingTimeOut;
                                break;
                            default:
                                maxRetry = config.levelLoadingMaxRetry;
                                timeout = config.levelLoadingTimeOut;
                                retryDelay = config.levelLoadingRetryDelay;
                                maxRetryDelay = config.levelLoadingMaxRetryTimeout;
                                break;
                        }
                        loader = this.createInternalLoader(context);
                        if ((_context$deliveryDire = context.deliveryDirectives) !== null && _context$deliveryDire !== void 0 && _context$deliveryDire.part) {
                            var levelDetails;
                            if (context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].LEVEL && context.level !== null) {
                                levelDetails = this.hls.levels[context.level].details;
                            } else if (context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].AUDIO_TRACK && context.id !== null) {
                                levelDetails = this.hls.audioTracks[context.id].details;
                            } else if (context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].SUBTITLE_TRACK && context.id !== null) {
                                levelDetails = this.hls.subtitleTracks[context.id].details;
                            }
                            if (levelDetails) {
                                var partTarget = levelDetails.partTarget;
                                var targetDuration = levelDetails.targetduration;
                                if (partTarget && targetDuration) {
                                    timeout = Math.min(Math.max(partTarget * 3, targetDuration * 0.8) * 1e3, timeout);
                                }
                            }
                        }
                        var loaderConfig = { timeout: timeout, maxRetry: maxRetry, retryDelay: retryDelay, maxRetryDelay: maxRetryDelay, highWaterMark: 0 };
                        var loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
                        loader.load(context, loaderConfig, loaderCallbacks);
                    };
                    _proto.loadsuccess = function loadsuccess(response, stats, context, networkDetails) {
                        if (networkDetails === void 0) {
                            networkDetails = null;
                        }
                        if (context.isSidxRequest) {
                            this.handleSidxRequest(response, context);
                            this.handlePlaylistLoaded(response, stats, context, networkDetails);
                            return;
                        }
                        this.resetInternalLoader(context.type);
                        var string = response.data;
                        if (string.indexOf("#EXTM3U") !== 0) {
                            this.handleManifestParsingError(response, context, "no EXTM3U delimiter", networkDetails);
                            return;
                        }
                        stats.parsing.start = performance.now();
                        if (string.indexOf("#EXTINF:") > 0 || string.indexOf("#EXT-X-TARGETDURATION:") > 0) {
                            this.handleTrackOrLevelPlaylist(response, stats, context, networkDetails);
                        } else {
                            this.handleMasterPlaylist(response, stats, context, networkDetails);
                        }
                    };
                    _proto.loaderror = function loaderror(response, context, networkDetails) {
                        if (networkDetails === void 0) {
                            networkDetails = null;
                        }
                        this.handleNetworkError(context, networkDetails, false, response);
                    };
                    _proto.loadtimeout = function loadtimeout(stats, context, networkDetails) {
                        if (networkDetails === void 0) {
                            networkDetails = null;
                        }
                        this.handleNetworkError(context, networkDetails, true);
                    };
                    _proto.handleMasterPlaylist = function handleMasterPlaylist(response, stats, context, networkDetails) {
                        var hls = this.hls;
                        var string = response.data;
                        var url = getResponseUrl(response, context);
                        var _M3U8Parser$parseMast = _m3u8_parser__WEBPACK_IMPORTED_MODULE_5__["default"].parseMasterPlaylist(string, url),
                            levels = _M3U8Parser$parseMast.levels,
                            sessionData = _M3U8Parser$parseMast.sessionData;
                        if (!levels.length) {
                            this.handleManifestParsingError(response, context, "no level found in manifest", networkDetails);
                            return;
                        }
                        var audioGroups = levels.map(function (level) {
                            return { id: level.attrs.AUDIO, audioCodec: level.audioCodec };
                        });
                        var subtitleGroups = levels.map(function (level) {
                            return { id: level.attrs.SUBTITLES, textCodec: level.textCodec };
                        });
                        var audioTracks = _m3u8_parser__WEBPACK_IMPORTED_MODULE_5__["default"].parseMasterPlaylistMedia(string, url, "AUDIO", audioGroups);
                        var subtitles = _m3u8_parser__WEBPACK_IMPORTED_MODULE_5__["default"].parseMasterPlaylistMedia(string, url, "SUBTITLES", subtitleGroups);
                        var captions = _m3u8_parser__WEBPACK_IMPORTED_MODULE_5__["default"].parseMasterPlaylistMedia(string, url, "CLOSED-CAPTIONS");
                        if (audioTracks.length) {
                            var embeddedAudioFound = audioTracks.some(function (audioTrack) {
                                return !audioTrack.url;
                            });
                            if (!embeddedAudioFound && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
                                _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one");
                                audioTracks.unshift({ type: "main", name: "main", default: false, autoselect: false, forced: false, id: -1, attrs: new _utils_attr_list__WEBPACK_IMPORTED_MODULE_7__["AttrList"]({}), bitrate: 0, url: "" });
                            }
                        }
                        hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_LOADED, {
                            levels: levels,
                            audioTracks: audioTracks,
                            subtitles: subtitles,
                            captions: captions,
                            url: url,
                            stats: stats,
                            networkDetails: networkDetails,
                            sessionData: sessionData,
                        });
                    };
                    _proto.handleTrackOrLevelPlaylist = function handleTrackOrLevelPlaylist(response, stats, context, networkDetails) {
                        var hls = this.hls;
                        var id = context.id,
                            level = context.level,
                            type = context.type;
                        var url = getResponseUrl(response, context);
                        var levelUrlId = Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(id) ? id : 0;
                        var levelId = Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(level) ? level : levelUrlId;
                        var levelType = mapContextToLevelType(context);
                        var levelDetails = _m3u8_parser__WEBPACK_IMPORTED_MODULE_5__["default"].parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId);
                        if (!levelDetails.fragments.length) {
                            hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, {
                                type: _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorTypes"].NETWORK_ERROR,
                                details: _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].LEVEL_EMPTY_ERROR,
                                fatal: false,
                                url: url,
                                reason: "no fragments found in level",
                                level: typeof context.level === "number" ? context.level : undefined,
                            });
                            return;
                        }
                        if (type === _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].MANIFEST) {
                            var singleLevel = { attrs: new _utils_attr_list__WEBPACK_IMPORTED_MODULE_7__["AttrList"]({}), bitrate: 0, details: levelDetails, name: "", url: url };
                            hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].MANIFEST_LOADED, { levels: [singleLevel], audioTracks: [], url: url, stats: stats, networkDetails: networkDetails, sessionData: null });
                        }
                        stats.parsing.end = performance.now();
                        if (levelDetails.needSidxRanges) {
                            var _levelDetails$fragmen;
                            var sidxUrl = (_levelDetails$fragmen = levelDetails.fragments[0].initSegment) === null || _levelDetails$fragmen === void 0 ? void 0 : _levelDetails$fragmen.url;
                            this.load({ url: sidxUrl, isSidxRequest: true, type: type, level: level, levelDetails: levelDetails, id: id, groupId: null, rangeStart: 0, rangeEnd: 2048, responseType: "arraybuffer", deliveryDirectives: null });
                            return;
                        }
                        context.levelDetails = levelDetails;
                        this.handlePlaylistLoaded(response, stats, context, networkDetails);
                    };
                    _proto.handleSidxRequest = function handleSidxRequest(response, context) {
                        var data = new Uint8Array(response.data);
                        var sidxBox = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__["findBox"])(data, ["sidx"])[0];
                        if (!sidxBox) {
                            return;
                        }
                        var sidxInfo = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__["parseSegmentIndex"])(sidxBox);
                        if (!sidxInfo) {
                            return;
                        }
                        var sidxReferences = sidxInfo.references;
                        var levelDetails = context.levelDetails;
                        sidxReferences.forEach(function (segmentRef, index) {
                            var segRefInfo = segmentRef.info;
                            var frag = levelDetails.fragments[index];
                            if (frag.byteRange.length === 0) {
                                frag.setByteRange(String(1 + segRefInfo.end - segRefInfo.start) + "@" + String(segRefInfo.start));
                            }
                            if (frag.initSegment) {
                                var moovBox = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_4__["findBox"])(data, ["moov"])[0];
                                var moovEndOffset = moovBox ? moovBox.length : null;
                                frag.initSegment.setByteRange(String(moovEndOffset) + "@0");
                            }
                        });
                    };
                    _proto.handleManifestParsingError = function handleManifestParsingError(response, context, reason, networkDetails) {
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, {
                            type: _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorTypes"].NETWORK_ERROR,
                            details: _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].MANIFEST_PARSING_ERROR,
                            fatal: context.type === _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].MANIFEST,
                            url: response.url,
                            reason: reason,
                            response: response,
                            context: context,
                            networkDetails: networkDetails,
                        });
                    };
                    _proto.handleNetworkError = function handleNetworkError(context, networkDetails, timeout, response) {
                        if (timeout === void 0) {
                            timeout = false;
                        }
                        _utils_logger__WEBPACK_IMPORTED_MODULE_3__["logger"].warn(
                            "[playlist-loader]: A network " + (timeout ? "timeout" : "error") + " occurred while loading " + context.type + " level: " + context.level + " id: " + context.id + ' group-id: "' + context.groupId + '"'
                        );
                        var details = _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].UNKNOWN;
                        var fatal = false;
                        var loader = this.getInternalLoader(context);
                        switch (context.type) {
                            case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].MANIFEST:
                                details = timeout ? _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].MANIFEST_LOAD_TIMEOUT : _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].MANIFEST_LOAD_ERROR;
                                fatal = true;
                                break;
                            case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].LEVEL:
                                details = timeout ? _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].LEVEL_LOAD_TIMEOUT : _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].LEVEL_LOAD_ERROR;
                                fatal = false;
                                break;
                            case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].AUDIO_TRACK:
                                details = timeout ? _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].AUDIO_TRACK_LOAD_TIMEOUT : _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].AUDIO_TRACK_LOAD_ERROR;
                                fatal = false;
                                break;
                            case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].SUBTITLE_TRACK:
                                details = timeout ? _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].SUBTITLE_TRACK_LOAD_TIMEOUT : _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorDetails"].SUBTITLE_LOAD_ERROR;
                                fatal = false;
                                break;
                        }
                        if (loader) {
                            this.resetInternalLoader(context.type);
                        }
                        var errorData = { type: _errors__WEBPACK_IMPORTED_MODULE_2__["ErrorTypes"].NETWORK_ERROR, details: details, fatal: fatal, url: context.url, loader: loader, context: context, networkDetails: networkDetails };
                        if (response) {
                            errorData.response = response;
                        }
                        this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].ERROR, errorData);
                    };
                    _proto.handlePlaylistLoaded = function handlePlaylistLoaded(response, stats, context, networkDetails) {
                        var type = context.type,
                            level = context.level,
                            id = context.id,
                            groupId = context.groupId,
                            loader = context.loader,
                            levelDetails = context.levelDetails,
                            deliveryDirectives = context.deliveryDirectives;
                        if (!(levelDetails !== null && levelDetails !== void 0 && levelDetails.targetduration)) {
                            this.handleManifestParsingError(response, context, "invalid target duration", networkDetails);
                            return;
                        }
                        if (!loader) {
                            return;
                        }
                        if (levelDetails.live) {
                            if (loader.getCacheAge) {
                                levelDetails.ageHeader = loader.getCacheAge() || 0;
                            }
                            if (!loader.getCacheAge || isNaN(levelDetails.ageHeader)) {
                                levelDetails.ageHeader = 0;
                            }
                        }
                        switch (type) {
                            case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].MANIFEST:
                            case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].LEVEL:
                                this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].LEVEL_LOADED, {
                                    details: levelDetails,
                                    level: level || 0,
                                    id: id || 0,
                                    stats: stats,
                                    networkDetails: networkDetails,
                                    deliveryDirectives: deliveryDirectives,
                                });
                                break;
                            case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].AUDIO_TRACK:
                                this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].AUDIO_TRACK_LOADED, {
                                    details: levelDetails,
                                    id: id || 0,
                                    groupId: groupId || "",
                                    stats: stats,
                                    networkDetails: networkDetails,
                                    deliveryDirectives: deliveryDirectives,
                                });
                                break;
                            case _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistContextType"].SUBTITLE_TRACK:
                                this.hls.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["Events"].SUBTITLE_TRACK_LOADED, {
                                    details: levelDetails,
                                    id: id || 0,
                                    groupId: groupId || "",
                                    stats: stats,
                                    networkDetails: networkDetails,
                                    deliveryDirectives: deliveryDirectives,
                                });
                                break;
                        }
                    };
                    return PlaylistLoader;
                })();
                __webpack_exports__["default"] = PlaylistLoader;
            },
            "./src/polyfills/number.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "isFiniteNumber", function () {
                    return isFiniteNumber;
                });
                __webpack_require__.d(__webpack_exports__, "MAX_SAFE_INTEGER", function () {
                    return MAX_SAFE_INTEGER;
                });
                var isFiniteNumber =
                    Number.isFinite ||
                    function (value) {
                        return typeof value === "number" && isFinite(value);
                    };
                var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
            },
            "./src/remux/aac-helper.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var AAC = (function () {
                    function AAC() {}
                    AAC.getSilentFrame = function getSilentFrame(codec, channelCount) {
                        switch (codec) {
                            case "mp4a.40.2":
                                if (channelCount === 1) {
                                    return new Uint8Array([0, 200, 0, 128, 35, 128]);
                                } else if (channelCount === 2) {
                                    return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
                                } else if (channelCount === 3) {
                                    return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
                                } else if (channelCount === 4) {
                                    return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
                                } else if (channelCount === 5) {
                                    return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
                                } else if (channelCount === 6) {
                                    return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
                                }
                                break;
                            default:
                                if (channelCount === 1) {
                                    return new Uint8Array([
                                        1,
                                        64,
                                        34,
                                        128,
                                        163,
                                        78,
                                        230,
                                        128,
                                        186,
                                        8,
                                        0,
                                        0,
                                        0,
                                        28,
                                        6,
                                        241,
                                        193,
                                        10,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        94,
                                    ]);
                                } else if (channelCount === 2) {
                                    return new Uint8Array([
                                        1,
                                        64,
                                        34,
                                        128,
                                        163,
                                        94,
                                        230,
                                        128,
                                        186,
                                        8,
                                        0,
                                        0,
                                        0,
                                        0,
                                        149,
                                        0,
                                        6,
                                        241,
                                        161,
                                        10,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        94,
                                    ]);
                                } else if (channelCount === 3) {
                                    return new Uint8Array([
                                        1,
                                        64,
                                        34,
                                        128,
                                        163,
                                        94,
                                        230,
                                        128,
                                        186,
                                        8,
                                        0,
                                        0,
                                        0,
                                        0,
                                        149,
                                        0,
                                        6,
                                        241,
                                        161,
                                        10,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        90,
                                        94,
                                    ]);
                                }
                                break;
                        }
                        return undefined;
                    };
                    return AAC;
                })();
                __webpack_exports__["default"] = AAC;
            },
            "./src/remux/mp4-generator.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var UINT32_MAX = Math.pow(2, 32) - 1;
                var MP4 = (function () {
                    function MP4() {}
                    MP4.init = function init() {
                        MP4.types = {
                            avc1: [],
                            avcC: [],
                            btrt: [],
                            dinf: [],
                            dref: [],
                            esds: [],
                            ftyp: [],
                            hdlr: [],
                            mdat: [],
                            mdhd: [],
                            mdia: [],
                            mfhd: [],
                            minf: [],
                            moof: [],
                            moov: [],
                            mp4a: [],
                            ".mp3": [],
                            mvex: [],
                            mvhd: [],
                            pasp: [],
                            sdtp: [],
                            stbl: [],
                            stco: [],
                            stsc: [],
                            stsd: [],
                            stsz: [],
                            stts: [],
                            tfdt: [],
                            tfhd: [],
                            traf: [],
                            trak: [],
                            trun: [],
                            trex: [],
                            tkhd: [],
                            vmhd: [],
                            smhd: [],
                        };
                        var i;
                        for (i in MP4.types) {
                            if (MP4.types.hasOwnProperty(i)) {
                                MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
                            }
                        }
                        var videoHdlr = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]);
                        var audioHdlr = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]);
                        MP4.HDLR_TYPES = { video: videoHdlr, audio: audioHdlr };
                        var dref = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]);
                        var stco = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
                        MP4.STTS = MP4.STSC = MP4.STCO = stco;
                        MP4.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
                        MP4.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]);
                        MP4.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
                        MP4.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);
                        var majorBrand = new Uint8Array([105, 115, 111, 109]);
                        var avc1Brand = new Uint8Array([97, 118, 99, 49]);
                        var minorVersion = new Uint8Array([0, 0, 0, 1]);
                        MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
                        MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));
                    };
                    MP4.box = function box(type) {
                        var size = 8;
                        for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                            payload[_key - 1] = arguments[_key];
                        }
                        var i = payload.length;
                        var len = i;
                        while (i--) {
                            size += payload[i].byteLength;
                        }
                        var result = new Uint8Array(size);
                        result[0] = (size >> 24) & 255;
                        result[1] = (size >> 16) & 255;
                        result[2] = (size >> 8) & 255;
                        result[3] = size & 255;
                        result.set(type, 4);
                        for (i = 0, size = 8; i < len; i++) {
                            result.set(payload[i], size);
                            size += payload[i].byteLength;
                        }
                        return result;
                    };
                    MP4.hdlr = function hdlr(type) {
                        return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);
                    };
                    MP4.mdat = function mdat(data) {
                        return MP4.box(MP4.types.mdat, data);
                    };
                    MP4.mdhd = function mdhd(timescale, duration) {
                        duration *= timescale;
                        var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
                        var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
                        return MP4.box(
                            MP4.types.mdhd,
                            new Uint8Array([
                                1,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                2,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                3,
                                (timescale >> 24) & 255,
                                (timescale >> 16) & 255,
                                (timescale >> 8) & 255,
                                timescale & 255,
                                upperWordDuration >> 24,
                                (upperWordDuration >> 16) & 255,
                                (upperWordDuration >> 8) & 255,
                                upperWordDuration & 255,
                                lowerWordDuration >> 24,
                                (lowerWordDuration >> 16) & 255,
                                (lowerWordDuration >> 8) & 255,
                                lowerWordDuration & 255,
                                85,
                                196,
                                0,
                                0,
                            ])
                        );
                    };
                    MP4.mdia = function mdia(track) {
                        return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));
                    };
                    MP4.mfhd = function mfhd(sequenceNumber) {
                        return MP4.box(MP4.types.mfhd, new Uint8Array([0, 0, 0, 0, sequenceNumber >> 24, (sequenceNumber >> 16) & 255, (sequenceNumber >> 8) & 255, sequenceNumber & 255]));
                    };
                    MP4.minf = function minf(track) {
                        if (track.type === "audio") {
                            return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));
                        } else {
                            return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));
                        }
                    };
                    MP4.moof = function moof(sn, baseMediaDecodeTime, track) {
                        return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));
                    };
                    MP4.moov = function moov(tracks) {
                        var i = tracks.length;
                        var boxes = [];
                        while (i--) {
                            boxes[i] = MP4.trak(tracks[i]);
                        }
                        return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));
                    };
                    MP4.mvex = function mvex(tracks) {
                        var i = tracks.length;
                        var boxes = [];
                        while (i--) {
                            boxes[i] = MP4.trex(tracks[i]);
                        }
                        return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));
                    };
                    MP4.mvhd = function mvhd(timescale, duration) {
                        duration *= timescale;
                        var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
                        var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
                        var bytes = new Uint8Array([
                            1,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            2,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            3,
                            (timescale >> 24) & 255,
                            (timescale >> 16) & 255,
                            (timescale >> 8) & 255,
                            timescale & 255,
                            upperWordDuration >> 24,
                            (upperWordDuration >> 16) & 255,
                            (upperWordDuration >> 8) & 255,
                            upperWordDuration & 255,
                            lowerWordDuration >> 24,
                            (lowerWordDuration >> 16) & 255,
                            (lowerWordDuration >> 8) & 255,
                            lowerWordDuration & 255,
                            0,
                            1,
                            0,
                            0,
                            1,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            1,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            1,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            64,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            255,
                            255,
                            255,
                            255,
                        ]);
                        return MP4.box(MP4.types.mvhd, bytes);
                    };
                    MP4.sdtp = function sdtp(track) {
                        var samples = track.samples || [];
                        var bytes = new Uint8Array(4 + samples.length);
                        var i;
                        var flags;
                        for (i = 0; i < samples.length; i++) {
                            flags = samples[i].flags;
                            bytes[i + 4] = (flags.dependsOn << 4) | (flags.isDependedOn << 2) | flags.hasRedundancy;
                        }
                        return MP4.box(MP4.types.sdtp, bytes);
                    };
                    MP4.stbl = function stbl(track) {
                        return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));
                    };
                    MP4.avc1 = function avc1(track) {
                        var sps = [];
                        var pps = [];
                        var i;
                        var data;
                        var len;
                        for (i = 0; i < track.sps.length; i++) {
                            data = track.sps[i];
                            len = data.byteLength;
                            sps.push((len >>> 8) & 255);
                            sps.push(len & 255);
                            sps = sps.concat(Array.prototype.slice.call(data));
                        }
                        for (i = 0; i < track.pps.length; i++) {
                            data = track.pps[i];
                            len = data.byteLength;
                            pps.push((len >>> 8) & 255);
                            pps.push(len & 255);
                            pps = pps.concat(Array.prototype.slice.call(data));
                        }
                        var avcc = MP4.box(MP4.types.avcC, new Uint8Array([1, sps[3], sps[4], sps[5], 252 | 3, 224 | track.sps.length].concat(sps).concat([track.pps.length]).concat(pps)));
                        var width = track.width;
                        var height = track.height;
                        var hSpacing = track.pixelRatio[0];
                        var vSpacing = track.pixelRatio[1];
                        return MP4.box(
                            MP4.types.avc1,
                            new Uint8Array([
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                1,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                (width >> 8) & 255,
                                width & 255,
                                (height >> 8) & 255,
                                height & 255,
                                0,
                                72,
                                0,
                                0,
                                0,
                                72,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                1,
                                18,
                                100,
                                97,
                                105,
                                108,
                                121,
                                109,
                                111,
                                116,
                                105,
                                111,
                                110,
                                47,
                                104,
                                108,
                                115,
                                46,
                                106,
                                115,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                24,
                                17,
                                17,
                            ]),
                            avcc,
                            MP4.box(MP4.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])),
                            MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24, (hSpacing >> 16) & 255, (hSpacing >> 8) & 255, hSpacing & 255, vSpacing >> 24, (vSpacing >> 16) & 255, (vSpacing >> 8) & 255, vSpacing & 255]))
                        );
                    };
                    MP4.esds = function esds(track) {
                        var configlen = track.config.length;
                        return new Uint8Array([0, 0, 0, 0, 3, 23 + configlen, 0, 1, 0, 4, 15 + configlen, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([configlen]).concat(track.config).concat([6, 1, 2]));
                    };
                    MP4.mp4a = function mp4a(track) {
                        var samplerate = track.samplerate;
                        return MP4.box(
                            MP4.types.mp4a,
                            new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, track.channelCount, 0, 16, 0, 0, 0, 0, (samplerate >> 8) & 255, samplerate & 255, 0, 0]),
                            MP4.box(MP4.types.esds, MP4.esds(track))
                        );
                    };
                    MP4.mp3 = function mp3(track) {
                        var samplerate = track.samplerate;
                        return MP4.box(MP4.types[".mp3"], new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, track.channelCount, 0, 16, 0, 0, 0, 0, (samplerate >> 8) & 255, samplerate & 255, 0, 0]));
                    };
                    MP4.stsd = function stsd(track) {
                        if (track.type === "audio") {
                            if (track.segmentCodec === "mp3" && track.codec === "mp3") {
                                return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));
                            }
                            return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));
                        } else {
                            return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));
                        }
                    };
                    MP4.tkhd = function tkhd(track) {
                        var id = track.id;
                        var duration = track.duration * track.timescale;
                        var width = track.width;
                        var height = track.height;
                        var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
                        var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
                        return MP4.box(
                            MP4.types.tkhd,
                            new Uint8Array([
                                1,
                                0,
                                0,
                                7,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                2,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                3,
                                (id >> 24) & 255,
                                (id >> 16) & 255,
                                (id >> 8) & 255,
                                id & 255,
                                0,
                                0,
                                0,
                                0,
                                upperWordDuration >> 24,
                                (upperWordDuration >> 16) & 255,
                                (upperWordDuration >> 8) & 255,
                                upperWordDuration & 255,
                                lowerWordDuration >> 24,
                                (lowerWordDuration >> 16) & 255,
                                (lowerWordDuration >> 8) & 255,
                                lowerWordDuration & 255,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                1,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                1,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                64,
                                0,
                                0,
                                0,
                                (width >> 8) & 255,
                                width & 255,
                                0,
                                0,
                                (height >> 8) & 255,
                                height & 255,
                                0,
                                0,
                            ])
                        );
                    };
                    MP4.traf = function traf(track, baseMediaDecodeTime) {
                        var sampleDependencyTable = MP4.sdtp(track);
                        var id = track.id;
                        var upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));
                        var lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
                        return MP4.box(
                            MP4.types.traf,
                            MP4.box(MP4.types.tfhd, new Uint8Array([0, 0, 0, 0, id >> 24, (id >> 16) & 255, (id >> 8) & 255, id & 255])),
                            MP4.box(
                                MP4.types.tfdt,
                                new Uint8Array([
                                    1,
                                    0,
                                    0,
                                    0,
                                    upperWordBaseMediaDecodeTime >> 24,
                                    (upperWordBaseMediaDecodeTime >> 16) & 255,
                                    (upperWordBaseMediaDecodeTime >> 8) & 255,
                                    upperWordBaseMediaDecodeTime & 255,
                                    lowerWordBaseMediaDecodeTime >> 24,
                                    (lowerWordBaseMediaDecodeTime >> 16) & 255,
                                    (lowerWordBaseMediaDecodeTime >> 8) & 255,
                                    lowerWordBaseMediaDecodeTime & 255,
                                ])
                            ),
                            MP4.trun(track, sampleDependencyTable.length + 16 + 20 + 8 + 16 + 8 + 8),
                            sampleDependencyTable
                        );
                    };
                    MP4.trak = function trak(track) {
                        track.duration = track.duration || 4294967295;
                        return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));
                    };
                    MP4.trex = function trex(track) {
                        var id = track.id;
                        return MP4.box(MP4.types.trex, new Uint8Array([0, 0, 0, 0, id >> 24, (id >> 16) & 255, (id >> 8) & 255, id & 255, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]));
                    };
                    MP4.trun = function trun(track, offset) {
                        var samples = track.samples || [];
                        var len = samples.length;
                        var arraylen = 12 + 16 * len;
                        var array = new Uint8Array(arraylen);
                        var i;
                        var sample;
                        var duration;
                        var size;
                        var flags;
                        var cts;
                        offset += 8 + arraylen;
                        array.set([track.type === "video" ? 1 : 0, 0, 15, 1, (len >>> 24) & 255, (len >>> 16) & 255, (len >>> 8) & 255, len & 255, (offset >>> 24) & 255, (offset >>> 16) & 255, (offset >>> 8) & 255, offset & 255], 0);
                        for (i = 0; i < len; i++) {
                            sample = samples[i];
                            duration = sample.duration;
                            size = sample.size;
                            flags = sample.flags;
                            cts = sample.cts;
                            array.set(
                                [
                                    (duration >>> 24) & 255,
                                    (duration >>> 16) & 255,
                                    (duration >>> 8) & 255,
                                    duration & 255,
                                    (size >>> 24) & 255,
                                    (size >>> 16) & 255,
                                    (size >>> 8) & 255,
                                    size & 255,
                                    (flags.isLeading << 2) | flags.dependsOn,
                                    (flags.isDependedOn << 6) | (flags.hasRedundancy << 4) | (flags.paddingValue << 1) | flags.isNonSync,
                                    flags.degradPrio & (240 << 8),
                                    flags.degradPrio & 15,
                                    (cts >>> 24) & 255,
                                    (cts >>> 16) & 255,
                                    (cts >>> 8) & 255,
                                    cts & 255,
                                ],
                                12 + 16 * i
                            );
                        }
                        return MP4.box(MP4.types.trun, array);
                    };
                    MP4.initSegment = function initSegment(tracks) {
                        if (!MP4.types) {
                            MP4.init();
                        }
                        var movie = MP4.moov(tracks);
                        var result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);
                        result.set(MP4.FTYP);
                        result.set(movie, MP4.FTYP.byteLength);
                        return result;
                    };
                    return MP4;
                })();
                MP4.types = void 0;
                MP4.HDLR_TYPES = void 0;
                MP4.STTS = void 0;
                MP4.STSC = void 0;
                MP4.STCO = void 0;
                MP4.STSZ = void 0;
                MP4.VMHD = void 0;
                MP4.SMHD = void 0;
                MP4.STSD = void 0;
                MP4.FTYP = void 0;
                MP4.DINF = void 0;
                __webpack_exports__["default"] = MP4;
            },
            "./src/remux/mp4-remuxer.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "default", function () {
                    return MP4Remuxer;
                });
                __webpack_require__.d(__webpack_exports__, "normalizePts", function () {
                    return normalizePts;
                });
                __webpack_require__.d(__webpack_exports__, "flushTextTrackMetadataCueSamples", function () {
                    return flushTextTrackMetadataCueSamples;
                });
                __webpack_require__.d(__webpack_exports__, "flushTextTrackUserdataCueSamples", function () {
                    return flushTextTrackUserdataCueSamples;
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/polyfills/number.ts");
                var _aac_helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/remux/aac-helper.ts");
                var _mp4_generator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/remux/mp4-generator.ts");
                var _events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/events.ts");
                var _errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/errors.ts");
                var _utils_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/utils/logger.ts");
                var _types_loader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("./src/types/loader.ts");
                var _utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("./src/utils/timescale-conversion.ts");
                function _extends() {
                    _extends = Object.assign
                        ? Object.assign.bind()
                        : function (target) {
                              for (var i = 1; i < arguments.length; i++) {
                                  var source = arguments[i];
                                  for (var key in source) {
                                      if (Object.prototype.hasOwnProperty.call(source, key)) {
                                          target[key] = source[key];
                                      }
                                  }
                              }
                              return target;
                          };
                    return _extends.apply(this, arguments);
                }
                var MAX_SILENT_FRAME_DURATION = 10 * 1e3;
                var AAC_SAMPLES_PER_FRAME = 1024;
                var MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;
                var chromeVersion = null;
                var safariWebkitVersion = null;
                var MP4Remuxer = (function () {
                    function MP4Remuxer(observer, config, typeSupported, vendor) {
                        if (vendor === void 0) {
                            vendor = "";
                        }
                        this.observer = void 0;
                        this.config = void 0;
                        this.typeSupported = void 0;
                        this.ISGenerated = false;
                        this._initPTS = void 0;
                        this._initDTS = void 0;
                        this.nextAvcDts = null;
                        this.nextAudioPts = null;
                        this.videoSampleDuration = null;
                        this.isAudioContiguous = false;
                        this.isVideoContiguous = false;
                        this.observer = observer;
                        this.config = config;
                        this.typeSupported = typeSupported;
                        this.ISGenerated = false;
                        if (chromeVersion === null) {
                            var userAgent = navigator.userAgent || "";
                            var result = userAgent.match(/Chrome\/(\d+)/i);
                            chromeVersion = result ? parseInt(result[1]) : 0;
                        }
                        if (safariWebkitVersion === null) {
                            var _result = navigator.userAgent.match(/Safari\/(\d+)/i);
                            safariWebkitVersion = _result ? parseInt(_result[1]) : 0;
                        }
                    }
                    var _proto = MP4Remuxer.prototype;
                    _proto.destroy = function destroy() {};
                    _proto.resetTimeStamp = function resetTimeStamp(defaultTimeStamp) {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].log("[mp4-remuxer]: initPTS & initDTS reset");
                        this._initPTS = this._initDTS = defaultTimeStamp;
                    };
                    _proto.resetNextTimestamp = function resetNextTimestamp() {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].log("[mp4-remuxer]: reset next timestamp");
                        this.isVideoContiguous = false;
                        this.isAudioContiguous = false;
                    };
                    _proto.resetInitSegment = function resetInitSegment() {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].log("[mp4-remuxer]: ISGenerated flag reset");
                        this.ISGenerated = false;
                    };
                    _proto.getVideoStartPts = function getVideoStartPts(videoSamples) {
                        var rolloverDetected = false;
                        var startPTS = videoSamples.reduce(function (minPTS, sample) {
                            var delta = sample.pts - minPTS;
                            if (delta < -4294967296) {
                                rolloverDetected = true;
                                return normalizePts(minPTS, sample.pts);
                            } else if (delta > 0) {
                                return minPTS;
                            } else {
                                return sample.pts;
                            }
                        }, videoSamples[0].pts);
                        if (rolloverDetected) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].debug("PTS rollover detected");
                        }
                        return startPTS;
                    };
                    _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, flush, playlistType) {
                        var video;
                        var audio;
                        var initSegment;
                        var text;
                        var id3;
                        var independent;
                        var audioTimeOffset = timeOffset;
                        var videoTimeOffset = timeOffset;
                        var hasAudio = audioTrack.pid > -1;
                        var hasVideo = videoTrack.pid > -1;
                        var length = videoTrack.samples.length;
                        var enoughAudioSamples = audioTrack.samples.length > 0;
                        var enoughVideoSamples = (flush && length > 0) || length > 1;
                        var canRemuxAvc = ((!hasAudio || enoughAudioSamples) && (!hasVideo || enoughVideoSamples)) || this.ISGenerated || flush;
                        if (canRemuxAvc) {
                            if (!this.ISGenerated) {
                                initSegment = this.generateIS(audioTrack, videoTrack, timeOffset);
                            }
                            var isVideoContiguous = this.isVideoContiguous;
                            var firstKeyFrameIndex = -1;
                            var firstKeyFramePTS;
                            if (enoughVideoSamples) {
                                firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);
                                if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {
                                    independent = true;
                                    if (firstKeyFrameIndex > 0) {
                                        _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].warn("[mp4-remuxer]: Dropped " + firstKeyFrameIndex + " out of " + length + " video samples due to a missing keyframe");
                                        var startPTS = this.getVideoStartPts(videoTrack.samples);
                                        videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);
                                        videoTrack.dropped += firstKeyFrameIndex;
                                        videoTimeOffset += (videoTrack.samples[0].pts - startPTS) / videoTrack.inputTimeScale;
                                        firstKeyFramePTS = videoTimeOffset;
                                    } else if (firstKeyFrameIndex === -1) {
                                        _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].warn("[mp4-remuxer]: No keyframe found out of " + length + " video samples");
                                        independent = false;
                                    }
                                }
                            }
                            if (this.ISGenerated) {
                                if (enoughAudioSamples && enoughVideoSamples) {
                                    var _startPTS = this.getVideoStartPts(videoTrack.samples);
                                    var tsDelta = normalizePts(audioTrack.samples[0].pts, _startPTS) - _startPTS;
                                    var audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;
                                    audioTimeOffset += Math.max(0, audiovideoTimestampDelta);
                                    videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);
                                }
                                if (enoughAudioSamples) {
                                    if (!audioTrack.samplerate) {
                                        _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].warn("[mp4-remuxer]: regenerate InitSegment as audio detected");
                                        initSegment = this.generateIS(audioTrack, videoTrack, timeOffset);
                                    }
                                    audio = this.remuxAudio(
                                        audioTrack,
                                        audioTimeOffset,
                                        this.isAudioContiguous,
                                        accurateTimeOffset,
                                        hasVideo || enoughVideoSamples || playlistType === _types_loader__WEBPACK_IMPORTED_MODULE_6__["PlaylistLevelType"].AUDIO ? videoTimeOffset : undefined
                                    );
                                    if (enoughVideoSamples) {
                                        var audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0;
                                        if (!videoTrack.inputTimeScale) {
                                            _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].warn("[mp4-remuxer]: regenerate InitSegment as video detected");
                                            initSegment = this.generateIS(audioTrack, videoTrack, timeOffset);
                                        }
                                        video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, audioTrackLength);
                                    }
                                } else if (enoughVideoSamples) {
                                    video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, 0);
                                }
                                if (video) {
                                    video.firstKeyFrame = firstKeyFrameIndex;
                                    video.independent = firstKeyFrameIndex !== -1;
                                    video.firstKeyFramePTS = firstKeyFramePTS;
                                }
                            }
                        }
                        if (this.ISGenerated) {
                            if (id3Track.samples.length) {
                                id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, this._initPTS, this._initDTS);
                            }
                            if (textTrack.samples.length) {
                                text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, this._initPTS);
                            }
                        }
                        return { audio: audio, video: video, initSegment: initSegment, independent: independent, text: text, id3: id3 };
                    };
                    _proto.generateIS = function generateIS(audioTrack, videoTrack, timeOffset) {
                        var audioSamples = audioTrack.samples;
                        var videoSamples = videoTrack.samples;
                        var typeSupported = this.typeSupported;
                        var tracks = {};
                        var computePTSDTS = !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(this._initPTS);
                        var container = "audio/mp4";
                        var initPTS;
                        var initDTS;
                        var timescale;
                        if (computePTSDTS) {
                            initPTS = initDTS = Infinity;
                        }
                        if (audioTrack.config && audioSamples.length) {
                            audioTrack.timescale = audioTrack.samplerate;
                            switch (audioTrack.segmentCodec) {
                                case "mp3":
                                    if (typeSupported.mpeg) {
                                        container = "audio/mpeg";
                                        audioTrack.codec = "";
                                    } else if (typeSupported.mp3) {
                                        audioTrack.codec = "mp3";
                                    }
                                    break;
                            }
                            tracks.audio = {
                                id: "audio",
                                container: container,
                                codec: audioTrack.codec,
                                initSegment: audioTrack.segmentCodec === "mp3" && typeSupported.mpeg ? new Uint8Array(0) : _mp4_generator__WEBPACK_IMPORTED_MODULE_2__["default"].initSegment([audioTrack]),
                                metadata: { channelCount: audioTrack.channelCount },
                            };
                            if (computePTSDTS) {
                                timescale = audioTrack.inputTimeScale;
                                initPTS = initDTS = audioSamples[0].pts - Math.round(timescale * timeOffset);
                            }
                        }
                        if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
                            videoTrack.timescale = videoTrack.inputTimeScale;
                            tracks.video = {
                                id: "main",
                                container: "video/mp4",
                                codec: videoTrack.codec,
                                initSegment: _mp4_generator__WEBPACK_IMPORTED_MODULE_2__["default"].initSegment([videoTrack]),
                                metadata: { width: videoTrack.width, height: videoTrack.height },
                            };
                            if (computePTSDTS) {
                                timescale = videoTrack.inputTimeScale;
                                var startPTS = this.getVideoStartPts(videoSamples);
                                var startOffset = Math.round(timescale * timeOffset);
                                initDTS = Math.min(initDTS, normalizePts(videoSamples[0].dts, startPTS) - startOffset);
                                initPTS = Math.min(initPTS, startPTS - startOffset);
                            }
                        }
                        if (Object.keys(tracks).length) {
                            this.ISGenerated = true;
                            if (computePTSDTS) {
                                this._initPTS = initPTS;
                                this._initDTS = initDTS;
                            }
                            return { tracks: tracks, initPTS: initPTS, timescale: timescale };
                        }
                    };
                    _proto.remuxVideo = function remuxVideo(track, timeOffset, contiguous, audioTrackLength) {
                        var timeScale = track.inputTimeScale;
                        var inputSamples = track.samples;
                        var outputSamples = [];
                        var nbSamples = inputSamples.length;
                        var initPTS = this._initPTS;
                        var nextAvcDts = this.nextAvcDts;
                        var offset = 8;
                        var mp4SampleDuration = this.videoSampleDuration;
                        var firstDTS;
                        var lastDTS;
                        var minPTS = Number.POSITIVE_INFINITY;
                        var maxPTS = Number.NEGATIVE_INFINITY;
                        var sortSamples = false;
                        if (!contiguous || nextAvcDts === null) {
                            var pts = timeOffset * timeScale;
                            var cts = inputSamples[0].pts - normalizePts(inputSamples[0].dts, inputSamples[0].pts);
                            nextAvcDts = pts - cts;
                        }
                        for (var i = 0; i < nbSamples; i++) {
                            var sample = inputSamples[i];
                            sample.pts = normalizePts(sample.pts - initPTS, nextAvcDts);
                            sample.dts = normalizePts(sample.dts - initPTS, nextAvcDts);
                            if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {
                                sortSamples = true;
                            }
                        }
                        if (sortSamples) {
                            inputSamples.sort(function (a, b) {
                                var deltadts = a.dts - b.dts;
                                var deltapts = a.pts - b.pts;
                                return deltadts || deltapts;
                            });
                        }
                        firstDTS = inputSamples[0].dts;
                        lastDTS = inputSamples[inputSamples.length - 1].dts;
                        var inputDuration = lastDTS - firstDTS;
                        var averageSampleDuration = inputDuration ? Math.round(inputDuration / (nbSamples - 1)) : mp4SampleDuration || track.inputTimeScale / 30;
                        if (contiguous) {
                            var delta = firstDTS - nextAvcDts;
                            var foundHole = delta > averageSampleDuration;
                            var foundOverlap = delta < -1;
                            if (foundHole || foundOverlap) {
                                if (foundHole) {
                                    _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].warn(
                                        "AVC: " + Object(_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__["toMsFromMpegTsClock"])(delta, true) + " ms (" + delta + "dts) hole between fragments detected, filling it"
                                    );
                                } else {
                                    _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].warn(
                                        "AVC: " + Object(_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__["toMsFromMpegTsClock"])(-delta, true) + " ms (" + delta + "dts) overlapping between fragments detected"
                                    );
                                }
                                firstDTS = nextAvcDts;
                                var firstPTS = inputSamples[0].pts - delta;
                                inputSamples[0].dts = firstDTS;
                                inputSamples[0].pts = firstPTS;
                                _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].log(
                                    "Video: First PTS/DTS adjusted: " +
                                        Object(_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__["toMsFromMpegTsClock"])(firstPTS, true) +
                                        "/" +
                                        Object(_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__["toMsFromMpegTsClock"])(firstDTS, true) +
                                        ", delta: " +
                                        Object(_utils_timescale_conversion__WEBPACK_IMPORTED_MODULE_7__["toMsFromMpegTsClock"])(delta, true) +
                                        " ms"
                                );
                            }
                        }
                        firstDTS = Math.max(0, firstDTS);
                        var nbNalu = 0;
                        var naluLen = 0;
                        for (var _i = 0; _i < nbSamples; _i++) {
                            var _sample = inputSamples[_i];
                            var units = _sample.units;
                            var nbUnits = units.length;
                            var sampleLen = 0;
                            for (var j = 0; j < nbUnits; j++) {
                                sampleLen += units[j].data.length;
                            }
                            naluLen += sampleLen;
                            nbNalu += nbUnits;
                            _sample.length = sampleLen;
                            _sample.dts = Math.max(_sample.dts, firstDTS);
                            minPTS = Math.min(_sample.pts, minPTS);
                            maxPTS = Math.max(_sample.pts, maxPTS);
                        }
                        lastDTS = inputSamples[nbSamples - 1].dts;
                        var mdatSize = naluLen + 4 * nbNalu + 8;
                        var mdat;
                        try {
                            mdat = new Uint8Array(mdatSize);
                        } catch (err) {
                            this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].ERROR, _events__WEBPACK_IMPORTED_MODULE_3__["Events"].ERROR, {
                                type: _errors__WEBPACK_IMPORTED_MODULE_4__["ErrorTypes"].MUX_ERROR,
                                details: _errors__WEBPACK_IMPORTED_MODULE_4__["ErrorDetails"].REMUX_ALLOC_ERROR,
                                fatal: false,
                                bytes: mdatSize,
                                reason: "fail allocating video mdat " + mdatSize,
                            });
                            return;
                        }
                        var view = new DataView(mdat.buffer);
                        view.setUint32(0, mdatSize);
                        mdat.set(_mp4_generator__WEBPACK_IMPORTED_MODULE_2__["default"].types.mdat, 4);
                        var stretchedLastFrame = false;
                        var minDtsDelta = Number.POSITIVE_INFINITY;
                        var minPtsDelta = Number.POSITIVE_INFINITY;
                        var maxDtsDelta = Number.NEGATIVE_INFINITY;
                        var maxPtsDelta = Number.NEGATIVE_INFINITY;
                        for (var _i2 = 0; _i2 < nbSamples; _i2++) {
                            var avcSample = inputSamples[_i2];
                            var avcSampleUnits = avcSample.units;
                            var mp4SampleLength = 0;
                            for (var _j = 0, _nbUnits = avcSampleUnits.length; _j < _nbUnits; _j++) {
                                var unit = avcSampleUnits[_j];
                                var unitData = unit.data;
                                var unitDataLen = unit.data.byteLength;
                                view.setUint32(offset, unitDataLen);
                                offset += 4;
                                mdat.set(unitData, offset);
                                offset += unitDataLen;
                                mp4SampleLength += 4 + unitDataLen;
                            }
                            var ptsDelta = void 0;
                            if (_i2 < nbSamples - 1) {
                                mp4SampleDuration = inputSamples[_i2 + 1].dts - avcSample.dts;
                                ptsDelta = inputSamples[_i2 + 1].pts - avcSample.pts;
                            } else {
                                var config = this.config;
                                var lastFrameDuration = _i2 > 0 ? avcSample.dts - inputSamples[_i2 - 1].dts : averageSampleDuration;
                                ptsDelta = _i2 > 0 ? avcSample.pts - inputSamples[_i2 - 1].pts : averageSampleDuration;
                                if (config.stretchShortVideoTrack && this.nextAudioPts !== null) {
                                    var gapTolerance = Math.floor(config.maxBufferHole * timeScale);
                                    var deltaToFrameEnd = (audioTrackLength ? minPTS + audioTrackLength * timeScale : this.nextAudioPts) - avcSample.pts;
                                    if (deltaToFrameEnd > gapTolerance) {
                                        mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
                                        if (mp4SampleDuration < 0) {
                                            mp4SampleDuration = lastFrameDuration;
                                        } else {
                                            stretchedLastFrame = true;
                                        }
                                        _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].log(
                                            "[mp4-remuxer]: It is approximately " + deltaToFrameEnd / 90 + " ms to the next segment; using duration " + mp4SampleDuration / 90 + " ms for the last video frame."
                                        );
                                    } else {
                                        mp4SampleDuration = lastFrameDuration;
                                    }
                                } else {
                                    mp4SampleDuration = lastFrameDuration;
                                }
                            }
                            var compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);
                            minDtsDelta = Math.min(minDtsDelta, mp4SampleDuration);
                            maxDtsDelta = Math.max(maxDtsDelta, mp4SampleDuration);
                            minPtsDelta = Math.min(minPtsDelta, ptsDelta);
                            maxPtsDelta = Math.max(maxPtsDelta, ptsDelta);
                            outputSamples.push(new Mp4Sample(avcSample.key, mp4SampleDuration, mp4SampleLength, compositionTimeOffset));
                        }
                        if (outputSamples.length) {
                            if (chromeVersion) {
                                if (chromeVersion < 70) {
                                    var flags = outputSamples[0].flags;
                                    flags.dependsOn = 2;
                                    flags.isNonSync = 0;
                                }
                            } else if (safariWebkitVersion) {
                                if (maxPtsDelta - minPtsDelta < maxDtsDelta - minDtsDelta && averageSampleDuration / maxDtsDelta < 0.025 && outputSamples[0].cts === 0) {
                                    _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
                                    var dts = firstDTS;
                                    for (var _i3 = 0, len = outputSamples.length; _i3 < len; _i3++) {
                                        var nextDts = dts + outputSamples[_i3].duration;
                                        var _pts = dts + outputSamples[_i3].cts;
                                        if (_i3 < len - 1) {
                                            var nextPts = nextDts + outputSamples[_i3 + 1].cts;
                                            outputSamples[_i3].duration = nextPts - _pts;
                                        } else {
                                            outputSamples[_i3].duration = _i3 ? outputSamples[_i3 - 1].duration : averageSampleDuration;
                                        }
                                        outputSamples[_i3].cts = 0;
                                        dts = nextDts;
                                    }
                                }
                            }
                        }
                        console.assert(mp4SampleDuration !== null, "mp4SampleDuration must be computed");
                        mp4SampleDuration = stretchedLastFrame || !mp4SampleDuration ? averageSampleDuration : mp4SampleDuration;
                        this.nextAvcDts = nextAvcDts = lastDTS + mp4SampleDuration;
                        this.videoSampleDuration = mp4SampleDuration;
                        this.isVideoContiguous = true;
                        var moof = _mp4_generator__WEBPACK_IMPORTED_MODULE_2__["default"].moof(track.sequenceNumber++, firstDTS, _extends({}, track, { samples: outputSamples }));
                        var type = "video";
                        var data = {
                            data1: moof,
                            data2: mdat,
                            startPTS: minPTS / timeScale,
                            endPTS: (maxPTS + mp4SampleDuration) / timeScale,
                            startDTS: firstDTS / timeScale,
                            endDTS: nextAvcDts / timeScale,
                            type: type,
                            hasAudio: false,
                            hasVideo: true,
                            nb: outputSamples.length,
                            dropped: track.dropped,
                        };
                        track.samples = [];
                        track.dropped = 0;
                        console.assert(mdat.length, "MDAT length must not be zero");
                        return data;
                    };
                    _proto.remuxAudio = function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset, videoTimeOffset) {
                        var inputTimeScale = track.inputTimeScale;
                        var mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;
                        var scaleFactor = inputTimeScale / mp4timeScale;
                        var mp4SampleDuration = track.segmentCodec === "aac" ? AAC_SAMPLES_PER_FRAME : MPEG_AUDIO_SAMPLE_PER_FRAME;
                        var inputSampleDuration = mp4SampleDuration * scaleFactor;
                        var initPTS = this._initPTS;
                        var rawMPEG = track.segmentCodec === "mp3" && this.typeSupported.mpeg;
                        var outputSamples = [];
                        var alignedWithVideo = videoTimeOffset !== undefined;
                        var inputSamples = track.samples;
                        var offset = rawMPEG ? 0 : 8;
                        var nextAudioPts = this.nextAudioPts || -1;
                        var timeOffsetMpegTS = timeOffset * inputTimeScale;
                        this.isAudioContiguous = contiguous =
                            contiguous ||
                            (inputSamples.length &&
                                nextAudioPts > 0 &&
                                ((accurateTimeOffset && Math.abs(timeOffsetMpegTS - nextAudioPts) < 9e3) || Math.abs(normalizePts(inputSamples[0].pts - initPTS, timeOffsetMpegTS) - nextAudioPts) < 20 * inputSampleDuration));
                        inputSamples.forEach(function (sample) {
                            sample.pts = normalizePts(sample.pts - initPTS, timeOffsetMpegTS);
                        });
                        if (!contiguous || nextAudioPts < 0) {
                            inputSamples = inputSamples.filter(function (sample) {
                                return sample.pts >= 0;
                            });
                            if (!inputSamples.length) {
                                return;
                            }
                            if (videoTimeOffset === 0) {
                                nextAudioPts = 0;
                            } else if (accurateTimeOffset && !alignedWithVideo) {
                                nextAudioPts = Math.max(0, timeOffsetMpegTS);
                            } else {
                                nextAudioPts = inputSamples[0].pts;
                            }
                        }
                        if (track.segmentCodec === "aac") {
                            var maxAudioFramesDrift = this.config.maxAudioFramesDrift;
                            for (var i = 0, nextPts = nextAudioPts; i < inputSamples.length; i++) {
                                var sample = inputSamples[i];
                                var pts = sample.pts;
                                var delta = pts - nextPts;
                                var duration = Math.abs((1e3 * delta) / inputTimeScale);
                                if (delta <= -maxAudioFramesDrift * inputSampleDuration && alignedWithVideo) {
                                    if (i === 0) {
                                        _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].warn("Audio frame @ " + (pts / inputTimeScale).toFixed(3) + "s overlaps nextAudioPts by " + Math.round((1e3 * delta) / inputTimeScale) + " ms.");
                                        this.nextAudioPts = nextAudioPts = nextPts = pts;
                                    }
                                } else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && alignedWithVideo) {
                                    var missing = Math.round(delta / inputSampleDuration);
                                    nextPts = pts - missing * inputSampleDuration;
                                    if (nextPts < 0) {
                                        missing--;
                                        nextPts += inputSampleDuration;
                                    }
                                    if (i === 0) {
                                        this.nextAudioPts = nextAudioPts = nextPts;
                                    }
                                    _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].warn(
                                        "[mp4-remuxer]: Injecting " + missing + " audio frame @ " + (nextPts / inputTimeScale).toFixed(3) + "s due to " + Math.round((1e3 * delta) / inputTimeScale) + " ms gap."
                                    );
                                    for (var j = 0; j < missing; j++) {
                                        var newStamp = Math.max(nextPts, 0);
                                        var fillFrame = _aac_helper__WEBPACK_IMPORTED_MODULE_1__["default"].getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                                        if (!fillFrame) {
                                            _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.");
                                            fillFrame = sample.unit.subarray();
                                        }
                                        inputSamples.splice(i, 0, { unit: fillFrame, pts: newStamp });
                                        nextPts += inputSampleDuration;
                                        i++;
                                    }
                                }
                                sample.pts = nextPts;
                                nextPts += inputSampleDuration;
                            }
                        }
                        var firstPTS = null;
                        var lastPTS = null;
                        var mdat;
                        var mdatSize = 0;
                        var sampleLength = inputSamples.length;
                        while (sampleLength--) {
                            mdatSize += inputSamples[sampleLength].unit.byteLength;
                        }
                        for (var _j2 = 0, _nbSamples = inputSamples.length; _j2 < _nbSamples; _j2++) {
                            var audioSample = inputSamples[_j2];
                            var unit = audioSample.unit;
                            var _pts2 = audioSample.pts;
                            if (lastPTS !== null) {
                                var prevSample = outputSamples[_j2 - 1];
                                prevSample.duration = Math.round((_pts2 - lastPTS) / scaleFactor);
                            } else {
                                if (contiguous && track.segmentCodec === "aac") {
                                    _pts2 = nextAudioPts;
                                }
                                firstPTS = _pts2;
                                if (mdatSize > 0) {
                                    mdatSize += offset;
                                    try {
                                        mdat = new Uint8Array(mdatSize);
                                    } catch (err) {
                                        this.observer.emit(_events__WEBPACK_IMPORTED_MODULE_3__["Events"].ERROR, _events__WEBPACK_IMPORTED_MODULE_3__["Events"].ERROR, {
                                            type: _errors__WEBPACK_IMPORTED_MODULE_4__["ErrorTypes"].MUX_ERROR,
                                            details: _errors__WEBPACK_IMPORTED_MODULE_4__["ErrorDetails"].REMUX_ALLOC_ERROR,
                                            fatal: false,
                                            bytes: mdatSize,
                                            reason: "fail allocating audio mdat " + mdatSize,
                                        });
                                        return;
                                    }
                                    if (!rawMPEG) {
                                        var view = new DataView(mdat.buffer);
                                        view.setUint32(0, mdatSize);
                                        mdat.set(_mp4_generator__WEBPACK_IMPORTED_MODULE_2__["default"].types.mdat, 4);
                                    }
                                } else {
                                    return;
                                }
                            }
                            mdat.set(unit, offset);
                            var unitLen = unit.byteLength;
                            offset += unitLen;
                            outputSamples.push(new Mp4Sample(true, mp4SampleDuration, unitLen, 0));
                            lastPTS = _pts2;
                        }
                        var nbSamples = outputSamples.length;
                        if (!nbSamples) {
                            return;
                        }
                        var lastSample = outputSamples[outputSamples.length - 1];
                        this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSample.duration;
                        var moof = rawMPEG ? new Uint8Array(0) : _mp4_generator__WEBPACK_IMPORTED_MODULE_2__["default"].moof(track.sequenceNumber++, firstPTS / scaleFactor, _extends({}, track, { samples: outputSamples }));
                        track.samples = [];
                        var start = firstPTS / inputTimeScale;
                        var end = nextAudioPts / inputTimeScale;
                        var type = "audio";
                        var audioData = { data1: moof, data2: mdat, startPTS: start, endPTS: end, startDTS: start, endDTS: end, type: type, hasAudio: true, hasVideo: false, nb: nbSamples };
                        this.isAudioContiguous = true;
                        console.assert(mdat.length, "MDAT length must not be zero");
                        return audioData;
                    };
                    _proto.remuxEmptyAudio = function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {
                        var inputTimeScale = track.inputTimeScale;
                        var mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;
                        var scaleFactor = inputTimeScale / mp4timeScale;
                        var nextAudioPts = this.nextAudioPts;
                        var startDTS = (nextAudioPts !== null ? nextAudioPts : videoData.startDTS * inputTimeScale) + this._initDTS;
                        var endDTS = videoData.endDTS * inputTimeScale + this._initDTS;
                        var frameDuration = scaleFactor * AAC_SAMPLES_PER_FRAME;
                        var nbSamples = Math.ceil((endDTS - startDTS) / frameDuration);
                        var silentFrame = _aac_helper__WEBPACK_IMPORTED_MODULE_1__["default"].getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                        _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].warn("[mp4-remuxer]: remux empty Audio");
                        if (!silentFrame) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_5__["logger"].trace("[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec");
                            return;
                        }
                        var samples = [];
                        for (var i = 0; i < nbSamples; i++) {
                            var stamp = startDTS + i * frameDuration;
                            samples.push({ unit: silentFrame, pts: stamp, dts: stamp });
                        }
                        track.samples = samples;
                        return this.remuxAudio(track, timeOffset, contiguous, false);
                    };
                    return MP4Remuxer;
                })();
                function normalizePts(value, reference) {
                    var offset;
                    if (reference === null) {
                        return value;
                    }
                    if (reference < value) {
                        offset = -8589934592;
                    } else {
                        offset = 8589934592;
                    }
                    while (Math.abs(value - reference) > 4294967296) {
                        value += offset;
                    }
                    return value;
                }
                function findKeyframeIndex(samples) {
                    for (var i = 0; i < samples.length; i++) {
                        if (samples[i].key) {
                            return i;
                        }
                    }
                    return -1;
                }
                function flushTextTrackMetadataCueSamples(track, timeOffset, initPTS, initDTS) {
                    var length = track.samples.length;
                    if (!length) {
                        return;
                    }
                    var inputTimeScale = track.inputTimeScale;
                    for (var index = 0; index < length; index++) {
                        var sample = track.samples[index];
                        sample.pts = normalizePts(sample.pts - initPTS, timeOffset * inputTimeScale) / inputTimeScale;
                        sample.dts = normalizePts(sample.dts - initDTS, timeOffset * inputTimeScale) / inputTimeScale;
                    }
                    var samples = track.samples;
                    track.samples = [];
                    return { samples: samples };
                }
                function flushTextTrackUserdataCueSamples(track, timeOffset, initPTS) {
                    var length = track.samples.length;
                    if (!length) {
                        return;
                    }
                    var inputTimeScale = track.inputTimeScale;
                    for (var index = 0; index < length; index++) {
                        var sample = track.samples[index];
                        sample.pts = normalizePts(sample.pts - initPTS, timeOffset * inputTimeScale) / inputTimeScale;
                    }
                    track.samples.sort(function (a, b) {
                        return a.pts - b.pts;
                    });
                    var samples = track.samples;
                    track.samples = [];
                    return { samples: samples };
                }
                var Mp4Sample = function Mp4Sample(isKeyframe, duration, size, cts) {
                    this.size = void 0;
                    this.duration = void 0;
                    this.cts = void 0;
                    this.flags = void 0;
                    this.duration = duration;
                    this.size = size;
                    this.cts = cts;
                    this.flags = new Mp4SampleFlags(isKeyframe);
                };
                var Mp4SampleFlags = function Mp4SampleFlags(isKeyframe) {
                    this.isLeading = 0;
                    this.isDependedOn = 0;
                    this.hasRedundancy = 0;
                    this.degradPrio = 0;
                    this.dependsOn = 1;
                    this.isNonSync = 1;
                    this.dependsOn = isKeyframe ? 2 : 1;
                    this.isNonSync = isKeyframe ? 0 : 1;
                };
            },
            "./src/remux/passthrough-remuxer.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/polyfills/number.ts");
                var _mp4_remuxer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/remux/mp4-remuxer.ts");
                var _utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/mp4-tools.ts");
                var _loader_fragment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/loader/fragment.ts");
                var _utils_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/utils/logger.ts");
                var PassThroughRemuxer = (function () {
                    function PassThroughRemuxer() {
                        this.emitInitSegment = false;
                        this.audioCodec = void 0;
                        this.videoCodec = void 0;
                        this.initData = void 0;
                        this.initPTS = void 0;
                        this.initTracks = void 0;
                        this.lastEndTime = null;
                    }
                    var _proto = PassThroughRemuxer.prototype;
                    _proto.destroy = function destroy() {};
                    _proto.resetTimeStamp = function resetTimeStamp(defaultInitPTS) {
                        this.initPTS = defaultInitPTS;
                        this.lastEndTime = null;
                    };
                    _proto.resetNextTimestamp = function resetNextTimestamp() {
                        this.lastEndTime = null;
                    };
                    _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec) {
                        this.audioCodec = audioCodec;
                        this.videoCodec = videoCodec;
                        this.generateInitSegment(initSegment);
                        this.emitInitSegment = true;
                    };
                    _proto.generateInitSegment = function generateInitSegment(initSegment) {
                        var audioCodec = this.audioCodec,
                            videoCodec = this.videoCodec;
                        if (!initSegment || !initSegment.byteLength) {
                            this.initTracks = undefined;
                            this.initData = undefined;
                            return;
                        }
                        var initData = (this.initData = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__["parseInitSegment"])(initSegment));
                        if (!audioCodec) {
                            audioCodec = getParsedTrackCodec(initData.audio, _loader_fragment__WEBPACK_IMPORTED_MODULE_3__["ElementaryStreamTypes"].AUDIO);
                        }
                        if (!videoCodec) {
                            videoCodec = getParsedTrackCodec(initData.video, _loader_fragment__WEBPACK_IMPORTED_MODULE_3__["ElementaryStreamTypes"].VIDEO);
                        }
                        var tracks = {};
                        if (initData.audio && initData.video) {
                            tracks.audiovideo = { container: "video/mp4", codec: audioCodec + "," + videoCodec, initSegment: initSegment, id: "main" };
                        } else if (initData.audio) {
                            tracks.audio = { container: "audio/mp4", codec: audioCodec, initSegment: initSegment, id: "audio" };
                        } else if (initData.video) {
                            tracks.video = { container: "video/mp4", codec: videoCodec, initSegment: initSegment, id: "main" };
                        } else {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_4__["logger"].warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.");
                        }
                        this.initTracks = tracks;
                    };
                    _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset) {
                        var _this$initPTS;
                        var initPTS = this.initPTS,
                            lastEndTime = this.lastEndTime;
                        var result = { audio: undefined, video: undefined, text: textTrack, id3: id3Track, initSegment: undefined };
                        if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(lastEndTime)) {
                            lastEndTime = this.lastEndTime = timeOffset || 0;
                        }
                        var data = videoTrack.samples;
                        if (!data || !data.length) {
                            return result;
                        }
                        var initSegment = { initPTS: undefined, timescale: 1 };
                        var initData = this.initData;
                        if (!initData || !initData.length) {
                            this.generateInitSegment(data);
                            initData = this.initData;
                        }
                        if (!initData || !initData.length) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_4__["logger"].warn("[passthrough-remuxer.ts]: Failed to generate initSegment.");
                            return result;
                        }
                        if (this.emitInitSegment) {
                            initSegment.tracks = this.initTracks;
                            this.emitInitSegment = false;
                        }
                        var startDTS = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__["getStartDTS"])(initData, data);
                        if (!Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(initPTS)) {
                            this.initPTS = initSegment.initPTS = initPTS = startDTS - timeOffset;
                        }
                        var duration = Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__["getDuration"])(data, initData);
                        var startTime = audioTrack ? startDTS - initPTS : lastEndTime;
                        var endTime = startTime + duration;
                        Object(_utils_mp4_tools__WEBPACK_IMPORTED_MODULE_2__["offsetStartDTS"])(initData, data, initPTS);
                        if (duration > 0) {
                            this.lastEndTime = endTime;
                        } else {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_4__["logger"].warn("Duration parsed from mp4 should be greater than zero");
                            this.resetNextTimestamp();
                        }
                        var hasAudio = !!initData.audio;
                        var hasVideo = !!initData.video;
                        var type = "";
                        if (hasAudio) {
                            type += "audio";
                        }
                        if (hasVideo) {
                            type += "video";
                        }
                        var track = { data1: data, startPTS: startTime, startDTS: startTime, endPTS: endTime, endDTS: endTime, type: type, hasAudio: hasAudio, hasVideo: hasVideo, nb: 1, dropped: 0 };
                        result.audio = track.type === "audio" ? track : undefined;
                        result.video = track.type !== "audio" ? track : undefined;
                        result.initSegment = initSegment;
                        var initPtsNum = (_this$initPTS = this.initPTS) != null ? _this$initPTS : 0;
                        result.id3 = Object(_mp4_remuxer__WEBPACK_IMPORTED_MODULE_1__["flushTextTrackMetadataCueSamples"])(id3Track, timeOffset, initPtsNum, initPtsNum);
                        if (textTrack.samples.length) {
                            result.text = Object(_mp4_remuxer__WEBPACK_IMPORTED_MODULE_1__["flushTextTrackUserdataCueSamples"])(textTrack, timeOffset, initPtsNum);
                        }
                        return result;
                    };
                    return PassThroughRemuxer;
                })();
                function getParsedTrackCodec(track, type) {
                    var parsedCodec = track === null || track === void 0 ? void 0 : track.codec;
                    if (parsedCodec && parsedCodec.length > 4) {
                        return parsedCodec;
                    }
                    if (parsedCodec === "hvc1" || parsedCodec === "hev1") {
                        return "hvc1.1.c.L120.90";
                    }
                    if (parsedCodec === "av01") {
                        return "av01.0.04M.08";
                    }
                    if (parsedCodec === "avc1" || type === _loader_fragment__WEBPACK_IMPORTED_MODULE_3__["ElementaryStreamTypes"].VIDEO) {
                        return "avc1.42e01e";
                    }
                    return "mp4a.40.5";
                }
                __webpack_exports__["default"] = PassThroughRemuxer;
            },
            "./src/task-loop.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "default", function () {
                    return TaskLoop;
                });
                var TaskLoop = (function () {
                    function TaskLoop() {
                        this._boundTick = void 0;
                        this._tickTimer = null;
                        this._tickInterval = null;
                        this._tickCallCount = 0;
                        this._boundTick = this.tick.bind(this);
                    }
                    var _proto = TaskLoop.prototype;
                    _proto.destroy = function destroy() {
                        this.onHandlerDestroying();
                        this.onHandlerDestroyed();
                    };
                    _proto.onHandlerDestroying = function onHandlerDestroying() {
                        this.clearNextTick();
                        this.clearInterval();
                    };
                    _proto.onHandlerDestroyed = function onHandlerDestroyed() {};
                    _proto.hasInterval = function hasInterval() {
                        return !!this._tickInterval;
                    };
                    _proto.hasNextTick = function hasNextTick() {
                        return !!this._tickTimer;
                    };
                    _proto.setInterval = function setInterval(millis) {
                        if (!this._tickInterval) {
                            this._tickInterval = self.setInterval(this._boundTick, millis);
                            return true;
                        }
                        return false;
                    };
                    _proto.clearInterval = function clearInterval() {
                        if (this._tickInterval) {
                            self.clearInterval(this._tickInterval);
                            this._tickInterval = null;
                            return true;
                        }
                        return false;
                    };
                    _proto.clearNextTick = function clearNextTick() {
                        if (this._tickTimer) {
                            self.clearTimeout(this._tickTimer);
                            this._tickTimer = null;
                            return true;
                        }
                        return false;
                    };
                    _proto.tick = function tick() {
                        this._tickCallCount++;
                        if (this._tickCallCount === 1) {
                            this.doTick();
                            if (this._tickCallCount > 1) {
                                this.tickImmediate();
                            }
                            this._tickCallCount = 0;
                        }
                    };
                    _proto.tickImmediate = function tickImmediate() {
                        this.clearNextTick();
                        this._tickTimer = self.setTimeout(this._boundTick, 0);
                    };
                    _proto.doTick = function doTick() {};
                    return TaskLoop;
                })();
            },
            "./src/types/cmcd.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "CMCDVersion", function () {
                    return CMCDVersion;
                });
                __webpack_require__.d(__webpack_exports__, "CMCDObjectType", function () {
                    return CMCDObjectType;
                });
                __webpack_require__.d(__webpack_exports__, "CMCDStreamingFormat", function () {
                    return CMCDStreamingFormat;
                });
                __webpack_require__.d(__webpack_exports__, "CMCDStreamType", function () {
                    return CMCDStreamType;
                });
                var CMCDVersion = 1;
                var CMCDObjectType;
                (function (CMCDObjectType) {
                    CMCDObjectType["MANIFEST"] = "m";
                    CMCDObjectType["AUDIO"] = "a";
                    CMCDObjectType["VIDEO"] = "v";
                    CMCDObjectType["MUXED"] = "av";
                    CMCDObjectType["INIT"] = "i";
                    CMCDObjectType["CAPTION"] = "c";
                    CMCDObjectType["TIMED_TEXT"] = "tt";
                    CMCDObjectType["KEY"] = "k";
                    CMCDObjectType["OTHER"] = "o";
                })(CMCDObjectType || (CMCDObjectType = {}));
                var CMCDStreamingFormat;
                (function (CMCDStreamingFormat) {
                    CMCDStreamingFormat["DASH"] = "d";
                    CMCDStreamingFormat["HLS"] = "h";
                    CMCDStreamingFormat["SMOOTH"] = "s";
                    CMCDStreamingFormat["OTHER"] = "o";
                })(CMCDStreamingFormat || (CMCDStreamingFormat = {}));
                var CMCDStreamType;
                (function (CMCDStreamType) {
                    CMCDStreamType["VOD"] = "v";
                    CMCDStreamType["LIVE"] = "l";
                })(CMCDStreamType || (CMCDStreamType = {}));
            },
            "./src/types/demuxer.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "MetadataSchema", function () {
                    return MetadataSchema;
                });
                var MetadataSchema;
                (function (MetadataSchema) {
                    MetadataSchema["audioId3"] = "org.id3";
                    MetadataSchema["dateRange"] = "com.apple.quicktime.HLS";
                    MetadataSchema["emsg"] = "https://aomedia.org/emsg/ID3";
                })(MetadataSchema || (MetadataSchema = {}));
            },
            "./src/types/level.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "HlsSkip", function () {
                    return HlsSkip;
                });
                __webpack_require__.d(__webpack_exports__, "getSkipValue", function () {
                    return getSkipValue;
                });
                __webpack_require__.d(__webpack_exports__, "HlsUrlParameters", function () {
                    return HlsUrlParameters;
                });
                __webpack_require__.d(__webpack_exports__, "Level", function () {
                    return Level;
                });
                function _defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    Object.defineProperty(Constructor, "prototype", { writable: false });
                    return Constructor;
                }
                var HlsSkip;
                (function (HlsSkip) {
                    HlsSkip["No"] = "";
                    HlsSkip["Yes"] = "YES";
                    HlsSkip["v2"] = "v2";
                })(HlsSkip || (HlsSkip = {}));
                function getSkipValue(details, msn) {
                    var canSkipUntil = details.canSkipUntil,
                        canSkipDateRanges = details.canSkipDateRanges,
                        endSN = details.endSN;
                    var snChangeGoal = msn !== undefined ? msn - endSN : 0;
                    if (canSkipUntil && snChangeGoal < canSkipUntil) {
                        if (canSkipDateRanges) {
                            return HlsSkip.v2;
                        }
                        return HlsSkip.Yes;
                    }
                    return HlsSkip.No;
                }
                var HlsUrlParameters = (function () {
                    function HlsUrlParameters(msn, part, skip) {
                        this.msn = void 0;
                        this.part = void 0;
                        this.skip = void 0;
                        this.msn = msn;
                        this.part = part;
                        this.skip = skip;
                    }
                    var _proto = HlsUrlParameters.prototype;
                    _proto.addDirectives = function addDirectives(uri) {
                        var url = new self.URL(uri);
                        if (this.msn !== undefined) {
                            url.searchParams.set("_HLS_msn", this.msn.toString());
                        }
                        if (this.part !== undefined) {
                            url.searchParams.set("_HLS_part", this.part.toString());
                        }
                        if (this.skip) {
                            url.searchParams.set("_HLS_skip", this.skip);
                        }
                        return url.toString();
                    };
                    return HlsUrlParameters;
                })();
                var Level = (function () {
                    function Level(data) {
                        this.attrs = void 0;
                        this.audioCodec = void 0;
                        this.bitrate = void 0;
                        this.codecSet = void 0;
                        this.height = void 0;
                        this.id = void 0;
                        this.name = void 0;
                        this.videoCodec = void 0;
                        this.width = void 0;
                        this.unknownCodecs = void 0;
                        this.audioGroupIds = void 0;
                        this.details = void 0;
                        this.fragmentError = 0;
                        this.loadError = 0;
                        this.loaded = void 0;
                        this.realBitrate = 0;
                        this.textGroupIds = void 0;
                        this.url = void 0;
                        this._urlId = 0;
                        this.url = [data.url];
                        this.attrs = data.attrs;
                        this.bitrate = data.bitrate;
                        if (data.details) {
                            this.details = data.details;
                        }
                        this.id = data.id || 0;
                        this.name = data.name;
                        this.width = data.width || 0;
                        this.height = data.height || 0;
                        this.audioCodec = data.audioCodec;
                        this.videoCodec = data.videoCodec;
                        this.unknownCodecs = data.unknownCodecs;
                        this.codecSet = [data.videoCodec, data.audioCodec]
                            .filter(function (c) {
                                return c;
                            })
                            .join(",")
                            .replace(/\.[^.,]+/g, "");
                    }
                    _createClass(Level, [
                        {
                            key: "maxBitrate",
                            get: function get() {
                                return Math.max(this.realBitrate, this.bitrate);
                            },
                        },
                        {
                            key: "uri",
                            get: function get() {
                                return this.url[this._urlId] || "";
                            },
                        },
                        {
                            key: "urlId",
                            get: function get() {
                                return this._urlId;
                            },
                            set: function set(value) {
                                var newValue = value % this.url.length;
                                if (this._urlId !== newValue) {
                                    this.details = undefined;
                                    this._urlId = newValue;
                                }
                            },
                        },
                    ]);
                    return Level;
                })();
            },
            "./src/types/loader.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "PlaylistContextType", function () {
                    return PlaylistContextType;
                });
                __webpack_require__.d(__webpack_exports__, "PlaylistLevelType", function () {
                    return PlaylistLevelType;
                });
                var PlaylistContextType;
                (function (PlaylistContextType) {
                    PlaylistContextType["MANIFEST"] = "manifest";
                    PlaylistContextType["LEVEL"] = "level";
                    PlaylistContextType["AUDIO_TRACK"] = "audioTrack";
                    PlaylistContextType["SUBTITLE_TRACK"] = "subtitleTrack";
                })(PlaylistContextType || (PlaylistContextType = {}));
                var PlaylistLevelType;
                (function (PlaylistLevelType) {
                    PlaylistLevelType["MAIN"] = "main";
                    PlaylistLevelType["AUDIO"] = "audio";
                    PlaylistLevelType["SUBTITLE"] = "subtitle";
                })(PlaylistLevelType || (PlaylistLevelType = {}));
            },
            "./src/types/transmuxer.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "ChunkMetadata", function () {
                    return ChunkMetadata;
                });
                var ChunkMetadata = function ChunkMetadata(level, sn, id, size, part, partial) {
                    if (size === void 0) {
                        size = 0;
                    }
                    if (part === void 0) {
                        part = -1;
                    }
                    if (partial === void 0) {
                        partial = false;
                    }
                    this.level = void 0;
                    this.sn = void 0;
                    this.part = void 0;
                    this.id = void 0;
                    this.size = void 0;
                    this.partial = void 0;
                    this.transmuxing = getNewPerformanceTiming();
                    this.buffering = { audio: getNewPerformanceTiming(), video: getNewPerformanceTiming(), audiovideo: getNewPerformanceTiming() };
                    this.level = level;
                    this.sn = sn;
                    this.id = id;
                    this.size = size;
                    this.part = part;
                    this.partial = partial;
                };
                function getNewPerformanceTiming() {
                    return { start: 0, executeStart: 0, executeEnd: 0, end: 0 };
                }
            },
            "./src/utils/attr-list.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "AttrList", function () {
                    return AttrList;
                });
                var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/;
                var ATTR_LIST_REGEX = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g;
                var AttrList = (function () {
                    function AttrList(attrs) {
                        if (typeof attrs === "string") {
                            attrs = AttrList.parseAttrList(attrs);
                        }
                        for (var attr in attrs) {
                            if (attrs.hasOwnProperty(attr)) {
                                this[attr] = attrs[attr];
                            }
                        }
                    }
                    var _proto = AttrList.prototype;
                    _proto.decimalInteger = function decimalInteger(attrName) {
                        var intValue = parseInt(this[attrName], 10);
                        if (intValue > Number.MAX_SAFE_INTEGER) {
                            return Infinity;
                        }
                        return intValue;
                    };
                    _proto.hexadecimalInteger = function hexadecimalInteger(attrName) {
                        if (this[attrName]) {
                            var stringValue = (this[attrName] || "0x").slice(2);
                            stringValue = (stringValue.length & 1 ? "0" : "") + stringValue;
                            var value = new Uint8Array(stringValue.length / 2);
                            for (var i = 0; i < stringValue.length / 2; i++) {
                                value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
                            }
                            return value;
                        } else {
                            return null;
                        }
                    };
                    _proto.hexadecimalIntegerAsNumber = function hexadecimalIntegerAsNumber(attrName) {
                        var intValue = parseInt(this[attrName], 16);
                        if (intValue > Number.MAX_SAFE_INTEGER) {
                            return Infinity;
                        }
                        return intValue;
                    };
                    _proto.decimalFloatingPoint = function decimalFloatingPoint(attrName) {
                        return parseFloat(this[attrName]);
                    };
                    _proto.optionalFloat = function optionalFloat(attrName, defaultValue) {
                        var value = this[attrName];
                        return value ? parseFloat(value) : defaultValue;
                    };
                    _proto.enumeratedString = function enumeratedString(attrName) {
                        return this[attrName];
                    };
                    _proto.bool = function bool(attrName) {
                        return this[attrName] === "YES";
                    };
                    _proto.decimalResolution = function decimalResolution(attrName) {
                        var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);
                        if (res === null) {
                            return undefined;
                        }
                        return { width: parseInt(res[1], 10), height: parseInt(res[2], 10) };
                    };
                    AttrList.parseAttrList = function parseAttrList(input) {
                        var match;
                        var attrs = {};
                        var quote = '"';
                        ATTR_LIST_REGEX.lastIndex = 0;
                        while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
                            var value = match[2];
                            if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {
                                value = value.slice(1, -1);
                            }
                            attrs[match[1]] = value;
                        }
                        return attrs;
                    };
                    return AttrList;
                })();
            },
            "./src/utils/binary-search.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var BinarySearch = {
                    search: function search(list, comparisonFn) {
                        var minIndex = 0;
                        var maxIndex = list.length - 1;
                        var currentIndex = null;
                        var currentElement = null;
                        while (minIndex <= maxIndex) {
                            currentIndex = ((minIndex + maxIndex) / 2) | 0;
                            currentElement = list[currentIndex];
                            var comparisonResult = comparisonFn(currentElement);
                            if (comparisonResult > 0) {
                                minIndex = currentIndex + 1;
                            } else if (comparisonResult < 0) {
                                maxIndex = currentIndex - 1;
                            } else {
                                return currentElement;
                            }
                        }
                        return null;
                    },
                };
                __webpack_exports__["default"] = BinarySearch;
            },
            "./src/utils/buffer-helper.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "BufferHelper", function () {
                    return BufferHelper;
                });
                var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/logger.ts");
                var noopBuffered = {
                    length: 0,
                    start: function start() {
                        return 0;
                    },
                    end: function end() {
                        return 0;
                    },
                };
                var BufferHelper = (function () {
                    function BufferHelper() {}
                    BufferHelper.isBuffered = function isBuffered(media, position) {
                        try {
                            if (media) {
                                var buffered = BufferHelper.getBuffered(media);
                                for (var i = 0; i < buffered.length; i++) {
                                    if (position >= buffered.start(i) && position <= buffered.end(i)) {
                                        return true;
                                    }
                                }
                            }
                        } catch (error) {}
                        return false;
                    };
                    BufferHelper.bufferInfo = function bufferInfo(media, pos, maxHoleDuration) {
                        try {
                            if (media) {
                                var vbuffered = BufferHelper.getBuffered(media);
                                var buffered = [];
                                var i;
                                for (i = 0; i < vbuffered.length; i++) {
                                    buffered.push({ start: vbuffered.start(i), end: vbuffered.end(i) });
                                }
                                return this.bufferedInfo(buffered, pos, maxHoleDuration);
                            }
                        } catch (error) {}
                        return { len: 0, start: pos, end: pos, nextStart: undefined };
                    };
                    BufferHelper.bufferedInfo = function bufferedInfo(buffered, pos, maxHoleDuration) {
                        pos = Math.max(0, pos);
                        buffered.sort(function (a, b) {
                            var diff = a.start - b.start;
                            if (diff) {
                                return diff;
                            } else {
                                return b.end - a.end;
                            }
                        });
                        var buffered2 = [];
                        if (maxHoleDuration) {
                            for (var i = 0; i < buffered.length; i++) {
                                var buf2len = buffered2.length;
                                if (buf2len) {
                                    var buf2end = buffered2[buf2len - 1].end;
                                    if (buffered[i].start - buf2end < maxHoleDuration) {
                                        if (buffered[i].end > buf2end) {
                                            buffered2[buf2len - 1].end = buffered[i].end;
                                        }
                                    } else {
                                        buffered2.push(buffered[i]);
                                    }
                                } else {
                                    buffered2.push(buffered[i]);
                                }
                            }
                        } else {
                            buffered2 = buffered;
                        }
                        var bufferLen = 0;
                        var bufferStartNext;
                        var bufferStart = pos;
                        var bufferEnd = pos;
                        for (var _i = 0; _i < buffered2.length; _i++) {
                            var start = buffered2[_i].start;
                            var end = buffered2[_i].end;
                            if (pos + maxHoleDuration >= start && pos < end) {
                                bufferStart = start;
                                bufferEnd = end;
                                bufferLen = bufferEnd - pos;
                            } else if (pos + maxHoleDuration < start) {
                                bufferStartNext = start;
                                break;
                            }
                        }
                        return { len: bufferLen, start: bufferStart || 0, end: bufferEnd || 0, nextStart: bufferStartNext };
                    };
                    BufferHelper.getBuffered = function getBuffered(media) {
                        try {
                            return media.buffered;
                        } catch (e) {
                            _logger__WEBPACK_IMPORTED_MODULE_0__["logger"].log("failed to get media.buffered", e);
                            return noopBuffered;
                        }
                    };
                    return BufferHelper;
                })();
            },
            "./src/utils/cea-608-parser.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "Row", function () {
                    return Row;
                });
                __webpack_require__.d(__webpack_exports__, "CaptionScreen", function () {
                    return CaptionScreen;
                });
                var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/logger.ts");
                var specialCea608CharsCodes = {
                    42: 225,
                    92: 233,
                    94: 237,
                    95: 243,
                    96: 250,
                    123: 231,
                    124: 247,
                    125: 209,
                    126: 241,
                    127: 9608,
                    128: 174,
                    129: 176,
                    130: 189,
                    131: 191,
                    132: 8482,
                    133: 162,
                    134: 163,
                    135: 9834,
                    136: 224,
                    137: 32,
                    138: 232,
                    139: 226,
                    140: 234,
                    141: 238,
                    142: 244,
                    143: 251,
                    144: 193,
                    145: 201,
                    146: 211,
                    147: 218,
                    148: 220,
                    149: 252,
                    150: 8216,
                    151: 161,
                    152: 42,
                    153: 8217,
                    154: 9473,
                    155: 169,
                    156: 8480,
                    157: 8226,
                    158: 8220,
                    159: 8221,
                    160: 192,
                    161: 194,
                    162: 199,
                    163: 200,
                    164: 202,
                    165: 203,
                    166: 235,
                    167: 206,
                    168: 207,
                    169: 239,
                    170: 212,
                    171: 217,
                    172: 249,
                    173: 219,
                    174: 171,
                    175: 187,
                    176: 195,
                    177: 227,
                    178: 205,
                    179: 204,
                    180: 236,
                    181: 210,
                    182: 242,
                    183: 213,
                    184: 245,
                    185: 123,
                    186: 125,
                    187: 92,
                    188: 94,
                    189: 95,
                    190: 124,
                    191: 8764,
                    192: 196,
                    193: 228,
                    194: 214,
                    195: 246,
                    196: 223,
                    197: 165,
                    198: 164,
                    199: 9475,
                    200: 197,
                    201: 229,
                    202: 216,
                    203: 248,
                    204: 9487,
                    205: 9491,
                    206: 9495,
                    207: 9499,
                };
                var getCharForByte = function getCharForByte(_byte) {
                    var charCode = _byte;
                    if (specialCea608CharsCodes.hasOwnProperty(_byte)) {
                        charCode = specialCea608CharsCodes[_byte];
                    }
                    return String.fromCharCode(charCode);
                };
                var NR_ROWS = 15;
                var NR_COLS = 100;
                var rowsLowCh1 = { 17: 1, 18: 3, 21: 5, 22: 7, 23: 9, 16: 11, 19: 12, 20: 14 };
                var rowsHighCh1 = { 17: 2, 18: 4, 21: 6, 22: 8, 23: 10, 19: 13, 20: 15 };
                var rowsLowCh2 = { 25: 1, 26: 3, 29: 5, 30: 7, 31: 9, 24: 11, 27: 12, 28: 14 };
                var rowsHighCh2 = { 25: 2, 26: 4, 29: 6, 30: 8, 31: 10, 27: 13, 28: 15 };
                var backgroundColors = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"];
                var VerboseLevel;
                (function (VerboseLevel) {
                    VerboseLevel[(VerboseLevel["ERROR"] = 0)] = "ERROR";
                    VerboseLevel[(VerboseLevel["TEXT"] = 1)] = "TEXT";
                    VerboseLevel[(VerboseLevel["WARNING"] = 2)] = "WARNING";
                    VerboseLevel[(VerboseLevel["INFO"] = 2)] = "INFO";
                    VerboseLevel[(VerboseLevel["DEBUG"] = 3)] = "DEBUG";
                    VerboseLevel[(VerboseLevel["DATA"] = 3)] = "DATA";
                })(VerboseLevel || (VerboseLevel = {}));
                var CaptionsLogger = (function () {
                    function CaptionsLogger() {
                        this.time = null;
                        this.verboseLevel = VerboseLevel.ERROR;
                    }
                    var _proto = CaptionsLogger.prototype;
                    _proto.log = function log(severity, msg) {
                        if (this.verboseLevel >= severity) {
                            _utils_logger__WEBPACK_IMPORTED_MODULE_0__["logger"].log(this.time + " [" + severity + "] " + msg);
                        }
                    };
                    return CaptionsLogger;
                })();
                var numArrayToHexArray = function numArrayToHexArray(numArray) {
                    var hexArray = [];
                    for (var j = 0; j < numArray.length; j++) {
                        hexArray.push(numArray[j].toString(16));
                    }
                    return hexArray;
                };
                var PenState = (function () {
                    function PenState(foreground, underline, italics, background, flash) {
                        this.foreground = void 0;
                        this.underline = void 0;
                        this.italics = void 0;
                        this.background = void 0;
                        this.flash = void 0;
                        this.foreground = foreground || "white";
                        this.underline = underline || false;
                        this.italics = italics || false;
                        this.background = background || "black";
                        this.flash = flash || false;
                    }
                    var _proto2 = PenState.prototype;
                    _proto2.reset = function reset() {
                        this.foreground = "white";
                        this.underline = false;
                        this.italics = false;
                        this.background = "black";
                        this.flash = false;
                    };
                    _proto2.setStyles = function setStyles(styles) {
                        var attribs = ["foreground", "underline", "italics", "background", "flash"];
                        for (var i = 0; i < attribs.length; i++) {
                            var style = attribs[i];
                            if (styles.hasOwnProperty(style)) {
                                this[style] = styles[style];
                            }
                        }
                    };
                    _proto2.isDefault = function isDefault() {
                        return this.foreground === "white" && !this.underline && !this.italics && this.background === "black" && !this.flash;
                    };
                    _proto2.equals = function equals(other) {
                        return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;
                    };
                    _proto2.copy = function copy(newPenState) {
                        this.foreground = newPenState.foreground;
                        this.underline = newPenState.underline;
                        this.italics = newPenState.italics;
                        this.background = newPenState.background;
                        this.flash = newPenState.flash;
                    };
                    _proto2.toString = function toString() {
                        return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash;
                    };
                    return PenState;
                })();
                var StyledUnicodeChar = (function () {
                    function StyledUnicodeChar(uchar, foreground, underline, italics, background, flash) {
                        this.uchar = void 0;
                        this.penState = void 0;
                        this.uchar = uchar || " ";
                        this.penState = new PenState(foreground, underline, italics, background, flash);
                    }
                    var _proto3 = StyledUnicodeChar.prototype;
                    _proto3.reset = function reset() {
                        this.uchar = " ";
                        this.penState.reset();
                    };
                    _proto3.setChar = function setChar(uchar, newPenState) {
                        this.uchar = uchar;
                        this.penState.copy(newPenState);
                    };
                    _proto3.setPenState = function setPenState(newPenState) {
                        this.penState.copy(newPenState);
                    };
                    _proto3.equals = function equals(other) {
                        return this.uchar === other.uchar && this.penState.equals(other.penState);
                    };
                    _proto3.copy = function copy(newChar) {
                        this.uchar = newChar.uchar;
                        this.penState.copy(newChar.penState);
                    };
                    _proto3.isEmpty = function isEmpty() {
                        return this.uchar === " " && this.penState.isDefault();
                    };
                    return StyledUnicodeChar;
                })();
                var Row = (function () {
                    function Row(logger) {
                        this.chars = void 0;
                        this.pos = void 0;
                        this.currPenState = void 0;
                        this.cueStartTime = void 0;
                        this.logger = void 0;
                        this.chars = [];
                        for (var i = 0; i < NR_COLS; i++) {
                            this.chars.push(new StyledUnicodeChar());
                        }
                        this.logger = logger;
                        this.pos = 0;
                        this.currPenState = new PenState();
                    }
                    var _proto4 = Row.prototype;
                    _proto4.equals = function equals(other) {
                        var equal = true;
                        for (var i = 0; i < NR_COLS; i++) {
                            if (!this.chars[i].equals(other.chars[i])) {
                                equal = false;
                                break;
                            }
                        }
                        return equal;
                    };
                    _proto4.copy = function copy(other) {
                        for (var i = 0; i < NR_COLS; i++) {
                            this.chars[i].copy(other.chars[i]);
                        }
                    };
                    _proto4.isEmpty = function isEmpty() {
                        var empty = true;
                        for (var i = 0; i < NR_COLS; i++) {
                            if (!this.chars[i].isEmpty()) {
                                empty = false;
                                break;
                            }
                        }
                        return empty;
                    };
                    _proto4.setCursor = function setCursor(absPos) {
                        if (this.pos !== absPos) {
                            this.pos = absPos;
                        }
                        if (this.pos < 0) {
                            this.logger.log(VerboseLevel.DEBUG, "Negative cursor position " + this.pos);
                            this.pos = 0;
                        } else if (this.pos > NR_COLS) {
                            this.logger.log(VerboseLevel.DEBUG, "Too large cursor position " + this.pos);
                            this.pos = NR_COLS;
                        }
                    };
                    _proto4.moveCursor = function moveCursor(relPos) {
                        var newPos = this.pos + relPos;
                        if (relPos > 1) {
                            for (var i = this.pos + 1; i < newPos + 1; i++) {
                                this.chars[i].setPenState(this.currPenState);
                            }
                        }
                        this.setCursor(newPos);
                    };
                    _proto4.backSpace = function backSpace() {
                        this.moveCursor(-1);
                        this.chars[this.pos].setChar(" ", this.currPenState);
                    };
                    _proto4.insertChar = function insertChar(_byte2) {
                        if (_byte2 >= 144) {
                            this.backSpace();
                        }
                        var _char = getCharForByte(_byte2);
                        if (this.pos >= NR_COLS) {
                            this.logger.log(VerboseLevel.ERROR, "Cannot insert " + _byte2.toString(16) + " (" + _char + ") at position " + this.pos + ". Skipping it!");
                            return;
                        }
                        this.chars[this.pos].setChar(_char, this.currPenState);
                        this.moveCursor(1);
                    };
                    _proto4.clearFromPos = function clearFromPos(startPos) {
                        var i;
                        for (i = startPos; i < NR_COLS; i++) {
                            this.chars[i].reset();
                        }
                    };
                    _proto4.clear = function clear() {
                        this.clearFromPos(0);
                        this.pos = 0;
                        this.currPenState.reset();
                    };
                    _proto4.clearToEndOfRow = function clearToEndOfRow() {
                        this.clearFromPos(this.pos);
                    };
                    _proto4.getTextString = function getTextString() {
                        var chars = [];
                        var empty = true;
                        for (var i = 0; i < NR_COLS; i++) {
                            var _char2 = this.chars[i].uchar;
                            if (_char2 !== " ") {
                                empty = false;
                            }
                            chars.push(_char2);
                        }
                        if (empty) {
                            return "";
                        } else {
                            return chars.join("");
                        }
                    };
                    _proto4.setPenStyles = function setPenStyles(styles) {
                        this.currPenState.setStyles(styles);
                        var currChar = this.chars[this.pos];
                        currChar.setPenState(this.currPenState);
                    };
                    return Row;
                })();
                var CaptionScreen = (function () {
                    function CaptionScreen(logger) {
                        this.rows = void 0;
                        this.currRow = void 0;
                        this.nrRollUpRows = void 0;
                        this.lastOutputScreen = void 0;
                        this.logger = void 0;
                        this.rows = [];
                        for (var i = 0; i < NR_ROWS; i++) {
                            this.rows.push(new Row(logger));
                        }
                        this.logger = logger;
                        this.currRow = NR_ROWS - 1;
                        this.nrRollUpRows = null;
                        this.lastOutputScreen = null;
                        this.reset();
                    }
                    var _proto5 = CaptionScreen.prototype;
                    _proto5.reset = function reset() {
                        for (var i = 0; i < NR_ROWS; i++) {
                            this.rows[i].clear();
                        }
                        this.currRow = NR_ROWS - 1;
                    };
                    _proto5.equals = function equals(other) {
                        var equal = true;
                        for (var i = 0; i < NR_ROWS; i++) {
                            if (!this.rows[i].equals(other.rows[i])) {
                                equal = false;
                                break;
                            }
                        }
                        return equal;
                    };
                    _proto5.copy = function copy(other) {
                        for (var i = 0; i < NR_ROWS; i++) {
                            this.rows[i].copy(other.rows[i]);
                        }
                    };
                    _proto5.isEmpty = function isEmpty() {
                        var empty = true;
                        for (var i = 0; i < NR_ROWS; i++) {
                            if (!this.rows[i].isEmpty()) {
                                empty = false;
                                break;
                            }
                        }
                        return empty;
                    };
                    _proto5.backSpace = function backSpace() {
                        var row = this.rows[this.currRow];
                        row.backSpace();
                    };
                    _proto5.clearToEndOfRow = function clearToEndOfRow() {
                        var row = this.rows[this.currRow];
                        row.clearToEndOfRow();
                    };
                    _proto5.insertChar = function insertChar(_char3) {
                        var row = this.rows[this.currRow];
                        row.insertChar(_char3);
                    };
                    _proto5.setPen = function setPen(styles) {
                        var row = this.rows[this.currRow];
                        row.setPenStyles(styles);
                    };
                    _proto5.moveCursor = function moveCursor(relPos) {
                        var row = this.rows[this.currRow];
                        row.moveCursor(relPos);
                    };
                    _proto5.setCursor = function setCursor(absPos) {
                        this.logger.log(VerboseLevel.INFO, "setCursor: " + absPos);
                        var row = this.rows[this.currRow];
                        row.setCursor(absPos);
                    };
                    _proto5.setPAC = function setPAC(pacData) {
                        this.logger.log(VerboseLevel.INFO, "pacData = " + JSON.stringify(pacData));
                        var newRow = pacData.row - 1;
                        if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
                            newRow = this.nrRollUpRows - 1;
                        }
                        if (this.nrRollUpRows && this.currRow !== newRow) {
                            for (var i = 0; i < NR_ROWS; i++) {
                                this.rows[i].clear();
                            }
                            var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
                            var lastOutputScreen = this.lastOutputScreen;
                            if (lastOutputScreen) {
                                var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;
                                var time = this.logger.time;
                                if (prevLineTime && time !== null && prevLineTime < time) {
                                    for (var _i = 0; _i < this.nrRollUpRows; _i++) {
                                        this.rows[newRow - this.nrRollUpRows + _i + 1].copy(lastOutputScreen.rows[topRowIndex + _i]);
                                    }
                                }
                            }
                        }
                        this.currRow = newRow;
                        var row = this.rows[this.currRow];
                        if (pacData.indent !== null) {
                            var indent = pacData.indent;
                            var prevPos = Math.max(indent - 1, 0);
                            row.setCursor(pacData.indent);
                            pacData.color = row.chars[prevPos].penState.foreground;
                        }
                        var styles = { foreground: pacData.color, underline: pacData.underline, italics: pacData.italics, background: "black", flash: false };
                        this.setPen(styles);
                    };
                    _proto5.setBkgData = function setBkgData(bkgData) {
                        this.logger.log(VerboseLevel.INFO, "bkgData = " + JSON.stringify(bkgData));
                        this.backSpace();
                        this.setPen(bkgData);
                        this.insertChar(32);
                    };
                    _proto5.setRollUpRows = function setRollUpRows(nrRows) {
                        this.nrRollUpRows = nrRows;
                    };
                    _proto5.rollUp = function rollUp() {
                        if (this.nrRollUpRows === null) {
                            this.logger.log(VerboseLevel.DEBUG, "roll_up but nrRollUpRows not set yet");
                            return;
                        }
                        this.logger.log(VerboseLevel.TEXT, this.getDisplayText());
                        var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
                        var topRow = this.rows.splice(topRowIndex, 1)[0];
                        topRow.clear();
                        this.rows.splice(this.currRow, 0, topRow);
                        this.logger.log(VerboseLevel.INFO, "Rolling up");
                    };
                    _proto5.getDisplayText = function getDisplayText(asOneRow) {
                        asOneRow = asOneRow || false;
                        var displayText = [];
                        var text = "";
                        var rowNr = -1;
                        for (var i = 0; i < NR_ROWS; i++) {
                            var rowText = this.rows[i].getTextString();
                            if (rowText) {
                                rowNr = i + 1;
                                if (asOneRow) {
                                    displayText.push("Row " + rowNr + ": '" + rowText + "'");
                                } else {
                                    displayText.push(rowText.trim());
                                }
                            }
                        }
                        if (displayText.length > 0) {
                            if (asOneRow) {
                                text = "[" + displayText.join(" | ") + "]";
                            } else {
                                text = displayText.join("\n");
                            }
                        }
                        return text;
                    };
                    _proto5.getTextAndFormat = function getTextAndFormat() {
                        return this.rows;
                    };
                    return CaptionScreen;
                })();
                var Cea608Channel = (function () {
                    function Cea608Channel(channelNumber, outputFilter, logger) {
                        this.chNr = void 0;
                        this.outputFilter = void 0;
                        this.mode = void 0;
                        this.verbose = void 0;
                        this.displayedMemory = void 0;
                        this.nonDisplayedMemory = void 0;
                        this.lastOutputScreen = void 0;
                        this.currRollUpRow = void 0;
                        this.writeScreen = void 0;
                        this.cueStartTime = void 0;
                        this.logger = void 0;
                        this.chNr = channelNumber;
                        this.outputFilter = outputFilter;
                        this.mode = null;
                        this.verbose = 0;
                        this.displayedMemory = new CaptionScreen(logger);
                        this.nonDisplayedMemory = new CaptionScreen(logger);
                        this.lastOutputScreen = new CaptionScreen(logger);
                        this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
                        this.writeScreen = this.displayedMemory;
                        this.mode = null;
                        this.cueStartTime = null;
                        this.logger = logger;
                    }
                    var _proto6 = Cea608Channel.prototype;
                    _proto6.reset = function reset() {
                        this.mode = null;
                        this.displayedMemory.reset();
                        this.nonDisplayedMemory.reset();
                        this.lastOutputScreen.reset();
                        this.outputFilter.reset();
                        this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
                        this.writeScreen = this.displayedMemory;
                        this.mode = null;
                        this.cueStartTime = null;
                    };
                    _proto6.getHandler = function getHandler() {
                        return this.outputFilter;
                    };
                    _proto6.setHandler = function setHandler(newHandler) {
                        this.outputFilter = newHandler;
                    };
                    _proto6.setPAC = function setPAC(pacData) {
                        this.writeScreen.setPAC(pacData);
                    };
                    _proto6.setBkgData = function setBkgData(bkgData) {
                        this.writeScreen.setBkgData(bkgData);
                    };
                    _proto6.setMode = function setMode(newMode) {
                        if (newMode === this.mode) {
                            return;
                        }
                        this.mode = newMode;
                        this.logger.log(VerboseLevel.INFO, "MODE=" + newMode);
                        if (this.mode === "MODE_POP-ON") {
                            this.writeScreen = this.nonDisplayedMemory;
                        } else {
                            this.writeScreen = this.displayedMemory;
                            this.writeScreen.reset();
                        }
                        if (this.mode !== "MODE_ROLL-UP") {
                            this.displayedMemory.nrRollUpRows = null;
                            this.nonDisplayedMemory.nrRollUpRows = null;
                        }
                        this.mode = newMode;
                    };
                    _proto6.insertChars = function insertChars(chars) {
                        for (var i = 0; i < chars.length; i++) {
                            this.writeScreen.insertChar(chars[i]);
                        }
                        var screen = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
                        this.logger.log(VerboseLevel.INFO, screen + ": " + this.writeScreen.getDisplayText(true));
                        if (this.mode === "MODE_PAINT-ON" || this.mode === "MODE_ROLL-UP") {
                            this.logger.log(VerboseLevel.TEXT, "DISPLAYED: " + this.displayedMemory.getDisplayText(true));
                            this.outputDataUpdate();
                        }
                    };
                    _proto6.ccRCL = function ccRCL() {
                        this.logger.log(VerboseLevel.INFO, "RCL - Resume Caption Loading");
                        this.setMode("MODE_POP-ON");
                    };
                    _proto6.ccBS = function ccBS() {
                        this.logger.log(VerboseLevel.INFO, "BS - BackSpace");
                        if (this.mode === "MODE_TEXT") {
                            return;
                        }
                        this.writeScreen.backSpace();
                        if (this.writeScreen === this.displayedMemory) {
                            this.outputDataUpdate();
                        }
                    };
                    _proto6.ccAOF = function ccAOF() {};
                    _proto6.ccAON = function ccAON() {};
                    _proto6.ccDER = function ccDER() {
                        this.logger.log(VerboseLevel.INFO, "DER- Delete to End of Row");
                        this.writeScreen.clearToEndOfRow();
                        this.outputDataUpdate();
                    };
                    _proto6.ccRU = function ccRU(nrRows) {
                        this.logger.log(VerboseLevel.INFO, "RU(" + nrRows + ") - Roll Up");
                        this.writeScreen = this.displayedMemory;
                        this.setMode("MODE_ROLL-UP");
                        this.writeScreen.setRollUpRows(nrRows);
                    };
                    _proto6.ccFON = function ccFON() {
                        this.logger.log(VerboseLevel.INFO, "FON - Flash On");
                        this.writeScreen.setPen({ flash: true });
                    };
                    _proto6.ccRDC = function ccRDC() {
                        this.logger.log(VerboseLevel.INFO, "RDC - Resume Direct Captioning");
                        this.setMode("MODE_PAINT-ON");
                    };
                    _proto6.ccTR = function ccTR() {
                        this.logger.log(VerboseLevel.INFO, "TR");
                        this.setMode("MODE_TEXT");
                    };
                    _proto6.ccRTD = function ccRTD() {
                        this.logger.log(VerboseLevel.INFO, "RTD");
                        this.setMode("MODE_TEXT");
                    };
                    _proto6.ccEDM = function ccEDM() {
                        this.logger.log(VerboseLevel.INFO, "EDM - Erase Displayed Memory");
                        this.displayedMemory.reset();
                        this.outputDataUpdate(true);
                    };
                    _proto6.ccCR = function ccCR() {
                        this.logger.log(VerboseLevel.INFO, "CR - Carriage Return");
                        this.writeScreen.rollUp();
                        this.outputDataUpdate(true);
                    };
                    _proto6.ccENM = function ccENM() {
                        this.logger.log(VerboseLevel.INFO, "ENM - Erase Non-displayed Memory");
                        this.nonDisplayedMemory.reset();
                    };
                    _proto6.ccEOC = function ccEOC() {
                        this.logger.log(VerboseLevel.INFO, "EOC - End Of Caption");
                        if (this.mode === "MODE_POP-ON") {
                            var tmp = this.displayedMemory;
                            this.displayedMemory = this.nonDisplayedMemory;
                            this.nonDisplayedMemory = tmp;
                            this.writeScreen = this.nonDisplayedMemory;
                            this.logger.log(VerboseLevel.TEXT, "DISP: " + this.displayedMemory.getDisplayText());
                        }
                        this.outputDataUpdate(true);
                    };
                    _proto6.ccTO = function ccTO(nrCols) {
                        this.logger.log(VerboseLevel.INFO, "TO(" + nrCols + ") - Tab Offset");
                        this.writeScreen.moveCursor(nrCols);
                    };
                    _proto6.ccMIDROW = function ccMIDROW(secondByte) {
                        var styles = { flash: false };
                        styles.underline = secondByte % 2 === 1;
                        styles.italics = secondByte >= 46;
                        if (!styles.italics) {
                            var colorIndex = Math.floor(secondByte / 2) - 16;
                            var colors = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
                            styles.foreground = colors[colorIndex];
                        } else {
                            styles.foreground = "white";
                        }
                        this.logger.log(VerboseLevel.INFO, "MIDROW: " + JSON.stringify(styles));
                        this.writeScreen.setPen(styles);
                    };
                    _proto6.outputDataUpdate = function outputDataUpdate(dispatch) {
                        if (dispatch === void 0) {
                            dispatch = false;
                        }
                        var time = this.logger.time;
                        if (time === null) {
                            return;
                        }
                        if (this.outputFilter) {
                            if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {
                                this.cueStartTime = time;
                            } else {
                                if (!this.displayedMemory.equals(this.lastOutputScreen)) {
                                    this.outputFilter.newCue(this.cueStartTime, time, this.lastOutputScreen);
                                    if (dispatch && this.outputFilter.dispatchCue) {
                                        this.outputFilter.dispatchCue();
                                    }
                                    this.cueStartTime = this.displayedMemory.isEmpty() ? null : time;
                                }
                            }
                            this.lastOutputScreen.copy(this.displayedMemory);
                        }
                    };
                    _proto6.cueSplitAtTime = function cueSplitAtTime(t) {
                        if (this.outputFilter) {
                            if (!this.displayedMemory.isEmpty()) {
                                if (this.outputFilter.newCue) {
                                    this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);
                                }
                                this.cueStartTime = t;
                            }
                        }
                    };
                    return Cea608Channel;
                })();
                var Cea608Parser = (function () {
                    function Cea608Parser(field, out1, out2) {
                        this.channels = void 0;
                        this.currentChannel = 0;
                        this.cmdHistory = void 0;
                        this.logger = void 0;
                        var logger = new CaptionsLogger();
                        this.channels = [null, new Cea608Channel(field, out1, logger), new Cea608Channel(field + 1, out2, logger)];
                        this.cmdHistory = createCmdHistory();
                        this.logger = logger;
                    }
                    var _proto7 = Cea608Parser.prototype;
                    _proto7.getHandler = function getHandler(channel) {
                        return this.channels[channel].getHandler();
                    };
                    _proto7.setHandler = function setHandler(channel, newHandler) {
                        this.channels[channel].setHandler(newHandler);
                    };
                    _proto7.addData = function addData(time, byteList) {
                        var cmdFound;
                        var a;
                        var b;
                        var charsFound = false;
                        this.logger.time = time;
                        for (var i = 0; i < byteList.length; i += 2) {
                            a = byteList[i] & 127;
                            b = byteList[i + 1] & 127;
                            if (a === 0 && b === 0) {
                                continue;
                            } else {
                                this.logger.log(VerboseLevel.DATA, "[" + numArrayToHexArray([byteList[i], byteList[i + 1]]) + "] -> (" + numArrayToHexArray([a, b]) + ")");
                            }
                            cmdFound = this.parseCmd(a, b);
                            if (!cmdFound) {
                                cmdFound = this.parseMidrow(a, b);
                            }
                            if (!cmdFound) {
                                cmdFound = this.parsePAC(a, b);
                            }
                            if (!cmdFound) {
                                cmdFound = this.parseBackgroundAttributes(a, b);
                            }
                            if (!cmdFound) {
                                charsFound = this.parseChars(a, b);
                                if (charsFound) {
                                    var currChNr = this.currentChannel;
                                    if (currChNr && currChNr > 0) {
                                        var channel = this.channels[currChNr];
                                        channel.insertChars(charsFound);
                                    } else {
                                        this.logger.log(VerboseLevel.WARNING, "No channel found yet. TEXT-MODE?");
                                    }
                                }
                            }
                            if (!cmdFound && !charsFound) {
                                this.logger.log(VerboseLevel.WARNING, "Couldn't parse cleaned data " + numArrayToHexArray([a, b]) + " orig: " + numArrayToHexArray([byteList[i], byteList[i + 1]]));
                            }
                        }
                    };
                    _proto7.parseCmd = function parseCmd(a, b) {
                        var cmdHistory = this.cmdHistory;
                        var cond1 = (a === 20 || a === 28 || a === 21 || a === 29) && b >= 32 && b <= 47;
                        var cond2 = (a === 23 || a === 31) && b >= 33 && b <= 35;
                        if (!(cond1 || cond2)) {
                            return false;
                        }
                        if (hasCmdRepeated(a, b, cmdHistory)) {
                            setLastCmd(null, null, cmdHistory);
                            this.logger.log(VerboseLevel.DEBUG, "Repeated command (" + numArrayToHexArray([a, b]) + ") is dropped");
                            return true;
                        }
                        var chNr = a === 20 || a === 21 || a === 23 ? 1 : 2;
                        var channel = this.channels[chNr];
                        if (a === 20 || a === 21 || a === 28 || a === 29) {
                            if (b === 32) {
                                channel.ccRCL();
                            } else if (b === 33) {
                                channel.ccBS();
                            } else if (b === 34) {
                                channel.ccAOF();
                            } else if (b === 35) {
                                channel.ccAON();
                            } else if (b === 36) {
                                channel.ccDER();
                            } else if (b === 37) {
                                channel.ccRU(2);
                            } else if (b === 38) {
                                channel.ccRU(3);
                            } else if (b === 39) {
                                channel.ccRU(4);
                            } else if (b === 40) {
                                channel.ccFON();
                            } else if (b === 41) {
                                channel.ccRDC();
                            } else if (b === 42) {
                                channel.ccTR();
                            } else if (b === 43) {
                                channel.ccRTD();
                            } else if (b === 44) {
                                channel.ccEDM();
                            } else if (b === 45) {
                                channel.ccCR();
                            } else if (b === 46) {
                                channel.ccENM();
                            } else if (b === 47) {
                                channel.ccEOC();
                            }
                        } else {
                            channel.ccTO(b - 32);
                        }
                        setLastCmd(a, b, cmdHistory);
                        this.currentChannel = chNr;
                        return true;
                    };
                    _proto7.parseMidrow = function parseMidrow(a, b) {
                        var chNr = 0;
                        if ((a === 17 || a === 25) && b >= 32 && b <= 47) {
                            if (a === 17) {
                                chNr = 1;
                            } else {
                                chNr = 2;
                            }
                            if (chNr !== this.currentChannel) {
                                this.logger.log(VerboseLevel.ERROR, "Mismatch channel in midrow parsing");
                                return false;
                            }
                            var channel = this.channels[chNr];
                            if (!channel) {
                                return false;
                            }
                            channel.ccMIDROW(b);
                            this.logger.log(VerboseLevel.DEBUG, "MIDROW (" + numArrayToHexArray([a, b]) + ")");
                            return true;
                        }
                        return false;
                    };
                    _proto7.parsePAC = function parsePAC(a, b) {
                        var row;
                        var cmdHistory = this.cmdHistory;
                        var case1 = ((a >= 17 && a <= 23) || (a >= 25 && a <= 31)) && b >= 64 && b <= 127;
                        var case2 = (a === 16 || a === 24) && b >= 64 && b <= 95;
                        if (!(case1 || case2)) {
                            return false;
                        }
                        if (hasCmdRepeated(a, b, cmdHistory)) {
                            setLastCmd(null, null, cmdHistory);
                            return true;
                        }
                        var chNr = a <= 23 ? 1 : 2;
                        if (b >= 64 && b <= 95) {
                            row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];
                        } else {
                            row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];
                        }
                        var channel = this.channels[chNr];
                        if (!channel) {
                            return false;
                        }
                        channel.setPAC(this.interpretPAC(row, b));
                        setLastCmd(a, b, cmdHistory);
                        this.currentChannel = chNr;
                        return true;
                    };
                    _proto7.interpretPAC = function interpretPAC(row, _byte3) {
                        var pacIndex;
                        var pacData = { color: null, italics: false, indent: null, underline: false, row: row };
                        if (_byte3 > 95) {
                            pacIndex = _byte3 - 96;
                        } else {
                            pacIndex = _byte3 - 64;
                        }
                        pacData.underline = (pacIndex & 1) === 1;
                        if (pacIndex <= 13) {
                            pacData.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(pacIndex / 2)];
                        } else if (pacIndex <= 15) {
                            pacData.italics = true;
                            pacData.color = "white";
                        } else {
                            pacData.indent = Math.floor((pacIndex - 16) / 2) * 4;
                        }
                        return pacData;
                    };
                    _proto7.parseChars = function parseChars(a, b) {
                        var channelNr;
                        var charCodes = null;
                        var charCode1 = null;
                        if (a >= 25) {
                            channelNr = 2;
                            charCode1 = a - 8;
                        } else {
                            channelNr = 1;
                            charCode1 = a;
                        }
                        if (charCode1 >= 17 && charCode1 <= 19) {
                            var oneCode;
                            if (charCode1 === 17) {
                                oneCode = b + 80;
                            } else if (charCode1 === 18) {
                                oneCode = b + 112;
                            } else {
                                oneCode = b + 144;
                            }
                            this.logger.log(VerboseLevel.INFO, "Special char '" + getCharForByte(oneCode) + "' in channel " + channelNr);
                            charCodes = [oneCode];
                        } else if (a >= 32 && a <= 127) {
                            charCodes = b === 0 ? [a] : [a, b];
                        }
                        if (charCodes) {
                            var hexCodes = numArrayToHexArray(charCodes);
                            this.logger.log(VerboseLevel.DEBUG, "Char codes =  " + hexCodes.join(","));
                            setLastCmd(a, b, this.cmdHistory);
                        }
                        return charCodes;
                    };
                    _proto7.parseBackgroundAttributes = function parseBackgroundAttributes(a, b) {
                        var case1 = (a === 16 || a === 24) && b >= 32 && b <= 47;
                        var case2 = (a === 23 || a === 31) && b >= 45 && b <= 47;
                        if (!(case1 || case2)) {
                            return false;
                        }
                        var index;
                        var bkgData = {};
                        if (a === 16 || a === 24) {
                            index = Math.floor((b - 32) / 2);
                            bkgData.background = backgroundColors[index];
                            if (b % 2 === 1) {
                                bkgData.background = bkgData.background + "_semi";
                            }
                        } else if (b === 45) {
                            bkgData.background = "transparent";
                        } else {
                            bkgData.foreground = "black";
                            if (b === 47) {
                                bkgData.underline = true;
                            }
                        }
                        var chNr = a <= 23 ? 1 : 2;
                        var channel = this.channels[chNr];
                        channel.setBkgData(bkgData);
                        setLastCmd(a, b, this.cmdHistory);
                        return true;
                    };
                    _proto7.reset = function reset() {
                        for (var i = 0; i < Object.keys(this.channels).length; i++) {
                            var channel = this.channels[i];
                            if (channel) {
                                channel.reset();
                            }
                        }
                        this.cmdHistory = createCmdHistory();
                    };
                    _proto7.cueSplitAtTime = function cueSplitAtTime(t) {
                        for (var i = 0; i < this.channels.length; i++) {
                            var channel = this.channels[i];
                            if (channel) {
                                channel.cueSplitAtTime(t);
                            }
                        }
                    };
                    return Cea608Parser;
                })();
                function setLastCmd(a, b, cmdHistory) {
                    cmdHistory.a = a;
                    cmdHistory.b = b;
                }
                function hasCmdRepeated(a, b, cmdHistory) {
                    return cmdHistory.a === a && cmdHistory.b === b;
                }
                function createCmdHistory() {
                    return { a: null, b: null };
                }
                __webpack_exports__["default"] = Cea608Parser;
            },
            "./src/utils/codecs.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "isCodecType", function () {
                    return isCodecType;
                });
                __webpack_require__.d(__webpack_exports__, "isCodecSupportedInMp4", function () {
                    return isCodecSupportedInMp4;
                });
                var sampleEntryCodesISO = {
                    audio: {
                        a3ds: true,
                        "ac-3": true,
                        "ac-4": true,
                        alac: true,
                        alaw: true,
                        dra1: true,
                        "dts+": true,
                        "dts-": true,
                        dtsc: true,
                        dtse: true,
                        dtsh: true,
                        "ec-3": true,
                        enca: true,
                        g719: true,
                        g726: true,
                        m4ae: true,
                        mha1: true,
                        mha2: true,
                        mhm1: true,
                        mhm2: true,
                        mlpa: true,
                        mp4a: true,
                        "raw ": true,
                        Opus: true,
                        samr: true,
                        sawb: true,
                        sawp: true,
                        sevc: true,
                        sqcp: true,
                        ssmv: true,
                        twos: true,
                        ulaw: true,
                    },
                    video: {
                        avc1: true,
                        avc2: true,
                        avc3: true,
                        avc4: true,
                        avcp: true,
                        av01: true,
                        drac: true,
                        dva1: true,
                        dvav: true,
                        dvh1: true,
                        dvhe: true,
                        encv: true,
                        hev1: true,
                        hvc1: true,
                        mjp2: true,
                        mp4v: true,
                        mvc1: true,
                        mvc2: true,
                        mvc3: true,
                        mvc4: true,
                        resv: true,
                        rv60: true,
                        s263: true,
                        svc1: true,
                        svc2: true,
                        "vc-1": true,
                        vp08: true,
                        vp09: true,
                    },
                    text: { stpp: true, wvtt: true },
                };
                function isCodecType(codec, type) {
                    var typeCodes = sampleEntryCodesISO[type];
                    return !!typeCodes && typeCodes[codec.slice(0, 4)] === true;
                }
                function isCodecSupportedInMp4(codec, type) {
                    return MediaSource.isTypeSupported((type || "video") + '/mp4;codecs="' + codec + '"');
                }
            },
            "./src/utils/cues.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _vttparser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/vttparser.ts");
                var _webvtt_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/webvtt-parser.ts");
                var _texttrack_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/texttrack-utils.ts");
                var WHITESPACE_CHAR = /\s/;
                var Cues = {
                    newCue: function newCue(track, startTime, endTime, captionScreen) {
                        var result = [];
                        var row;
                        var cue;
                        var indenting;
                        var indent;
                        var text;
                        var Cue = self.VTTCue || self.TextTrackCue;
                        for (var r = 0; r < captionScreen.rows.length; r++) {
                            row = captionScreen.rows[r];
                            indenting = true;
                            indent = 0;
                            text = "";
                            if (!row.isEmpty()) {
                                for (var c = 0; c < row.chars.length; c++) {
                                    if (WHITESPACE_CHAR.test(row.chars[c].uchar) && indenting) {
                                        indent++;
                                    } else {
                                        text += row.chars[c].uchar;
                                        indenting = false;
                                    }
                                }
                                row.cueStartTime = startTime;
                                if (startTime === endTime) {
                                    endTime += 1e-4;
                                }
                                if (indent >= 16) {
                                    indent--;
                                } else {
                                    indent++;
                                }
                                var cueText = Object(_vttparser__WEBPACK_IMPORTED_MODULE_0__["fixLineBreaks"])(text.trim());
                                var id = Object(_webvtt_parser__WEBPACK_IMPORTED_MODULE_1__["generateCueId"])(startTime, endTime, cueText);
                                if (!track || !track.cues || !track.cues.getCueById(id)) {
                                    cue = new Cue(startTime, endTime, cueText);
                                    cue.id = id;
                                    cue.line = r + 1;
                                    cue.align = "left";
                                    cue.position = 10 + Math.min(80, Math.floor((indent * 8) / 32) * 10);
                                    result.push(cue);
                                }
                            }
                        }
                        if (track && result.length) {
                            result.sort(function (cueA, cueB) {
                                if (cueA.line === "auto" || cueB.line === "auto") {
                                    return 0;
                                }
                                if (cueA.line > 8 && cueB.line > 8) {
                                    return cueB.line - cueA.line;
                                }
                                return cueA.line - cueB.line;
                            });
                            result.forEach(function (cue) {
                                return Object(_texttrack_utils__WEBPACK_IMPORTED_MODULE_2__["addCueToTrack"])(track, cue);
                            });
                        }
                        return result;
                    },
                };
                __webpack_exports__["default"] = Cues;
            },
            "./src/utils/discontinuities.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "findFirstFragWithCC", function () {
                    return findFirstFragWithCC;
                });
                __webpack_require__.d(__webpack_exports__, "shouldAlignOnDiscontinuities", function () {
                    return shouldAlignOnDiscontinuities;
                });
                __webpack_require__.d(__webpack_exports__, "findDiscontinuousReferenceFrag", function () {
                    return findDiscontinuousReferenceFrag;
                });
                __webpack_require__.d(__webpack_exports__, "adjustSlidingStart", function () {
                    return adjustSlidingStart;
                });
                __webpack_require__.d(__webpack_exports__, "alignStream", function () {
                    return alignStream;
                });
                __webpack_require__.d(__webpack_exports__, "alignPDT", function () {
                    return alignPDT;
                });
                __webpack_require__.d(__webpack_exports__, "alignFragmentByPDTDelta", function () {
                    return alignFragmentByPDTDelta;
                });
                __webpack_require__.d(__webpack_exports__, "alignMediaPlaylistByPDT", function () {
                    return alignMediaPlaylistByPDT;
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/polyfills/number.ts");
                var _logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/logger.ts");
                var _controller_level_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/controller/level-helper.ts");
                function findFirstFragWithCC(fragments, cc) {
                    var firstFrag = null;
                    for (var i = 0, len = fragments.length; i < len; i++) {
                        var currentFrag = fragments[i];
                        if (currentFrag && currentFrag.cc === cc) {
                            firstFrag = currentFrag;
                            break;
                        }
                    }
                    return firstFrag;
                }
                function shouldAlignOnDiscontinuities(lastFrag, lastLevel, details) {
                    if (lastLevel.details) {
                        if (details.endCC > details.startCC || (lastFrag && lastFrag.cc < details.startCC)) {
                            return true;
                        }
                    }
                    return false;
                }
                function findDiscontinuousReferenceFrag(prevDetails, curDetails) {
                    var prevFrags = prevDetails.fragments;
                    var curFrags = curDetails.fragments;
                    if (!curFrags.length || !prevFrags.length) {
                        _logger__WEBPACK_IMPORTED_MODULE_1__["logger"].log("No fragments to align");
                        return;
                    }
                    var prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);
                    if (!prevStartFrag || (prevStartFrag && !prevStartFrag.startPTS)) {
                        _logger__WEBPACK_IMPORTED_MODULE_1__["logger"].log("No frag in previous level to align on");
                        return;
                    }
                    return prevStartFrag;
                }
                function adjustFragmentStart(frag, sliding) {
                    if (frag) {
                        var start = frag.start + sliding;
                        frag.start = frag.startPTS = start;
                        frag.endPTS = start + frag.duration;
                    }
                }
                function adjustSlidingStart(sliding, details) {
                    var fragments = details.fragments;
                    for (var i = 0, len = fragments.length; i < len; i++) {
                        adjustFragmentStart(fragments[i], sliding);
                    }
                    if (details.fragmentHint) {
                        adjustFragmentStart(details.fragmentHint, sliding);
                    }
                    details.alignedSliding = true;
                }
                function alignStream(lastFrag, lastLevel, details) {
                    if (!lastLevel) {
                        return;
                    }
                    alignDiscontinuities(lastFrag, details, lastLevel);
                    if (!details.alignedSliding && lastLevel.details) {
                        alignPDT(details, lastLevel.details);
                    }
                    if (!details.alignedSliding && lastLevel.details && !details.skippedSegments) {
                        Object(_controller_level_helper__WEBPACK_IMPORTED_MODULE_2__["adjustSliding"])(lastLevel.details, details);
                    }
                }
                function alignDiscontinuities(lastFrag, details, lastLevel) {
                    if (shouldAlignOnDiscontinuities(lastFrag, lastLevel, details)) {
                        var referenceFrag = findDiscontinuousReferenceFrag(lastLevel.details, details);
                        if (referenceFrag && Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(referenceFrag.start)) {
                            _logger__WEBPACK_IMPORTED_MODULE_1__["logger"].log("Adjusting PTS using last level due to CC increase within current level " + details.url);
                            adjustSlidingStart(referenceFrag.start, details);
                        }
                    }
                }
                function alignPDT(details, lastDetails) {
                    if (!lastDetails.fragments.length || !details.hasProgramDateTime || !lastDetails.hasProgramDateTime) {
                        return;
                    }
                    var lastPDT = lastDetails.fragments[0].programDateTime;
                    var newPDT = details.fragments[0].programDateTime;
                    var sliding = (newPDT - lastPDT) / 1e3 + lastDetails.fragments[0].start;
                    if (sliding && Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(sliding)) {
                        _logger__WEBPACK_IMPORTED_MODULE_1__["logger"].log("Adjusting PTS using programDateTime delta " + (newPDT - lastPDT) + "ms, sliding:" + sliding.toFixed(3) + " " + details.url + " ");
                        adjustSlidingStart(sliding, details);
                    }
                }
                function alignFragmentByPDTDelta(frag, delta) {
                    var programDateTime = frag.programDateTime;
                    if (!programDateTime) return;
                    var start = (programDateTime - delta) / 1e3;
                    frag.start = frag.startPTS = start;
                    frag.endPTS = start + frag.duration;
                }
                function alignMediaPlaylistByPDT(details, refDetails) {
                    if (!refDetails.fragments.length || !details.hasProgramDateTime || !refDetails.hasProgramDateTime) {
                        return;
                    }
                    var refPDT = refDetails.fragments[0].programDateTime;
                    var refStart = refDetails.fragments[0].start;
                    var delta = refPDT - refStart * 1e3;
                    details.fragments.forEach(function (frag) {
                        alignFragmentByPDTDelta(frag, delta);
                    });
                    if (details.fragmentHint) {
                        alignFragmentByPDTDelta(details.fragmentHint, delta);
                    }
                    details.alignedSliding = true;
                }
            },
            "./src/utils/ewma-bandwidth-estimator.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _utils_ewma__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/ewma.ts");
                var EwmaBandWidthEstimator = (function () {
                    function EwmaBandWidthEstimator(slow, fast, defaultEstimate) {
                        this.defaultEstimate_ = void 0;
                        this.minWeight_ = void 0;
                        this.minDelayMs_ = void 0;
                        this.slow_ = void 0;
                        this.fast_ = void 0;
                        this.defaultEstimate_ = defaultEstimate;
                        this.minWeight_ = 0.001;
                        this.minDelayMs_ = 50;
                        this.slow_ = new _utils_ewma__WEBPACK_IMPORTED_MODULE_0__["default"](slow);
                        this.fast_ = new _utils_ewma__WEBPACK_IMPORTED_MODULE_0__["default"](fast);
                    }
                    var _proto = EwmaBandWidthEstimator.prototype;
                    _proto.update = function update(slow, fast) {
                        var slow_ = this.slow_,
                            fast_ = this.fast_;
                        if (this.slow_.halfLife !== slow) {
                            this.slow_ = new _utils_ewma__WEBPACK_IMPORTED_MODULE_0__["default"](slow, slow_.getEstimate(), slow_.getTotalWeight());
                        }
                        if (this.fast_.halfLife !== fast) {
                            this.fast_ = new _utils_ewma__WEBPACK_IMPORTED_MODULE_0__["default"](fast, fast_.getEstimate(), fast_.getTotalWeight());
                        }
                    };
                    _proto.sample = function sample(durationMs, numBytes) {
                        durationMs = Math.max(durationMs, this.minDelayMs_);
                        var numBits = 8 * numBytes;
                        var durationS = durationMs / 1e3;
                        var bandwidthInBps = numBits / durationS;
                        this.fast_.sample(durationS, bandwidthInBps);
                        this.slow_.sample(durationS, bandwidthInBps);
                    };
                    _proto.canEstimate = function canEstimate() {
                        var fast = this.fast_;
                        return fast && fast.getTotalWeight() >= this.minWeight_;
                    };
                    _proto.getEstimate = function getEstimate() {
                        if (this.canEstimate()) {
                            return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
                        } else {
                            return this.defaultEstimate_;
                        }
                    };
                    _proto.destroy = function destroy() {};
                    return EwmaBandWidthEstimator;
                })();
                __webpack_exports__["default"] = EwmaBandWidthEstimator;
            },
            "./src/utils/ewma.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var EWMA = (function () {
                    function EWMA(halfLife, estimate, weight) {
                        if (estimate === void 0) {
                            estimate = 0;
                        }
                        if (weight === void 0) {
                            weight = 0;
                        }
                        this.halfLife = void 0;
                        this.alpha_ = void 0;
                        this.estimate_ = void 0;
                        this.totalWeight_ = void 0;
                        this.halfLife = halfLife;
                        this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
                        this.estimate_ = estimate;
                        this.totalWeight_ = weight;
                    }
                    var _proto = EWMA.prototype;
                    _proto.sample = function sample(weight, value) {
                        var adjAlpha = Math.pow(this.alpha_, weight);
                        this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
                        this.totalWeight_ += weight;
                    };
                    _proto.getTotalWeight = function getTotalWeight() {
                        return this.totalWeight_;
                    };
                    _proto.getEstimate = function getEstimate() {
                        if (this.alpha_) {
                            var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
                            if (zeroFactor) {
                                return this.estimate_ / zeroFactor;
                            }
                        }
                        return this.estimate_;
                    };
                    return EWMA;
                })();
                __webpack_exports__["default"] = EWMA;
            },
            "./src/utils/fetch-loader.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "fetchSupported", function () {
                    return fetchSupported;
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/polyfills/number.ts");
                var _loader_load_stats__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/loader/load-stats.ts");
                var _demux_chunk_cache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/demux/chunk-cache.ts");
                function _inheritsLoose(subClass, superClass) {
                    subClass.prototype = Object.create(superClass.prototype);
                    subClass.prototype.constructor = subClass;
                    _setPrototypeOf(subClass, superClass);
                }
                function _wrapNativeSuper(Class) {
                    var _cache = typeof Map === "function" ? new Map() : undefined;
                    _wrapNativeSuper = function _wrapNativeSuper(Class) {
                        if (Class === null || !_isNativeFunction(Class)) return Class;
                        if (typeof Class !== "function") {
                            throw new TypeError("Super expression must either be null or a function");
                        }
                        if (typeof _cache !== "undefined") {
                            if (_cache.has(Class)) return _cache.get(Class);
                            _cache.set(Class, Wrapper);
                        }
                        function Wrapper() {
                            return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                        }
                        Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
                        return _setPrototypeOf(Wrapper, Class);
                    };
                    return _wrapNativeSuper(Class);
                }
                function _construct(Parent, args, Class) {
                    if (_isNativeReflectConstruct()) {
                        _construct = Reflect.construct.bind();
                    } else {
                        _construct = function _construct(Parent, args, Class) {
                            var a = [null];
                            a.push.apply(a, args);
                            var Constructor = Function.bind.apply(Parent, a);
                            var instance = new Constructor();
                            if (Class) _setPrototypeOf(instance, Class.prototype);
                            return instance;
                        };
                    }
                    return _construct.apply(null, arguments);
                }
                function _isNativeReflectConstruct() {
                    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if (typeof Proxy === "function") return true;
                    try {
                        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
                        return true;
                    } catch (e) {
                        return false;
                    }
                }
                function _isNativeFunction(fn) {
                    return Function.toString.call(fn).indexOf("[native code]") !== -1;
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf
                        ? Object.setPrototypeOf.bind()
                        : function _setPrototypeOf(o, p) {
                              o.__proto__ = p;
                              return o;
                          };
                    return _setPrototypeOf(o, p);
                }
                function _getPrototypeOf(o) {
                    _getPrototypeOf = Object.setPrototypeOf
                        ? Object.getPrototypeOf.bind()
                        : function _getPrototypeOf(o) {
                              return o.__proto__ || Object.getPrototypeOf(o);
                          };
                    return _getPrototypeOf(o);
                }
                function _extends() {
                    _extends = Object.assign
                        ? Object.assign.bind()
                        : function (target) {
                              for (var i = 1; i < arguments.length; i++) {
                                  var source = arguments[i];
                                  for (var key in source) {
                                      if (Object.prototype.hasOwnProperty.call(source, key)) {
                                          target[key] = source[key];
                                      }
                                  }
                              }
                              return target;
                          };
                    return _extends.apply(this, arguments);
                }
                function fetchSupported() {
                    if (self.fetch && self.AbortController && self.ReadableStream && self.Request) {
                        try {
                            new self.ReadableStream({});
                            return true;
                        } catch (e) {}
                    }
                    return false;
                }
                var FetchLoader = (function () {
                    function FetchLoader(config) {
                        this.fetchSetup = void 0;
                        this.requestTimeout = void 0;
                        this.request = void 0;
                        this.response = void 0;
                        this.controller = void 0;
                        this.context = void 0;
                        this.config = null;
                        this.callbacks = null;
                        this.stats = void 0;
                        this.loader = null;
                        this.fetchSetup = config.fetchSetup || getRequest;
                        this.controller = new self.AbortController();
                        this.stats = new _loader_load_stats__WEBPACK_IMPORTED_MODULE_1__["LoadStats"]();
                    }
                    var _proto = FetchLoader.prototype;
                    _proto.destroy = function destroy() {
                        this.loader = this.callbacks = null;
                        this.abortInternal();
                    };
                    _proto.abortInternal = function abortInternal() {
                        var response = this.response;
                        if (!response || !response.ok) {
                            this.stats.aborted = true;
                            this.controller.abort();
                        }
                    };
                    _proto.abort = function abort() {
                        var _this$callbacks;
                        this.abortInternal();
                        if ((_this$callbacks = this.callbacks) !== null && _this$callbacks !== void 0 && _this$callbacks.onAbort) {
                            this.callbacks.onAbort(this.stats, this.context, this.response);
                        }
                    };
                    _proto.load = function load(context, config, callbacks) {
                        var _this = this;
                        var stats = this.stats;
                        if (stats.loading.start) {
                            throw new Error("Loader can only be used once.");
                        }
                        stats.loading.start = self.performance.now();
                        var initParams = getRequestParameters(context, this.controller.signal);
                        var onProgress = callbacks.onProgress;
                        var isArrayBuffer = context.responseType === "arraybuffer";
                        var LENGTH = isArrayBuffer ? "byteLength" : "length";
                        this.context = context;
                        this.config = config;
                        this.callbacks = callbacks;
                        this.request = this.fetchSetup(context, initParams);
                        self.clearTimeout(this.requestTimeout);
                        this.requestTimeout = self.setTimeout(function () {
                            _this.abortInternal();
                            callbacks.onTimeout(stats, context, _this.response);
                        }, config.timeout);
                        self.fetch(this.request)
                            .then(function (response) {
                                _this.response = _this.loader = response;
                                if (!response.ok) {
                                    var status = response.status,
                                        statusText = response.statusText;
                                    throw new FetchError(statusText || "fetch, bad network response", status, response);
                                }
                                stats.loading.first = Math.max(self.performance.now(), stats.loading.start);
                                stats.total = parseInt(response.headers.get("Content-Length") || "0");
                                if (onProgress && Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(config.highWaterMark)) {
                                    return _this.loadProgressively(response, stats, context, config.highWaterMark, onProgress);
                                }
                                if (isArrayBuffer) {
                                    return response.arrayBuffer();
                                }
                                return response.text();
                            })
                            .then(function (responseData) {
                                var response = _this.response;
                                self.clearTimeout(_this.requestTimeout);
                                stats.loading.end = Math.max(self.performance.now(), stats.loading.first);
                                stats.loaded = stats.total = responseData[LENGTH];
                                var loaderResponse = { url: response.url, data: responseData };
                                if (onProgress && !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(config.highWaterMark)) {
                                    onProgress(stats, context, responseData, response);
                                }
                                callbacks.onSuccess(loaderResponse, stats, context, response);
                            })
                            .catch(function (error) {
                                self.clearTimeout(_this.requestTimeout);
                                if (stats.aborted) {
                                    return;
                                }
                                var code = !error ? 0 : error.code || 0;
                                var text = !error ? null : error.message;
                                callbacks.onError({ code: code, text: text }, context, error ? error.details : null);
                            });
                    };
                    _proto.getCacheAge = function getCacheAge() {
                        var result = null;
                        if (this.response) {
                            var ageHeader = this.response.headers.get("age");
                            result = ageHeader ? parseFloat(ageHeader) : null;
                        }
                        return result;
                    };
                    _proto.loadProgressively = function loadProgressively(response, stats, context, highWaterMark, onProgress) {
                        if (highWaterMark === void 0) {
                            highWaterMark = 0;
                        }
                        var chunkCache = new _demux_chunk_cache__WEBPACK_IMPORTED_MODULE_2__["default"]();
                        var reader = response.body.getReader();
                        var pump = function pump() {
                            return reader
                                .read()
                                .then(function (data) {
                                    if (data.done) {
                                        if (chunkCache.dataLength) {
                                            onProgress(stats, context, chunkCache.flush(), response);
                                        }
                                        return Promise.resolve(new ArrayBuffer(0));
                                    }
                                    var chunk = data.value;
                                    var len = chunk.length;
                                    stats.loaded += len;
                                    if (len < highWaterMark || chunkCache.dataLength) {
                                        chunkCache.push(chunk);
                                        if (chunkCache.dataLength >= highWaterMark) {
                                            onProgress(stats, context, chunkCache.flush(), response);
                                        }
                                    } else {
                                        onProgress(stats, context, chunk, response);
                                    }
                                    return pump();
                                })
                                .catch(function () {
                                    return Promise.reject();
                                });
                        };
                        return pump();
                    };
                    return FetchLoader;
                })();
                function getRequestParameters(context, signal) {
                    var initParams = { method: "GET", mode: "cors", credentials: "same-origin", signal: signal, headers: new self.Headers(_extends({}, context.headers)) };
                    if (context.rangeEnd) {
                        initParams.headers.set("Range", "bytes=" + context.rangeStart + "-" + String(context.rangeEnd - 1));
                    }
                    return initParams;
                }
                function getRequest(context, initParams) {
                    return new self.Request(context.url, initParams);
                }
                var FetchError = (function (_Error) {
                    _inheritsLoose(FetchError, _Error);
                    function FetchError(message, code, details) {
                        var _this2;
                        _this2 = _Error.call(this, message) || this;
                        _this2.code = void 0;
                        _this2.details = void 0;
                        _this2.code = code;
                        _this2.details = details;
                        return _this2;
                    }
                    return FetchError;
                })(_wrapNativeSuper(Error));
                __webpack_exports__["default"] = FetchLoader;
            },
            "./src/utils/imsc1-ttml-parser.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "IMSC1_CODEC", function () {
                    return IMSC1_CODEC;
                });
                __webpack_require__.d(__webpack_exports__, "parseIMSC1", function () {
                    return parseIMSC1;
                });
                var _mp4_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/mp4-tools.ts");
                var _vttparser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/vttparser.ts");
                var _vttcue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/utils/vttcue.ts");
                var _demux_id3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/demux/id3.ts");
                var _timescale_conversion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/utils/timescale-conversion.ts");
                var _webvtt_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("./src/utils/webvtt-parser.ts");
                function _extends() {
                    _extends = Object.assign
                        ? Object.assign.bind()
                        : function (target) {
                              for (var i = 1; i < arguments.length; i++) {
                                  var source = arguments[i];
                                  for (var key in source) {
                                      if (Object.prototype.hasOwnProperty.call(source, key)) {
                                          target[key] = source[key];
                                      }
                                  }
                              }
                              return target;
                          };
                    return _extends.apply(this, arguments);
                }
                var IMSC1_CODEC = "stpp.ttml.im1t";
                var HMSF_REGEX = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/;
                var TIME_UNIT_REGEX = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/;
                var textAlignToLineAlign = { left: "start", center: "center", right: "end", start: "start", end: "end" };
                function parseIMSC1(payload, initPTS, timescale, callBack, errorCallBack) {
                    var results = Object(_mp4_tools__WEBPACK_IMPORTED_MODULE_0__["findBox"])(new Uint8Array(payload), ["mdat"]);
                    if (results.length === 0) {
                        errorCallBack(new Error("Could not parse IMSC1 mdat"));
                        return;
                    }
                    var ttmlList = results.map(function (mdat) {
                        return Object(_demux_id3__WEBPACK_IMPORTED_MODULE_3__["utf8ArrayToStr"])(mdat);
                    });
                    var syncTime = Object(_timescale_conversion__WEBPACK_IMPORTED_MODULE_4__["toTimescaleFromScale"])(initPTS, 1, timescale);
                    try {
                        ttmlList.forEach(function (ttml) {
                            return callBack(parseTTML(ttml, syncTime));
                        });
                    } catch (error) {
                        errorCallBack(error);
                    }
                }
                function parseTTML(ttml, syncTime) {
                    var parser = new DOMParser();
                    var xmlDoc = parser.parseFromString(ttml, "text/xml");
                    var tt = xmlDoc.getElementsByTagName("tt")[0];
                    if (!tt) {
                        throw new Error("Invalid ttml");
                    }
                    var defaultRateInfo = { frameRate: 30, subFrameRate: 1, frameRateMultiplier: 0, tickRate: 0 };
                    var rateInfo = Object.keys(defaultRateInfo).reduce(function (result, key) {
                        result[key] = tt.getAttribute("ttp:" + key) || defaultRateInfo[key];
                        return result;
                    }, {});
                    var trim = tt.getAttribute("xml:space") !== "preserve";
                    var styleElements = collectionToDictionary(getElementCollection(tt, "styling", "style"));
                    var regionElements = collectionToDictionary(getElementCollection(tt, "layout", "region"));
                    var cueElements = getElementCollection(tt, "body", "[begin]");
                    return [].map
                        .call(cueElements, function (cueElement) {
                            var cueText = getTextContent(cueElement, trim);
                            if (!cueText || !cueElement.hasAttribute("begin")) {
                                return null;
                            }
                            var startTime = parseTtmlTime(cueElement.getAttribute("begin"), rateInfo);
                            var duration = parseTtmlTime(cueElement.getAttribute("dur"), rateInfo);
                            var endTime = parseTtmlTime(cueElement.getAttribute("end"), rateInfo);
                            if (startTime === null) {
                                throw timestampParsingError(cueElement);
                            }
                            if (endTime === null) {
                                if (duration === null) {
                                    throw timestampParsingError(cueElement);
                                }
                                endTime = startTime + duration;
                            }
                            var cue = new _vttcue__WEBPACK_IMPORTED_MODULE_2__["default"](startTime - syncTime, endTime - syncTime, cueText);
                            cue.id = Object(_webvtt_parser__WEBPACK_IMPORTED_MODULE_5__["generateCueId"])(cue.startTime, cue.endTime, cue.text);
                            var region = regionElements[cueElement.getAttribute("region")];
                            var style = styleElements[cueElement.getAttribute("style")];
                            cue.position = 10;
                            cue.size = 80;
                            var styles = getTtmlStyles(region, style, styleElements);
                            var textAlign = styles.textAlign;
                            if (textAlign) {
                                var lineAlign = textAlignToLineAlign[textAlign];
                                if (lineAlign) {
                                    cue.lineAlign = lineAlign;
                                }
                                cue.align = textAlign;
                            }
                            _extends(cue, styles);
                            return cue;
                        })
                        .filter(function (cue) {
                            return cue !== null;
                        });
                }
                function getElementCollection(fromElement, parentName, childName) {
                    var parent = fromElement.getElementsByTagName(parentName)[0];
                    if (parent) {
                        return [].slice.call(parent.querySelectorAll(childName));
                    }
                    return [];
                }
                function collectionToDictionary(elementsWithId) {
                    return elementsWithId.reduce(function (dict, element) {
                        var id = element.getAttribute("xml:id");
                        if (id) {
                            dict[id] = element;
                        }
                        return dict;
                    }, {});
                }
                function getTextContent(element, trim) {
                    return [].slice.call(element.childNodes).reduce(function (str, node, i) {
                        var _node$childNodes;
                        if (node.nodeName === "br" && i) {
                            return str + "\n";
                        }
                        if ((_node$childNodes = node.childNodes) !== null && _node$childNodes !== void 0 && _node$childNodes.length) {
                            return getTextContent(node, trim);
                        } else if (trim) {
                            return str + node.textContent.trim().replace(/\s+/g, " ");
                        }
                        return str + node.textContent;
                    }, "");
                }
                function getTtmlStyles(region, style, styleElements) {
                    var ttsNs = "http://www.w3.org/ns/ttml#styling";
                    var regionStyle = null;
                    var styleAttributes = ["displayAlign", "textAlign", "color", "backgroundColor", "fontSize", "fontFamily"];
                    var regionStyleName = region !== null && region !== void 0 && region.hasAttribute("style") ? region.getAttribute("style") : null;
                    if (regionStyleName && styleElements.hasOwnProperty(regionStyleName)) {
                        regionStyle = styleElements[regionStyleName];
                    }
                    return styleAttributes.reduce(function (styles, name) {
                        var value = getAttributeNS(style, ttsNs, name) || getAttributeNS(region, ttsNs, name) || getAttributeNS(regionStyle, ttsNs, name);
                        if (value) {
                            styles[name] = value;
                        }
                        return styles;
                    }, {});
                }
                function getAttributeNS(element, ns, name) {
                    if (!element) {
                        return null;
                    }
                    return element.hasAttributeNS(ns, name) ? element.getAttributeNS(ns, name) : null;
                }
                function timestampParsingError(node) {
                    return new Error("Could not parse ttml timestamp " + node);
                }
                function parseTtmlTime(timeAttributeValue, rateInfo) {
                    if (!timeAttributeValue) {
                        return null;
                    }
                    var seconds = Object(_vttparser__WEBPACK_IMPORTED_MODULE_1__["parseTimeStamp"])(timeAttributeValue);
                    if (seconds === null) {
                        if (HMSF_REGEX.test(timeAttributeValue)) {
                            seconds = parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo);
                        } else if (TIME_UNIT_REGEX.test(timeAttributeValue)) {
                            seconds = parseTimeUnits(timeAttributeValue, rateInfo);
                        }
                    }
                    return seconds;
                }
                function parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo) {
                    var m = HMSF_REGEX.exec(timeAttributeValue);
                    var frames = (m[4] | 0) + (m[5] | 0) / rateInfo.subFrameRate;
                    return (m[1] | 0) * 3600 + (m[2] | 0) * 60 + (m[3] | 0) + frames / rateInfo.frameRate;
                }
                function parseTimeUnits(timeAttributeValue, rateInfo) {
                    var m = TIME_UNIT_REGEX.exec(timeAttributeValue);
                    var value = Number(m[1]);
                    var unit = m[2];
                    switch (unit) {
                        case "h":
                            return value * 3600;
                        case "m":
                            return value * 60;
                        case "ms":
                            return value * 1e3;
                        case "f":
                            return value / rateInfo.frameRate;
                        case "t":
                            return value / rateInfo.tickRate;
                    }
                    return value;
                }
            },
            "./src/utils/logger.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "enableLogs", function () {
                    return enableLogs;
                });
                __webpack_require__.d(__webpack_exports__, "logger", function () {
                    return logger;
                });
                var noop = function noop() {};
                var fakeLogger = { trace: noop, debug: noop, log: noop, warn: noop, info: noop, error: noop };
                var exportedLogger = fakeLogger;
                function consolePrintFn(type) {
                    var func = self.console[type];
                    if (func) {
                        return func.bind(self.console, "[" + type + "] >");
                    }
                    return noop;
                }
                function exportLoggerFunctions(debugConfig) {
                    for (var _len = arguments.length, functions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                        functions[_key - 1] = arguments[_key];
                    }
                    functions.forEach(function (type) {
                        exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);
                    });
                }
                function enableLogs(debugConfig) {
                    if ((self.console && debugConfig === true) || typeof debugConfig === "object") {
                        exportLoggerFunctions(debugConfig, "debug", "log", "info", "warn", "error");
                        try {
                            exportedLogger.log();
                        } catch (e) {
                            exportedLogger = fakeLogger;
                        }
                    } else {
                        exportedLogger = fakeLogger;
                    }
                }
                var logger = exportedLogger;
            },
            "./src/utils/mediakeys-helper.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "KeySystems", function () {
                    return KeySystems;
                });
                __webpack_require__.d(__webpack_exports__, "requestMediaKeySystemAccess", function () {
                    return requestMediaKeySystemAccess;
                });
                var KeySystems;
                (function (KeySystems) {
                    KeySystems["WIDEVINE"] = "com.widevine.alpha";
                    KeySystems["PLAYREADY"] = "com.microsoft.playready";
                })(KeySystems || (KeySystems = {}));
                var requestMediaKeySystemAccess = (function () {
                    if (typeof self !== "undefined" && self.navigator && self.navigator.requestMediaKeySystemAccess) {
                        return self.navigator.requestMediaKeySystemAccess.bind(self.navigator);
                    } else {
                        return null;
                    }
                })();
            },
            "./src/utils/mediasource-helper.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "getMediaSource", function () {
                    return getMediaSource;
                });
                function getMediaSource() {
                    return self.MediaSource || self.WebKitMediaSource;
                }
            },
            "./src/utils/mp4-tools.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "RemuxerTrackIdConfig", function () {
                    return RemuxerTrackIdConfig;
                });
                __webpack_require__.d(__webpack_exports__, "bin2str", function () {
                    return bin2str;
                });
                __webpack_require__.d(__webpack_exports__, "readUint16", function () {
                    return readUint16;
                });
                __webpack_require__.d(__webpack_exports__, "readUint32", function () {
                    return readUint32;
                });
                __webpack_require__.d(__webpack_exports__, "readSint32", function () {
                    return readSint32;
                });
                __webpack_require__.d(__webpack_exports__, "writeUint32", function () {
                    return writeUint32;
                });
                __webpack_require__.d(__webpack_exports__, "findBox", function () {
                    return findBox;
                });
                __webpack_require__.d(__webpack_exports__, "parseSegmentIndex", function () {
                    return parseSegmentIndex;
                });
                __webpack_require__.d(__webpack_exports__, "parseInitSegment", function () {
                    return parseInitSegment;
                });
                __webpack_require__.d(__webpack_exports__, "getStartDTS", function () {
                    return getStartDTS;
                });
                __webpack_require__.d(__webpack_exports__, "getDuration", function () {
                    return getDuration;
                });
                __webpack_require__.d(__webpack_exports__, "computeRawDurationFromSamples", function () {
                    return computeRawDurationFromSamples;
                });
                __webpack_require__.d(__webpack_exports__, "offsetStartDTS", function () {
                    return offsetStartDTS;
                });
                __webpack_require__.d(__webpack_exports__, "segmentValidRange", function () {
                    return segmentValidRange;
                });
                __webpack_require__.d(__webpack_exports__, "appendUint8Array", function () {
                    return appendUint8Array;
                });
                __webpack_require__.d(__webpack_exports__, "parseSamples", function () {
                    return parseSamples;
                });
                __webpack_require__.d(__webpack_exports__, "parseSEIMessageFromNALu", function () {
                    return parseSEIMessageFromNALu;
                });
                __webpack_require__.d(__webpack_exports__, "parseEmsg", function () {
                    return parseEmsg;
                });
                var _typed_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/typed-array.ts");
                var _loader_fragment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/loader/fragment.ts");
                var _demux_id3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/demux/id3.ts");
                var UINT32_MAX = Math.pow(2, 32) - 1;
                var push = [].push;
                var RemuxerTrackIdConfig = { video: 1, audio: 2, id3: 3, text: 4 };
                function bin2str(data) {
                    return String.fromCharCode.apply(null, data);
                }
                function readUint16(buffer, offset) {
                    var val = (buffer[offset] << 8) | buffer[offset + 1];
                    return val < 0 ? 65536 + val : val;
                }
                function readUint32(buffer, offset) {
                    var val = readSint32(buffer, offset);
                    return val < 0 ? 4294967296 + val : val;
                }
                function readSint32(buffer, offset) {
                    return (buffer[offset] << 24) | (buffer[offset + 1] << 16) | (buffer[offset + 2] << 8) | buffer[offset + 3];
                }
                function writeUint32(buffer, offset, value) {
                    buffer[offset] = value >> 24;
                    buffer[offset + 1] = (value >> 16) & 255;
                    buffer[offset + 2] = (value >> 8) & 255;
                    buffer[offset + 3] = value & 255;
                }
                function findBox(data, path) {
                    var results = [];
                    if (!path.length) {
                        return results;
                    }
                    var end = data.byteLength;
                    for (var i = 0; i < end; ) {
                        var size = readUint32(data, i);
                        var type = bin2str(data.subarray(i + 4, i + 8));
                        var endbox = size > 1 ? i + size : end;
                        if (type === path[0]) {
                            if (path.length === 1) {
                                results.push(data.subarray(i + 8, endbox));
                            } else {
                                var subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));
                                if (subresults.length) {
                                    push.apply(results, subresults);
                                }
                            }
                        }
                        i = endbox;
                    }
                    return results;
                }
                function parseSegmentIndex(sidx) {
                    var references = [];
                    var version = sidx[0];
                    var index = 8;
                    var timescale = readUint32(sidx, index);
                    index += 4;
                    var earliestPresentationTime = 0;
                    var firstOffset = 0;
                    if (version === 0) {
                        index += 8;
                    } else {
                        index += 16;
                    }
                    index += 2;
                    var startByte = sidx.length + firstOffset;
                    var referencesCount = readUint16(sidx, index);
                    index += 2;
                    for (var i = 0; i < referencesCount; i++) {
                        var referenceIndex = index;
                        var referenceInfo = readUint32(sidx, referenceIndex);
                        referenceIndex += 4;
                        var referenceSize = referenceInfo & 2147483647;
                        var referenceType = (referenceInfo & 2147483648) >>> 31;
                        if (referenceType === 1) {
                            console.warn("SIDX has hierarchical references (not supported)");
                            return null;
                        }
                        var subsegmentDuration = readUint32(sidx, referenceIndex);
                        referenceIndex += 4;
                        references.push({ referenceSize: referenceSize, subsegmentDuration: subsegmentDuration, info: { duration: subsegmentDuration / timescale, start: startByte, end: startByte + referenceSize - 1 } });
                        startByte += referenceSize;
                        referenceIndex += 4;
                        index = referenceIndex;
                    }
                    return { earliestPresentationTime: earliestPresentationTime, timescale: timescale, version: version, referencesCount: referencesCount, references: references };
                }
                function parseInitSegment(initSegment) {
                    var result = [];
                    var traks = findBox(initSegment, ["moov", "trak"]);
                    for (var i = 0; i < traks.length; i++) {
                        var trak = traks[i];
                        var tkhd = findBox(trak, ["tkhd"])[0];
                        if (tkhd) {
                            var version = tkhd[0];
                            var _index = version === 0 ? 12 : 20;
                            var trackId = readUint32(tkhd, _index);
                            var mdhd = findBox(trak, ["mdia", "mdhd"])[0];
                            if (mdhd) {
                                version = mdhd[0];
                                _index = version === 0 ? 12 : 20;
                                var timescale = readUint32(mdhd, _index);
                                var hdlr = findBox(trak, ["mdia", "hdlr"])[0];
                                if (hdlr) {
                                    var hdlrType = bin2str(hdlr.subarray(8, 12));
                                    var type = { soun: _loader_fragment__WEBPACK_IMPORTED_MODULE_1__["ElementaryStreamTypes"].AUDIO, vide: _loader_fragment__WEBPACK_IMPORTED_MODULE_1__["ElementaryStreamTypes"].VIDEO }[hdlrType];
                                    if (type) {
                                        var stsd = findBox(trak, ["mdia", "minf", "stbl", "stsd"])[0];
                                        var codec = void 0;
                                        if (stsd) {
                                            codec = bin2str(stsd.subarray(12, 16));
                                        }
                                        result[trackId] = { timescale: timescale, type: type };
                                        result[type] = { timescale: timescale, id: trackId, codec: codec };
                                    }
                                }
                            }
                        }
                    }
                    var trex = findBox(initSegment, ["moov", "mvex", "trex"]);
                    trex.forEach(function (trex) {
                        var trackId = readUint32(trex, 4);
                        var track = result[trackId];
                        if (track) {
                            track.default = { duration: readUint32(trex, 12), flags: readUint32(trex, 20) };
                        }
                    });
                    return result;
                }
                function getStartDTS(initData, fmp4) {
                    return (
                        findBox(fmp4, ["moof", "traf"]).reduce(function (result, traf) {
                            var tfdt = findBox(traf, ["tfdt"])[0];
                            var version = tfdt[0];
                            var start = findBox(traf, ["tfhd"]).reduce(function (result, tfhd) {
                                var id = readUint32(tfhd, 4);
                                var track = initData[id];
                                if (track) {
                                    var baseTime = readUint32(tfdt, 4);
                                    if (version === 1) {
                                        baseTime *= Math.pow(2, 32);
                                        baseTime += readUint32(tfdt, 8);
                                    }
                                    var scale = track.timescale || 9e4;
                                    var startTime = baseTime / scale;
                                    if (isFinite(startTime) && (result === null || startTime < result)) {
                                        return startTime;
                                    }
                                }
                                return result;
                            }, null);
                            if (start !== null && isFinite(start) && (result === null || start < result)) {
                                return start;
                            }
                            return result;
                        }, null) || 0
                    );
                }
                function getDuration(data, initData) {
                    var rawDuration = 0;
                    var videoDuration = 0;
                    var audioDuration = 0;
                    var trafs = findBox(data, ["moof", "traf"]);
                    for (var i = 0; i < trafs.length; i++) {
                        var traf = trafs[i];
                        var tfhd = findBox(traf, ["tfhd"])[0];
                        var id = readUint32(tfhd, 4);
                        var track = initData[id];
                        if (!track) {
                            continue;
                        }
                        var trackDefault = track.default;
                        var tfhdFlags = readUint32(tfhd, 0) | (trackDefault === null || trackDefault === void 0 ? void 0 : trackDefault.flags);
                        var sampleDuration = trackDefault === null || trackDefault === void 0 ? void 0 : trackDefault.duration;
                        if (tfhdFlags & 8) {
                            if (tfhdFlags & 2) {
                                sampleDuration = readUint32(tfhd, 12);
                            } else {
                                sampleDuration = readUint32(tfhd, 8);
                            }
                        }
                        var timescale = track.timescale || 9e4;
                        var truns = findBox(traf, ["trun"]);
                        for (var j = 0; j < truns.length; j++) {
                            rawDuration = computeRawDurationFromSamples(truns[j]);
                            if (!rawDuration && sampleDuration) {
                                var sampleCount = readUint32(truns[j], 4);
                                rawDuration = sampleDuration * sampleCount;
                            }
                            if (track.type === _loader_fragment__WEBPACK_IMPORTED_MODULE_1__["ElementaryStreamTypes"].VIDEO) {
                                videoDuration += rawDuration / timescale;
                            } else if (track.type === _loader_fragment__WEBPACK_IMPORTED_MODULE_1__["ElementaryStreamTypes"].AUDIO) {
                                audioDuration += rawDuration / timescale;
                            }
                        }
                    }
                    if (videoDuration === 0 && audioDuration === 0) {
                        var sidxDuration = 0;
                        var sidxs = findBox(data, ["sidx"]);
                        for (var _i = 0; _i < sidxs.length; _i++) {
                            var sidx = parseSegmentIndex(sidxs[_i]);
                            if (sidx !== null && sidx !== void 0 && sidx.references) {
                                sidxDuration += sidx.references.reduce(function (dur, ref) {
                                    return dur + ref.info.duration || 0;
                                }, 0);
                            }
                        }
                        return sidxDuration;
                    }
                    if (videoDuration) {
                        return videoDuration;
                    }
                    return audioDuration;
                }
                function computeRawDurationFromSamples(trun) {
                    var flags = readUint32(trun, 0);
                    var offset = 8;
                    if (flags & 1) {
                        offset += 4;
                    }
                    if (flags & 4) {
                        offset += 4;
                    }
                    var duration = 0;
                    var sampleCount = readUint32(trun, 4);
                    for (var i = 0; i < sampleCount; i++) {
                        if (flags & 256) {
                            var sampleDuration = readUint32(trun, offset);
                            duration += sampleDuration;
                            offset += 4;
                        }
                        if (flags & 512) {
                            offset += 4;
                        }
                        if (flags & 1024) {
                            offset += 4;
                        }
                        if (flags & 2048) {
                            offset += 4;
                        }
                    }
                    return duration;
                }
                function offsetStartDTS(initData, fmp4, timeOffset) {
                    findBox(fmp4, ["moof", "traf"]).forEach(function (traf) {
                        findBox(traf, ["tfhd"]).forEach(function (tfhd) {
                            var id = readUint32(tfhd, 4);
                            var track = initData[id];
                            if (!track) {
                                return;
                            }
                            var timescale = track.timescale || 9e4;
                            findBox(traf, ["tfdt"]).forEach(function (tfdt) {
                                var version = tfdt[0];
                                var baseMediaDecodeTime = readUint32(tfdt, 4);
                                if (version === 0) {
                                    baseMediaDecodeTime -= timeOffset * timescale;
                                    baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
                                    writeUint32(tfdt, 4, baseMediaDecodeTime);
                                } else {
                                    baseMediaDecodeTime *= Math.pow(2, 32);
                                    baseMediaDecodeTime += readUint32(tfdt, 8);
                                    baseMediaDecodeTime -= timeOffset * timescale;
                                    baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
                                    var upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));
                                    var lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
                                    writeUint32(tfdt, 4, upper);
                                    writeUint32(tfdt, 8, lower);
                                }
                            });
                        });
                    });
                }
                function segmentValidRange(data) {
                    var segmentedRange = { valid: null, remainder: null };
                    var moofs = findBox(data, ["moof"]);
                    if (!moofs) {
                        return segmentedRange;
                    } else if (moofs.length < 2) {
                        segmentedRange.remainder = data;
                        return segmentedRange;
                    }
                    var last = moofs[moofs.length - 1];
                    segmentedRange.valid = Object(_typed_array__WEBPACK_IMPORTED_MODULE_0__["sliceUint8"])(data, 0, last.byteOffset - 8);
                    segmentedRange.remainder = Object(_typed_array__WEBPACK_IMPORTED_MODULE_0__["sliceUint8"])(data, last.byteOffset - 8);
                    return segmentedRange;
                }
                function appendUint8Array(data1, data2) {
                    var temp = new Uint8Array(data1.length + data2.length);
                    temp.set(data1);
                    temp.set(data2, data1.length);
                    return temp;
                }
                function parseSamples(timeOffset, track) {
                    var seiSamples = [];
                    var videoData = track.samples;
                    var timescale = track.timescale;
                    var trackId = track.id;
                    var isHEVCFlavor = false;
                    var moofs = findBox(videoData, ["moof"]);
                    moofs.map(function (moof) {
                        var moofOffset = moof.byteOffset - 8;
                        var trafs = findBox(moof, ["traf"]);
                        trafs.map(function (traf) {
                            var baseTime = findBox(traf, ["tfdt"]).map(function (tfdt) {
                                var version = tfdt[0];
                                var result = readUint32(tfdt, 4);
                                if (version === 1) {
                                    result *= Math.pow(2, 32);
                                    result += readUint32(tfdt, 8);
                                }
                                return result / timescale;
                            })[0];
                            if (baseTime !== undefined) {
                                timeOffset = baseTime;
                            }
                            return findBox(traf, ["tfhd"]).map(function (tfhd) {
                                var id = readUint32(tfhd, 4);
                                var tfhdFlags = readUint32(tfhd, 0) & 16777215;
                                var baseDataOffsetPresent = (tfhdFlags & 1) !== 0;
                                var sampleDescriptionIndexPresent = (tfhdFlags & 2) !== 0;
                                var defaultSampleDurationPresent = (tfhdFlags & 8) !== 0;
                                var defaultSampleDuration = 0;
                                var defaultSampleSizePresent = (tfhdFlags & 16) !== 0;
                                var defaultSampleSize = 0;
                                var defaultSampleFlagsPresent = (tfhdFlags & 32) !== 0;
                                var tfhdOffset = 8;
                                if (id === trackId) {
                                    if (baseDataOffsetPresent) {
                                        tfhdOffset += 8;
                                    }
                                    if (sampleDescriptionIndexPresent) {
                                        tfhdOffset += 4;
                                    }
                                    if (defaultSampleDurationPresent) {
                                        defaultSampleDuration = readUint32(tfhd, tfhdOffset);
                                        tfhdOffset += 4;
                                    }
                                    if (defaultSampleSizePresent) {
                                        defaultSampleSize = readUint32(tfhd, tfhdOffset);
                                        tfhdOffset += 4;
                                    }
                                    if (defaultSampleFlagsPresent) {
                                        tfhdOffset += 4;
                                    }
                                    if (track.type === "video") {
                                        isHEVCFlavor = isHEVC(track.codec);
                                    }
                                    findBox(traf, ["trun"]).map(function (trun) {
                                        var version = trun[0];
                                        var flags = readUint32(trun, 0) & 16777215;
                                        var dataOffsetPresent = (flags & 1) !== 0;
                                        var dataOffset = 0;
                                        var firstSampleFlagsPresent = (flags & 4) !== 0;
                                        var sampleDurationPresent = (flags & 256) !== 0;
                                        var sampleDuration = 0;
                                        var sampleSizePresent = (flags & 512) !== 0;
                                        var sampleSize = 0;
                                        var sampleFlagsPresent = (flags & 1024) !== 0;
                                        var sampleCompositionOffsetsPresent = (flags & 2048) !== 0;
                                        var compositionOffset = 0;
                                        var sampleCount = readUint32(trun, 4);
                                        var trunOffset = 8;
                                        if (dataOffsetPresent) {
                                            dataOffset = readUint32(trun, trunOffset);
                                            trunOffset += 4;
                                        }
                                        if (firstSampleFlagsPresent) {
                                            trunOffset += 4;
                                        }
                                        var sampleOffset = dataOffset + moofOffset;
                                        for (var ix = 0; ix < sampleCount; ix++) {
                                            if (sampleDurationPresent) {
                                                sampleDuration = readUint32(trun, trunOffset);
                                                trunOffset += 4;
                                            } else {
                                                sampleDuration = defaultSampleDuration;
                                            }
                                            if (sampleSizePresent) {
                                                sampleSize = readUint32(trun, trunOffset);
                                                trunOffset += 4;
                                            } else {
                                                sampleSize = defaultSampleSize;
                                            }
                                            if (sampleFlagsPresent) {
                                                trunOffset += 4;
                                            }
                                            if (sampleCompositionOffsetsPresent) {
                                                if (version === 0) {
                                                    compositionOffset = readUint32(trun, trunOffset);
                                                } else {
                                                    compositionOffset = readSint32(trun, trunOffset);
                                                }
                                                trunOffset += 4;
                                            }
                                            if (track.type === _loader_fragment__WEBPACK_IMPORTED_MODULE_1__["ElementaryStreamTypes"].VIDEO) {
                                                var naluTotalSize = 0;
                                                while (naluTotalSize < sampleSize) {
                                                    var naluSize = readUint32(videoData, sampleOffset);
                                                    sampleOffset += 4;
                                                    var naluType = videoData[sampleOffset] & 31;
                                                    if (isSEIMessage(isHEVCFlavor, naluType)) {
                                                        var data = videoData.subarray(sampleOffset, sampleOffset + naluSize);
                                                        parseSEIMessageFromNALu(data, timeOffset + compositionOffset / timescale, seiSamples);
                                                    }
                                                    sampleOffset += naluSize;
                                                    naluTotalSize += naluSize + 4;
                                                }
                                            }
                                            timeOffset += sampleDuration / timescale;
                                        }
                                    });
                                }
                            });
                        });
                    });
                    return seiSamples;
                }
                function isHEVC(codec) {
                    if (!codec) {
                        return false;
                    }
                    var delimit = codec.indexOf(".");
                    var baseCodec = delimit < 0 ? codec : codec.substring(0, delimit);
                    return baseCodec === "hvc1" || baseCodec === "hev1" || baseCodec === "dvh1" || baseCodec === "dvhe";
                }
                function isSEIMessage(isHEVCFlavor, naluType) {
                    return isHEVCFlavor ? naluType === 39 || naluType === 40 : naluType === 6;
                }
                function parseSEIMessageFromNALu(unescapedData, pts, samples) {
                    var data = discardEPB(unescapedData);
                    var seiPtr = 0;
                    seiPtr++;
                    var payloadType = 0;
                    var payloadSize = 0;
                    var endOfCaptions = false;
                    var b = 0;
                    while (seiPtr < data.length) {
                        payloadType = 0;
                        do {
                            if (seiPtr >= data.length) {
                                break;
                            }
                            b = data[seiPtr++];
                            payloadType += b;
                        } while (b === 255);
                        payloadSize = 0;
                        do {
                            if (seiPtr >= data.length) {
                                break;
                            }
                            b = data[seiPtr++];
                            payloadSize += b;
                        } while (b === 255);
                        var leftOver = data.length - seiPtr;
                        if (!endOfCaptions && payloadType === 4 && seiPtr < data.length) {
                            endOfCaptions = true;
                            var countryCode = data[seiPtr++];
                            if (countryCode === 181) {
                                var providerCode = readUint16(data, seiPtr);
                                seiPtr += 2;
                                if (providerCode === 49) {
                                    var userStructure = readUint32(data, seiPtr);
                                    seiPtr += 4;
                                    if (userStructure === 1195456820) {
                                        var userDataType = data[seiPtr++];
                                        if (userDataType === 3) {
                                            var firstByte = data[seiPtr++];
                                            var totalCCs = 31 & firstByte;
                                            var enabled = 64 & firstByte;
                                            var totalBytes = enabled ? 2 + totalCCs * 3 : 0;
                                            var byteArray = new Uint8Array(totalBytes);
                                            if (enabled) {
                                                byteArray[0] = firstByte;
                                                for (var i = 1; i < totalBytes; i++) {
                                                    byteArray[i] = data[seiPtr++];
                                                }
                                            }
                                            samples.push({ type: userDataType, payloadType: payloadType, pts: pts, bytes: byteArray });
                                        }
                                    }
                                }
                            }
                        } else if (payloadType === 5 && payloadSize < leftOver) {
                            endOfCaptions = true;
                            if (payloadSize > 16) {
                                var uuidStrArray = [];
                                for (var _i2 = 0; _i2 < 16; _i2++) {
                                    var _b = data[seiPtr++].toString(16);
                                    uuidStrArray.push(_b.length == 1 ? "0" + _b : _b);
                                    if (_i2 === 3 || _i2 === 5 || _i2 === 7 || _i2 === 9) {
                                        uuidStrArray.push("-");
                                    }
                                }
                                var length = payloadSize - 16;
                                var userDataBytes = new Uint8Array(length);
                                for (var _i3 = 0; _i3 < length; _i3++) {
                                    userDataBytes[_i3] = data[seiPtr++];
                                }
                                samples.push({ payloadType: payloadType, pts: pts, uuid: uuidStrArray.join(""), userData: Object(_demux_id3__WEBPACK_IMPORTED_MODULE_2__["utf8ArrayToStr"])(userDataBytes), userDataBytes: userDataBytes });
                            }
                        } else if (payloadSize < leftOver) {
                            seiPtr += payloadSize;
                        } else if (payloadSize > leftOver) {
                            break;
                        }
                    }
                }
                function discardEPB(data) {
                    var length = data.byteLength;
                    var EPBPositions = [];
                    var i = 1;
                    while (i < length - 2) {
                        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 3) {
                            EPBPositions.push(i + 2);
                            i += 2;
                        } else {
                            i++;
                        }
                    }
                    if (EPBPositions.length === 0) {
                        return data;
                    }
                    var newLength = length - EPBPositions.length;
                    var newData = new Uint8Array(newLength);
                    var sourceIndex = 0;
                    for (i = 0; i < newLength; sourceIndex++, i++) {
                        if (sourceIndex === EPBPositions[0]) {
                            sourceIndex++;
                            EPBPositions.shift();
                        }
                        newData[i] = data[sourceIndex];
                    }
                    return newData;
                }
                function parseEmsg(data) {
                    var version = data[0];
                    var schemeIdUri = "";
                    var value = "";
                    var timeScale = 0;
                    var presentationTimeDelta = 0;
                    var presentationTime = 0;
                    var eventDuration = 0;
                    var id = 0;
                    var offset = 0;
                    if (version === 0) {
                        while (bin2str(data.subarray(offset, offset + 1)) !== "\0") {
                            schemeIdUri += bin2str(data.subarray(offset, offset + 1));
                            offset += 1;
                        }
                        schemeIdUri += bin2str(data.subarray(offset, offset + 1));
                        offset += 1;
                        while (bin2str(data.subarray(offset, offset + 1)) !== "\0") {
                            value += bin2str(data.subarray(offset, offset + 1));
                            offset += 1;
                        }
                        value += bin2str(data.subarray(offset, offset + 1));
                        offset += 1;
                        timeScale = readUint32(data, 12);
                        presentationTimeDelta = readUint32(data, 16);
                        eventDuration = readUint32(data, 20);
                        id = readUint32(data, 24);
                        offset = 28;
                    } else if (version === 1) {
                        offset += 4;
                        timeScale = readUint32(data, offset);
                        offset += 4;
                        var leftPresentationTime = readUint32(data, offset);
                        offset += 4;
                        var rightPresentationTime = readUint32(data, offset);
                        offset += 4;
                        presentationTime = Math.pow(2, 32) * leftPresentationTime + rightPresentationTime;
                        if (!Number.isSafeInteger(presentationTime)) {
                            presentationTime = Number.MAX_SAFE_INTEGER;
                            console.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box");
                        }
                        eventDuration = readUint32(data, offset);
                        offset += 4;
                        id = readUint32(data, offset);
                        offset += 4;
                        while (bin2str(data.subarray(offset, offset + 1)) !== "\0") {
                            schemeIdUri += bin2str(data.subarray(offset, offset + 1));
                            offset += 1;
                        }
                        schemeIdUri += bin2str(data.subarray(offset, offset + 1));
                        offset += 1;
                        while (bin2str(data.subarray(offset, offset + 1)) !== "\0") {
                            value += bin2str(data.subarray(offset, offset + 1));
                            offset += 1;
                        }
                        value += bin2str(data.subarray(offset, offset + 1));
                        offset += 1;
                    }
                    var payload = data.subarray(offset, data.byteLength);
                    return { schemeIdUri: schemeIdUri, value: value, timeScale: timeScale, presentationTime: presentationTime, presentationTimeDelta: presentationTimeDelta, eventDuration: eventDuration, id: id, payload: payload };
                }
            },
            "./src/utils/output-filter.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "default", function () {
                    return OutputFilter;
                });
                var OutputFilter = (function () {
                    function OutputFilter(timelineController, trackName) {
                        this.timelineController = void 0;
                        this.cueRanges = [];
                        this.trackName = void 0;
                        this.startTime = null;
                        this.endTime = null;
                        this.screen = null;
                        this.timelineController = timelineController;
                        this.trackName = trackName;
                    }
                    var _proto = OutputFilter.prototype;
                    _proto.dispatchCue = function dispatchCue() {
                        if (this.startTime === null) {
                            return;
                        }
                        this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges);
                        this.startTime = null;
                    };
                    _proto.newCue = function newCue(startTime, endTime, screen) {
                        if (this.startTime === null || this.startTime > startTime) {
                            this.startTime = startTime;
                        }
                        this.endTime = endTime;
                        this.screen = screen;
                        this.timelineController.createCaptionsTrack(this.trackName);
                    };
                    _proto.reset = function reset() {
                        this.cueRanges = [];
                        this.startTime = null;
                    };
                    return OutputFilter;
                })();
            },
            "./src/utils/texttrack-utils.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "sendAddTrackEvent", function () {
                    return sendAddTrackEvent;
                });
                __webpack_require__.d(__webpack_exports__, "addCueToTrack", function () {
                    return addCueToTrack;
                });
                __webpack_require__.d(__webpack_exports__, "clearCurrentCues", function () {
                    return clearCurrentCues;
                });
                __webpack_require__.d(__webpack_exports__, "removeCuesInRange", function () {
                    return removeCuesInRange;
                });
                __webpack_require__.d(__webpack_exports__, "getCuesInRange", function () {
                    return getCuesInRange;
                });
                var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/logger.ts");
                function sendAddTrackEvent(track, videoEl) {
                    var event;
                    try {
                        event = new Event("addtrack");
                    } catch (err) {
                        event = document.createEvent("Event");
                        event.initEvent("addtrack", false, false);
                    }
                    event.track = track;
                    videoEl.dispatchEvent(event);
                }
                function addCueToTrack(track, cue) {
                    var mode = track.mode;
                    if (mode === "disabled") {
                        track.mode = "hidden";
                    }
                    if (track.cues && !track.cues.getCueById(cue.id)) {
                        try {
                            track.addCue(cue);
                            if (!track.cues.getCueById(cue.id)) {
                                throw new Error("addCue is failed for: " + cue);
                            }
                        } catch (err) {
                            _logger__WEBPACK_IMPORTED_MODULE_0__["logger"].debug("[texttrack-utils]: " + err);
                            var textTrackCue = new self.TextTrackCue(cue.startTime, cue.endTime, cue.text);
                            textTrackCue.id = cue.id;
                            track.addCue(textTrackCue);
                        }
                    }
                    if (mode === "disabled") {
                        track.mode = mode;
                    }
                }
                function clearCurrentCues(track) {
                    var mode = track.mode;
                    if (mode === "disabled") {
                        track.mode = "hidden";
                    }
                    if (track.cues) {
                        for (var i = track.cues.length; i--; ) {
                            track.removeCue(track.cues[i]);
                        }
                    }
                    if (mode === "disabled") {
                        track.mode = mode;
                    }
                }
                function removeCuesInRange(track, start, end, predicate) {
                    var mode = track.mode;
                    if (mode === "disabled") {
                        track.mode = "hidden";
                    }
                    if (track.cues && track.cues.length > 0) {
                        var cues = getCuesInRange(track.cues, start, end);
                        for (var i = 0; i < cues.length; i++) {
                            if (!predicate || predicate(cues[i])) {
                                track.removeCue(cues[i]);
                            }
                        }
                    }
                    if (mode === "disabled") {
                        track.mode = mode;
                    }
                }
                function getFirstCueIndexAfterTime(cues, time) {
                    if (time < cues[0].startTime) {
                        return 0;
                    }
                    var len = cues.length - 1;
                    if (time > cues[len].endTime) {
                        return -1;
                    }
                    var left = 0;
                    var right = len;
                    while (left <= right) {
                        var mid = Math.floor((right + left) / 2);
                        if (time < cues[mid].startTime) {
                            right = mid - 1;
                        } else if (time > cues[mid].startTime && left < len) {
                            left = mid + 1;
                        } else {
                            return mid;
                        }
                    }
                    return cues[left].startTime - time < time - cues[right].startTime ? left : right;
                }
                function getCuesInRange(cues, start, end) {
                    var cuesFound = [];
                    var firstCueInRange = getFirstCueIndexAfterTime(cues, start);
                    if (firstCueInRange > -1) {
                        for (var i = firstCueInRange, len = cues.length; i < len; i++) {
                            var _cue = cues[i];
                            if (_cue.startTime >= start && _cue.endTime <= end) {
                                cuesFound.push(_cue);
                            } else if (_cue.startTime > end) {
                                return cuesFound;
                            }
                        }
                    }
                    return cuesFound;
                }
            },
            "./src/utils/time-ranges.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var TimeRanges = {
                    toString: function toString(r) {
                        var log = "";
                        var len = r.length;
                        for (var i = 0; i < len; i++) {
                            log += "[" + r.start(i).toFixed(3) + "," + r.end(i).toFixed(3) + "]";
                        }
                        return log;
                    },
                };
                __webpack_exports__["default"] = TimeRanges;
            },
            "./src/utils/timescale-conversion.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "toTimescaleFromBase", function () {
                    return toTimescaleFromBase;
                });
                __webpack_require__.d(__webpack_exports__, "toTimescaleFromScale", function () {
                    return toTimescaleFromScale;
                });
                __webpack_require__.d(__webpack_exports__, "toMsFromMpegTsClock", function () {
                    return toMsFromMpegTsClock;
                });
                __webpack_require__.d(__webpack_exports__, "toMpegTsClockFromTimescale", function () {
                    return toMpegTsClockFromTimescale;
                });
                var MPEG_TS_CLOCK_FREQ_HZ = 9e4;
                function toTimescaleFromBase(value, destScale, srcBase, round) {
                    if (srcBase === void 0) {
                        srcBase = 1;
                    }
                    if (round === void 0) {
                        round = false;
                    }
                    var result = value * destScale * srcBase;
                    return round ? Math.round(result) : result;
                }
                function toTimescaleFromScale(value, destScale, srcScale, round) {
                    if (srcScale === void 0) {
                        srcScale = 1;
                    }
                    if (round === void 0) {
                        round = false;
                    }
                    return toTimescaleFromBase(value, destScale, 1 / srcScale, round);
                }
                function toMsFromMpegTsClock(value, round) {
                    if (round === void 0) {
                        round = false;
                    }
                    return toTimescaleFromBase(value, 1e3, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);
                }
                function toMpegTsClockFromTimescale(value, srcScale) {
                    if (srcScale === void 0) {
                        srcScale = 1;
                    }
                    return toTimescaleFromBase(value, MPEG_TS_CLOCK_FREQ_HZ, 1 / srcScale);
                }
            },
            "./src/utils/typed-array.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "sliceUint8", function () {
                    return sliceUint8;
                });
                function sliceUint8(array, start, end) {
                    return Uint8Array.prototype.slice ? array.slice(start, end) : new Uint8Array(Array.prototype.slice.call(array, start, end));
                }
            },
            "./src/utils/vttcue.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_exports__["default"] = (function () {
                    if (typeof self !== "undefined" && self.VTTCue) {
                        return self.VTTCue;
                    }
                    var AllowedDirections = ["", "lr", "rl"];
                    var AllowedAlignments = ["start", "middle", "end", "left", "right"];
                    function isAllowedValue(allowed, value) {
                        if (typeof value !== "string") {
                            return false;
                        }
                        if (!Array.isArray(allowed)) {
                            return false;
                        }
                        var lcValue = value.toLowerCase();
                        if (~allowed.indexOf(lcValue)) {
                            return lcValue;
                        }
                        return false;
                    }
                    function findDirectionSetting(value) {
                        return isAllowedValue(AllowedDirections, value);
                    }
                    function findAlignSetting(value) {
                        return isAllowedValue(AllowedAlignments, value);
                    }
                    function extend(obj) {
                        for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                            rest[_key - 1] = arguments[_key];
                        }
                        var i = 1;
                        for (; i < arguments.length; i++) {
                            var cobj = arguments[i];
                            for (var p in cobj) {
                                obj[p] = cobj[p];
                            }
                        }
                        return obj;
                    }
                    function VTTCue(startTime, endTime, text) {
                        var cue = this;
                        var baseObj = { enumerable: true };
                        cue.hasBeenReset = false;
                        var _id = "";
                        var _pauseOnExit = false;
                        var _startTime = startTime;
                        var _endTime = endTime;
                        var _text = text;
                        var _region = null;
                        var _vertical = "";
                        var _snapToLines = true;
                        var _line = "auto";
                        var _lineAlign = "start";
                        var _position = 50;
                        var _positionAlign = "middle";
                        var _size = 50;
                        var _align = "middle";
                        Object.defineProperty(
                            cue,
                            "id",
                            extend({}, baseObj, {
                                get: function get() {
                                    return _id;
                                },
                                set: function set(value) {
                                    _id = "" + value;
                                },
                            })
                        );
                        Object.defineProperty(
                            cue,
                            "pauseOnExit",
                            extend({}, baseObj, {
                                get: function get() {
                                    return _pauseOnExit;
                                },
                                set: function set(value) {
                                    _pauseOnExit = !!value;
                                },
                            })
                        );
                        Object.defineProperty(
                            cue,
                            "startTime",
                            extend({}, baseObj, {
                                get: function get() {
                                    return _startTime;
                                },
                                set: function set(value) {
                                    if (typeof value !== "number") {
                                        throw new TypeError("Start time must be set to a number.");
                                    }
                                    _startTime = value;
                                    this.hasBeenReset = true;
                                },
                            })
                        );
                        Object.defineProperty(
                            cue,
                            "endTime",
                            extend({}, baseObj, {
                                get: function get() {
                                    return _endTime;
                                },
                                set: function set(value) {
                                    if (typeof value !== "number") {
                                        throw new TypeError("End time must be set to a number.");
                                    }
                                    _endTime = value;
                                    this.hasBeenReset = true;
                                },
                            })
                        );
                        Object.defineProperty(
                            cue,
                            "text",
                            extend({}, baseObj, {
                                get: function get() {
                                    return _text;
                                },
                                set: function set(value) {
                                    _text = "" + value;
                                    this.hasBeenReset = true;
                                },
                            })
                        );
                        Object.defineProperty(
                            cue,
                            "region",
                            extend({}, baseObj, {
                                get: function get() {
                                    return _region;
                                },
                                set: function set(value) {
                                    _region = value;
                                    this.hasBeenReset = true;
                                },
                            })
                        );
                        Object.defineProperty(
                            cue,
                            "vertical",
                            extend({}, baseObj, {
                                get: function get() {
                                    return _vertical;
                                },
                                set: function set(value) {
                                    var setting = findDirectionSetting(value);
                                    if (setting === false) {
                                        throw new SyntaxError("An invalid or illegal string was specified.");
                                    }
                                    _vertical = setting;
                                    this.hasBeenReset = true;
                                },
                            })
                        );
                        Object.defineProperty(
                            cue,
                            "snapToLines",
                            extend({}, baseObj, {
                                get: function get() {
                                    return _snapToLines;
                                },
                                set: function set(value) {
                                    _snapToLines = !!value;
                                    this.hasBeenReset = true;
                                },
                            })
                        );
                        Object.defineProperty(
                            cue,
                            "line",
                            extend({}, baseObj, {
                                get: function get() {
                                    return _line;
                                },
                                set: function set(value) {
                                    if (typeof value !== "number" && value !== "auto") {
                                        throw new SyntaxError("An invalid number or illegal string was specified.");
                                    }
                                    _line = value;
                                    this.hasBeenReset = true;
                                },
                            })
                        );
                        Object.defineProperty(
                            cue,
                            "lineAlign",
                            extend({}, baseObj, {
                                get: function get() {
                                    return _lineAlign;
                                },
                                set: function set(value) {
                                    var setting = findAlignSetting(value);
                                    if (!setting) {
                                        throw new SyntaxError("An invalid or illegal string was specified.");
                                    }
                                    _lineAlign = setting;
                                    this.hasBeenReset = true;
                                },
                            })
                        );
                        Object.defineProperty(
                            cue,
                            "position",
                            extend({}, baseObj, {
                                get: function get() {
                                    return _position;
                                },
                                set: function set(value) {
                                    if (value < 0 || value > 100) {
                                        throw new Error("Position must be between 0 and 100.");
                                    }
                                    _position = value;
                                    this.hasBeenReset = true;
                                },
                            })
                        );
                        Object.defineProperty(
                            cue,
                            "positionAlign",
                            extend({}, baseObj, {
                                get: function get() {
                                    return _positionAlign;
                                },
                                set: function set(value) {
                                    var setting = findAlignSetting(value);
                                    if (!setting) {
                                        throw new SyntaxError("An invalid or illegal string was specified.");
                                    }
                                    _positionAlign = setting;
                                    this.hasBeenReset = true;
                                },
                            })
                        );
                        Object.defineProperty(
                            cue,
                            "size",
                            extend({}, baseObj, {
                                get: function get() {
                                    return _size;
                                },
                                set: function set(value) {
                                    if (value < 0 || value > 100) {
                                        throw new Error("Size must be between 0 and 100.");
                                    }
                                    _size = value;
                                    this.hasBeenReset = true;
                                },
                            })
                        );
                        Object.defineProperty(
                            cue,
                            "align",
                            extend({}, baseObj, {
                                get: function get() {
                                    return _align;
                                },
                                set: function set(value) {
                                    var setting = findAlignSetting(value);
                                    if (!setting) {
                                        throw new SyntaxError("An invalid or illegal string was specified.");
                                    }
                                    _align = setting;
                                    this.hasBeenReset = true;
                                },
                            })
                        );
                        cue.displayState = undefined;
                    }
                    VTTCue.prototype.getCueAsHTML = function () {
                        var WebVTT = self.WebVTT;
                        return WebVTT.convertCueToDOMTree(self, this.text);
                    };
                    return VTTCue;
                })();
            },
            "./src/utils/vttparser.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "parseTimeStamp", function () {
                    return parseTimeStamp;
                });
                __webpack_require__.d(__webpack_exports__, "fixLineBreaks", function () {
                    return fixLineBreaks;
                });
                __webpack_require__.d(__webpack_exports__, "VTTParser", function () {
                    return VTTParser;
                });
                var _vttcue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/vttcue.ts");
                var StringDecoder = (function () {
                    function StringDecoder() {}
                    var _proto = StringDecoder.prototype;
                    _proto.decode = function decode(data, options) {
                        if (!data) {
                            return "";
                        }
                        if (typeof data !== "string") {
                            throw new Error("Error - expected string data.");
                        }
                        return decodeURIComponent(encodeURIComponent(data));
                    };
                    return StringDecoder;
                })();
                function parseTimeStamp(input) {
                    function computeSeconds(h, m, s, f) {
                        return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + parseFloat(f || 0);
                    }
                    var m = input.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
                    if (!m) {
                        return null;
                    }
                    if (parseFloat(m[2]) > 59) {
                        return computeSeconds(m[2], m[3], 0, m[4]);
                    }
                    return computeSeconds(m[1], m[2], m[3], m[4]);
                }
                var Settings = (function () {
                    function Settings() {
                        this.values = Object.create(null);
                    }
                    var _proto2 = Settings.prototype;
                    _proto2.set = function set(k, v) {
                        if (!this.get(k) && v !== "") {
                            this.values[k] = v;
                        }
                    };
                    _proto2.get = function get(k, dflt, defaultKey) {
                        if (defaultKey) {
                            return this.has(k) ? this.values[k] : dflt[defaultKey];
                        }
                        return this.has(k) ? this.values[k] : dflt;
                    };
                    _proto2.has = function has(k) {
                        return k in this.values;
                    };
                    _proto2.alt = function alt(k, v, a) {
                        for (var n = 0; n < a.length; ++n) {
                            if (v === a[n]) {
                                this.set(k, v);
                                break;
                            }
                        }
                    };
                    _proto2.integer = function integer(k, v) {
                        if (/^-?\d+$/.test(v)) {
                            this.set(k, parseInt(v, 10));
                        }
                    };
                    _proto2.percent = function percent(k, v) {
                        if (/^([\d]{1,3})(\.[\d]*)?%$/.test(v)) {
                            var percent = parseFloat(v);
                            if (percent >= 0 && percent <= 100) {
                                this.set(k, percent);
                                return true;
                            }
                        }
                        return false;
                    };
                    return Settings;
                })();
                function parseOptions(input, callback, keyValueDelim, groupDelim) {
                    var groups = groupDelim ? input.split(groupDelim) : [input];
                    for (var i in groups) {
                        if (typeof groups[i] !== "string") {
                            continue;
                        }
                        var kv = groups[i].split(keyValueDelim);
                        if (kv.length !== 2) {
                            continue;
                        }
                        var _k = kv[0];
                        var _v = kv[1];
                        callback(_k, _v);
                    }
                }
                var defaults = new _vttcue__WEBPACK_IMPORTED_MODULE_0__["default"](0, 0, "");
                var center = defaults.align === "middle" ? "middle" : "center";
                function parseCue(input, cue, regionList) {
                    var oInput = input;
                    function consumeTimeStamp() {
                        var ts = parseTimeStamp(input);
                        if (ts === null) {
                            throw new Error("Malformed timestamp: " + oInput);
                        }
                        input = input.replace(/^[^\sa-zA-Z-]+/, "");
                        return ts;
                    }
                    function consumeCueSettings(input, cue) {
                        var settings = new Settings();
                        parseOptions(
                            input,
                            function (k, v) {
                                var vals;
                                switch (k) {
                                    case "region":
                                        for (var i = regionList.length - 1; i >= 0; i--) {
                                            if (regionList[i].id === v) {
                                                settings.set(k, regionList[i].region);
                                                break;
                                            }
                                        }
                                        break;
                                    case "vertical":
                                        settings.alt(k, v, ["rl", "lr"]);
                                        break;
                                    case "line":
                                        vals = v.split(",");
                                        settings.integer(k, vals[0]);
                                        if (settings.percent(k, vals[0])) {
                                            settings.set("snapToLines", false);
                                        }
                                        settings.alt(k, vals[0], ["auto"]);
                                        if (vals.length === 2) {
                                            settings.alt("lineAlign", vals[1], ["start", center, "end"]);
                                        }
                                        break;
                                    case "position":
                                        vals = v.split(",");
                                        settings.percent(k, vals[0]);
                                        if (vals.length === 2) {
                                            settings.alt("positionAlign", vals[1], ["start", center, "end", "line-left", "line-right", "auto"]);
                                        }
                                        break;
                                    case "size":
                                        settings.percent(k, v);
                                        break;
                                    case "align":
                                        settings.alt(k, v, ["start", center, "end", "left", "right"]);
                                        break;
                                }
                            },
                            /:/,
                            /\s/
                        );
                        cue.region = settings.get("region", null);
                        cue.vertical = settings.get("vertical", "");
                        var line = settings.get("line", "auto");
                        if (line === "auto" && defaults.line === -1) {
                            line = -1;
                        }
                        cue.line = line;
                        cue.lineAlign = settings.get("lineAlign", "start");
                        cue.snapToLines = settings.get("snapToLines", true);
                        cue.size = settings.get("size", 100);
                        cue.align = settings.get("align", center);
                        var position = settings.get("position", "auto");
                        if (position === "auto" && defaults.position === 50) {
                            position = cue.align === "start" || cue.align === "left" ? 0 : cue.align === "end" || cue.align === "right" ? 100 : 50;
                        }
                        cue.position = position;
                    }
                    function skipWhitespace() {
                        input = input.replace(/^\s+/, "");
                    }
                    skipWhitespace();
                    cue.startTime = consumeTimeStamp();
                    skipWhitespace();
                    if (input.slice(0, 3) !== "--\x3e") {
                        throw new Error("Malformed time stamp (time stamps must be separated by '--\x3e'): " + oInput);
                    }
                    input = input.slice(3);
                    skipWhitespace();
                    cue.endTime = consumeTimeStamp();
                    skipWhitespace();
                    consumeCueSettings(input, cue);
                }
                function fixLineBreaks(input) {
                    return input.replace(/<br(?: \/)?>/gi, "\n");
                }
                var VTTParser = (function () {
                    function VTTParser() {
                        this.state = "INITIAL";
                        this.buffer = "";
                        this.decoder = new StringDecoder();
                        this.regionList = [];
                        this.cue = null;
                        this.oncue = void 0;
                        this.onparsingerror = void 0;
                        this.onflush = void 0;
                    }
                    var _proto3 = VTTParser.prototype;
                    _proto3.parse = function parse(data) {
                        var _this = this;
                        if (data) {
                            _this.buffer += _this.decoder.decode(data, { stream: true });
                        }
                        function collectNextLine() {
                            var buffer = _this.buffer;
                            var pos = 0;
                            buffer = fixLineBreaks(buffer);
                            while (pos < buffer.length && buffer[pos] !== "\r" && buffer[pos] !== "\n") {
                                ++pos;
                            }
                            var line = buffer.slice(0, pos);
                            if (buffer[pos] === "\r") {
                                ++pos;
                            }
                            if (buffer[pos] === "\n") {
                                ++pos;
                            }
                            _this.buffer = buffer.slice(pos);
                            return line;
                        }
                        function parseHeader(input) {
                            parseOptions(input, function (k, v) {}, /:/);
                        }
                        try {
                            var line = "";
                            if (_this.state === "INITIAL") {
                                if (!/\r\n|\n/.test(_this.buffer)) {
                                    return this;
                                }
                                line = collectNextLine();
                                var m = line.match(/^(ï»¿)?WEBVTT([ \t].*)?$/);
                                if (!m || !m[0]) {
                                    throw new Error("Malformed WebVTT signature.");
                                }
                                _this.state = "HEADER";
                            }
                            var alreadyCollectedLine = false;
                            while (_this.buffer) {
                                if (!/\r\n|\n/.test(_this.buffer)) {
                                    return this;
                                }
                                if (!alreadyCollectedLine) {
                                    line = collectNextLine();
                                } else {
                                    alreadyCollectedLine = false;
                                }
                                switch (_this.state) {
                                    case "HEADER":
                                        if (/:/.test(line)) {
                                            parseHeader(line);
                                        } else if (!line) {
                                            _this.state = "ID";
                                        }
                                        continue;
                                    case "NOTE":
                                        if (!line) {
                                            _this.state = "ID";
                                        }
                                        continue;
                                    case "ID":
                                        if (/^NOTE($|[ \t])/.test(line)) {
                                            _this.state = "NOTE";
                                            break;
                                        }
                                        if (!line) {
                                            continue;
                                        }
                                        _this.cue = new _vttcue__WEBPACK_IMPORTED_MODULE_0__["default"](0, 0, "");
                                        _this.state = "CUE";
                                        if (line.indexOf("--\x3e") === -1) {
                                            _this.cue.id = line;
                                            continue;
                                        }
                                    case "CUE":
                                        if (!_this.cue) {
                                            _this.state = "BADCUE";
                                            continue;
                                        }
                                        try {
                                            parseCue(line, _this.cue, _this.regionList);
                                        } catch (e) {
                                            _this.cue = null;
                                            _this.state = "BADCUE";
                                            continue;
                                        }
                                        _this.state = "CUETEXT";
                                        continue;
                                    case "CUETEXT":
                                        {
                                            var hasSubstring = line.indexOf("--\x3e") !== -1;
                                            if (!line || (hasSubstring && (alreadyCollectedLine = true))) {
                                                if (_this.oncue && _this.cue) {
                                                    _this.oncue(_this.cue);
                                                }
                                                _this.cue = null;
                                                _this.state = "ID";
                                                continue;
                                            }
                                            if (_this.cue === null) {
                                                continue;
                                            }
                                            if (_this.cue.text) {
                                                _this.cue.text += "\n";
                                            }
                                            _this.cue.text += line;
                                        }
                                        continue;
                                    case "BADCUE":
                                        if (!line) {
                                            _this.state = "ID";
                                        }
                                }
                            }
                        } catch (e) {
                            if (_this.state === "CUETEXT" && _this.cue && _this.oncue) {
                                _this.oncue(_this.cue);
                            }
                            _this.cue = null;
                            _this.state = _this.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
                        }
                        return this;
                    };
                    _proto3.flush = function flush() {
                        var _this = this;
                        try {
                            if (_this.cue || _this.state === "HEADER") {
                                _this.buffer += "\n\n";
                                _this.parse();
                            }
                            if (_this.state === "INITIAL" || _this.state === "BADWEBVTT") {
                                throw new Error("Malformed WebVTT signature.");
                            }
                        } catch (e) {
                            if (_this.onparsingerror) {
                                _this.onparsingerror(e);
                            }
                        }
                        if (_this.onflush) {
                            _this.onflush();
                        }
                        return this;
                    };
                    return VTTParser;
                })();
            },
            "./src/utils/webvtt-parser.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "generateCueId", function () {
                    return generateCueId;
                });
                __webpack_require__.d(__webpack_exports__, "parseWebVTT", function () {
                    return parseWebVTT;
                });
                var _home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/polyfills/number.ts");
                var _vttparser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/vttparser.ts");
                var _demux_id3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./src/demux/id3.ts");
                var _timescale_conversion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./src/utils/timescale-conversion.ts");
                var _remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("./src/remux/mp4-remuxer.ts");
                var LINEBREAKS = /\r\n|\n\r|\n|\r/g;
                var startsWith = function startsWith(inputString, searchString, position) {
                    if (position === void 0) {
                        position = 0;
                    }
                    return inputString.slice(position, position + searchString.length) === searchString;
                };
                var cueString2millis = function cueString2millis(timeString) {
                    var ts = parseInt(timeString.slice(-3));
                    var secs = parseInt(timeString.slice(-6, -4));
                    var mins = parseInt(timeString.slice(-9, -7));
                    var hours = timeString.length > 9 ? parseInt(timeString.substring(0, timeString.indexOf(":"))) : 0;
                    if (
                        !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(ts) ||
                        !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(secs) ||
                        !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(mins) ||
                        !Object(_home_runner_work_hls_js_hls_js_src_polyfills_number__WEBPACK_IMPORTED_MODULE_0__["isFiniteNumber"])(hours)
                    ) {
                        throw Error("Malformed X-TIMESTAMP-MAP: Local:" + timeString);
                    }
                    ts += 1e3 * secs;
                    ts += 60 * 1e3 * mins;
                    ts += 60 * 60 * 1e3 * hours;
                    return ts;
                };
                var hash = function hash(text) {
                    var hash = 5381;
                    var i = text.length;
                    while (i) {
                        hash = (hash * 33) ^ text.charCodeAt(--i);
                    }
                    return (hash >>> 0).toString();
                };
                function generateCueId(startTime, endTime, text) {
                    return hash(startTime.toString()) + hash(endTime.toString()) + hash(text);
                }
                var calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {
                    var currCC = vttCCs[cc];
                    var prevCC = vttCCs[currCC.prevCC];
                    if (!prevCC || (!prevCC.new && currCC.new)) {
                        vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;
                        currCC.new = false;
                        return;
                    }
                    while ((_prevCC = prevCC) !== null && _prevCC !== void 0 && _prevCC.new) {
                        var _prevCC;
                        vttCCs.ccOffset += currCC.start - prevCC.start;
                        currCC.new = false;
                        currCC = prevCC;
                        prevCC = vttCCs[currCC.prevCC];
                    }
                    vttCCs.presentationOffset = presentationTime;
                };
                function parseWebVTT(vttByteArray, initPTS, timescale, vttCCs, cc, timeOffset, callBack, errorCallBack) {
                    var parser = new _vttparser__WEBPACK_IMPORTED_MODULE_1__["VTTParser"]();
                    var vttLines = Object(_demux_id3__WEBPACK_IMPORTED_MODULE_2__["utf8ArrayToStr"])(new Uint8Array(vttByteArray)).trim().replace(LINEBREAKS, "\n").split("\n");
                    var cues = [];
                    var initPTS90Hz = Object(_timescale_conversion__WEBPACK_IMPORTED_MODULE_3__["toMpegTsClockFromTimescale"])(initPTS, timescale);
                    var cueTime = "00:00.000";
                    var timestampMapMPEGTS = 0;
                    var timestampMapLOCAL = 0;
                    var parsingError;
                    var inHeader = true;
                    parser.oncue = function (cue) {
                        var currCC = vttCCs[cc];
                        var cueOffset = vttCCs.ccOffset;
                        var webVttMpegTsMapOffset = (timestampMapMPEGTS - initPTS90Hz) / 9e4;
                        if (currCC !== null && currCC !== void 0 && currCC.new) {
                            if (timestampMapLOCAL !== undefined) {
                                cueOffset = vttCCs.ccOffset = currCC.start;
                            } else {
                                calculateOffset(vttCCs, cc, webVttMpegTsMapOffset);
                            }
                        }
                        if (webVttMpegTsMapOffset) {
                            cueOffset = webVttMpegTsMapOffset - vttCCs.presentationOffset;
                        }
                        var duration = cue.endTime - cue.startTime;
                        var startTime = Object(_remux_mp4_remuxer__WEBPACK_IMPORTED_MODULE_4__["normalizePts"])((cue.startTime + cueOffset - timestampMapLOCAL) * 9e4, timeOffset * 9e4) / 9e4;
                        cue.startTime = Math.max(startTime, 0);
                        cue.endTime = Math.max(startTime + duration, 0);
                        var text = cue.text.trim();
                        cue.text = decodeURIComponent(encodeURIComponent(text));
                        if (!cue.id) {
                            cue.id = generateCueId(cue.startTime, cue.endTime, text);
                        }
                        if (cue.endTime > 0) {
                            cues.push(cue);
                        }
                    };
                    parser.onparsingerror = function (error) {
                        parsingError = error;
                    };
                    parser.onflush = function () {
                        if (parsingError) {
                            errorCallBack(parsingError);
                            return;
                        }
                        callBack(cues);
                    };
                    vttLines.forEach(function (line) {
                        if (inHeader) {
                            if (startsWith(line, "X-TIMESTAMP-MAP=")) {
                                inHeader = false;
                                line.slice(16)
                                    .split(",")
                                    .forEach(function (timestamp) {
                                        if (startsWith(timestamp, "LOCAL:")) {
                                            cueTime = timestamp.slice(6);
                                        } else if (startsWith(timestamp, "MPEGTS:")) {
                                            timestampMapMPEGTS = parseInt(timestamp.slice(7));
                                        }
                                    });
                                try {
                                    timestampMapLOCAL = cueString2millis(cueTime) / 1e3;
                                } catch (error) {
                                    parsingError = error;
                                }
                                return;
                            } else if (line === "") {
                                inHeader = false;
                            }
                        }
                        parser.parse(line + "\n");
                    });
                    parser.flush();
                }
            },
            "./src/utils/xhr-loader.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/utils/logger.ts");
                var _loader_load_stats__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/loader/load-stats.ts");
                var AGE_HEADER_LINE_REGEX = /^age:\s*[\d.]+\s*$/m;
                var XhrLoader = (function () {
                    function XhrLoader(config) {
                        this.xhrSetup = void 0;
                        this.requestTimeout = void 0;
                        this.retryTimeout = void 0;
                        this.retryDelay = void 0;
                        this.config = null;
                        this.callbacks = null;
                        this.context = void 0;
                        this.loader = null;
                        this.stats = void 0;
                        this.xhrSetup = config ? config.xhrSetup : null;
                        this.stats = new _loader_load_stats__WEBPACK_IMPORTED_MODULE_1__["LoadStats"]();
                        this.retryDelay = 0;
                    }
                    var _proto = XhrLoader.prototype;
                    _proto.destroy = function destroy() {
                        this.callbacks = null;
                        this.abortInternal();
                        this.loader = null;
                        this.config = null;
                    };
                    _proto.abortInternal = function abortInternal() {
                        var loader = this.loader;
                        self.clearTimeout(this.requestTimeout);
                        self.clearTimeout(this.retryTimeout);
                        if (loader) {
                            loader.onreadystatechange = null;
                            loader.onprogress = null;
                            if (loader.readyState !== 4) {
                                this.stats.aborted = true;
                                loader.abort();
                            }
                        }
                    };
                    _proto.abort = function abort() {
                        var _this$callbacks;
                        this.abortInternal();
                        if ((_this$callbacks = this.callbacks) !== null && _this$callbacks !== void 0 && _this$callbacks.onAbort) {
                            this.callbacks.onAbort(this.stats, this.context, this.loader);
                        }
                    };
                    _proto.load = function load(context, config, callbacks) {
                        if (this.stats.loading.start) {
                            throw new Error("Loader can only be used once.");
                        }
                        this.stats.loading.start = self.performance.now();
                        this.context = context;
                        this.config = config;
                        this.callbacks = callbacks;
                        this.retryDelay = config.retryDelay;
                        this.loadInternal();
                    };
                    _proto.loadInternal = function loadInternal() {
                        var config = this.config,
                            context = this.context;
                        if (!config) {
                            return;
                        }
                        var xhr = (this.loader = new self.XMLHttpRequest());
                        var stats = this.stats;
                        stats.loading.first = 0;
                        stats.loaded = 0;
                        var xhrSetup = this.xhrSetup;
                        try {
                            if (xhrSetup) {
                                try {
                                    xhrSetup(xhr, context.url);
                                } catch (e) {
                                    xhr.open("GET", context.url, true);
                                    xhrSetup(xhr, context.url);
                                }
                            }
                            if (!xhr.readyState) {
                                xhr.open("GET", context.url, true);
                            }
                            var headers = this.context.headers;
                            if (headers) {
                                for (var header in headers) {
                                    xhr.setRequestHeader(header, headers[header]);
                                }
                            }
                        } catch (e) {
                            this.callbacks.onError({ code: xhr.status, text: e.message }, context, xhr);
                            return;
                        }
                        if (context.rangeEnd) {
                            xhr.setRequestHeader("Range", "bytes=" + context.rangeStart + "-" + (context.rangeEnd - 1));
                        }
                        xhr.onreadystatechange = this.readystatechange.bind(this);
                        xhr.onprogress = this.loadprogress.bind(this);
                        xhr.responseType = context.responseType;
                        self.clearTimeout(this.requestTimeout);
                        this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);
                        xhr.send();
                    };
                    _proto.readystatechange = function readystatechange() {
                        var context = this.context,
                            xhr = this.loader,
                            stats = this.stats;
                        if (!context || !xhr) {
                            return;
                        }
                        var readyState = xhr.readyState;
                        var config = this.config;
                        if (stats.aborted) {
                            return;
                        }
                        if (readyState >= 2) {
                            self.clearTimeout(this.requestTimeout);
                            if (stats.loading.first === 0) {
                                stats.loading.first = Math.max(self.performance.now(), stats.loading.start);
                            }
                            if (readyState === 4) {
                                xhr.onreadystatechange = null;
                                xhr.onprogress = null;
                                var status = xhr.status;
                                if (status >= 200 && status < 300) {
                                    stats.loading.end = Math.max(self.performance.now(), stats.loading.first);
                                    var data;
                                    var len;
                                    if (context.responseType === "arraybuffer") {
                                        data = xhr.response;
                                        len = data.byteLength;
                                    } else {
                                        data = xhr.responseText;
                                        len = data.length;
                                    }
                                    stats.loaded = stats.total = len;
                                    if (!this.callbacks) {
                                        return;
                                    }
                                    var onProgress = this.callbacks.onProgress;
                                    if (onProgress) {
                                        onProgress(stats, context, data, xhr);
                                    }
                                    if (!this.callbacks) {
                                        return;
                                    }
                                    var response = { url: xhr.responseURL, data: data };
                                    this.callbacks.onSuccess(response, stats, context, xhr);
                                } else {
                                    if (stats.retry >= config.maxRetry || (status >= 400 && status < 499)) {
                                        _utils_logger__WEBPACK_IMPORTED_MODULE_0__["logger"].error(status + " while loading " + context.url);
                                        this.callbacks.onError({ code: status, text: xhr.statusText }, context, xhr);
                                    } else {
                                        _utils_logger__WEBPACK_IMPORTED_MODULE_0__["logger"].warn(status + " while loading " + context.url + ", retrying in " + this.retryDelay + "...");
                                        this.abortInternal();
                                        this.loader = null;
                                        self.clearTimeout(this.retryTimeout);
                                        this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);
                                        this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);
                                        stats.retry++;
                                    }
                                }
                            } else {
                                self.clearTimeout(this.requestTimeout);
                                this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);
                            }
                        }
                    };
                    _proto.loadtimeout = function loadtimeout() {
                        _utils_logger__WEBPACK_IMPORTED_MODULE_0__["logger"].warn("timeout while loading " + this.context.url);
                        var callbacks = this.callbacks;
                        if (callbacks) {
                            this.abortInternal();
                            callbacks.onTimeout(this.stats, this.context, this.loader);
                        }
                    };
                    _proto.loadprogress = function loadprogress(event) {
                        var stats = this.stats;
                        stats.loaded = event.loaded;
                        if (event.lengthComputable) {
                            stats.total = event.total;
                        }
                    };
                    _proto.getCacheAge = function getCacheAge() {
                        var result = null;
                        if (this.loader && AGE_HEADER_LINE_REGEX.test(this.loader.getAllResponseHeaders())) {
                            var ageHeader = this.loader.getResponseHeader("age");
                            result = ageHeader ? parseFloat(ageHeader) : null;
                        }
                        return result;
                    };
                    return XhrLoader;
                })();
                __webpack_exports__["default"] = XhrLoader;
            },
        })["default"];
    });
typeof window !== "undefined" &&
    (function webpackUniversalModuleDefinition(root, factory) {
        if (typeof exports === "object" && typeof module === "object") module.exports = factory();
        else if (typeof define === "function" && define.amd) define([], factory);
        else if (typeof exports === "object") exports["HlsDemo"] = factory();
        else root["HlsDemo"] = factory();
    })(this, function () {
        return (function (modules) {
            var installedModules = {};
            function __webpack_require__(moduleId) {
                if (installedModules[moduleId]) {
                    return installedModules[moduleId].exports;
                }
                var module = (installedModules[moduleId] = { i: moduleId, l: false, exports: {} });
                modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
                module.l = true;
                return module.exports;
            }
            __webpack_require__.m = modules;
            __webpack_require__.c = installedModules;
            __webpack_require__.d = function (exports, name, getter) {
                if (!__webpack_require__.o(exports, name)) {
                    Object.defineProperty(exports, name, { enumerable: true, get: getter });
                }
            };
            __webpack_require__.r = function (exports) {
                if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                    Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
                }
                Object.defineProperty(exports, "__esModule", { value: true });
            };
            __webpack_require__.t = function (value, mode) {
                if (mode & 1) value = __webpack_require__(value);
                if (mode & 8) return value;
                if (mode & 4 && typeof value === "object" && value && value.__esModule) return value;
                var ns = Object.create(null);
                __webpack_require__.r(ns);
                Object.defineProperty(ns, "default", { enumerable: true, value: value });
                if (mode & 2 && typeof value != "string")
                    for (var key in value)
                        __webpack_require__.d(
                            ns,
                            key,
                            function (key) {
                                return value[key];
                            }.bind(null, key)
                        );
                return ns;
            };
            __webpack_require__.n = function (module) {
                var getter =
                    module && module.__esModule
                        ? function getDefault() {
                              return module["default"];
                          }
                        : function getModuleExports() {
                              return module;
                          };
                __webpack_require__.d(getter, "a", getter);
                return getter;
            };
            __webpack_require__.o = function (object, property) {
                return Object.prototype.hasOwnProperty.call(object, property);
            };
            __webpack_require__.p = "/dist/";
            return __webpack_require__((__webpack_require__.s = "./demo/main.js"));
        })({
            "./demo/chart/chartjs-horizontal-bar.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "applyChartInstanceOverrides", function () {
                    return applyChartInstanceOverrides;
                });
                __webpack_require__.d(__webpack_exports__, "hhmmss", function () {
                    return hhmmss;
                });
                var chart_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/chart.js/dist/Chart.js");
                var chart_js__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(chart_js__WEBPACK_IMPORTED_MODULE_0__);
                function _extends() {
                    _extends = Object.assign
                        ? Object.assign.bind()
                        : function (target) {
                              for (var i = 1; i < arguments.length; i++) {
                                  var source = arguments[i];
                                  for (var key in source) {
                                      if (Object.prototype.hasOwnProperty.call(source, key)) {
                                          target[key] = source[key];
                                      }
                                  }
                              }
                              return target;
                          };
                    return _extends.apply(this, arguments);
                }
                chart_js__WEBPACK_IMPORTED_MODULE_0___default.a.controllers.horizontalBar.prototype.calculateBarValuePixels = function (datasetIndex, index, options) {
                    var chart = this.chart;
                    var scale = this._getValueScale();
                    var datasets = chart.data.datasets;
                    if (!datasets) {
                        throw new Error("Chart datasets are " + datasets);
                    }
                    scale._parseValue = scaleParseValue;
                    var obj = datasets[datasetIndex].data[index];
                    var value = scale._parseValue(obj);
                    var start = value.start === undefined ? 0 : value.max >= 0 && value.min >= 0 ? value.min : value.max;
                    var length = value.start === undefined ? value.end : value.max >= 0 && value.min >= 0 ? value.max - value.min : value.min - value.max;
                    var base = scale.getPixelForValue(start);
                    var head = scale.getPixelForValue(start + length);
                    var size = head - base;
                    return { size: size, base: base, head: head, center: head + size / 2 };
                };
                chart_js__WEBPACK_IMPORTED_MODULE_0___default.a.controllers.horizontalBar.prototype.calculateBarIndexPixels = function (datasetIndex, index, ruler, options) {
                    var rowHeight = options.barThickness;
                    var size = rowHeight * options.categoryPercentage;
                    var center = ruler.start + (datasetIndex * rowHeight + rowHeight / 2);
                    return { base: center - size / 2, head: center + size / 2, center: center, size: size };
                };
                chart_js__WEBPACK_IMPORTED_MODULE_0___default.a.controllers.horizontalBar.prototype.draw = function () {
                    var rects = this.getMeta().data;
                    var len = rects.length;
                    var dataset = this.getDataset();
                    if (len !== dataset.data.length) {
                        return;
                    }
                    var chart = this.chart;
                    var scale = this._getValueScale();
                    scale._parseValue = scaleParseValue;
                    var ctx = chart.ctx;
                    var chartArea = chart.chartArea;
                    chart_js__WEBPACK_IMPORTED_MODULE_0___default.a.helpers.canvas.clipArea(ctx, chartArea);
                    if (!this.lineHeight) {
                        this.lineHeight = Math.ceil(ctx.measureText("0").actualBoundingBoxAscent) + 2;
                    }
                    var lineHeight = this.lineHeight;
                    var range = 0;
                    for (var i = 0; i < len; ++i) {
                        var rect = rects[i];
                        var view = rect._view;
                        if (!intersects(view.base, view.x, chartArea.left, chartArea.right)) {
                            continue;
                        }
                        var obj = dataset.data[i];
                        var val = scale._parseValue(obj);
                        if (!isNaN(val.min) && !isNaN(val.max)) {
                            var dataType = obj.dataType;
                            var stats = obj.stats;
                            var isPart = dataType === "part";
                            var isFragmentHint = dataType === "fragmentHint";
                            var isFragment = dataType === "fragment" || isPart || isFragmentHint;
                            var isCue = dataType === "cue";
                            if (isCue) {
                                view.y += view.height * 0.5 * (i % 2) - view.height * 0.25;
                            } else if (isPart) {
                                view.height -= 22;
                            }
                            var bounds = boundingRects(view);
                            var drawText = bounds.w > lineHeight * 1.5 && !isFragmentHint;
                            if (isFragment || isCue) {
                                if (drawText) {
                                    view.borderWidth = 1;
                                    if (i === 0) {
                                        view.borderSkipped = false;
                                    }
                                } else {
                                    range = range || scale.getValueForPixel(chartArea.right) - scale.getValueForPixel(chartArea.left);
                                    if (range > 300 || isCue) {
                                        view.borderWidth = 0;
                                    }
                                }
                                if (isFragmentHint) {
                                    view.borderWidth = 0;
                                    view.backgroundColor = "rgba(0, 0, 0, 0.1)";
                                } else {
                                    view.backgroundColor = "rgba(0, 0, 0, " + (0.05 + (i % 2) / 12) + ")";
                                }
                            }
                            rect.draw();
                            if (isFragment) {
                                if (!stats) {
                                    stats = {};
                                }
                                if (isPart) {
                                    ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
                                    ctx.fillRect(bounds.x, bounds.y, bounds.w, bounds.h);
                                }
                                if (stats.aborted) {
                                    ctx.fillStyle = "rgba(100, 0, 0, 0.3)";
                                    ctx.fillRect(bounds.x, bounds.y, bounds.w, bounds.h);
                                }
                                if (stats.loaded && stats.total) {
                                    ctx.fillStyle = "rgba(50, 20, 100, 0.3)";
                                    ctx.fillRect(bounds.x, bounds.y, (bounds.w * stats.loaded) / stats.total, bounds.h);
                                }
                            } else if (isCue) {
                                if (obj.active) {
                                    ctx.fillStyle = "rgba(100, 100, 10, 0.4)";
                                    ctx.fillRect(bounds.x, bounds.y, bounds.w, bounds.h);
                                }
                            }
                            if (drawText) {
                                var start = val.start;
                                ctx.fillStyle = "rgb(0, 0, 0)";
                                if (stats) {
                                    var snBounds = _extends({}, bounds);
                                    if (obj.cc) {
                                        var ccLabel = "cc:" + obj.cc;
                                        var ccWidth = Math.min(ctx.measureText(ccLabel).width + 2, snBounds.w / 2 - 2);
                                        if (ccWidth) {
                                            ctx.fillText(ccLabel, snBounds.x + 2, snBounds.y + lineHeight, snBounds.w / 2 - 4);
                                            snBounds.x += ccWidth;
                                            snBounds.w -= ccWidth;
                                        }
                                    }
                                    var snLabel = isPart ? "part: " + obj.index : "sn: " + obj.sn;
                                    var textWidth = Math.min(ctx.measureText(snLabel).width + 2, snBounds.w - 2);
                                    ctx.fillText(snLabel, snBounds.x + snBounds.w - textWidth, snBounds.y + lineHeight, snBounds.w - 4);
                                }
                                if (isCue) {
                                    var strLength = Math.min(30, Math.ceil(bounds.w / (lineHeight / 3)));
                                    ctx.fillText(("" + obj.content).slice(0, strLength), bounds.x + 2, bounds.y + bounds.h - 3, bounds.w - 5);
                                } else if (!isPart) {
                                    var _float = start !== (start | 0);
                                    var fixedDigits = _float ? Math.min(5, Math.max(1, Math.floor(bounds.w / 10 - 1))) : 0;
                                    var startString = hhmmss(start, fixedDigits);
                                    ctx.fillText(startString, bounds.x + 2, bounds.y + bounds.h - 3, bounds.w - 5);
                                }
                            }
                        }
                    }
                    chart_js__WEBPACK_IMPORTED_MODULE_0___default.a.helpers.canvas.unclipArea(chart.ctx);
                };
                function applyChartInstanceOverrides(chart) {
                    Object.keys(chart.scales).forEach(function (axis) {
                        var scale = chart.scales[axis];
                        scale._parseValue = scaleParseValue;
                    });
                }
                function scaleParseValue(value) {
                    if (value === undefined) {
                        console.warn("Chart values undefined (update chart)");
                        return {};
                    }
                    var start;
                    var end;
                    var min;
                    var max;
                    if (Array.isArray(value)) {
                        start = +this.getRightValue(value[0]);
                        end = +this.getRightValue(value[1]);
                        min = Math.min(start, end);
                        max = Math.max(start, end);
                    } else {
                        start = +this.getRightValue(value.start);
                        if ("end" in value) {
                            end = +this.getRightValue(value.end);
                        } else {
                            end = +this.getRightValue(value.start + value.duration);
                        }
                        min = Math.min(start, end);
                        max = Math.max(start, end);
                    }
                    return { min: min, max: max, start: start, end: end };
                }
                function intersects(x1, x2, x3, x4) {
                    return x2 > x3 && x1 < x4;
                }
                function boundingRects(vm) {
                    var half = vm.height / 2;
                    var left = Math.min(vm.x, vm.base);
                    var right = Math.max(vm.x, vm.base);
                    var top = vm.y - half;
                    var bottom = vm.y + half;
                    return { x: left, y: top, w: right - left, h: bottom - top };
                }
                function hhmmss(value, fixedDigits) {
                    var h = (value / 3600) | 0;
                    var m = ((value / 60) | 0) % 60;
                    var s = value % 60;
                    return (h + ":" + pad(m, 2) + ":" + pad(s.toFixed(fixedDigits), fixedDigits ? fixedDigits + 3 : 2)).replace(/^(?:0+:?)*(\d.*?)(?:\.0*)?$/, "$1");
                }
                function pad(str, length) {
                    str = "" + str;
                    while (str.length < length) {
                        str = "0" + str;
                    }
                    return str;
                }
            },
            "./demo/chart/timeline-chart.ts": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "TimelineChart", function () {
                    return TimelineChart;
                });
                var chart_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/chart.js/dist/Chart.js");
                var chart_js__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(chart_js__WEBPACK_IMPORTED_MODULE_0__);
                var _chartjs_horizontal_bar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./demo/chart/chartjs-horizontal-bar.ts");
                function _extends() {
                    _extends = Object.assign
                        ? Object.assign.bind()
                        : function (target) {
                              for (var i = 1; i < arguments.length; i++) {
                                  var source = arguments[i];
                                  for (var key in source) {
                                      if (Object.prototype.hasOwnProperty.call(source, key)) {
                                          target[key] = source[key];
                                      }
                                  }
                              }
                              return target;
                          };
                    return _extends.apply(this, arguments);
                }
                function _defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    Object.defineProperty(Constructor, "prototype", { writable: false });
                    return Constructor;
                }
                var X_AXIS_SECONDS = "x-axis-seconds";
                var TimelineChart = (function () {
                    function TimelineChart(canvas, chartJsOptions) {
                        var _this = this;
                        this.chart = void 0;
                        this.rafDebounceRequestId = -1;
                        this.imageDataBuffer = null;
                        this.media = null;
                        this.tracksChangeHandler = void 0;
                        this.cuesChangeHandler = void 0;
                        this.hidden = true;
                        this.zoom100 = 60;
                        var ctx = canvas.getContext("2d");
                        if (!ctx) {
                            throw new Error("Could not get CanvasRenderingContext2D from canvas: " + canvas);
                        }
                        var chart = (this.chart = self.chart = new chart_js__WEBPACK_IMPORTED_MODULE_0___default.a(ctx, {
                            type: "horizontalBar",
                            data: { labels: [], datasets: [] },
                            options: _extends(getChartOptions(), chartJsOptions),
                            plugins: [
                                {
                                    afterRender: function afterRender(chart) {
                                        _this.imageDataBuffer = null;
                                        _this.drawCurrentTime();
                                    },
                                },
                            ],
                        }));
                        Object(_chartjs_horizontal_bar__WEBPACK_IMPORTED_MODULE_1__["applyChartInstanceOverrides"])(chart);
                        canvas.ondblclick = function (event) {
                            var chart = _this.chart;
                            var chartArea = chart.chartArea;
                            var element = chart.getElementAtEvent(event);
                            var pos = chart_js__WEBPACK_IMPORTED_MODULE_0___default.a.helpers.getRelativePosition(event, chart);
                            var scale = _this.chartScales[X_AXIS_SECONDS];
                            if (element.length || pos.x > chartArea.left) {
                                var amount = event.getModifierState("Shift") ? -1 : 0.5;
                                _this.zoom(scale, pos, amount);
                            } else {
                                scale.options.ticks.min = 0;
                                scale.options.ticks.max = _this.zoom100;
                            }
                            _this.update();
                        };
                        canvas.onwheel = function (event) {
                            if (event.deltaMode) {
                                return;
                            }
                            var chart = _this.chart;
                            var chartArea = chart.chartArea;
                            var pos = chart_js__WEBPACK_IMPORTED_MODULE_0___default.a.helpers.getRelativePosition(event, chart);
                            if (pos.x > chartArea.left - 11) {
                                var scale = _this.chartScales[X_AXIS_SECONDS];
                                if (event.deltaY) {
                                    var direction = -event.deltaY / Math.abs(event.deltaY);
                                    var normal = Math.min(333, Math.abs(event.deltaY)) / 1e3;
                                    var ease = 1 - (1 - normal) * (1 - normal);
                                    _this.zoom(scale, pos, ease * direction);
                                } else if (event.deltaX) {
                                    _this.pan(scale, event.deltaX / 10, scale.min, scale.max);
                                }
                                event.preventDefault();
                            }
                        };
                        var moved = false;
                        var gestureScale = 1;
                        canvas.onpointerdown = function (downEvent) {
                            if (!downEvent.isPrimary || gestureScale !== 1) {
                                return;
                            }
                            var chart = _this.chart;
                            var chartArea = chart.chartArea;
                            var pos = chart_js__WEBPACK_IMPORTED_MODULE_0___default.a.helpers.getRelativePosition(downEvent, chart);
                            if (pos.x > chartArea.left) {
                                var scale = _this.chartScales[X_AXIS_SECONDS];
                                var startX = downEvent.clientX;
                                var min = scale.min,
                                    max = scale.max;
                                var xToVal = (max - min) / scale.width;
                                moved = false;
                                canvas.setPointerCapture(downEvent.pointerId);
                                canvas.onpointermove = function (moveEvent) {
                                    if (!downEvent.isPrimary || gestureScale !== 1) {
                                        return;
                                    }
                                    var movedX = startX - moveEvent.clientX;
                                    var movedValue = movedX * xToVal;
                                    moved = moved || Math.abs(movedX) > 8;
                                    _this.pan(scale, movedValue, min, max);
                                };
                            }
                        };
                        canvas.onpointerup = canvas.onpointercancel = function (upEvent) {
                            if (canvas.onpointermove) {
                                canvas.onpointermove = null;
                                canvas.releasePointerCapture(upEvent.pointerId);
                            }
                            if (!moved && upEvent.isPrimary) {
                                _this.click(upEvent);
                            }
                        };
                        canvas.ongesturestart = function (event) {
                            gestureScale = 1;
                            event.preventDefault();
                        };
                        canvas.ongestureend = function (event) {
                            gestureScale = 1;
                        };
                        canvas.ongesturechange = function (event) {
                            var chart = _this.chart;
                            var chartArea = chart.chartArea;
                            var pos = chart_js__WEBPACK_IMPORTED_MODULE_0___default.a.helpers.getRelativePosition(event, chart);
                            if (pos.x > chartArea.left) {
                                var scale = _this.chartScales[X_AXIS_SECONDS];
                                var amount = event.scale - gestureScale;
                                _this.zoom(scale, pos, amount);
                                gestureScale = event.scale;
                            }
                        };
                    }
                    var _proto = TimelineChart.prototype;
                    _proto.click = function click(event) {
                        var chart = this.chart;
                        var element = chart.getElementAtEvent(event);
                        if (element.length && chart.data.datasets) {
                            var _self$hls;
                            var dataset = chart.data.datasets[element[0]._datasetIndex];
                            var obj = dataset.data[element[0]._index];
                            console.log(obj);
                            if ((_self$hls = self.hls) !== null && _self$hls !== void 0 && _self$hls.media) {
                                var scale = this.chartScales[X_AXIS_SECONDS];
                                var pos = chart_js__WEBPACK_IMPORTED_MODULE_0___default.a.helpers.getRelativePosition(event, chart);
                                self.hls.media.currentTime = scale.getValueForPixel(pos.x);
                            }
                        }
                    };
                    _proto.pan = function pan(scale, amount, min, max) {
                        if (amount === 0) {
                            return;
                        }
                        var pan = amount;
                        if (amount > 0) {
                            pan = Math.min(this.zoom100 + 10 - max, amount);
                        } else {
                            pan = Math.max(-10 - min, amount);
                        }
                        scale.options.ticks.min = min + pan;
                        scale.options.ticks.max = max + pan;
                        this.updateOnRepaint();
                    };
                    _proto.zoom = function zoom(scale, pos, amount) {
                        var range = scale.max - scale.min;
                        var diff = range * amount;
                        var minPercent = (scale.getValueForPixel(pos.x) - scale.min) / range;
                        var maxPercent = 1 - minPercent;
                        var minDelta = diff * minPercent;
                        var maxDelta = diff * maxPercent;
                        scale.options.ticks.min = Math.max(-10, scale.min + minDelta);
                        scale.options.ticks.max = Math.min(this.zoom100 + 10, scale.max - maxDelta);
                        this.updateOnRepaint();
                    };
                    _proto.reset = function reset() {
                        var scale = this.chartScales[X_AXIS_SECONDS];
                        scale.options.ticks.min = 0;
                        scale.options.ticks.max = 60;
                        var _this$chart$data = this.chart.data,
                            labels = _this$chart$data.labels,
                            datasets = _this$chart$data.datasets;
                        if (labels && datasets) {
                            labels.length = 0;
                            datasets.length = 0;
                            this.resize(datasets);
                        }
                    };
                    _proto.update = function update() {
                        var _this$chart$ctx;
                        if (this.hidden || !((_this$chart$ctx = this.chart.ctx) !== null && _this$chart$ctx !== void 0 && _this$chart$ctx.canvas.width)) {
                            return;
                        }
                        self.cancelAnimationFrame(this.rafDebounceRequestId);
                        this.chart.update({ duration: 0, lazy: true });
                    };
                    _proto.updateOnRepaint = function updateOnRepaint() {
                        var _this2 = this;
                        if (this.hidden) {
                            return;
                        }
                        self.cancelAnimationFrame(this.rafDebounceRequestId);
                        this.rafDebounceRequestId = self.requestAnimationFrame(function () {
                            return _this2.update();
                        });
                    };
                    _proto.resize = function resize(datasets) {
                        var _this3 = this;
                        if (this.hidden) {
                            return;
                        }
                        if (datasets !== null && datasets !== void 0 && datasets.length) {
                            var _this$chart$canvas;
                            var scale = this.chartScales[X_AXIS_SECONDS];
                            var top = this.chart.chartArea.top;
                            var height =
                                top +
                                datasets.reduce(function (val, dataset) {
                                    return val + dataset.barThickness;
                                }, 0) +
                                scale.height +
                                5;
                            var container = (_this$chart$canvas = this.chart.canvas) === null || _this$chart$canvas === void 0 ? void 0 : _this$chart$canvas.parentElement;
                            if (container) {
                                container.style.height = height + "px";
                            }
                        }
                        self.cancelAnimationFrame(this.rafDebounceRequestId);
                        this.rafDebounceRequestId = self.requestAnimationFrame(function () {
                            _this3.chart.resize();
                        });
                    };
                    _proto.show = function show() {
                        this.hidden = false;
                    };
                    _proto.hide = function hide() {
                        this.hidden = true;
                    };
                    _proto.updateLevels = function updateLevels(levels, levelSwitched) {
                        var _this4 = this;
                        var _this$chart$data2 = this.chart.data,
                            labels = _this$chart$data2.labels,
                            datasets = _this$chart$data2.datasets;
                        if (!labels || !datasets) {
                            return;
                        }
                        var _self$hls2 = self.hls,
                            loadLevel = _self$hls2.loadLevel,
                            nextLoadLevel = _self$hls2.nextLoadLevel,
                            nextAutoLevel = _self$hls2.nextAutoLevel;
                        var currentLevel = levelSwitched !== undefined ? levelSwitched : self.hls.currentLevel;
                        levels.forEach(function (level, i) {
                            var index = level.id || i;
                            labels.push(getLevelName(level, index));
                            var borderColor = null;
                            if (currentLevel === i) {
                                borderColor = "rgba(32, 32, 240, 1.0)";
                            } else if (loadLevel === i) {
                                borderColor = "rgba(255, 128, 0, 1.0)";
                            } else if (nextLoadLevel === i) {
                                borderColor = "rgba(200, 200, 64, 1.0)";
                            } else if (nextAutoLevel === i) {
                                borderColor = "rgba(160, 0, 160, 1.0)";
                            }
                            datasets.push(datasetWithDefaults({ url: Array.isArray(level.url) ? level.url[level.urlId || 0] : level.url, trackType: "level", borderColor: borderColor, level: index }));
                            if (level.details) {
                                _this4.updateLevelOrTrack(level.details);
                            }
                        });
                        this.resize(datasets);
                    };
                    _proto.updateAudioTracks = function updateAudioTracks(audioTracks) {
                        var _this5 = this;
                        var _this$chart$data3 = this.chart.data,
                            labels = _this$chart$data3.labels,
                            datasets = _this$chart$data3.datasets;
                        if (!labels || !datasets) {
                            return;
                        }
                        var audioTrack = self.hls.audioTrack;
                        audioTracks.forEach(function (track, i) {
                            labels.push(getAudioTrackName(track, i));
                            datasets.push(datasetWithDefaults({ url: track.url, trackType: "audioTrack", borderColor: audioTrack === i ? "rgba(32, 32, 240, 1.0)" : null, audioTrack: i }));
                            if (track.details) {
                                _this5.updateLevelOrTrack(track.details);
                            }
                        });
                        this.resize(datasets);
                    };
                    _proto.updateSubtitleTracks = function updateSubtitleTracks(subtitles) {
                        var _this6 = this;
                        var _this$chart$data4 = this.chart.data,
                            labels = _this$chart$data4.labels,
                            datasets = _this$chart$data4.datasets;
                        if (!labels || !datasets) {
                            return;
                        }
                        var subtitleTrack = self.hls.subtitleTrack;
                        subtitles.forEach(function (track, i) {
                            labels.push(getSubtitlesName(track, i));
                            datasets.push(datasetWithDefaults({ url: track.url, trackType: "subtitleTrack", borderColor: subtitleTrack === i ? "rgba(32, 32, 240, 1.0)" : null, subtitleTrack: i }));
                            if (track.details) {
                                _this6.updateLevelOrTrack(track.details);
                            }
                        });
                        this.resize(datasets);
                    };
                    _proto.removeType = function removeType(trackType) {
                        var _this$chart$data5 = this.chart.data,
                            labels = _this$chart$data5.labels,
                            datasets = _this$chart$data5.datasets;
                        if (!labels || !datasets) {
                            return;
                        }
                        var i = datasets.length;
                        while (i--) {
                            if (datasets[i].trackType === trackType) {
                                datasets.splice(i, 1);
                                labels.splice(i, 1);
                            }
                        }
                    };
                    _proto.updateLevelOrTrack = function updateLevelOrTrack(details) {
                        var targetduration = details.targetduration,
                            totalduration = details.totalduration,
                            url = details.url;
                        var datasets = this.chart.data.datasets;
                        var levelDataSet = arrayFind(datasets, function (dataset) {
                            return stripDeliveryDirectives(url) === stripDeliveryDirectives(dataset.url || "");
                        });
                        if (!levelDataSet) {
                            levelDataSet = arrayFind(datasets, function (dataset) {
                                var _details$fragments$;
                                return ((_details$fragments$ = details.fragments[0]) === null || _details$fragments$ === void 0 ? void 0 : _details$fragments$.level) === dataset.level;
                            });
                        }
                        if (!levelDataSet) {
                            return;
                        }
                        var data = levelDataSet.data;
                        data.length = 0;
                        if (details.fragments) {
                            details.fragments.forEach(function (fragment) {
                                var chartFragment = _extends({ dataType: "fragment" }, fragment, { loader: null });
                                data.push(chartFragment);
                            });
                        }
                        if (details.partList) {
                            details.partList.forEach(function (part) {
                                var chartPart = _extends({ dataType: "part", start: part.fragment.start + part.fragOffset }, part, { fragment: _extends({}, part.fragment, { loader: null }) });
                                data.push(chartPart);
                            });
                            if (details.fragmentHint) {
                                var chartFragment = _extends({ dataType: "fragmentHint" }, details.fragmentHint, { loader: null });
                                data.push(chartFragment);
                            }
                        }
                        var start = getPlaylistStart(details);
                        this.maxZoom = this.zoom100 = Math.max(start + totalduration + targetduration * 3, this.zoom100);
                        this.updateOnRepaint();
                    };
                    _proto.updateFragment = function updateFragment(data) {
                        var datasets = this.chart.data.datasets;
                        var frag = data.frag;
                        var levelDataSet = arrayFind(datasets, function (dataset) {
                            return frag.baseurl === dataset.url;
                        });
                        if (!levelDataSet) {
                            levelDataSet = arrayFind(datasets, function (dataset) {
                                return frag.level === dataset.level;
                            });
                        }
                        if (!levelDataSet) {
                            return;
                        }
                        var fragData = arrayFind(levelDataSet.data, function (fragData) {
                            return fragData.relurl === frag.relurl && fragData.sn === frag.sn;
                        });
                        if (fragData && fragData !== frag) {
                            _extends(fragData, frag);
                        }
                        this.updateOnRepaint();
                    };
                    _proto.updateSourceBuffers = function updateSourceBuffers(tracks, media) {
                        var _this7 = this;
                        var _this$chart$data6 = this.chart.data,
                            labels = _this$chart$data6.labels,
                            datasets = _this$chart$data6.datasets;
                        if (!labels || !datasets) {
                            return;
                        }
                        var trackTypes = Object.keys(tracks).sort(function (type) {
                            return type === "video" ? 1 : -1;
                        });
                        var mediaBufferData = [];
                        this.removeSourceBuffers();
                        this.media = media;
                        trackTypes.forEach(function (type) {
                            var track = tracks[type];
                            var data = [];
                            var sourceBuffer = track.buffer;
                            var backgroundColor = { video: "rgba(0, 0, 255, 0.2)", audio: "rgba(128, 128, 0, 0.2)", audiovideo: "rgba(128, 128, 255, 0.2)" }[type];
                            labels.unshift(type + " buffer (" + track.id + ")");
                            datasets.unshift(datasetWithDefaults({ data: data, categoryPercentage: 0.5, backgroundColor: backgroundColor, sourceBuffer: sourceBuffer }));
                            sourceBuffer.addEventListener("update", function () {
                                try {
                                    replaceTimeRangeTuples(sourceBuffer.buffered, data);
                                } catch (error) {
                                    console.warn(error);
                                    return;
                                }
                                replaceTimeRangeTuples(media.buffered, mediaBufferData);
                                _this7.update();
                            });
                        });
                        if (trackTypes.length === 0) {
                            media.onprogress = function () {
                                replaceTimeRangeTuples(media.buffered, mediaBufferData);
                                _this7.update();
                            };
                        }
                        labels.unshift("media buffer");
                        datasets.unshift(datasetWithDefaults({ data: mediaBufferData, categoryPercentage: 0.5, backgroundColor: "rgba(0, 255, 0, 0.2)", media: media }));
                        media.ontimeupdate = function () {
                            return _this7.drawCurrentTime();
                        };
                        var textTracks = media.textTracks;
                        this.tracksChangeHandler =
                            this.tracksChangeHandler ||
                            function (e) {
                                return _this7.setTextTracks(e.currentTarget);
                            };
                        textTracks.removeEventListener("addtrack", this.tracksChangeHandler);
                        textTracks.removeEventListener("removetrack", this.tracksChangeHandler);
                        textTracks.removeEventListener("change", this.tracksChangeHandler);
                        textTracks.addEventListener("addtrack", this.tracksChangeHandler);
                        textTracks.addEventListener("removetrack", this.tracksChangeHandler);
                        textTracks.addEventListener("change", this.tracksChangeHandler);
                        this.setTextTracks(textTracks);
                        this.resize(datasets);
                    };
                    _proto.removeSourceBuffers = function removeSourceBuffers() {
                        var _this$chart$data7 = this.chart.data,
                            labels = _this$chart$data7.labels,
                            datasets = _this$chart$data7.datasets;
                        if (!labels || !datasets) {
                            return;
                        }
                        var i = datasets.length;
                        while (i--) {
                            if ((labels[0] || "").toString().indexOf("buffer") > -1) {
                                datasets.splice(i, 1);
                                labels.splice(i, 1);
                            }
                        }
                    };
                    _proto.setTextTracks = function setTextTracks(textTracks) {
                        var _this8 = this;
                        var _this$chart$data8 = this.chart.data,
                            labels = _this$chart$data8.labels,
                            datasets = _this$chart$data8.datasets;
                        if (!labels || !datasets) {
                            return;
                        }
                        this.removeType("textTrack");
                        [].forEach.call(textTracks, function (textTrack, i) {
                            var data = [];
                            labels.push((textTrack.name || textTrack.label) + " " + textTrack.kind + " (" + textTrack.mode + ")");
                            datasets.push(datasetWithDefaults({ data: data, categoryPercentage: 0.5, url: "", trackType: "textTrack", borderColor: (textTrack.mode !== "hidden") === i ? "rgba(32, 32, 240, 1.0)" : null, textTrack: i }));
                            _this8.cuesChangeHandler =
                                _this8.cuesChangeHandler ||
                                function (e) {
                                    return _this8.updateTextTrackCues(e.currentTarget);
                                };
                            textTrack._data = data;
                            textTrack.removeEventListener("cuechange", _this8.cuesChangeHandler);
                            textTrack.addEventListener("cuechange", _this8.cuesChangeHandler);
                            _this8.updateTextTrackCues(textTrack);
                        });
                        this.resize(datasets);
                    };
                    _proto.updateTextTrackCues = function updateTextTrackCues(textTrack) {
                        var data = textTrack._data;
                        if (!data) {
                            return;
                        }
                        var activeCues = textTrack.activeCues,
                            cues = textTrack.cues;
                        data.length = 0;
                        if (!cues) {
                            return;
                        }
                        var length = cues.length;
                        var activeLength = 0;
                        var activeMin = Infinity;
                        var activeMax = 0;
                        if (activeCues) {
                            activeLength = activeCues.length;
                            for (var i = 0; i < activeLength; i++) {
                                var cue = activeCues[i];
                                if (!cue && activeCues.item) {
                                    cue = activeCues.item(i);
                                }
                                if (cue) {
                                    activeMin = Math.min(activeMin, cue.startTime);
                                    activeMax = cue.endTime ? Math.max(activeMax, cue.endTime) : activeMax;
                                } else {
                                    activeLength--;
                                }
                            }
                        }
                        var _loop = function _loop(_i) {
                            var cue = cues[_i];
                            if (!cue && cues.item) {
                                cue = cues.item(_i);
                            }
                            if (!cue) {
                                return "continue";
                            }
                            var start = cue.startTime;
                            var end = cue.endTime;
                            var content = getCueLabel(cue);
                            var active = false;
                            if (activeLength && end >= activeMin && start <= activeMax) {
                                active = [].some.call(activeCues, function (activeCue) {
                                    return cuesMatch(activeCue, cue);
                                });
                            }
                            data.push({ start: start, end: end, content: content, active: active, dataType: "cue" });
                        };
                        for (var _i = 0; _i < length; _i++) {
                            var _ret = _loop(_i);
                            if (_ret === "continue") continue;
                        }
                        this.updateOnRepaint();
                    };
                    _proto.drawCurrentTime = function drawCurrentTime() {
                        var _self$hls3;
                        var chart = this.chart;
                        if ((_self$hls3 = self.hls) !== null && _self$hls3 !== void 0 && _self$hls3.media && chart.data.datasets.length) {
                            var currentTime = self.hls.media.currentTime;
                            var scale = this.chartScales[X_AXIS_SECONDS];
                            var ctx = chart.ctx;
                            if (this.hidden || !ctx || !ctx.canvas.width) {
                                return;
                            }
                            var chartArea = chart.chartArea;
                            var x = scale.getPixelForValue(currentTime);
                            ctx.restore();
                            ctx.save();
                            this.drawLineX(ctx, x, chartArea);
                            if (x > chartArea.left && x < chartArea.right) {
                                ctx.fillStyle = this.getCurrentTimeColor(self.hls.media);
                                var y = chartArea.top + chart.data.datasets[0].barThickness + 1;
                                ctx.fillText(Object(_chartjs_horizontal_bar__WEBPACK_IMPORTED_MODULE_1__["hhmmss"])(currentTime, 5), x + 2, y, 100);
                            }
                            ctx.restore();
                        }
                    };
                    _proto.getCurrentTimeColor = function getCurrentTimeColor(video) {
                        if (!video.readyState || video.ended) {
                            return "rgba(0, 0, 0, 0.9)";
                        }
                        if (video.seeking || video.readyState < 3) {
                            return "rgba(255, 128, 0, 0.9)";
                        }
                        if (video.paused) {
                            return "rgba(128, 0, 255, 0.9)";
                        }
                        return "rgba(0, 0, 255, 0.9)";
                    };
                    _proto.drawLineX = function drawLineX(ctx, x, chartArea) {
                        if (!this.imageDataBuffer) {
                            var devicePixelRatio = self.devicePixelRatio || 1;
                            this.imageDataBuffer = ctx.getImageData(0, 0, chartArea.right * devicePixelRatio, chartArea.bottom * devicePixelRatio);
                        } else {
                            ctx.fillStyle = "#ffffff";
                            ctx.fillRect(0, 0, chartArea.right, chartArea.bottom);
                            ctx.putImageData(this.imageDataBuffer, 0, 0);
                        }
                        if (x > chartArea.left && x < chartArea.right) {
                            ctx.lineWidth = 1;
                            ctx.strokeStyle = this.getCurrentTimeColor(self.hls.media);
                            ctx.beginPath();
                            ctx.moveTo(x, chartArea.top);
                            ctx.lineTo(x, chartArea.bottom);
                            ctx.stroke();
                        }
                    };
                    _createClass(TimelineChart, [
                        {
                            key: "chartScales",
                            get: function get() {
                                return this.chart.scales;
                            },
                        },
                        {
                            key: "minZoom",
                            get: function get() {
                                var scale = this.chartScales[X_AXIS_SECONDS];
                                if (scale) {
                                    return scale.options.ticks.min;
                                }
                                return 1;
                            },
                        },
                        {
                            key: "maxZoom",
                            get: function get() {
                                var scale = this.chartScales[X_AXIS_SECONDS];
                                if (scale) {
                                    return scale.options.ticks.max;
                                }
                                return this.zoom100;
                            },
                            set: function set(x) {
                                var currentZoom = this.maxZoom;
                                var newZoom = Math.max(x, currentZoom);
                                if (currentZoom === 60 && newZoom !== currentZoom) {
                                    var scale = this.chartScales[X_AXIS_SECONDS];
                                    scale.options.ticks.max = newZoom;
                                }
                            },
                        },
                    ]);
                    return TimelineChart;
                })();
                function stripDeliveryDirectives(url) {
                    if (url === "") {
                        return url;
                    }
                    try {
                        var webUrl = new self.URL(url);
                        webUrl.searchParams.delete("_HLS_msn");
                        webUrl.searchParams.delete("_HLS_part");
                        webUrl.searchParams.delete("_HLS_skip");
                        webUrl.searchParams.sort();
                        return webUrl.href;
                    } catch (e) {
                        return url.replace(/[?&]_HLS_(?:msn|part|skip)=[^?&]+/g, "");
                    }
                }
                function datasetWithDefaults(options) {
                    return _extends({ data: [], xAxisID: X_AXIS_SECONDS, barThickness: 35, categoryPercentage: 1 }, options);
                }
                function getPlaylistStart(details) {
                    var _details$fragments;
                    return (_details$fragments = details.fragments) !== null && _details$fragments !== void 0 && _details$fragments.length ? details.fragments[0].start : 0;
                }
                function getLevelName(level, index) {
                    var _level$attrs;
                    var label = "(main playlist)";
                    if ((_level$attrs = level.attrs) !== null && _level$attrs !== void 0 && _level$attrs.BANDWIDTH) {
                        label = getMainLevelAttribute(level) + "@" + level.attrs.BANDWIDTH;
                        if (level.name) {
                            label = label + " (" + level.name + ")";
                        }
                    } else if (level.name) {
                        label = level.name;
                    }
                    return label + " L-" + index;
                }
                function getMainLevelAttribute(level) {
                    return level.attrs.RESOLUTION || level.attrs.CODECS || level.attrs.AUDIO;
                }
                function getAudioTrackName(track, index) {
                    var label = track.lang ? track.name + "/" + track.lang : track.name;
                    return label + " (" + (track.groupId || track.attrs["GROUP-ID"]) + ") A-" + index;
                }
                function getSubtitlesName(track, index) {
                    var label = track.lang ? track.name + "/" + track.lang : track.name;
                    return label + " (" + (track.groupId || track.attrs["GROUP-ID"]) + ") S-" + index;
                }
                function replaceTimeRangeTuples(timeRanges, data) {
                    data.length = 0;
                    var length = timeRanges.length;
                    for (var i = 0; i < length; i++) {
                        data.push([timeRanges.start(i), timeRanges.end(i)]);
                    }
                }
                function cuesMatch(cue1, cue2) {
                    return cue1.startTime === cue2.startTime && cue1.endTime === cue2.endTime && cue1.text === cue2.text && cue1.data === cue2.data && JSON.stringify(cue1.value) === JSON.stringify(cue2.value);
                }
                function getCueLabel(cue) {
                    if (cue.text) {
                        return cue.text;
                    }
                    var result = parseDataCue(cue);
                    return JSON.stringify(result);
                }
                function parseDataCue(cue) {
                    var data = {};
                    var value = cue.value;
                    if (value) {
                        if (value.info) {
                            var collection = data[value.key];
                            if (collection !== Object(collection)) {
                                collection = {};
                                data[value.key] = collection;
                            }
                            collection[value.info] = value.data;
                        } else {
                            data[value.key] = value.data;
                        }
                    }
                    return data;
                }
                function getChartOptions() {
                    return {
                        animation: { duration: 0 },
                        elements: { rectangle: { borderWidth: 1, borderColor: "rgba(20, 20, 20, 1)" } },
                        events: ["click", "touchstart"],
                        hover: { mode: null, animationDuration: 0 },
                        legend: { display: false },
                        maintainAspectRatio: false,
                        responsiveAnimationDuration: 0,
                        scales: {
                            xAxes: [
                                {
                                    id: X_AXIS_SECONDS,
                                    ticks: {
                                        beginAtZero: true,
                                        sampleSize: 0,
                                        maxRotation: 0,
                                        callback: function callback(tickValue, i, ticks) {
                                            if (i === 0 || i === ticks.length - 1) {
                                                return tickValue ? "" : "0";
                                            } else {
                                                return Object(_chartjs_horizontal_bar__WEBPACK_IMPORTED_MODULE_1__["hhmmss"])(tickValue, 2);
                                            }
                                        },
                                    },
                                },
                            ],
                            yAxes: [{ gridLines: { display: false } }],
                        },
                        tooltips: { enabled: false },
                    };
                }
                function arrayFind(array, predicate) {
                    var len = array.length >>> 0;
                    if (typeof predicate !== "function") {
                        throw TypeError("predicate must be a function");
                    }
                    var thisArg = arguments[2];
                    var k = 0;
                    while (k < len) {
                        var kValue = array[k];
                        if (predicate.call(thisArg, kValue, k, array)) {
                            return kValue;
                        }
                        k++;
                    }
                    return undefined;
                }
            },
            "./demo/demo-utils.js": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "sortObject", function () {
                    return sortObject;
                });
                __webpack_require__.d(__webpack_exports__, "copyTextToClipboard", function () {
                    return copyTextToClipboard;
                });
                function sortObject(obj) {
                    if (typeof obj !== "object") {
                        return obj;
                    }
                    var temp = {};
                    var keys = [];
                    for (var key in obj) {
                        keys.push(key);
                    }
                    keys.sort();
                    for (var index in keys) {
                        temp[keys[index]] = sortObject(obj[keys[index]]);
                    }
                    return temp;
                }
                function copyTextToClipboard(text) {
                    var textArea = document.createElement("textarea");
                    textArea.value = text;
                    document.body.appendChild(textArea);
                    textArea.select();
                    try {
                        var successful = document.execCommand("copy");
                        var msg = successful ? "successful" : "unsuccessful";
                        console.log("Copying text command was " + msg);
                    } catch (err) {
                        console.log("Oops, unable to copy");
                    }
                    document.body.removeChild(textArea);
                }
            },
            "./demo/main.js": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var jsonpack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/jsonpack/main.js");
                var jsonpack__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(jsonpack__WEBPACK_IMPORTED_MODULE_0__);
                var promise_polyfill_src_polyfill__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/promise-polyfill/src/polyfill.js");
                var _demo_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./demo/demo-utils.js");
                var _chart_timeline_chart__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("./demo/chart/timeline-chart.ts");
                var NETLIFY = {};
                var STORAGE_KEYS = { Editor_Persistence: "hlsjs:config-editor-persist", Hls_Config: "hlsjs:config", volume: "hlsjs:volume", demo_tabs: "hlsjs:demo-tabs" };
                var testStreams = __webpack_require__("./tests/test-streams.js");
                var defaultTestStreamUrl = testStreams[Object.keys(testStreams)[0]].url;
                var sourceURL = decodeURIComponent(getURLParam("src", defaultTestStreamUrl));
                var demoConfig = getURLParam("demoConfig", null);
                if (demoConfig) {
                    demoConfig = JSON.parse(atob(demoConfig));
                } else {
                    demoConfig = {};
                }
                var hlsjsDefaults = { debug: true, enableWorker: true, lowLatencyMode: true, backBufferLength: 60 * 1.5 };
                var enableStreaming = getDemoConfigPropOrDefault("enableStreaming", true);
                var autoRecoverError = getDemoConfigPropOrDefault("autoRecoverError", true);
                var levelCapping = getDemoConfigPropOrDefault("levelCapping", -1);
                var limitMetrics = getDemoConfigPropOrDefault("limitMetrics", -1);
                var dumpfMP4 = getDemoConfigPropOrDefault("dumpfMP4", false);
                var stopOnStall = getDemoConfigPropOrDefault("stopOnStall", false);
                var bufferingIdx = -1;
                var selectedTestStream = null;
                var video = document.querySelector("#video");
                var startTime = Date.now();
                var lastSeekingIdx;
                var lastStartPosition;
                var lastDuration;
                var lastAudioTrackSwitchingIdx;
                var hls;
                var url;
                var events;
                var stats;
                var tracks;
                var fmp4Data;
                var configPersistenceEnabled = false;
                var configEditor = null;
                var chart;
                var resizeAsyncCallbackId = -1;
                var requestAnimationFrame = self.requestAnimationFrame || self.setTimeout;
                var cancelAnimationFrame = self.cancelAnimationFrame || self.clearTimeout;
                var resizeHandlers = [];
                var resize = function resize() {
                    cancelAnimationFrame(resizeAsyncCallbackId);
                    resizeAsyncCallbackId = requestAnimationFrame(function () {
                        resizeHandlers.forEach(function (handler) {
                            handler();
                        });
                    });
                };
                self.onresize = resize;
                if (self.screen && self.screen.orientation) {
                    self.screen.orientation.onchange = resize;
                }
                var playerResize = function playerResize() {
                    var bounds = video.getBoundingClientRect();
                    $("#currentSize").html(Math.round(bounds.width * 10) / 10 + " x " + Math.round(bounds.height * 10) / 10);
                    if (video.videoWidth && video.videoHeight) {
                        $("#currentResolution").html(video.videoWidth + " x " + video.videoHeight);
                    }
                };
                resizeHandlers.push(playerResize);
                $(document).ready(function () {
                    setupConfigEditor();
                    chart = setupTimelineChart();
                    Object.keys(testStreams).forEach(function (key, index) {
                        var stream = testStreams[key];
                        var option = new Option(stream.description, key);
                        $("#streamSelect").append(option);
                        if (stream.url === sourceURL) {
                            document.querySelector("#streamSelect").selectedIndex = index + 1;
                        }
                    });
                    var videoWidth = video.style.width;
                    if (videoWidth) {
                        $("#videoSize option").each(function (i, option) {
                            if (option.value === videoWidth) {
                                document.querySelector("#videoSize").selectedIndex = i;
                                $("#bufferedCanvas").width(videoWidth);
                                resize();
                                return false;
                            }
                        });
                    }
                    $("#streamSelect").change(function () {
                        var key = $("#streamSelect").val() || Object.keys(testStreams)[0];
                        selectedTestStream = testStreams[key];
                        var streamUrl = selectedTestStream.url;
                        $("#streamURL").val(streamUrl);
                        loadSelectedStream();
                    });
                    $("#streamURL").change(function () {
                        selectedTestStream = null;
                        loadSelectedStream();
                    });
                    $("#videoSize").change(function () {
                        $("#video").width($("#videoSize").val());
                        $("#bufferedCanvas").width($("#videoSize").val());
                        checkBuffer();
                        resize();
                    });
                    $("#enableStreaming").click(function () {
                        enableStreaming = this.checked;
                        loadSelectedStream();
                    });
                    $("#autoRecoverError").click(function () {
                        autoRecoverError = this.checked;
                        onDemoConfigChanged();
                    });
                    $("#stopOnStall").click(function () {
                        stopOnStall = this.checked;
                        onDemoConfigChanged();
                    });
                    $("#dumpfMP4").click(function () {
                        dumpfMP4 = this.checked;
                        $(".btn-dump").toggle(dumpfMP4);
                        onDemoConfigChanged();
                    });
                    $("#limitMetrics").change(function () {
                        limitMetrics = this.value;
                        onDemoConfigChanged();
                    });
                    $("#levelCapping").change(function () {
                        levelCapping = this.value;
                        onDemoConfigChanged();
                    });
                    $("#limitMetrics").val(limitMetrics);
                    $("#enableStreaming").prop("checked", enableStreaming);
                    $("#autoRecoverError").prop("checked", autoRecoverError);
                    $("#stopOnStall").prop("checked", stopOnStall);
                    $("#dumpfMP4").prop("checked", dumpfMP4);
                    $("#levelCapping").val(levelCapping);
                    function getVersionLink(version) {
                        var alphaRegex = /[-.]0\.alpha\./;
                        if (alphaRegex.test(version)) {
                            return "https://www.npmjs.com/package/hls.js/v/" + encodeURIComponent(version);
                        } else if (NETLIFY.reviewID) {
                            return "https://github.com/video-dev/hls.js/pull/" + NETLIFY.reviewID;
                        } else if (NETLIFY.branch) {
                            return "https://github.com/video-dev/hls.js/tree/" + encodeURIComponent(NETLIFY.branch);
                        }
                        return "https://github.com/video-dev/hls.js/releases/tag/v" + encodeURIComponent(version);
                    }
                    var version = Hls.version;
                    if (version) {
                        var $a = $("<a />")
                            .attr("target", "_blank")
                            .attr("rel", "noopener noreferrer")
                            .attr("href", getVersionLink(version))
                            .text("v" + version);
                        $(".title").append(" ").append($a);
                    }
                    $("#streamURL").val(sourceURL);
                    var volumeSettings = JSON.parse(localStorage.getItem(STORAGE_KEYS.volume)) || { volume: 0.05, muted: false };
                    video.volume = volumeSettings.volume;
                    video.muted = volumeSettings.muted;
                    $(".btn-dump").toggle(dumpfMP4);
                    $("#toggleButtons").show();
                    $("#metricsButtonWindow").toggle(self.windowSliding);
                    $("#metricsButtonFixed").toggle(!self.windowSliding);
                    loadSelectedStream();
                    var tabIndexesCSV = localStorage.getItem(STORAGE_KEYS.demo_tabs);
                    if (tabIndexesCSV === null) {
                        tabIndexesCSV = "0,1,2";
                    }
                    if (tabIndexesCSV) {
                        tabIndexesCSV.split(",").forEach(function (indexString) {
                            toggleTab($(".demo-tab-btn")[parseInt(indexString) || 0], true);
                        });
                    }
                    $(window).on("popstate", function () {
                        window.location.reload();
                    });
                });
                function setupGlobals() {
                    self.events = events = { url: url, t0: self.performance.now(), load: [], buffer: [], video: [], level: [], bitrate: [] };
                    lastAudioTrackSwitchingIdx = undefined;
                    lastSeekingIdx = undefined;
                    bufferingIdx = -1;
                    self.recoverDecodingErrorDate = null;
                    self.recoverSwapAudioCodecDate = null;
                    self.fmp4Data = fmp4Data = { audio: [], video: [] };
                    self.onClickBufferedRange = onClickBufferedRange;
                    self.updateLevelInfo = updateLevelInfo;
                    self.onDemoConfigChanged = onDemoConfigChanged;
                    self.createfMP4 = createfMP4;
                    self.goToMetricsPermaLink = goToMetricsPermaLink;
                    self.toggleTab = toggleTab;
                    self.toggleTabClick = toggleTabClick;
                    self.applyConfigEditorValue = applyConfigEditorValue;
                }
                function trimArray(target, limit) {
                    if (limit < 0) {
                        return;
                    }
                    while (target.length > limit) {
                        target.shift();
                    }
                }
                function trimEventHistory() {
                    var x = limitMetrics;
                    if (x < 0) {
                        return;
                    }
                    trimArray(events.load, x);
                    trimArray(events.buffer, x);
                    trimArray(events.video, x);
                    trimArray(events.level, x);
                    trimArray(events.bitrate, x);
                }
                function loadSelectedStream() {
                    $("#statusOut,#errorOut").empty();
                    if (!Hls.isSupported()) {
                        handleUnsupported();
                        return;
                    }
                    url = $("#streamURL").val();
                    setupGlobals();
                    hideCanvas();
                    if (hls) {
                        hls.destroy();
                        clearInterval(hls.bufferTimer);
                        hls = null;
                    }
                    if (!enableStreaming) {
                        logStatus("Streaming disabled");
                        return;
                    }
                    logStatus("Loading " + url);
                    var hlsConfig = $.extend({}, hlsjsDefaults, getEditorValue({ parse: true }));
                    if (selectedTestStream && selectedTestStream.config) {
                        console.info("[loadSelectedStream] extending hls config with stream-specific config: ", selectedTestStream.config);
                        $.extend(hlsConfig, selectedTestStream.config);
                        updateConfigEditorValue(hlsConfig);
                    }
                    onDemoConfigChanged(true);
                    console.log("Using Hls.js config:", hlsConfig);
                    self.hls = hls = new Hls(hlsConfig);
                    logStatus("Loading manifest and attaching video element...");
                    var expiredTracks = [].filter.call(video.textTracks, function (track) {
                        return track.kind !== "metadata";
                    });
                    if (expiredTracks.length) {
                        var kinds = expiredTracks
                            .map(function (track) {
                                return track.kind;
                            })
                            .filter(function (kind, index, self) {
                                return self.indexOf(kind) === index;
                            });
                        logStatus("Replacing video element to remove " + kinds.join(" and ") + " text tracks");
                        var videoWithExpiredTextTracks = video;
                        video = videoWithExpiredTextTracks.cloneNode(false);
                        video.removeAttribute("src");
                        video.volume = videoWithExpiredTextTracks.volume;
                        video.muted = videoWithExpiredTextTracks.muted;
                        videoWithExpiredTextTracks.parentNode.insertBefore(video, videoWithExpiredTextTracks);
                        videoWithExpiredTextTracks.parentNode.removeChild(videoWithExpiredTextTracks);
                    }
                    addChartEventListeners(hls);
                    addVideoEventListeners(video);
                    hls.loadSource(url);
                    hls.autoLevelCapping = levelCapping;
                    hls.attachMedia(video);
                    hls.on(Hls.Events.MEDIA_ATTACHED, function () {
                        logStatus("Media element attached");
                        bufferingIdx = -1;
                        events.video.push({ time: self.performance.now() - events.t0, type: "Media attached" });
                        trimEventHistory();
                    });
                    hls.on(Hls.Events.MEDIA_DETACHED, function () {
                        logStatus("Media element detached");
                        clearInterval(hls.bufferTimer);
                        bufferingIdx = -1;
                        tracks = [];
                        events.video.push({ time: self.performance.now() - events.t0, type: "Media detached" });
                        trimEventHistory();
                    });
                    hls.on(Hls.Events.DESTROYING, function () {
                        clearInterval(hls.bufferTimer);
                    });
                    hls.on(Hls.Events.BUFFER_RESET, function () {
                        clearInterval(hls.bufferTimer);
                    });
                    hls.on(Hls.Events.FRAG_PARSING_INIT_SEGMENT, function (eventName, data) {
                        showCanvas();
                        events.video.push({ time: self.performance.now() - events.t0, type: data.id + " init segment" });
                        trimEventHistory();
                    });
                    hls.on(Hls.Events.FRAG_PARSING_METADATA, function (eventName, data) {});
                    hls.on(Hls.Events.LEVEL_SWITCHING, function (eventName, data) {
                        events.level.push({ time: self.performance.now() - events.t0, id: data.level, bitrate: Math.round(hls.levels[data.level].bitrate / 1e3) });
                        trimEventHistory();
                        updateLevelInfo();
                    });
                    hls.on(Hls.Events.MANIFEST_PARSED, function (eventName, data) {
                        events.load.push({
                            type: "manifest",
                            name: "",
                            start: 0,
                            end: data.levels.length,
                            time: data.stats.loading.start - events.t0,
                            latency: data.stats.loading.first - data.stats.loading.start,
                            load: data.stats.loading.end - data.stats.loading.first,
                            duration: data.stats.loading.end - data.stats.loading.first,
                        });
                        trimEventHistory();
                        self.refreshCanvas();
                    });
                    hls.on(Hls.Events.MANIFEST_PARSED, function (eventName, data) {
                        logStatus(hls.levels.length + " quality levels found");
                        logStatus("Manifest successfully loaded");
                        stats = { levelNb: data.levels.length, levelParsed: 0 };
                        trimEventHistory();
                        updateLevelInfo();
                    });
                    hls.on(Hls.Events.AUDIO_TRACKS_UPDATED, function (eventName, data) {
                        logStatus("No of audio tracks found: " + data.audioTracks.length);
                        updateAudioTrackInfo();
                    });
                    hls.on(Hls.Events.AUDIO_TRACK_SWITCHING, function (eventName, data) {
                        logStatus("Audio track switching...");
                        updateAudioTrackInfo();
                        events.video.push({ time: self.performance.now() - events.t0, type: "audio switching", name: "@" + data.id });
                        trimEventHistory();
                        lastAudioTrackSwitchingIdx = events.video.length - 1;
                    });
                    hls.on(Hls.Events.AUDIO_TRACK_SWITCHED, function (eventName, data) {
                        logStatus("Audio track switched");
                        updateAudioTrackInfo();
                        var event = { time: self.performance.now() - events.t0, type: "audio switched", name: "@" + data.id };
                        if (lastAudioTrackSwitchingIdx !== undefined) {
                            events.video[lastAudioTrackSwitchingIdx].duration = event.time - events.video[lastAudioTrackSwitchingIdx].time;
                            lastAudioTrackSwitchingIdx = undefined;
                        }
                        events.video.push(event);
                        trimEventHistory();
                    });
                    hls.on(Hls.Events.LEVEL_LOADED, function (eventName, data) {
                        events.isLive = data.details.live;
                        var event = {
                            type: "level",
                            id: data.level,
                            start: data.details.startSN,
                            end: data.details.endSN,
                            time: data.stats.loading.start - events.t0,
                            latency: data.stats.loading.first - data.stats.loading.start,
                            load: data.stats.loading.end - data.stats.loading.first,
                            parsing: data.stats.parsing.end - data.stats.loading.end,
                            duration: data.stats.loading.end - data.stats.loading.first,
                        };
                        var parsingDuration = data.stats.parsing.end - data.stats.loading.end;
                        if (stats.levelParsed) {
                            this.sumLevelParsingMs += parsingDuration;
                        } else {
                            this.sumLevelParsingMs = parsingDuration;
                        }
                        stats.levelParsed++;
                        stats.levelParsingUs = Math.round((1e3 * this.sumLevelParsingMs) / stats.levelParsed);
                        events.load.push(event);
                        trimEventHistory();
                        self.refreshCanvas();
                    });
                    hls.on(Hls.Events.AUDIO_TRACK_LOADED, function (eventName, data) {
                        events.isLive = data.details.live;
                        var event = {
                            type: "audio track",
                            id: data.id,
                            start: data.details.startSN,
                            end: data.details.endSN,
                            time: data.stats.loading.start - events.t0,
                            latency: data.stats.loading.first - data.stats.loading.start,
                            load: data.stats.loading.end - data.stats.loading.first,
                            parsing: data.stats.parsing.end - data.stats.loading.end,
                            duration: data.stats.loading.end - data.stats.loading.first,
                        };
                        events.load.push(event);
                        trimEventHistory();
                        self.refreshCanvas();
                    });
                    hls.on(Hls.Events.FRAG_BUFFERED, function (eventName, data) {
                        var event = {
                            type: data.frag.type + (data.part ? " part" : " fragment"),
                            id: data.frag.level,
                            id2: data.frag.sn,
                            id3: data.part ? data.part.index : undefined,
                            time: data.stats.loading.start - events.t0,
                            latency: data.stats.loading.first - data.stats.loading.start,
                            load: data.stats.loading.end - data.stats.loading.first,
                            parsing: data.stats.parsing.end - data.stats.loading.end,
                            buffer: data.stats.buffering.end - data.stats.parsing.end,
                            duration: data.stats.buffering.end - data.stats.loading.first,
                            bw: Math.round((8 * data.stats.total) / (data.stats.buffering.end - data.stats.loading.start)),
                            size: data.stats.total,
                        };
                        events.load.push(event);
                        events.bitrate.push({ time: self.performance.now() - events.t0, bitrate: event.bw, duration: data.frag.duration, level: event.id });
                        if (events.buffer.length === 0) {
                            events.buffer.push({ time: 0, buffer: 0, pos: 0 });
                        }
                        clearInterval(hls.bufferTimer);
                        hls.bufferTimer = self.setInterval(checkBuffer, 100);
                        trimEventHistory();
                        self.refreshCanvas();
                        updateLevelInfo();
                        var latency = data.stats.loading.first - data.stats.loading.start;
                        var parsing = data.stats.parsing.end - data.stats.loading.end;
                        var process = data.stats.buffering.end - data.stats.loading.start;
                        var bitrate = Math.round((8 * data.stats.total) / (data.stats.buffering.end - data.stats.loading.first));
                        if (stats.fragBuffered) {
                            stats.fragMinLatency = Math.min(stats.fragMinLatency, latency);
                            stats.fragMaxLatency = Math.max(stats.fragMaxLatency, latency);
                            stats.fragMinProcess = Math.min(stats.fragMinProcess, process);
                            stats.fragMaxProcess = Math.max(stats.fragMaxProcess, process);
                            stats.fragMinKbps = Math.min(stats.fragMinKbps, bitrate);
                            stats.fragMaxKbps = Math.max(stats.fragMaxKbps, bitrate);
                            stats.autoLevelCappingMin = Math.min(stats.autoLevelCappingMin, hls.autoLevelCapping);
                            stats.autoLevelCappingMax = Math.max(stats.autoLevelCappingMax, hls.autoLevelCapping);
                            stats.fragBuffered++;
                        } else {
                            stats.fragMinLatency = stats.fragMaxLatency = latency;
                            stats.fragMinProcess = stats.fragMaxProcess = process;
                            stats.fragMinKbps = stats.fragMaxKbps = bitrate;
                            stats.fragBuffered = 1;
                            stats.fragBufferedBytes = 0;
                            stats.autoLevelCappingMin = stats.autoLevelCappingMax = hls.autoLevelCapping;
                            this.sumLatency = 0;
                            this.sumKbps = 0;
                            this.sumProcess = 0;
                            this.sumParsing = 0;
                        }
                        stats.fraglastLatency = latency;
                        this.sumLatency += latency;
                        stats.fragAvgLatency = Math.round(this.sumLatency / stats.fragBuffered);
                        stats.fragLastProcess = process;
                        this.sumProcess += process;
                        this.sumParsing += parsing;
                        stats.fragAvgProcess = Math.round(this.sumProcess / stats.fragBuffered);
                        stats.fragLastKbps = bitrate;
                        this.sumKbps += bitrate;
                        stats.fragAvgKbps = Math.round(this.sumKbps / stats.fragBuffered);
                        stats.fragBufferedBytes += data.stats.total;
                        stats.fragparsingKbps = Math.round((8 * stats.fragBufferedBytes) / this.sumParsing);
                        stats.fragparsingMs = Math.round(this.sumParsing);
                        stats.autoLevelCappingLast = hls.autoLevelCapping;
                    });
                    hls.on(Hls.Events.LEVEL_SWITCHED, function (eventName, data) {
                        var event = { time: self.performance.now() - events.t0, type: "level switched", name: data.level };
                        events.video.push(event);
                        trimEventHistory();
                        self.refreshCanvas();
                        updateLevelInfo();
                    });
                    hls.on(Hls.Events.FRAG_CHANGED, function (eventName, data) {
                        var event = { time: self.performance.now() - events.t0, type: "frag changed", name: data.frag.sn + " @ " + data.frag.level };
                        events.video.push(event);
                        trimEventHistory();
                        self.refreshCanvas();
                        updateLevelInfo();
                        stats.tagList = data.frag.tagList;
                        var level = data.frag.level;
                        var autoLevel = hls.autoLevelEnabled;
                        if (stats.levelStart === undefined) {
                            stats.levelStart = level;
                        }
                        stats.fragProgramDateTime = data.frag.programDateTime;
                        stats.fragStart = data.frag.start;
                        if (autoLevel) {
                            if (stats.fragChangedAuto) {
                                stats.autoLevelMin = Math.min(stats.autoLevelMin, level);
                                stats.autoLevelMax = Math.max(stats.autoLevelMax, level);
                                stats.fragChangedAuto++;
                                if (this.levelLastAuto && level !== stats.autoLevelLast) {
                                    stats.autoLevelSwitch++;
                                }
                            } else {
                                stats.autoLevelMin = stats.autoLevelMax = level;
                                stats.autoLevelSwitch = 0;
                                stats.fragChangedAuto = 1;
                                this.sumAutoLevel = 0;
                            }
                            this.sumAutoLevel += level;
                            stats.autoLevelAvg = Math.round((1e3 * this.sumAutoLevel) / stats.fragChangedAuto) / 1e3;
                            stats.autoLevelLast = level;
                        } else {
                            if (stats.fragChangedManual) {
                                stats.manualLevelMin = Math.min(stats.manualLevelMin, level);
                                stats.manualLevelMax = Math.max(stats.manualLevelMax, level);
                                stats.fragChangedManual++;
                                if (!this.levelLastAuto && level !== stats.manualLevelLast) {
                                    stats.manualLevelSwitch++;
                                }
                            } else {
                                stats.manualLevelMin = stats.manualLevelMax = level;
                                stats.manualLevelSwitch = 0;
                                stats.fragChangedManual = 1;
                            }
                            stats.manualLevelLast = level;
                        }
                        this.levelLastAuto = autoLevel;
                    });
                    hls.on(Hls.Events.FRAG_LOAD_EMERGENCY_ABORTED, function (eventName, data) {
                        if (stats) {
                            if (stats.fragLoadEmergencyAborted === undefined) {
                                stats.fragLoadEmergencyAborted = 1;
                            } else {
                                stats.fragLoadEmergencyAborted++;
                            }
                        }
                    });
                    hls.on(Hls.Events.FRAG_DECRYPTED, function (eventName, data) {
                        if (!stats.fragDecrypted) {
                            stats.fragDecrypted = 0;
                            this.totalDecryptTime = 0;
                            stats.fragAvgDecryptTime = 0;
                        }
                        stats.fragDecrypted++;
                        this.totalDecryptTime += data.stats.tdecrypt - data.stats.tstart;
                        stats.fragAvgDecryptTime = this.totalDecryptTime / stats.fragDecrypted;
                    });
                    hls.on(Hls.Events.ERROR, function (eventName, data) {
                        console.warn("Error event:", data);
                        switch (data.details) {
                            case Hls.ErrorDetails.MANIFEST_LOAD_ERROR:
                                try {
                                    $("#errorOut").html('Cannot load <a href="' + data.context.url + '">' + url + "</a><br>HTTP response code:" + data.response.code + " <br>" + data.response.text);
                                    if (data.response.code === 0) {
                                        $("#errorOut").append(
                                            'This might be a CORS issue, consider installing <a href="https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi">Allow-Control-Allow-Origin</a> Chrome Extension'
                                        );
                                    }
                                } catch (err) {
                                    $("#errorOut").html('Cannot load <a href="' + data.context.url + '">' + url + "</a><br>Response body: " + data.response.text);
                                }
                                break;
                            case Hls.ErrorDetails.MANIFEST_LOAD_TIMEOUT:
                                logError("Timeout while loading manifest");
                                break;
                            case Hls.ErrorDetails.MANIFEST_PARSING_ERROR:
                                logError("Error while parsing manifest:" + data.reason);
                                break;
                            case Hls.ErrorDetails.LEVEL_EMPTY_ERROR:
                                logError("Loaded level contains no fragments " + data.level + " " + data.url);
                                break;
                            case Hls.ErrorDetails.LEVEL_LOAD_ERROR:
                                logError("Error while loading level playlist " + data.context.level + " " + data.url);
                                break;
                            case Hls.ErrorDetails.LEVEL_LOAD_TIMEOUT:
                                logError("Timeout while loading level playlist " + data.context.level + " " + data.url);
                                break;
                            case Hls.ErrorDetails.LEVEL_SWITCH_ERROR:
                                logError("Error while trying to switch to level " + data.level);
                                break;
                            case Hls.ErrorDetails.FRAG_LOAD_ERROR:
                                logError("Error while loading fragment " + data.frag.url);
                                break;
                            case Hls.ErrorDetails.FRAG_LOAD_TIMEOUT:
                                logError("Timeout while loading fragment " + data.frag.url);
                                break;
                            case Hls.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
                                logError("Fragment-loop loading error");
                                break;
                            case Hls.ErrorDetails.FRAG_DECRYPT_ERROR:
                                logError("Decrypting error:" + data.reason);
                                break;
                            case Hls.ErrorDetails.FRAG_PARSING_ERROR:
                                logError("Parsing error:" + data.reason);
                                break;
                            case Hls.ErrorDetails.KEY_LOAD_ERROR:
                                logError("Error while loading key " + data.frag.decryptdata.uri);
                                break;
                            case Hls.ErrorDetails.KEY_LOAD_TIMEOUT:
                                logError("Timeout while loading key " + data.frag.decryptdata.uri);
                                break;
                            case Hls.ErrorDetails.BUFFER_APPEND_ERROR:
                                logError("Buffer append error");
                                break;
                            case Hls.ErrorDetails.BUFFER_ADD_CODEC_ERROR:
                                logError("Buffer add codec error for " + data.mimeType + ":" + data.error.message);
                                break;
                            case Hls.ErrorDetails.BUFFER_APPENDING_ERROR:
                                logError("Buffer appending error");
                                break;
                            case Hls.ErrorDetails.BUFFER_STALLED_ERROR:
                                logError("Buffer stalled error");
                                if (stopOnStall) {
                                    hls.stopLoad();
                                    video.pause();
                                }
                                break;
                            default:
                                break;
                        }
                        if (data.fatal) {
                            console.error("Fatal error : " + data.details);
                            switch (data.type) {
                                case Hls.ErrorTypes.MEDIA_ERROR:
                                    logError("A media error occurred: " + data.details);
                                    handleMediaError();
                                    break;
                                case Hls.ErrorTypes.NETWORK_ERROR:
                                    logError("A network error occurred: " + data.details);
                                    break;
                                default:
                                    logError("An unrecoverable error occurred: " + data.details);
                                    hls.destroy();
                                    break;
                            }
                        }
                        if (!stats) {
                            stats = {};
                        }
                        if (stats[data.details] === undefined) {
                            stats[data.details] = 1;
                        } else {
                            stats[data.details] += 1;
                        }
                        if (data.fatal) {
                            if (stats.fatalError === undefined) {
                                stats.fatalError = 1;
                            } else {
                                stats.fatalError += 1;
                            }
                        }
                        $("#statisticsOut").text(JSON.stringify(Object(_demo_utils__WEBPACK_IMPORTED_MODULE_2__["sortObject"])(stats), null, "\t"));
                    });
                    hls.on(Hls.Events.BUFFER_CREATED, function (eventName, data) {
                        tracks = data.tracks;
                    });
                    hls.on(Hls.Events.BUFFER_APPENDING, function (eventName, data) {
                        if (dumpfMP4) {
                            fmp4Data[data.type].push(data.data);
                        }
                    });
                    hls.on(Hls.Events.FPS_DROP, function (eventName, data) {
                        var event = { time: self.performance.now() - events.t0, type: "frame drop", name: data.currentDropped + "/" + data.currentDecoded };
                        events.video.push(event);
                        trimEventHistory();
                        if (stats) {
                            if (stats.fpsDropEvent === undefined) {
                                stats.fpsDropEvent = 1;
                            } else {
                                stats.fpsDropEvent++;
                            }
                            stats.fpsTotalDroppedFrames = data.totalDroppedFrames;
                        }
                    });
                }
                function addVideoEventListeners(video) {
                    video.removeEventListener("resize", handleVideoEvent);
                    video.removeEventListener("seeking", handleVideoEvent);
                    video.removeEventListener("seeked", handleVideoEvent);
                    video.removeEventListener("pause", handleVideoEvent);
                    video.removeEventListener("play", handleVideoEvent);
                    video.removeEventListener("canplay", handleVideoEvent);
                    video.removeEventListener("canplaythrough", handleVideoEvent);
                    video.removeEventListener("ended", handleVideoEvent);
                    video.removeEventListener("playing", handleVideoEvent);
                    video.removeEventListener("error", handleVideoEvent);
                    video.removeEventListener("loadedmetadata", handleVideoEvent);
                    video.removeEventListener("loadeddata", handleVideoEvent);
                    video.removeEventListener("durationchange", handleVideoEvent);
                    video.removeEventListener("volumechange", handleVolumeEvent);
                    video.addEventListener("resize", handleVideoEvent);
                    video.addEventListener("seeking", handleVideoEvent);
                    video.addEventListener("seeked", handleVideoEvent);
                    video.addEventListener("pause", handleVideoEvent);
                    video.addEventListener("play", handleVideoEvent);
                    video.addEventListener("canplay", handleVideoEvent);
                    video.addEventListener("canplaythrough", handleVideoEvent);
                    video.addEventListener("ended", handleVideoEvent);
                    video.addEventListener("playing", handleVideoEvent);
                    video.addEventListener("error", handleVideoEvent);
                    video.addEventListener("loadedmetadata", handleVideoEvent);
                    video.addEventListener("loadeddata", handleVideoEvent);
                    video.addEventListener("durationchange", handleVideoEvent);
                    video.addEventListener("volumechange", handleVolumeEvent);
                }
                function handleUnsupported() {
                    if (navigator.userAgent.toLowerCase().indexOf("firefox") !== -1) {
                        logStatus(
                            "You are using Firefox, it looks like MediaSource is not enabled,<br>please ensure the following keys are set appropriately in <b>about:config</b><br>media.mediasource.enabled=true<br>media.mediasource.mp4.enabled=true<br><b>media.mediasource.whitelist=false</b>"
                        );
                    } else {
                        logStatus("Your Browser does not support MediaSourceExtension / MP4 mediasource");
                    }
                }
                function handleVideoEvent(evt) {
                    var data = "";
                    switch (evt.type) {
                        case "durationchange":
                            if (evt.target.duration - lastDuration <= 0.5) {
                                return;
                            }
                            lastDuration = evt.target.duration;
                            data = Math.round(evt.target.duration * 1e3);
                            break;
                        case "resize":
                            data = evt.target.videoWidth + "/" + evt.target.videoHeight;
                            playerResize();
                            break;
                        case "loadedmetadata":
                        case "loadeddata":
                        case "canplay":
                        case "canplaythrough":
                        case "ended":
                        case "seeking":
                        case "seeked":
                        case "play":
                        case "playing":
                            lastStartPosition = evt.target.currentTime;
                        case "pause":
                        case "waiting":
                        case "stalled":
                        case "error":
                            data = Math.round(evt.target.currentTime * 1e3);
                            if (evt.type === "error") {
                                var errorTxt;
                                var mediaError = evt.currentTarget.error;
                                switch (mediaError.code) {
                                    case mediaError.MEDIA_ERR_ABORTED:
                                        errorTxt = "You aborted the video playback";
                                        break;
                                    case mediaError.MEDIA_ERR_DECODE:
                                        errorTxt = "The video playback was aborted due to a corruption problem or because the video used features your browser did not support";
                                        handleMediaError();
                                        break;
                                    case mediaError.MEDIA_ERR_NETWORK:
                                        errorTxt = "A network error caused the video download to fail part-way";
                                        break;
                                    case mediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:
                                        errorTxt = "The video could not be loaded, either because the server or network failed or because the format is not supported";
                                        break;
                                }
                                if (mediaError.message) {
                                    errorTxt += " - " + mediaError.message;
                                }
                                logStatus(errorTxt);
                                console.error(errorTxt);
                            }
                            break;
                        default:
                            break;
                    }
                    var event = { time: self.performance.now() - events.t0, type: evt.type, name: data };
                    events.video.push(event);
                    if (evt.type === "seeking") {
                        lastSeekingIdx = events.video.length - 1;
                    }
                    if (evt.type === "seeked") {
                        events.video[lastSeekingIdx].duration = event.time - events.video[lastSeekingIdx].time;
                    }
                    trimEventHistory();
                }
                function handleVolumeEvent() {
                    localStorage.setItem(STORAGE_KEYS.volume, JSON.stringify({ muted: video.muted, volume: video.volume }));
                }
                function handleLevelError(data) {
                    var levelObj = data.context || data;
                    hls.removeLevel(levelObj.level, levelObj.urlId || 0);
                    if (!hls.levels.length) {
                        logError("All levels have been removed");
                        hls.destroy();
                        return;
                    }
                    hls.currentLevel = 0;
                    hls.currentLevel = -1;
                }
                function handleMediaError() {
                    if (autoRecoverError) {
                        var now = self.performance.now();
                        if (!self.recoverDecodingErrorDate || now - self.recoverDecodingErrorDate > 3e3) {
                            self.recoverDecodingErrorDate = self.performance.now();
                            $("#statusOut").append(", trying to recover media error.");
                            hls.recoverMediaError();
                        } else {
                            if (!self.recoverSwapAudioCodecDate || now - self.recoverSwapAudioCodecDate > 3e3) {
                                self.recoverSwapAudioCodecDate = self.performance.now();
                                $("#statusOut").append(", trying to swap audio codec and recover media error.");
                                hls.swapAudioCodec();
                                hls.recoverMediaError();
                            } else {
                                $("#statusOut").append(", cannot recover. Last media error recovery failed.");
                            }
                        }
                    }
                }
                function timeRangesToString(r) {
                    var log = "";
                    for (var i = 0; i < r.length; i++) {
                        log += "[" + r.start(i) + ", " + r.end(i) + "]";
                        log += " ";
                    }
                    return log;
                }
                function checkBuffer() {
                    var canvas = document.querySelector("#bufferedCanvas");
                    var ctx = canvas.getContext("2d");
                    var r = video.buffered;
                    var seekableEnd = getSeekableEnd();
                    var bufferingDuration;
                    if (r) {
                        ctx.fillStyle = "black";
                        if (!canvas.width || canvas.width !== video.clientWidth) {
                            canvas.width = video.clientWidth;
                        }
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        var pos = video.currentTime;
                        var bufferLen = 0;
                        ctx.fillStyle = "gray";
                        for (var i = 0; i < r.length; i++) {
                            var start = (r.start(i) / seekableEnd) * canvas.width;
                            var end = (r.end(i) / seekableEnd) * canvas.width;
                            ctx.fillRect(start, 2, Math.max(2, end - start), 11);
                            if (pos >= r.start(i) && pos < r.end(i)) {
                                bufferLen = r.end(i) - pos;
                            }
                        }
                        if (bufferLen <= 0.1 && video.paused === false && pos - lastStartPosition > 0.5) {
                            if (lastDuration - pos <= 0.5 && events.isLive === false) {
                            } else {
                                if (bufferingIdx !== -1) {
                                    bufferingDuration = self.performance.now() - events.t0 - events.video[bufferingIdx].time;
                                    events.video[bufferingIdx].duration = bufferingDuration;
                                    events.video[bufferingIdx].name = bufferingDuration;
                                } else {
                                    events.video.push({ type: "buffering", time: self.performance.now() - events.t0 });
                                    trimEventHistory();
                                    bufferingIdx = events.video.length - 1;
                                }
                            }
                        }
                        if (bufferLen > 0.1 && bufferingIdx !== -1) {
                            bufferingDuration = self.performance.now() - events.t0 - events.video[bufferingIdx].time;
                            events.video[bufferingIdx].duration = bufferingDuration;
                            events.video[bufferingIdx].name = bufferingDuration;
                            bufferingIdx = -1;
                        }
                        var event = { time: self.performance.now() - events.t0, buffer: Math.round(bufferLen * 1e3), pos: Math.round(pos * 1e3) };
                        var bufEvents = events.buffer;
                        var bufEventLen = bufEvents.length;
                        if (bufEventLen > 1) {
                            var event0 = bufEvents[bufEventLen - 2];
                            var event1 = bufEvents[bufEventLen - 1];
                            var slopeBuf0 = (event0.buffer - event1.buffer) / (event0.time - event1.time);
                            var slopeBuf1 = (event1.buffer - event.buffer) / (event1.time - event.time);
                            var slopePos0 = (event0.pos - event1.pos) / (event0.time - event1.time);
                            var slopePos1 = (event1.pos - event.pos) / (event1.time - event.time);
                            if ((slopeBuf0 === slopeBuf1 || Math.abs(slopeBuf0 / slopeBuf1 - 1) <= 0.3) && (slopePos0 === slopePos1 || Math.abs(slopePos0 / slopePos1 - 1) <= 0.3)) {
                                bufEvents.pop();
                            }
                        }
                        events.buffer.push(event);
                        trimEventHistory();
                        self.refreshCanvas();
                        if ($("#statsDisplayTab").is(":visible")) {
                            var log = "Duration: " + video.duration + "\nBuffered: " + timeRangesToString(video.buffered) + "\nSeekable: " + timeRangesToString(video.seekable) + "\nPlayed: " + timeRangesToString(video.played) + "\n";
                            if (hls.media) {
                                for (var type in tracks) {
                                    log += "Buffer for " + type + " contains:" + timeRangesToString(tracks[type].buffer.buffered) + "\n";
                                }
                                var videoPlaybackQuality = video.getVideoPlaybackQuality;
                                if (videoPlaybackQuality && typeof videoPlaybackQuality === typeof Function) {
                                    log += "Dropped frames: " + video.getVideoPlaybackQuality().droppedVideoFrames + "\n";
                                    log += "Corrupted frames: " + video.getVideoPlaybackQuality().corruptedVideoFrames + "\n";
                                } else if (video.webkitDroppedFrameCount) {
                                    log += "Dropped frames: " + video.webkitDroppedFrameCount + "\n";
                                }
                            }
                            log += "Bandwidth Estimate: " + hls.bandwidthEstimate.toFixed(3) + "\n";
                            if (events.isLive) {
                                log +=
                                    "Live Stats:\n" +
                                    ("  Max Latency: " + hls.maxLatency + "\n") +
                                    ("  Target Latency: " + hls.targetLatency.toFixed(3) + "\n") +
                                    ("  Latency: " + hls.latency.toFixed(3) + "\n") +
                                    ("  Drift: " + hls.drift.toFixed(3) + " (edge advance rate)\n") +
                                    ("  Edge Stall: " + hls.latencyController.edgeStalled.toFixed(3) + " (playlist refresh over target duration/part)\n") +
                                    ("  Playback rate: " + video.playbackRate.toFixed(2) + "\n");
                                if (stats.fragProgramDateTime) {
                                    var currentPDT = stats.fragProgramDateTime + (video.currentTime - stats.fragStart) * 1e3;
                                    log += "  Program Date Time: " + new Date(currentPDT).toISOString();
                                    var pdtLatency = (Date.now() - currentPDT) / 1e3;
                                    if (pdtLatency > 0) {
                                        log += " (" + pdtLatency.toFixed(3) + " seconds ago)";
                                    }
                                }
                            }
                            $("#bufferedOut").text(log);
                            $("#statisticsOut").text(JSON.stringify(Object(_demo_utils__WEBPACK_IMPORTED_MODULE_2__["sortObject"])(stats), null, "\t"));
                        }
                        ctx.fillStyle = "blue";
                        var x = (video.currentTime / seekableEnd) * canvas.width;
                        ctx.fillRect(x, 0, 2, 15);
                    } else if (ctx.fillStyle !== "black") {
                        ctx.fillStyle = "black";
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                }
                function showCanvas() {
                    self.showMetrics();
                    $("#bufferedOut").show();
                    $("#bufferedCanvas").show();
                }
                function hideCanvas() {
                    self.hideMetrics();
                    $("#bufferedOut").hide();
                    $("#bufferedCanvas").hide();
                }
                function getMetrics() {
                    var json = JSON.stringify(events);
                    var jsonpacked = Object(jsonpack__WEBPACK_IMPORTED_MODULE_0__["pack"])(json);
                    return btoa(jsonpacked);
                }
                self.copyMetricsToClipBoard = function () {
                    Object(_demo_utils__WEBPACK_IMPORTED_MODULE_2__["copyTextToClipboard"])(getMetrics());
                };
                self.goToMetrics = function () {
                    var url = document.URL;
                    url = url.slice(0, url.lastIndexOf("/") + 1) + "metrics.html";
                    self.open(url, "_blank");
                };
                function goToMetricsPermaLink() {
                    var url = document.URL;
                    var b64 = getMetrics();
                    url = url.slice(0, url.lastIndexOf("/") + 1) + "metrics.html#data=" + b64;
                    self.open(url, "_blank");
                }
                function onClickBufferedRange(event) {
                    var canvas = document.querySelector("#bufferedCanvas");
                    var target = ((event.clientX - canvas.offsetLeft) / canvas.width) * getSeekableEnd();
                    video.currentTime = target;
                }
                function getSeekableEnd() {
                    if (isFinite(video.duration)) {
                        return video.duration;
                    }
                    if (video.seekable.length) {
                        return video.seekable.end(video.seekable.length - 1);
                    }
                    return 0;
                }
                function getLevelButtonHtml(key, levels, onclickReplace, autoEnabled) {
                    var onclickAuto = (key + "=-1").replace(/^(\w+)=([^=]+)$/, onclickReplace);
                    var codecs = levels.reduce(function (uniqueCodecs, level) {
                        var levelCodecs = codecs2label(level.attrs.CODECS);
                        if (levelCodecs && uniqueCodecs.indexOf(levelCodecs) === -1) {
                            uniqueCodecs.push(levelCodecs);
                        }
                        return uniqueCodecs;
                    }, []);
                    return (
                        '<button type="button" class="btn btn-sm ' +
                        (autoEnabled ? "btn-primary" : "btn-success") +
                        '" onclick="' +
                        onclickAuto +
                        '">auto</button>' +
                        levels
                            .map(function (level, i) {
                                var enabled = hls[key] === i;
                                var onclick = (key + "=" + i).replace(/^(\w+)=(\w+)$/, onclickReplace);
                                var label = level2label(levels[i], i, codecs);
                                return '<button type="button" class="btn btn-sm ' + (enabled ? "btn-primary" : "btn-success") + '" onclick="' + onclick + '">' + label + "</button>";
                            })
                            .join("")
                    );
                }
                function updateLevelInfo() {
                    var levels = hls.levels;
                    if (!levels) {
                        return;
                    }
                    var htmlCurrentLevel = getLevelButtonHtml("currentLevel", levels, "hls.$1=$2", hls.autoLevelEnabled);
                    var htmlNextLevel = getLevelButtonHtml("nextLevel", levels, "hls.$1=$2", hls.autoLevelEnabled);
                    var htmlLoadLevel = getLevelButtonHtml("loadLevel", levels, "hls.$1=$2", hls.autoLevelEnabled);
                    var htmlCapLevel = getLevelButtonHtml("autoLevelCapping", levels, "levelCapping=hls.$1=$2;updateLevelInfo();onDemoConfigChanged();", hls.autoLevelCapping === -1);
                    if ($("#currentLevelControl").html() !== htmlCurrentLevel) {
                        $("#currentLevelControl").html(htmlCurrentLevel);
                    }
                    if ($("#nextLevelControl").html() !== htmlNextLevel) {
                        $("#nextLevelControl").html(htmlNextLevel);
                    }
                    if ($("#loadLevelControl").html() !== htmlLoadLevel) {
                        $("#loadLevelControl").html(htmlLoadLevel);
                    }
                    if ($("#levelCappingControl").html() !== htmlCapLevel) {
                        $("#levelCappingControl").html(htmlCapLevel);
                    }
                }
                function updateAudioTrackInfo() {
                    var buttonTemplate = '<button type="button" class="btn btn-sm ';
                    var buttonEnabled = 'btn-primary" ';
                    var buttonDisabled = 'btn-success" ';
                    var html1 = "";
                    var audioTrackId = hls.audioTrack;
                    var len = hls.audioTracks.length;
                    var track = hls.audioTracks[audioTrackId];
                    for (var i = 0; i < len; i++) {
                        html1 += buttonTemplate;
                        if (audioTrackId === i) {
                            html1 += buttonEnabled;
                        } else {
                            html1 += buttonDisabled;
                        }
                        html1 += 'onclick="hls.audioTrack=' + i + '">' + hls.audioTracks[i].name + "</button>";
                    }
                    $("#audioTrackLabel").text(track ? track.lang || track.name : "None selected");
                    $("#audioTrackControl").html(html1);
                }
                function codecs2label(levelCodecs) {
                    if (levelCodecs) {
                        return levelCodecs.replace(/([ah]vc.)[^,;]+/, "$1").replace("mp4a.40.2", "mp4a");
                    }
                    return "";
                }
                function level2label(level, i, manifestCodecs) {
                    var levelCodecs = codecs2label(level.attrs.CODECS);
                    var levelNameInfo = level.name ? '"' + level.name + '": ' : "";
                    var codecInfo = levelCodecs && manifestCodecs.length > 1 ? " / " + levelCodecs : "";
                    if (level.height) {
                        return i + " (" + levelNameInfo + level.height + "p / " + Math.round(level.bitrate / 1024) + "kb" + codecInfo + ")";
                    }
                    if (level.bitrate) {
                        return i + " (" + levelNameInfo + Math.round(level.bitrate / 1024) + "kb" + codecInfo + ")";
                    }
                    if (codecInfo) {
                        return i + " (" + levelNameInfo + levelCodecs + ")";
                    }
                    if (level.name) {
                        return i + " (" + level.name + ")";
                    }
                    return "" + i;
                }
                function getDemoConfigPropOrDefault(propName, defaultVal) {
                    return typeof demoConfig[propName] !== "undefined" ? demoConfig[propName] : defaultVal;
                }
                function getURLParam(sParam, defaultValue) {
                    var sPageURL = self.location.search.substring(1);
                    var sURLVariables = sPageURL.split("&");
                    for (var i = 0; i < sURLVariables.length; i++) {
                        var sParameterName = sURLVariables[i].split("=");
                        if (sParameterName[0] === sParam) {
                            return sParameterName[1] === "undefined" ? undefined : sParameterName[1] === "false" ? false : sParameterName[1];
                        }
                    }
                    return defaultValue;
                }
                function onDemoConfigChanged(firstLoad) {
                    demoConfig = { enableStreaming: enableStreaming, autoRecoverError: autoRecoverError, stopOnStall: stopOnStall, dumpfMP4: dumpfMP4, levelCapping: levelCapping, limitMetrics: limitMetrics };
                    if (configPersistenceEnabled) {
                        persistEditorValue();
                    }
                    var serializedDemoConfig = btoa(JSON.stringify(demoConfig));
                    var baseURL = document.URL.split("?")[0];
                    var streamURL = $("#streamURL").val();
                    var permalinkURL = baseURL + "?src=" + encodeURIComponent(streamURL) + "&demoConfig=" + serializedDemoConfig;
                    $("#StreamPermalink").html('<a href="' + permalinkURL + '">' + permalinkURL + "</a>");
                    if (!firstLoad && window.location.href !== permalinkURL) {
                        window.history.pushState(null, null, permalinkURL);
                    }
                }
                function onConfigPersistenceChanged(event) {
                    configPersistenceEnabled = event.target.checked;
                    localStorage.setItem(STORAGE_KEYS.Editor_Persistence, JSON.stringify(configPersistenceEnabled));
                    if (configPersistenceEnabled) {
                        persistEditorValue();
                    } else {
                        localStorage.removeItem(STORAGE_KEYS.Hls_Config);
                    }
                }
                function getEditorValue(options) {
                    options = $.extend({ parse: false }, options || {});
                    var value = configEditor.session.getValue();
                    if (options.parse) {
                        try {
                            value = JSON.parse(value);
                        } catch (e) {
                            console.warn("[getEditorValue] could not parse editor value", e);
                            value = {};
                        }
                    }
                    return value;
                }
                function getPersistedHlsConfig() {
                    var value = localStorage.getItem(STORAGE_KEYS.Hls_Config);
                    if (value === null) {
                        return value;
                    }
                    try {
                        value = JSON.parse(value);
                    } catch (e) {
                        console.warn("[getPersistedHlsConfig] could not hls config json", e);
                        value = {};
                    }
                    return value;
                }
                function persistEditorValue() {
                    localStorage.setItem(STORAGE_KEYS.Hls_Config, getEditorValue());
                }
                function setupConfigEditor() {
                    configEditor = self.ace.edit("config-editor");
                    configEditor.setTheme("ace/theme/github");
                    configEditor.session.setMode("ace/mode/json");
                    var contents = hlsjsDefaults;
                    var shouldRestorePersisted = JSON.parse(localStorage.getItem(STORAGE_KEYS.Editor_Persistence)) === true;
                    if (shouldRestorePersisted) {
                        $.extend(contents, getPersistedHlsConfig());
                    }
                    var elPersistence = document.querySelector("#config-persistence");
                    elPersistence.addEventListener("change", onConfigPersistenceChanged);
                    elPersistence.checked = shouldRestorePersisted;
                    configPersistenceEnabled = shouldRestorePersisted;
                    updateConfigEditorValue(contents);
                }
                function setupTimelineChart() {
                    var canvas = document.querySelector("#timeline-chart");
                    var chart = new _chart_timeline_chart__WEBPACK_IMPORTED_MODULE_3__["TimelineChart"](canvas, { responsive: false });
                    resizeHandlers.push(function () {
                        chart.resize();
                    });
                    chart.resize();
                    return chart;
                }
                function addChartEventListeners(hls) {
                    var updateLevelOrTrack = function updateLevelOrTrack(eventName, data) {
                        chart.updateLevelOrTrack(data.details);
                    };
                    var updateFragment = function updateFragment(eventName, data) {
                        if (data.stats) {
                            var _data$stats = data.stats,
                                retry = _data$stats.retry,
                                loaded = _data$stats.loaded,
                                total = _data$stats.total,
                                trequest = _data$stats.trequest,
                                tfirst = _data$stats.tfirst,
                                tload = _data$stats.tload;
                            if (trequest && tload) {
                                data.frag.stats = { loaded: loaded, retry: retry, total: total, loading: { start: trequest, first: tfirst, end: tload } };
                            }
                        }
                        chart.updateFragment(data);
                    };
                    var updateChart = function updateChart() {
                        chart.update();
                    };
                    hls.on(
                        Hls.Events.MANIFEST_LOADING,
                        function () {
                            chart.reset();
                        },
                        chart
                    );
                    hls.on(
                        Hls.Events.MANIFEST_PARSED,
                        function (eventName, data) {
                            var levels = data.levels;
                            chart.removeType("level");
                            chart.removeType("audioTrack");
                            chart.removeType("subtitleTrack");
                            chart.updateLevels(levels);
                        },
                        chart
                    );
                    hls.on(
                        Hls.Events.BUFFER_CREATED,
                        function (eventName, _ref) {
                            var tracks = _ref.tracks;
                            chart.updateSourceBuffers(tracks, hls.media);
                        },
                        chart
                    );
                    hls.on(
                        Hls.Events.BUFFER_RESET,
                        function () {
                            chart.removeSourceBuffers();
                        },
                        chart
                    );
                    hls.on(Hls.Events.LEVELS_UPDATED, function (eventName, _ref2) {
                        var levels = _ref2.levels;
                        chart.removeType("level");
                        chart.updateLevels(levels);
                    });
                    hls.on(
                        Hls.Events.LEVEL_SWITCHED,
                        function (eventName, _ref3) {
                            var level = _ref3.level;
                            chart.removeType("level");
                            chart.updateLevels(hls.levels, level);
                        },
                        chart
                    );
                    hls.on(
                        Hls.Events.LEVEL_LOADING,
                        function () {
                            chart.removeType("level");
                            chart.updateLevels(hls.levels);
                        },
                        chart
                    );
                    hls.on(
                        Hls.Events.LEVEL_UPDATED,
                        function (eventName, _ref4) {
                            var details = _ref4.details;
                            chart.updateLevelOrTrack(details);
                        },
                        chart
                    );
                    hls.on(
                        Hls.Events.AUDIO_TRACKS_UPDATED,
                        function (eventName, _ref5) {
                            var audioTracks = _ref5.audioTracks;
                            chart.removeType("audioTrack");
                            chart.updateAudioTracks(audioTracks);
                        },
                        chart
                    );
                    hls.on(
                        Hls.Events.SUBTITLE_TRACKS_UPDATED,
                        function (eventName, _ref6) {
                            var subtitleTracks = _ref6.subtitleTracks;
                            chart.removeType("subtitleTrack");
                            chart.updateSubtitleTracks(subtitleTracks);
                        },
                        chart
                    );
                    hls.on(
                        Hls.Events.AUDIO_TRACK_SWITCHED,
                        function (eventName) {
                            chart.removeType("audioTrack");
                            chart.updateAudioTracks(hls.audioTracks);
                        },
                        chart
                    );
                    hls.on(
                        Hls.Events.SUBTITLE_TRACK_SWITCH,
                        function (eventName) {
                            chart.removeType("subtitleTrack");
                            chart.updateSubtitleTracks(hls.subtitleTracks);
                        },
                        chart
                    );
                    hls.on(Hls.Events.AUDIO_TRACK_LOADED, updateLevelOrTrack, chart);
                    hls.on(Hls.Events.SUBTITLE_TRACK_LOADED, updateLevelOrTrack, chart);
                    hls.on(Hls.Events.LEVEL_PTS_UPDATED, updateLevelOrTrack, chart);
                    hls.on(Hls.Events.FRAG_LOADED, updateFragment, chart);
                    hls.on(Hls.Events.FRAG_PARSED, updateFragment, chart);
                    hls.on(Hls.Events.FRAG_CHANGED, updateFragment, chart);
                    hls.on(Hls.Events.BUFFER_APPENDING, updateChart, chart);
                    hls.on(Hls.Events.BUFFER_APPENDED, updateChart, chart);
                    hls.on(Hls.Events.BUFFER_FLUSHED, updateChart, chart);
                }
                function updateConfigEditorValue(obj) {
                    var json = JSON.stringify(obj, null, 2);
                    configEditor.session.setValue(json);
                }
                function applyConfigEditorValue() {
                    onDemoConfigChanged();
                    loadSelectedStream();
                }
                function createfMP4(type) {
                    if (fmp4Data[type].length) {
                        var blob = new Blob([arrayConcat(fmp4Data[type])], { type: "application/octet-stream" });
                        var filename = type + "-" + new Date().toISOString() + ".mp4";
                        self.saveAs(blob, filename);
                    } else if (!dumpfMP4) {
                        console.error('Check "Dump transmuxed fMP4 data" first to make appended media available for saving.');
                    }
                }
                function arrayConcat(inputArray) {
                    var totalLength = inputArray.reduce(function (prev, cur) {
                        return prev + cur.length;
                    }, 0);
                    var result = new Uint8Array(totalLength);
                    var offset = 0;
                    inputArray.forEach(function (element) {
                        result.set(element, offset);
                        offset += element.length;
                    });
                    return result;
                }
                function hideAllTabs() {
                    $(".demo-tab-btn").css("background-color", "");
                    $(".demo-tab").hide();
                }
                function toggleTabClick(btn) {
                    toggleTab(btn);
                    var tabIndexes = $(".demo-tab-btn")
                        .toArray()
                        .map(function (el, i) {
                            return $("#" + $(el).data("tab")).is(":visible") ? i : null;
                        })
                        .filter(function (i) {
                            return i !== null;
                        });
                    localStorage.setItem(STORAGE_KEYS.demo_tabs, tabIndexes.join(","));
                }
                function toggleTab(btn, dontHideOpenTabs) {
                    var tabElId = $(btn).data("tab");
                    var modifierPressed = dontHideOpenTabs || (self.event && (self.event.metaKey || self.event.shiftKey));
                    if (!modifierPressed) {
                        hideAllTabs();
                    }
                    if (modifierPressed) {
                        $("#" + tabElId).toggle();
                    } else {
                        $("#" + tabElId).show();
                    }
                    $(btn).css("background-color", $("#" + tabElId).is(":visible") ? "orange" : "");
                    if (!$("#statsDisplayTab").is(":visible")) {
                        self.hideMetrics();
                    }
                    if (hls) {
                        if ($("#timelineTab").is(":visible")) {
                            chart.show();
                            chart.resize(chart.chart.data ? chart.chart.data.datasets : null);
                        } else {
                            chart.hide();
                        }
                    }
                }
                function appendLog(textElId, message) {
                    var el = $("#" + textElId);
                    var logText = el.text();
                    if (logText.length) {
                        logText += "\n";
                    }
                    var timestamp = (Date.now() - startTime) / 1e3;
                    var newMessage = timestamp + " | " + message;
                    logText += newMessage;
                    el.text(logText);
                    var element = el[0];
                    element.scrollTop = element.scrollHeight - element.clientHeight;
                }
                function logStatus(message) {
                    appendLog("statusOut", message);
                }
                function logError(message) {
                    appendLog("errorOut", message);
                }
            },
            "./node_modules/chart.js/dist/Chart.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true
                        ? (module.exports = factory(
                              (function () {
                                  try {
                                      return __webpack_require__("./node_modules/moment/moment.js");
                                  } catch (e) {}
                              })()
                          ))
                        : undefined;
                })(this, function (moment) {
                    "use strict";
                    moment = moment && moment.hasOwnProperty("default") ? moment["default"] : moment;
                    function createCommonjsModule(fn, module) {
                        return (module = { exports: {} }), fn(module, module.exports), module.exports;
                    }
                    function getCjsExportFromNamespace(n) {
                        return (n && n["default"]) || n;
                    }
                    var colorName = {
                        aliceblue: [240, 248, 255],
                        antiquewhite: [250, 235, 215],
                        aqua: [0, 255, 255],
                        aquamarine: [127, 255, 212],
                        azure: [240, 255, 255],
                        beige: [245, 245, 220],
                        bisque: [255, 228, 196],
                        black: [0, 0, 0],
                        blanchedalmond: [255, 235, 205],
                        blue: [0, 0, 255],
                        blueviolet: [138, 43, 226],
                        brown: [165, 42, 42],
                        burlywood: [222, 184, 135],
                        cadetblue: [95, 158, 160],
                        chartreuse: [127, 255, 0],
                        chocolate: [210, 105, 30],
                        coral: [255, 127, 80],
                        cornflowerblue: [100, 149, 237],
                        cornsilk: [255, 248, 220],
                        crimson: [220, 20, 60],
                        cyan: [0, 255, 255],
                        darkblue: [0, 0, 139],
                        darkcyan: [0, 139, 139],
                        darkgoldenrod: [184, 134, 11],
                        darkgray: [169, 169, 169],
                        darkgreen: [0, 100, 0],
                        darkgrey: [169, 169, 169],
                        darkkhaki: [189, 183, 107],
                        darkmagenta: [139, 0, 139],
                        darkolivegreen: [85, 107, 47],
                        darkorange: [255, 140, 0],
                        darkorchid: [153, 50, 204],
                        darkred: [139, 0, 0],
                        darksalmon: [233, 150, 122],
                        darkseagreen: [143, 188, 143],
                        darkslateblue: [72, 61, 139],
                        darkslategray: [47, 79, 79],
                        darkslategrey: [47, 79, 79],
                        darkturquoise: [0, 206, 209],
                        darkviolet: [148, 0, 211],
                        deeppink: [255, 20, 147],
                        deepskyblue: [0, 191, 255],
                        dimgray: [105, 105, 105],
                        dimgrey: [105, 105, 105],
                        dodgerblue: [30, 144, 255],
                        firebrick: [178, 34, 34],
                        floralwhite: [255, 250, 240],
                        forestgreen: [34, 139, 34],
                        fuchsia: [255, 0, 255],
                        gainsboro: [220, 220, 220],
                        ghostwhite: [248, 248, 255],
                        gold: [255, 215, 0],
                        goldenrod: [218, 165, 32],
                        gray: [128, 128, 128],
                        green: [0, 128, 0],
                        greenyellow: [173, 255, 47],
                        grey: [128, 128, 128],
                        honeydew: [240, 255, 240],
                        hotpink: [255, 105, 180],
                        indianred: [205, 92, 92],
                        indigo: [75, 0, 130],
                        ivory: [255, 255, 240],
                        khaki: [240, 230, 140],
                        lavender: [230, 230, 250],
                        lavenderblush: [255, 240, 245],
                        lawngreen: [124, 252, 0],
                        lemonchiffon: [255, 250, 205],
                        lightblue: [173, 216, 230],
                        lightcoral: [240, 128, 128],
                        lightcyan: [224, 255, 255],
                        lightgoldenrodyellow: [250, 250, 210],
                        lightgray: [211, 211, 211],
                        lightgreen: [144, 238, 144],
                        lightgrey: [211, 211, 211],
                        lightpink: [255, 182, 193],
                        lightsalmon: [255, 160, 122],
                        lightseagreen: [32, 178, 170],
                        lightskyblue: [135, 206, 250],
                        lightslategray: [119, 136, 153],
                        lightslategrey: [119, 136, 153],
                        lightsteelblue: [176, 196, 222],
                        lightyellow: [255, 255, 224],
                        lime: [0, 255, 0],
                        limegreen: [50, 205, 50],
                        linen: [250, 240, 230],
                        magenta: [255, 0, 255],
                        maroon: [128, 0, 0],
                        mediumaquamarine: [102, 205, 170],
                        mediumblue: [0, 0, 205],
                        mediumorchid: [186, 85, 211],
                        mediumpurple: [147, 112, 219],
                        mediumseagreen: [60, 179, 113],
                        mediumslateblue: [123, 104, 238],
                        mediumspringgreen: [0, 250, 154],
                        mediumturquoise: [72, 209, 204],
                        mediumvioletred: [199, 21, 133],
                        midnightblue: [25, 25, 112],
                        mintcream: [245, 255, 250],
                        mistyrose: [255, 228, 225],
                        moccasin: [255, 228, 181],
                        navajowhite: [255, 222, 173],
                        navy: [0, 0, 128],
                        oldlace: [253, 245, 230],
                        olive: [128, 128, 0],
                        olivedrab: [107, 142, 35],
                        orange: [255, 165, 0],
                        orangered: [255, 69, 0],
                        orchid: [218, 112, 214],
                        palegoldenrod: [238, 232, 170],
                        palegreen: [152, 251, 152],
                        paleturquoise: [175, 238, 238],
                        palevioletred: [219, 112, 147],
                        papayawhip: [255, 239, 213],
                        peachpuff: [255, 218, 185],
                        peru: [205, 133, 63],
                        pink: [255, 192, 203],
                        plum: [221, 160, 221],
                        powderblue: [176, 224, 230],
                        purple: [128, 0, 128],
                        rebeccapurple: [102, 51, 153],
                        red: [255, 0, 0],
                        rosybrown: [188, 143, 143],
                        royalblue: [65, 105, 225],
                        saddlebrown: [139, 69, 19],
                        salmon: [250, 128, 114],
                        sandybrown: [244, 164, 96],
                        seagreen: [46, 139, 87],
                        seashell: [255, 245, 238],
                        sienna: [160, 82, 45],
                        silver: [192, 192, 192],
                        skyblue: [135, 206, 235],
                        slateblue: [106, 90, 205],
                        slategray: [112, 128, 144],
                        slategrey: [112, 128, 144],
                        snow: [255, 250, 250],
                        springgreen: [0, 255, 127],
                        steelblue: [70, 130, 180],
                        tan: [210, 180, 140],
                        teal: [0, 128, 128],
                        thistle: [216, 191, 216],
                        tomato: [255, 99, 71],
                        turquoise: [64, 224, 208],
                        violet: [238, 130, 238],
                        wheat: [245, 222, 179],
                        white: [255, 255, 255],
                        whitesmoke: [245, 245, 245],
                        yellow: [255, 255, 0],
                        yellowgreen: [154, 205, 50],
                    };
                    var conversions = createCommonjsModule(function (module) {
                        var reverseKeywords = {};
                        for (var key in colorName) {
                            if (colorName.hasOwnProperty(key)) {
                                reverseKeywords[colorName[key]] = key;
                            }
                        }
                        var convert = (module.exports = {
                            rgb: { channels: 3, labels: "rgb" },
                            hsl: { channels: 3, labels: "hsl" },
                            hsv: { channels: 3, labels: "hsv" },
                            hwb: { channels: 3, labels: "hwb" },
                            cmyk: { channels: 4, labels: "cmyk" },
                            xyz: { channels: 3, labels: "xyz" },
                            lab: { channels: 3, labels: "lab" },
                            lch: { channels: 3, labels: "lch" },
                            hex: { channels: 1, labels: ["hex"] },
                            keyword: { channels: 1, labels: ["keyword"] },
                            ansi16: { channels: 1, labels: ["ansi16"] },
                            ansi256: { channels: 1, labels: ["ansi256"] },
                            hcg: { channels: 3, labels: ["h", "c", "g"] },
                            apple: { channels: 3, labels: ["r16", "g16", "b16"] },
                            gray: { channels: 1, labels: ["gray"] },
                        });
                        for (var model in convert) {
                            if (convert.hasOwnProperty(model)) {
                                if (!("channels" in convert[model])) {
                                    throw new Error("missing channels property: " + model);
                                }
                                if (!("labels" in convert[model])) {
                                    throw new Error("missing channel labels property: " + model);
                                }
                                if (convert[model].labels.length !== convert[model].channels) {
                                    throw new Error("channel and label counts mismatch: " + model);
                                }
                                var channels = convert[model].channels;
                                var labels = convert[model].labels;
                                delete convert[model].channels;
                                delete convert[model].labels;
                                Object.defineProperty(convert[model], "channels", { value: channels });
                                Object.defineProperty(convert[model], "labels", { value: labels });
                            }
                        }
                        convert.rgb.hsl = function (rgb) {
                            var r = rgb[0] / 255;
                            var g = rgb[1] / 255;
                            var b = rgb[2] / 255;
                            var min = Math.min(r, g, b);
                            var max = Math.max(r, g, b);
                            var delta = max - min;
                            var h;
                            var s;
                            var l;
                            if (max === min) {
                                h = 0;
                            } else if (r === max) {
                                h = (g - b) / delta;
                            } else if (g === max) {
                                h = 2 + (b - r) / delta;
                            } else if (b === max) {
                                h = 4 + (r - g) / delta;
                            }
                            h = Math.min(h * 60, 360);
                            if (h < 0) {
                                h += 360;
                            }
                            l = (min + max) / 2;
                            if (max === min) {
                                s = 0;
                            } else if (l <= 0.5) {
                                s = delta / (max + min);
                            } else {
                                s = delta / (2 - max - min);
                            }
                            return [h, s * 100, l * 100];
                        };
                        convert.rgb.hsv = function (rgb) {
                            var rdif;
                            var gdif;
                            var bdif;
                            var h;
                            var s;
                            var r = rgb[0] / 255;
                            var g = rgb[1] / 255;
                            var b = rgb[2] / 255;
                            var v = Math.max(r, g, b);
                            var diff = v - Math.min(r, g, b);
                            var diffc = function (c) {
                                return (v - c) / 6 / diff + 1 / 2;
                            };
                            if (diff === 0) {
                                h = s = 0;
                            } else {
                                s = diff / v;
                                rdif = diffc(r);
                                gdif = diffc(g);
                                bdif = diffc(b);
                                if (r === v) {
                                    h = bdif - gdif;
                                } else if (g === v) {
                                    h = 1 / 3 + rdif - bdif;
                                } else if (b === v) {
                                    h = 2 / 3 + gdif - rdif;
                                }
                                if (h < 0) {
                                    h += 1;
                                } else if (h > 1) {
                                    h -= 1;
                                }
                            }
                            return [h * 360, s * 100, v * 100];
                        };
                        convert.rgb.hwb = function (rgb) {
                            var r = rgb[0];
                            var g = rgb[1];
                            var b = rgb[2];
                            var h = convert.rgb.hsl(rgb)[0];
                            var w = (1 / 255) * Math.min(r, Math.min(g, b));
                            b = 1 - (1 / 255) * Math.max(r, Math.max(g, b));
                            return [h, w * 100, b * 100];
                        };
                        convert.rgb.cmyk = function (rgb) {
                            var r = rgb[0] / 255;
                            var g = rgb[1] / 255;
                            var b = rgb[2] / 255;
                            var c;
                            var m;
                            var y;
                            var k;
                            k = Math.min(1 - r, 1 - g, 1 - b);
                            c = (1 - r - k) / (1 - k) || 0;
                            m = (1 - g - k) / (1 - k) || 0;
                            y = (1 - b - k) / (1 - k) || 0;
                            return [c * 100, m * 100, y * 100, k * 100];
                        };
                        function comparativeDistance(x, y) {
                            return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
                        }
                        convert.rgb.keyword = function (rgb) {
                            var reversed = reverseKeywords[rgb];
                            if (reversed) {
                                return reversed;
                            }
                            var currentClosestDistance = Infinity;
                            var currentClosestKeyword;
                            for (var keyword in colorName) {
                                if (colorName.hasOwnProperty(keyword)) {
                                    var value = colorName[keyword];
                                    var distance = comparativeDistance(rgb, value);
                                    if (distance < currentClosestDistance) {
                                        currentClosestDistance = distance;
                                        currentClosestKeyword = keyword;
                                    }
                                }
                            }
                            return currentClosestKeyword;
                        };
                        convert.keyword.rgb = function (keyword) {
                            return colorName[keyword];
                        };
                        convert.rgb.xyz = function (rgb) {
                            var r = rgb[0] / 255;
                            var g = rgb[1] / 255;
                            var b = rgb[2] / 255;
                            r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
                            g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
                            b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
                            var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
                            var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
                            var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
                            return [x * 100, y * 100, z * 100];
                        };
                        convert.rgb.lab = function (rgb) {
                            var xyz = convert.rgb.xyz(rgb);
                            var x = xyz[0];
                            var y = xyz[1];
                            var z = xyz[2];
                            var l;
                            var a;
                            var b;
                            x /= 95.047;
                            y /= 100;
                            z /= 108.883;
                            x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
                            y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
                            z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
                            l = 116 * y - 16;
                            a = 500 * (x - y);
                            b = 200 * (y - z);
                            return [l, a, b];
                        };
                        convert.hsl.rgb = function (hsl) {
                            var h = hsl[0] / 360;
                            var s = hsl[1] / 100;
                            var l = hsl[2] / 100;
                            var t1;
                            var t2;
                            var t3;
                            var rgb;
                            var val;
                            if (s === 0) {
                                val = l * 255;
                                return [val, val, val];
                            }
                            if (l < 0.5) {
                                t2 = l * (1 + s);
                            } else {
                                t2 = l + s - l * s;
                            }
                            t1 = 2 * l - t2;
                            rgb = [0, 0, 0];
                            for (var i = 0; i < 3; i++) {
                                t3 = h + (1 / 3) * -(i - 1);
                                if (t3 < 0) {
                                    t3++;
                                }
                                if (t3 > 1) {
                                    t3--;
                                }
                                if (6 * t3 < 1) {
                                    val = t1 + (t2 - t1) * 6 * t3;
                                } else if (2 * t3 < 1) {
                                    val = t2;
                                } else if (3 * t3 < 2) {
                                    val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
                                } else {
                                    val = t1;
                                }
                                rgb[i] = val * 255;
                            }
                            return rgb;
                        };
                        convert.hsl.hsv = function (hsl) {
                            var h = hsl[0];
                            var s = hsl[1] / 100;
                            var l = hsl[2] / 100;
                            var smin = s;
                            var lmin = Math.max(l, 0.01);
                            var sv;
                            var v;
                            l *= 2;
                            s *= l <= 1 ? l : 2 - l;
                            smin *= lmin <= 1 ? lmin : 2 - lmin;
                            v = (l + s) / 2;
                            sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);
                            return [h, sv * 100, v * 100];
                        };
                        convert.hsv.rgb = function (hsv) {
                            var h = hsv[0] / 60;
                            var s = hsv[1] / 100;
                            var v = hsv[2] / 100;
                            var hi = Math.floor(h) % 6;
                            var f = h - Math.floor(h);
                            var p = 255 * v * (1 - s);
                            var q = 255 * v * (1 - s * f);
                            var t = 255 * v * (1 - s * (1 - f));
                            v *= 255;
                            switch (hi) {
                                case 0:
                                    return [v, t, p];
                                case 1:
                                    return [q, v, p];
                                case 2:
                                    return [p, v, t];
                                case 3:
                                    return [p, q, v];
                                case 4:
                                    return [t, p, v];
                                case 5:
                                    return [v, p, q];
                            }
                        };
                        convert.hsv.hsl = function (hsv) {
                            var h = hsv[0];
                            var s = hsv[1] / 100;
                            var v = hsv[2] / 100;
                            var vmin = Math.max(v, 0.01);
                            var lmin;
                            var sl;
                            var l;
                            l = (2 - s) * v;
                            lmin = (2 - s) * vmin;
                            sl = s * vmin;
                            sl /= lmin <= 1 ? lmin : 2 - lmin;
                            sl = sl || 0;
                            l /= 2;
                            return [h, sl * 100, l * 100];
                        };
                        convert.hwb.rgb = function (hwb) {
                            var h = hwb[0] / 360;
                            var wh = hwb[1] / 100;
                            var bl = hwb[2] / 100;
                            var ratio = wh + bl;
                            var i;
                            var v;
                            var f;
                            var n;
                            if (ratio > 1) {
                                wh /= ratio;
                                bl /= ratio;
                            }
                            i = Math.floor(6 * h);
                            v = 1 - bl;
                            f = 6 * h - i;
                            if ((i & 1) !== 0) {
                                f = 1 - f;
                            }
                            n = wh + f * (v - wh);
                            var r;
                            var g;
                            var b;
                            switch (i) {
                                default:
                                case 6:
                                case 0:
                                    r = v;
                                    g = n;
                                    b = wh;
                                    break;
                                case 1:
                                    r = n;
                                    g = v;
                                    b = wh;
                                    break;
                                case 2:
                                    r = wh;
                                    g = v;
                                    b = n;
                                    break;
                                case 3:
                                    r = wh;
                                    g = n;
                                    b = v;
                                    break;
                                case 4:
                                    r = n;
                                    g = wh;
                                    b = v;
                                    break;
                                case 5:
                                    r = v;
                                    g = wh;
                                    b = n;
                                    break;
                            }
                            return [r * 255, g * 255, b * 255];
                        };
                        convert.cmyk.rgb = function (cmyk) {
                            var c = cmyk[0] / 100;
                            var m = cmyk[1] / 100;
                            var y = cmyk[2] / 100;
                            var k = cmyk[3] / 100;
                            var r;
                            var g;
                            var b;
                            r = 1 - Math.min(1, c * (1 - k) + k);
                            g = 1 - Math.min(1, m * (1 - k) + k);
                            b = 1 - Math.min(1, y * (1 - k) + k);
                            return [r * 255, g * 255, b * 255];
                        };
                        convert.xyz.rgb = function (xyz) {
                            var x = xyz[0] / 100;
                            var y = xyz[1] / 100;
                            var z = xyz[2] / 100;
                            var r;
                            var g;
                            var b;
                            r = x * 3.2406 + y * -1.5372 + z * -0.4986;
                            g = x * -0.9689 + y * 1.8758 + z * 0.0415;
                            b = x * 0.0557 + y * -0.204 + z * 1.057;
                            r = r > 0.0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
                            g = g > 0.0031308 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
                            b = b > 0.0031308 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
                            r = Math.min(Math.max(0, r), 1);
                            g = Math.min(Math.max(0, g), 1);
                            b = Math.min(Math.max(0, b), 1);
                            return [r * 255, g * 255, b * 255];
                        };
                        convert.xyz.lab = function (xyz) {
                            var x = xyz[0];
                            var y = xyz[1];
                            var z = xyz[2];
                            var l;
                            var a;
                            var b;
                            x /= 95.047;
                            y /= 100;
                            z /= 108.883;
                            x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
                            y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
                            z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
                            l = 116 * y - 16;
                            a = 500 * (x - y);
                            b = 200 * (y - z);
                            return [l, a, b];
                        };
                        convert.lab.xyz = function (lab) {
                            var l = lab[0];
                            var a = lab[1];
                            var b = lab[2];
                            var x;
                            var y;
                            var z;
                            y = (l + 16) / 116;
                            x = a / 500 + y;
                            z = y - b / 200;
                            var y2 = Math.pow(y, 3);
                            var x2 = Math.pow(x, 3);
                            var z2 = Math.pow(z, 3);
                            y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
                            x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
                            z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
                            x *= 95.047;
                            y *= 100;
                            z *= 108.883;
                            return [x, y, z];
                        };
                        convert.lab.lch = function (lab) {
                            var l = lab[0];
                            var a = lab[1];
                            var b = lab[2];
                            var hr;
                            var h;
                            var c;
                            hr = Math.atan2(b, a);
                            h = (hr * 360) / 2 / Math.PI;
                            if (h < 0) {
                                h += 360;
                            }
                            c = Math.sqrt(a * a + b * b);
                            return [l, c, h];
                        };
                        convert.lch.lab = function (lch) {
                            var l = lch[0];
                            var c = lch[1];
                            var h = lch[2];
                            var a;
                            var b;
                            var hr;
                            hr = (h / 360) * 2 * Math.PI;
                            a = c * Math.cos(hr);
                            b = c * Math.sin(hr);
                            return [l, a, b];
                        };
                        convert.rgb.ansi16 = function (args) {
                            var r = args[0];
                            var g = args[1];
                            var b = args[2];
                            var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
                            value = Math.round(value / 50);
                            if (value === 0) {
                                return 30;
                            }
                            var ansi = 30 + ((Math.round(b / 255) << 2) | (Math.round(g / 255) << 1) | Math.round(r / 255));
                            if (value === 2) {
                                ansi += 60;
                            }
                            return ansi;
                        };
                        convert.hsv.ansi16 = function (args) {
                            return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
                        };
                        convert.rgb.ansi256 = function (args) {
                            var r = args[0];
                            var g = args[1];
                            var b = args[2];
                            if (r === g && g === b) {
                                if (r < 8) {
                                    return 16;
                                }
                                if (r > 248) {
                                    return 231;
                                }
                                return Math.round(((r - 8) / 247) * 24) + 232;
                            }
                            var ansi = 16 + 36 * Math.round((r / 255) * 5) + 6 * Math.round((g / 255) * 5) + Math.round((b / 255) * 5);
                            return ansi;
                        };
                        convert.ansi16.rgb = function (args) {
                            var color = args % 10;
                            if (color === 0 || color === 7) {
                                if (args > 50) {
                                    color += 3.5;
                                }
                                color = (color / 10.5) * 255;
                                return [color, color, color];
                            }
                            var mult = (~~(args > 50) + 1) * 0.5;
                            var r = (color & 1) * mult * 255;
                            var g = ((color >> 1) & 1) * mult * 255;
                            var b = ((color >> 2) & 1) * mult * 255;
                            return [r, g, b];
                        };
                        convert.ansi256.rgb = function (args) {
                            if (args >= 232) {
                                var c = (args - 232) * 10 + 8;
                                return [c, c, c];
                            }
                            args -= 16;
                            var rem;
                            var r = (Math.floor(args / 36) / 5) * 255;
                            var g = (Math.floor((rem = args % 36) / 6) / 5) * 255;
                            var b = ((rem % 6) / 5) * 255;
                            return [r, g, b];
                        };
                        convert.rgb.hex = function (args) {
                            var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
                            var string = integer.toString(16).toUpperCase();
                            return "000000".substring(string.length) + string;
                        };
                        convert.hex.rgb = function (args) {
                            var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
                            if (!match) {
                                return [0, 0, 0];
                            }
                            var colorString = match[0];
                            if (match[0].length === 3) {
                                colorString = colorString
                                    .split("")
                                    .map(function (char) {
                                        return char + char;
                                    })
                                    .join("");
                            }
                            var integer = parseInt(colorString, 16);
                            var r = (integer >> 16) & 255;
                            var g = (integer >> 8) & 255;
                            var b = integer & 255;
                            return [r, g, b];
                        };
                        convert.rgb.hcg = function (rgb) {
                            var r = rgb[0] / 255;
                            var g = rgb[1] / 255;
                            var b = rgb[2] / 255;
                            var max = Math.max(Math.max(r, g), b);
                            var min = Math.min(Math.min(r, g), b);
                            var chroma = max - min;
                            var grayscale;
                            var hue;
                            if (chroma < 1) {
                                grayscale = min / (1 - chroma);
                            } else {
                                grayscale = 0;
                            }
                            if (chroma <= 0) {
                                hue = 0;
                            } else if (max === r) {
                                hue = ((g - b) / chroma) % 6;
                            } else if (max === g) {
                                hue = 2 + (b - r) / chroma;
                            } else {
                                hue = 4 + (r - g) / chroma + 4;
                            }
                            hue /= 6;
                            hue %= 1;
                            return [hue * 360, chroma * 100, grayscale * 100];
                        };
                        convert.hsl.hcg = function (hsl) {
                            var s = hsl[1] / 100;
                            var l = hsl[2] / 100;
                            var c = 1;
                            var f = 0;
                            if (l < 0.5) {
                                c = 2 * s * l;
                            } else {
                                c = 2 * s * (1 - l);
                            }
                            if (c < 1) {
                                f = (l - 0.5 * c) / (1 - c);
                            }
                            return [hsl[0], c * 100, f * 100];
                        };
                        convert.hsv.hcg = function (hsv) {
                            var s = hsv[1] / 100;
                            var v = hsv[2] / 100;
                            var c = s * v;
                            var f = 0;
                            if (c < 1) {
                                f = (v - c) / (1 - c);
                            }
                            return [hsv[0], c * 100, f * 100];
                        };
                        convert.hcg.rgb = function (hcg) {
                            var h = hcg[0] / 360;
                            var c = hcg[1] / 100;
                            var g = hcg[2] / 100;
                            if (c === 0) {
                                return [g * 255, g * 255, g * 255];
                            }
                            var pure = [0, 0, 0];
                            var hi = (h % 1) * 6;
                            var v = hi % 1;
                            var w = 1 - v;
                            var mg = 0;
                            switch (Math.floor(hi)) {
                                case 0:
                                    pure[0] = 1;
                                    pure[1] = v;
                                    pure[2] = 0;
                                    break;
                                case 1:
                                    pure[0] = w;
                                    pure[1] = 1;
                                    pure[2] = 0;
                                    break;
                                case 2:
                                    pure[0] = 0;
                                    pure[1] = 1;
                                    pure[2] = v;
                                    break;
                                case 3:
                                    pure[0] = 0;
                                    pure[1] = w;
                                    pure[2] = 1;
                                    break;
                                case 4:
                                    pure[0] = v;
                                    pure[1] = 0;
                                    pure[2] = 1;
                                    break;
                                default:
                                    pure[0] = 1;
                                    pure[1] = 0;
                                    pure[2] = w;
                            }
                            mg = (1 - c) * g;
                            return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
                        };
                        convert.hcg.hsv = function (hcg) {
                            var c = hcg[1] / 100;
                            var g = hcg[2] / 100;
                            var v = c + g * (1 - c);
                            var f = 0;
                            if (v > 0) {
                                f = c / v;
                            }
                            return [hcg[0], f * 100, v * 100];
                        };
                        convert.hcg.hsl = function (hcg) {
                            var c = hcg[1] / 100;
                            var g = hcg[2] / 100;
                            var l = g * (1 - c) + 0.5 * c;
                            var s = 0;
                            if (l > 0 && l < 0.5) {
                                s = c / (2 * l);
                            } else if (l >= 0.5 && l < 1) {
                                s = c / (2 * (1 - l));
                            }
                            return [hcg[0], s * 100, l * 100];
                        };
                        convert.hcg.hwb = function (hcg) {
                            var c = hcg[1] / 100;
                            var g = hcg[2] / 100;
                            var v = c + g * (1 - c);
                            return [hcg[0], (v - c) * 100, (1 - v) * 100];
                        };
                        convert.hwb.hcg = function (hwb) {
                            var w = hwb[1] / 100;
                            var b = hwb[2] / 100;
                            var v = 1 - b;
                            var c = v - w;
                            var g = 0;
                            if (c < 1) {
                                g = (v - c) / (1 - c);
                            }
                            return [hwb[0], c * 100, g * 100];
                        };
                        convert.apple.rgb = function (apple) {
                            return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
                        };
                        convert.rgb.apple = function (rgb) {
                            return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
                        };
                        convert.gray.rgb = function (args) {
                            return [(args[0] / 100) * 255, (args[0] / 100) * 255, (args[0] / 100) * 255];
                        };
                        convert.gray.hsl = convert.gray.hsv = function (args) {
                            return [0, 0, args[0]];
                        };
                        convert.gray.hwb = function (gray) {
                            return [0, 100, gray[0]];
                        };
                        convert.gray.cmyk = function (gray) {
                            return [0, 0, 0, gray[0]];
                        };
                        convert.gray.lab = function (gray) {
                            return [gray[0], 0, 0];
                        };
                        convert.gray.hex = function (gray) {
                            var val = Math.round((gray[0] / 100) * 255) & 255;
                            var integer = (val << 16) + (val << 8) + val;
                            var string = integer.toString(16).toUpperCase();
                            return "000000".substring(string.length) + string;
                        };
                        convert.rgb.gray = function (rgb) {
                            var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
                            return [(val / 255) * 100];
                        };
                    });
                    var conversions_1 = conversions.rgb;
                    var conversions_2 = conversions.hsl;
                    var conversions_3 = conversions.hsv;
                    var conversions_4 = conversions.hwb;
                    var conversions_5 = conversions.cmyk;
                    var conversions_6 = conversions.xyz;
                    var conversions_7 = conversions.lab;
                    var conversions_8 = conversions.lch;
                    var conversions_9 = conversions.hex;
                    var conversions_10 = conversions.keyword;
                    var conversions_11 = conversions.ansi16;
                    var conversions_12 = conversions.ansi256;
                    var conversions_13 = conversions.hcg;
                    var conversions_14 = conversions.apple;
                    var conversions_15 = conversions.gray;
                    function buildGraph() {
                        var graph = {};
                        var models = Object.keys(conversions);
                        for (var len = models.length, i = 0; i < len; i++) {
                            graph[models[i]] = { distance: -1, parent: null };
                        }
                        return graph;
                    }
                    function deriveBFS(fromModel) {
                        var graph = buildGraph();
                        var queue = [fromModel];
                        graph[fromModel].distance = 0;
                        while (queue.length) {
                            var current = queue.pop();
                            var adjacents = Object.keys(conversions[current]);
                            for (var len = adjacents.length, i = 0; i < len; i++) {
                                var adjacent = adjacents[i];
                                var node = graph[adjacent];
                                if (node.distance === -1) {
                                    node.distance = graph[current].distance + 1;
                                    node.parent = current;
                                    queue.unshift(adjacent);
                                }
                            }
                        }
                        return graph;
                    }
                    function link(from, to) {
                        return function (args) {
                            return to(from(args));
                        };
                    }
                    function wrapConversion(toModel, graph) {
                        var path = [graph[toModel].parent, toModel];
                        var fn = conversions[graph[toModel].parent][toModel];
                        var cur = graph[toModel].parent;
                        while (graph[cur].parent) {
                            path.unshift(graph[cur].parent);
                            fn = link(conversions[graph[cur].parent][cur], fn);
                            cur = graph[cur].parent;
                        }
                        fn.conversion = path;
                        return fn;
                    }
                    var route = function (fromModel) {
                        var graph = deriveBFS(fromModel);
                        var conversion = {};
                        var models = Object.keys(graph);
                        for (var len = models.length, i = 0; i < len; i++) {
                            var toModel = models[i];
                            var node = graph[toModel];
                            if (node.parent === null) {
                                continue;
                            }
                            conversion[toModel] = wrapConversion(toModel, graph);
                        }
                        return conversion;
                    };
                    var convert = {};
                    var models = Object.keys(conversions);
                    function wrapRaw(fn) {
                        var wrappedFn = function (args) {
                            if (args === undefined || args === null) {
                                return args;
                            }
                            if (arguments.length > 1) {
                                args = Array.prototype.slice.call(arguments);
                            }
                            return fn(args);
                        };
                        if ("conversion" in fn) {
                            wrappedFn.conversion = fn.conversion;
                        }
                        return wrappedFn;
                    }
                    function wrapRounded(fn) {
                        var wrappedFn = function (args) {
                            if (args === undefined || args === null) {
                                return args;
                            }
                            if (arguments.length > 1) {
                                args = Array.prototype.slice.call(arguments);
                            }
                            var result = fn(args);
                            if (typeof result === "object") {
                                for (var len = result.length, i = 0; i < len; i++) {
                                    result[i] = Math.round(result[i]);
                                }
                            }
                            return result;
                        };
                        if ("conversion" in fn) {
                            wrappedFn.conversion = fn.conversion;
                        }
                        return wrappedFn;
                    }
                    models.forEach(function (fromModel) {
                        convert[fromModel] = {};
                        Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
                        Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
                        var routes = route(fromModel);
                        var routeModels = Object.keys(routes);
                        routeModels.forEach(function (toModel) {
                            var fn = routes[toModel];
                            convert[fromModel][toModel] = wrapRounded(fn);
                            convert[fromModel][toModel].raw = wrapRaw(fn);
                        });
                    });
                    var colorConvert = convert;
                    var colorName$1 = {
                        aliceblue: [240, 248, 255],
                        antiquewhite: [250, 235, 215],
                        aqua: [0, 255, 255],
                        aquamarine: [127, 255, 212],
                        azure: [240, 255, 255],
                        beige: [245, 245, 220],
                        bisque: [255, 228, 196],
                        black: [0, 0, 0],
                        blanchedalmond: [255, 235, 205],
                        blue: [0, 0, 255],
                        blueviolet: [138, 43, 226],
                        brown: [165, 42, 42],
                        burlywood: [222, 184, 135],
                        cadetblue: [95, 158, 160],
                        chartreuse: [127, 255, 0],
                        chocolate: [210, 105, 30],
                        coral: [255, 127, 80],
                        cornflowerblue: [100, 149, 237],
                        cornsilk: [255, 248, 220],
                        crimson: [220, 20, 60],
                        cyan: [0, 255, 255],
                        darkblue: [0, 0, 139],
                        darkcyan: [0, 139, 139],
                        darkgoldenrod: [184, 134, 11],
                        darkgray: [169, 169, 169],
                        darkgreen: [0, 100, 0],
                        darkgrey: [169, 169, 169],
                        darkkhaki: [189, 183, 107],
                        darkmagenta: [139, 0, 139],
                        darkolivegreen: [85, 107, 47],
                        darkorange: [255, 140, 0],
                        darkorchid: [153, 50, 204],
                        darkred: [139, 0, 0],
                        darksalmon: [233, 150, 122],
                        darkseagreen: [143, 188, 143],
                        darkslateblue: [72, 61, 139],
                        darkslategray: [47, 79, 79],
                        darkslategrey: [47, 79, 79],
                        darkturquoise: [0, 206, 209],
                        darkviolet: [148, 0, 211],
                        deeppink: [255, 20, 147],
                        deepskyblue: [0, 191, 255],
                        dimgray: [105, 105, 105],
                        dimgrey: [105, 105, 105],
                        dodgerblue: [30, 144, 255],
                        firebrick: [178, 34, 34],
                        floralwhite: [255, 250, 240],
                        forestgreen: [34, 139, 34],
                        fuchsia: [255, 0, 255],
                        gainsboro: [220, 220, 220],
                        ghostwhite: [248, 248, 255],
                        gold: [255, 215, 0],
                        goldenrod: [218, 165, 32],
                        gray: [128, 128, 128],
                        green: [0, 128, 0],
                        greenyellow: [173, 255, 47],
                        grey: [128, 128, 128],
                        honeydew: [240, 255, 240],
                        hotpink: [255, 105, 180],
                        indianred: [205, 92, 92],
                        indigo: [75, 0, 130],
                        ivory: [255, 255, 240],
                        khaki: [240, 230, 140],
                        lavender: [230, 230, 250],
                        lavenderblush: [255, 240, 245],
                        lawngreen: [124, 252, 0],
                        lemonchiffon: [255, 250, 205],
                        lightblue: [173, 216, 230],
                        lightcoral: [240, 128, 128],
                        lightcyan: [224, 255, 255],
                        lightgoldenrodyellow: [250, 250, 210],
                        lightgray: [211, 211, 211],
                        lightgreen: [144, 238, 144],
                        lightgrey: [211, 211, 211],
                        lightpink: [255, 182, 193],
                        lightsalmon: [255, 160, 122],
                        lightseagreen: [32, 178, 170],
                        lightskyblue: [135, 206, 250],
                        lightslategray: [119, 136, 153],
                        lightslategrey: [119, 136, 153],
                        lightsteelblue: [176, 196, 222],
                        lightyellow: [255, 255, 224],
                        lime: [0, 255, 0],
                        limegreen: [50, 205, 50],
                        linen: [250, 240, 230],
                        magenta: [255, 0, 255],
                        maroon: [128, 0, 0],
                        mediumaquamarine: [102, 205, 170],
                        mediumblue: [0, 0, 205],
                        mediumorchid: [186, 85, 211],
                        mediumpurple: [147, 112, 219],
                        mediumseagreen: [60, 179, 113],
                        mediumslateblue: [123, 104, 238],
                        mediumspringgreen: [0, 250, 154],
                        mediumturquoise: [72, 209, 204],
                        mediumvioletred: [199, 21, 133],
                        midnightblue: [25, 25, 112],
                        mintcream: [245, 255, 250],
                        mistyrose: [255, 228, 225],
                        moccasin: [255, 228, 181],
                        navajowhite: [255, 222, 173],
                        navy: [0, 0, 128],
                        oldlace: [253, 245, 230],
                        olive: [128, 128, 0],
                        olivedrab: [107, 142, 35],
                        orange: [255, 165, 0],
                        orangered: [255, 69, 0],
                        orchid: [218, 112, 214],
                        palegoldenrod: [238, 232, 170],
                        palegreen: [152, 251, 152],
                        paleturquoise: [175, 238, 238],
                        palevioletred: [219, 112, 147],
                        papayawhip: [255, 239, 213],
                        peachpuff: [255, 218, 185],
                        peru: [205, 133, 63],
                        pink: [255, 192, 203],
                        plum: [221, 160, 221],
                        powderblue: [176, 224, 230],
                        purple: [128, 0, 128],
                        rebeccapurple: [102, 51, 153],
                        red: [255, 0, 0],
                        rosybrown: [188, 143, 143],
                        royalblue: [65, 105, 225],
                        saddlebrown: [139, 69, 19],
                        salmon: [250, 128, 114],
                        sandybrown: [244, 164, 96],
                        seagreen: [46, 139, 87],
                        seashell: [255, 245, 238],
                        sienna: [160, 82, 45],
                        silver: [192, 192, 192],
                        skyblue: [135, 206, 235],
                        slateblue: [106, 90, 205],
                        slategray: [112, 128, 144],
                        slategrey: [112, 128, 144],
                        snow: [255, 250, 250],
                        springgreen: [0, 255, 127],
                        steelblue: [70, 130, 180],
                        tan: [210, 180, 140],
                        teal: [0, 128, 128],
                        thistle: [216, 191, 216],
                        tomato: [255, 99, 71],
                        turquoise: [64, 224, 208],
                        violet: [238, 130, 238],
                        wheat: [245, 222, 179],
                        white: [255, 255, 255],
                        whitesmoke: [245, 245, 245],
                        yellow: [255, 255, 0],
                        yellowgreen: [154, 205, 50],
                    };
                    var colorString = {
                        getRgba: getRgba,
                        getHsla: getHsla,
                        getRgb: getRgb,
                        getHsl: getHsl,
                        getHwb: getHwb,
                        getAlpha: getAlpha,
                        hexString: hexString,
                        rgbString: rgbString,
                        rgbaString: rgbaString,
                        percentString: percentString,
                        percentaString: percentaString,
                        hslString: hslString,
                        hslaString: hslaString,
                        hwbString: hwbString,
                        keyword: keyword,
                    };
                    function getRgba(string) {
                        if (!string) {
                            return;
                        }
                        var abbr = /^#([a-fA-F0-9]{3,4})$/i,
                            hex = /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i,
                            rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
                            per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
                            keyword = /(\w+)/;
                        var rgb = [0, 0, 0],
                            a = 1,
                            match = string.match(abbr),
                            hexAlpha = "";
                        if (match) {
                            match = match[1];
                            hexAlpha = match[3];
                            for (var i = 0; i < rgb.length; i++) {
                                rgb[i] = parseInt(match[i] + match[i], 16);
                            }
                            if (hexAlpha) {
                                a = Math.round((parseInt(hexAlpha + hexAlpha, 16) / 255) * 100) / 100;
                            }
                        } else if ((match = string.match(hex))) {
                            hexAlpha = match[2];
                            match = match[1];
                            for (var i = 0; i < rgb.length; i++) {
                                rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
                            }
                            if (hexAlpha) {
                                a = Math.round((parseInt(hexAlpha, 16) / 255) * 100) / 100;
                            }
                        } else if ((match = string.match(rgba))) {
                            for (var i = 0; i < rgb.length; i++) {
                                rgb[i] = parseInt(match[i + 1]);
                            }
                            a = parseFloat(match[4]);
                        } else if ((match = string.match(per))) {
                            for (var i = 0; i < rgb.length; i++) {
                                rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
                            }
                            a = parseFloat(match[4]);
                        } else if ((match = string.match(keyword))) {
                            if (match[1] == "transparent") {
                                return [0, 0, 0, 0];
                            }
                            rgb = colorName$1[match[1]];
                            if (!rgb) {
                                return;
                            }
                        }
                        for (var i = 0; i < rgb.length; i++) {
                            rgb[i] = scale(rgb[i], 0, 255);
                        }
                        if (!a && a != 0) {
                            a = 1;
                        } else {
                            a = scale(a, 0, 1);
                        }
                        rgb[3] = a;
                        return rgb;
                    }
                    function getHsla(string) {
                        if (!string) {
                            return;
                        }
                        var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
                        var match = string.match(hsl);
                        if (match) {
                            var alpha = parseFloat(match[4]);
                            var h = scale(parseInt(match[1]), 0, 360),
                                s = scale(parseFloat(match[2]), 0, 100),
                                l = scale(parseFloat(match[3]), 0, 100),
                                a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
                            return [h, s, l, a];
                        }
                    }
                    function getHwb(string) {
                        if (!string) {
                            return;
                        }
                        var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
                        var match = string.match(hwb);
                        if (match) {
                            var alpha = parseFloat(match[4]);
                            var h = scale(parseInt(match[1]), 0, 360),
                                w = scale(parseFloat(match[2]), 0, 100),
                                b = scale(parseFloat(match[3]), 0, 100),
                                a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
                            return [h, w, b, a];
                        }
                    }
                    function getRgb(string) {
                        var rgba = getRgba(string);
                        return rgba && rgba.slice(0, 3);
                    }
                    function getHsl(string) {
                        var hsla = getHsla(string);
                        return hsla && hsla.slice(0, 3);
                    }
                    function getAlpha(string) {
                        var vals = getRgba(string);
                        if (vals) {
                            return vals[3];
                        } else if ((vals = getHsla(string))) {
                            return vals[3];
                        } else if ((vals = getHwb(string))) {
                            return vals[3];
                        }
                    }
                    function hexString(rgba, a) {
                        var a = a !== undefined && rgba.length === 3 ? a : rgba[3];
                        return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (a >= 0 && a < 1 ? hexDouble(Math.round(a * 255)) : "");
                    }
                    function rgbString(rgba, alpha) {
                        if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
                            return rgbaString(rgba, alpha);
                        }
                        return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
                    }
                    function rgbaString(rgba, alpha) {
                        if (alpha === undefined) {
                            alpha = rgba[3] !== undefined ? rgba[3] : 1;
                        }
                        return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", " + alpha + ")";
                    }
                    function percentString(rgba, alpha) {
                        if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
                            return percentaString(rgba, alpha);
                        }
                        var r = Math.round((rgba[0] / 255) * 100),
                            g = Math.round((rgba[1] / 255) * 100),
                            b = Math.round((rgba[2] / 255) * 100);
                        return "rgb(" + r + "%, " + g + "%, " + b + "%)";
                    }
                    function percentaString(rgba, alpha) {
                        var r = Math.round((rgba[0] / 255) * 100),
                            g = Math.round((rgba[1] / 255) * 100),
                            b = Math.round((rgba[2] / 255) * 100);
                        return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
                    }
                    function hslString(hsla, alpha) {
                        if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {
                            return hslaString(hsla, alpha);
                        }
                        return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
                    }
                    function hslaString(hsla, alpha) {
                        if (alpha === undefined) {
                            alpha = hsla[3] !== undefined ? hsla[3] : 1;
                        }
                        return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + alpha + ")";
                    }
                    function hwbString(hwb, alpha) {
                        if (alpha === undefined) {
                            alpha = hwb[3] !== undefined ? hwb[3] : 1;
                        }
                        return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%" + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
                    }
                    function keyword(rgb) {
                        return reverseNames[rgb.slice(0, 3)];
                    }
                    function scale(num, min, max) {
                        return Math.min(Math.max(min, num), max);
                    }
                    function hexDouble(num) {
                        var str = num.toString(16).toUpperCase();
                        return str.length < 2 ? "0" + str : str;
                    }
                    var reverseNames = {};
                    for (var name in colorName$1) {
                        reverseNames[colorName$1[name]] = name;
                    }
                    var Color = function (obj) {
                        if (obj instanceof Color) {
                            return obj;
                        }
                        if (!(this instanceof Color)) {
                            return new Color(obj);
                        }
                        this.valid = false;
                        this.values = { rgb: [0, 0, 0], hsl: [0, 0, 0], hsv: [0, 0, 0], hwb: [0, 0, 0], cmyk: [0, 0, 0, 0], alpha: 1 };
                        var vals;
                        if (typeof obj === "string") {
                            vals = colorString.getRgba(obj);
                            if (vals) {
                                this.setValues("rgb", vals);
                            } else if ((vals = colorString.getHsla(obj))) {
                                this.setValues("hsl", vals);
                            } else if ((vals = colorString.getHwb(obj))) {
                                this.setValues("hwb", vals);
                            }
                        } else if (typeof obj === "object") {
                            vals = obj;
                            if (vals.r !== undefined || vals.red !== undefined) {
                                this.setValues("rgb", vals);
                            } else if (vals.l !== undefined || vals.lightness !== undefined) {
                                this.setValues("hsl", vals);
                            } else if (vals.v !== undefined || vals.value !== undefined) {
                                this.setValues("hsv", vals);
                            } else if (vals.w !== undefined || vals.whiteness !== undefined) {
                                this.setValues("hwb", vals);
                            } else if (vals.c !== undefined || vals.cyan !== undefined) {
                                this.setValues("cmyk", vals);
                            }
                        }
                    };
                    Color.prototype = {
                        isValid: function () {
                            return this.valid;
                        },
                        rgb: function () {
                            return this.setSpace("rgb", arguments);
                        },
                        hsl: function () {
                            return this.setSpace("hsl", arguments);
                        },
                        hsv: function () {
                            return this.setSpace("hsv", arguments);
                        },
                        hwb: function () {
                            return this.setSpace("hwb", arguments);
                        },
                        cmyk: function () {
                            return this.setSpace("cmyk", arguments);
                        },
                        rgbArray: function () {
                            return this.values.rgb;
                        },
                        hslArray: function () {
                            return this.values.hsl;
                        },
                        hsvArray: function () {
                            return this.values.hsv;
                        },
                        hwbArray: function () {
                            var values = this.values;
                            if (values.alpha !== 1) {
                                return values.hwb.concat([values.alpha]);
                            }
                            return values.hwb;
                        },
                        cmykArray: function () {
                            return this.values.cmyk;
                        },
                        rgbaArray: function () {
                            var values = this.values;
                            return values.rgb.concat([values.alpha]);
                        },
                        hslaArray: function () {
                            var values = this.values;
                            return values.hsl.concat([values.alpha]);
                        },
                        alpha: function (val) {
                            if (val === undefined) {
                                return this.values.alpha;
                            }
                            this.setValues("alpha", val);
                            return this;
                        },
                        red: function (val) {
                            return this.setChannel("rgb", 0, val);
                        },
                        green: function (val) {
                            return this.setChannel("rgb", 1, val);
                        },
                        blue: function (val) {
                            return this.setChannel("rgb", 2, val);
                        },
                        hue: function (val) {
                            if (val) {
                                val %= 360;
                                val = val < 0 ? 360 + val : val;
                            }
                            return this.setChannel("hsl", 0, val);
                        },
                        saturation: function (val) {
                            return this.setChannel("hsl", 1, val);
                        },
                        lightness: function (val) {
                            return this.setChannel("hsl", 2, val);
                        },
                        saturationv: function (val) {
                            return this.setChannel("hsv", 1, val);
                        },
                        whiteness: function (val) {
                            return this.setChannel("hwb", 1, val);
                        },
                        blackness: function (val) {
                            return this.setChannel("hwb", 2, val);
                        },
                        value: function (val) {
                            return this.setChannel("hsv", 2, val);
                        },
                        cyan: function (val) {
                            return this.setChannel("cmyk", 0, val);
                        },
                        magenta: function (val) {
                            return this.setChannel("cmyk", 1, val);
                        },
                        yellow: function (val) {
                            return this.setChannel("cmyk", 2, val);
                        },
                        black: function (val) {
                            return this.setChannel("cmyk", 3, val);
                        },
                        hexString: function () {
                            return colorString.hexString(this.values.rgb);
                        },
                        rgbString: function () {
                            return colorString.rgbString(this.values.rgb, this.values.alpha);
                        },
                        rgbaString: function () {
                            return colorString.rgbaString(this.values.rgb, this.values.alpha);
                        },
                        percentString: function () {
                            return colorString.percentString(this.values.rgb, this.values.alpha);
                        },
                        hslString: function () {
                            return colorString.hslString(this.values.hsl, this.values.alpha);
                        },
                        hslaString: function () {
                            return colorString.hslaString(this.values.hsl, this.values.alpha);
                        },
                        hwbString: function () {
                            return colorString.hwbString(this.values.hwb, this.values.alpha);
                        },
                        keyword: function () {
                            return colorString.keyword(this.values.rgb, this.values.alpha);
                        },
                        rgbNumber: function () {
                            var rgb = this.values.rgb;
                            return (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
                        },
                        luminosity: function () {
                            var rgb = this.values.rgb;
                            var lum = [];
                            for (var i = 0; i < rgb.length; i++) {
                                var chan = rgb[i] / 255;
                                lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
                            }
                            return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
                        },
                        contrast: function (color2) {
                            var lum1 = this.luminosity();
                            var lum2 = color2.luminosity();
                            if (lum1 > lum2) {
                                return (lum1 + 0.05) / (lum2 + 0.05);
                            }
                            return (lum2 + 0.05) / (lum1 + 0.05);
                        },
                        level: function (color2) {
                            var contrastRatio = this.contrast(color2);
                            if (contrastRatio >= 7.1) {
                                return "AAA";
                            }
                            return contrastRatio >= 4.5 ? "AA" : "";
                        },
                        dark: function () {
                            var rgb = this.values.rgb;
                            var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1e3;
                            return yiq < 128;
                        },
                        light: function () {
                            return !this.dark();
                        },
                        negate: function () {
                            var rgb = [];
                            for (var i = 0; i < 3; i++) {
                                rgb[i] = 255 - this.values.rgb[i];
                            }
                            this.setValues("rgb", rgb);
                            return this;
                        },
                        lighten: function (ratio) {
                            var hsl = this.values.hsl;
                            hsl[2] += hsl[2] * ratio;
                            this.setValues("hsl", hsl);
                            return this;
                        },
                        darken: function (ratio) {
                            var hsl = this.values.hsl;
                            hsl[2] -= hsl[2] * ratio;
                            this.setValues("hsl", hsl);
                            return this;
                        },
                        saturate: function (ratio) {
                            var hsl = this.values.hsl;
                            hsl[1] += hsl[1] * ratio;
                            this.setValues("hsl", hsl);
                            return this;
                        },
                        desaturate: function (ratio) {
                            var hsl = this.values.hsl;
                            hsl[1] -= hsl[1] * ratio;
                            this.setValues("hsl", hsl);
                            return this;
                        },
                        whiten: function (ratio) {
                            var hwb = this.values.hwb;
                            hwb[1] += hwb[1] * ratio;
                            this.setValues("hwb", hwb);
                            return this;
                        },
                        blacken: function (ratio) {
                            var hwb = this.values.hwb;
                            hwb[2] += hwb[2] * ratio;
                            this.setValues("hwb", hwb);
                            return this;
                        },
                        greyscale: function () {
                            var rgb = this.values.rgb;
                            var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
                            this.setValues("rgb", [val, val, val]);
                            return this;
                        },
                        clearer: function (ratio) {
                            var alpha = this.values.alpha;
                            this.setValues("alpha", alpha - alpha * ratio);
                            return this;
                        },
                        opaquer: function (ratio) {
                            var alpha = this.values.alpha;
                            this.setValues("alpha", alpha + alpha * ratio);
                            return this;
                        },
                        rotate: function (degrees) {
                            var hsl = this.values.hsl;
                            var hue = (hsl[0] + degrees) % 360;
                            hsl[0] = hue < 0 ? 360 + hue : hue;
                            this.setValues("hsl", hsl);
                            return this;
                        },
                        mix: function (mixinColor, weight) {
                            var color1 = this;
                            var color2 = mixinColor;
                            var p = weight === undefined ? 0.5 : weight;
                            var w = 2 * p - 1;
                            var a = color1.alpha() - color2.alpha();
                            var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
                            var w2 = 1 - w1;
                            return this.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue()).alpha(color1.alpha() * p + color2.alpha() * (1 - p));
                        },
                        toJSON: function () {
                            return this.rgb();
                        },
                        clone: function () {
                            var result = new Color();
                            var source = this.values;
                            var target = result.values;
                            var value, type;
                            for (var prop in source) {
                                if (source.hasOwnProperty(prop)) {
                                    value = source[prop];
                                    type = {}.toString.call(value);
                                    if (type === "[object Array]") {
                                        target[prop] = value.slice(0);
                                    } else if (type === "[object Number]") {
                                        target[prop] = value;
                                    } else {
                                        console.error("unexpected color value:", value);
                                    }
                                }
                            }
                            return result;
                        },
                    };
                    Color.prototype.spaces = {
                        rgb: ["red", "green", "blue"],
                        hsl: ["hue", "saturation", "lightness"],
                        hsv: ["hue", "saturation", "value"],
                        hwb: ["hue", "whiteness", "blackness"],
                        cmyk: ["cyan", "magenta", "yellow", "black"],
                    };
                    Color.prototype.maxes = { rgb: [255, 255, 255], hsl: [360, 100, 100], hsv: [360, 100, 100], hwb: [360, 100, 100], cmyk: [100, 100, 100, 100] };
                    Color.prototype.getValues = function (space) {
                        var values = this.values;
                        var vals = {};
                        for (var i = 0; i < space.length; i++) {
                            vals[space.charAt(i)] = values[space][i];
                        }
                        if (values.alpha !== 1) {
                            vals.a = values.alpha;
                        }
                        return vals;
                    };
                    Color.prototype.setValues = function (space, vals) {
                        var values = this.values;
                        var spaces = this.spaces;
                        var maxes = this.maxes;
                        var alpha = 1;
                        var i;
                        this.valid = true;
                        if (space === "alpha") {
                            alpha = vals;
                        } else if (vals.length) {
                            values[space] = vals.slice(0, space.length);
                            alpha = vals[space.length];
                        } else if (vals[space.charAt(0)] !== undefined) {
                            for (i = 0; i < space.length; i++) {
                                values[space][i] = vals[space.charAt(i)];
                            }
                            alpha = vals.a;
                        } else if (vals[spaces[space][0]] !== undefined) {
                            var chans = spaces[space];
                            for (i = 0; i < space.length; i++) {
                                values[space][i] = vals[chans[i]];
                            }
                            alpha = vals.alpha;
                        }
                        values.alpha = Math.max(0, Math.min(1, alpha === undefined ? values.alpha : alpha));
                        if (space === "alpha") {
                            return false;
                        }
                        var capped;
                        for (i = 0; i < space.length; i++) {
                            capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
                            values[space][i] = Math.round(capped);
                        }
                        for (var sname in spaces) {
                            if (sname !== space) {
                                values[sname] = colorConvert[space][sname](values[space]);
                            }
                        }
                        return true;
                    };
                    Color.prototype.setSpace = function (space, args) {
                        var vals = args[0];
                        if (vals === undefined) {
                            return this.getValues(space);
                        }
                        if (typeof vals === "number") {
                            vals = Array.prototype.slice.call(args);
                        }
                        this.setValues(space, vals);
                        return this;
                    };
                    Color.prototype.setChannel = function (space, index, val) {
                        var svalues = this.values[space];
                        if (val === undefined) {
                            return svalues[index];
                        } else if (val === svalues[index]) {
                            return this;
                        }
                        svalues[index] = val;
                        this.setValues(space, svalues);
                        return this;
                    };
                    if (typeof window !== "undefined") {
                        window.Color = Color;
                    }
                    var chartjsColor = Color;
                    function isValidKey(key) {
                        return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
                    }
                    var helpers = {
                        noop: function () {},
                        uid: (function () {
                            var id = 0;
                            return function () {
                                return id++;
                            };
                        })(),
                        isNullOrUndef: function (value) {
                            return value === null || typeof value === "undefined";
                        },
                        isArray: function (value) {
                            if (Array.isArray && Array.isArray(value)) {
                                return true;
                            }
                            var type = Object.prototype.toString.call(value);
                            if (type.substr(0, 7) === "[object" && type.substr(-6) === "Array]") {
                                return true;
                            }
                            return false;
                        },
                        isObject: function (value) {
                            return value !== null && Object.prototype.toString.call(value) === "[object Object]";
                        },
                        isFinite: function (value) {
                            return (typeof value === "number" || value instanceof Number) && isFinite(value);
                        },
                        valueOrDefault: function (value, defaultValue) {
                            return typeof value === "undefined" ? defaultValue : value;
                        },
                        valueAtIndexOrDefault: function (value, index, defaultValue) {
                            return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
                        },
                        callback: function (fn, args, thisArg) {
                            if (fn && typeof fn.call === "function") {
                                return fn.apply(thisArg, args);
                            }
                        },
                        each: function (loopable, fn, thisArg, reverse) {
                            var i, len, keys;
                            if (helpers.isArray(loopable)) {
                                len = loopable.length;
                                if (reverse) {
                                    for (i = len - 1; i >= 0; i--) {
                                        fn.call(thisArg, loopable[i], i);
                                    }
                                } else {
                                    for (i = 0; i < len; i++) {
                                        fn.call(thisArg, loopable[i], i);
                                    }
                                }
                            } else if (helpers.isObject(loopable)) {
                                keys = Object.keys(loopable);
                                len = keys.length;
                                for (i = 0; i < len; i++) {
                                    fn.call(thisArg, loopable[keys[i]], keys[i]);
                                }
                            }
                        },
                        arrayEquals: function (a0, a1) {
                            var i, ilen, v0, v1;
                            if (!a0 || !a1 || a0.length !== a1.length) {
                                return false;
                            }
                            for (i = 0, ilen = a0.length; i < ilen; ++i) {
                                v0 = a0[i];
                                v1 = a1[i];
                                if (v0 instanceof Array && v1 instanceof Array) {
                                    if (!helpers.arrayEquals(v0, v1)) {
                                        return false;
                                    }
                                } else if (v0 !== v1) {
                                    return false;
                                }
                            }
                            return true;
                        },
                        clone: function (source) {
                            if (helpers.isArray(source)) {
                                return source.map(helpers.clone);
                            }
                            if (helpers.isObject(source)) {
                                var target = Object.create(source);
                                var keys = Object.keys(source);
                                var klen = keys.length;
                                var k = 0;
                                for (; k < klen; ++k) {
                                    target[keys[k]] = helpers.clone(source[keys[k]]);
                                }
                                return target;
                            }
                            return source;
                        },
                        _merger: function (key, target, source, options) {
                            if (!isValidKey(key)) {
                                return;
                            }
                            var tval = target[key];
                            var sval = source[key];
                            if (helpers.isObject(tval) && helpers.isObject(sval)) {
                                helpers.merge(tval, sval, options);
                            } else {
                                target[key] = helpers.clone(sval);
                            }
                        },
                        _mergerIf: function (key, target, source) {
                            if (!isValidKey(key)) {
                                return;
                            }
                            var tval = target[key];
                            var sval = source[key];
                            if (helpers.isObject(tval) && helpers.isObject(sval)) {
                                helpers.mergeIf(tval, sval);
                            } else if (!target.hasOwnProperty(key)) {
                                target[key] = helpers.clone(sval);
                            }
                        },
                        merge: function (target, source, options) {
                            var sources = helpers.isArray(source) ? source : [source];
                            var ilen = sources.length;
                            var merge, i, keys, klen, k;
                            if (!helpers.isObject(target)) {
                                return target;
                            }
                            options = options || {};
                            merge = options.merger || helpers._merger;
                            for (i = 0; i < ilen; ++i) {
                                source = sources[i];
                                if (!helpers.isObject(source)) {
                                    continue;
                                }
                                keys = Object.keys(source);
                                for (k = 0, klen = keys.length; k < klen; ++k) {
                                    merge(keys[k], target, source, options);
                                }
                            }
                            return target;
                        },
                        mergeIf: function (target, source) {
                            return helpers.merge(target, source, { merger: helpers._mergerIf });
                        },
                        extend:
                            Object.assign ||
                            function (target) {
                                return helpers.merge(target, [].slice.call(arguments, 1), {
                                    merger: function (key, dst, src) {
                                        dst[key] = src[key];
                                    },
                                });
                            },
                        inherits: function (extensions) {
                            var me = this;
                            var ChartElement =
                                extensions && extensions.hasOwnProperty("constructor")
                                    ? extensions.constructor
                                    : function () {
                                          return me.apply(this, arguments);
                                      };
                            var Surrogate = function () {
                                this.constructor = ChartElement;
                            };
                            Surrogate.prototype = me.prototype;
                            ChartElement.prototype = new Surrogate();
                            ChartElement.extend = helpers.inherits;
                            if (extensions) {
                                helpers.extend(ChartElement.prototype, extensions);
                            }
                            ChartElement.__super__ = me.prototype;
                            return ChartElement;
                        },
                        _deprecated: function (scope, value, previous, current) {
                            if (value !== undefined) {
                                console.warn(scope + ': "' + previous + '" is deprecated. Please use "' + current + '" instead');
                            }
                        },
                    };
                    var helpers_core = helpers;
                    helpers.callCallback = helpers.callback;
                    helpers.indexOf = function (array, item, fromIndex) {
                        return Array.prototype.indexOf.call(array, item, fromIndex);
                    };
                    helpers.getValueOrDefault = helpers.valueOrDefault;
                    helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
                    var effects = {
                        linear: function (t) {
                            return t;
                        },
                        easeInQuad: function (t) {
                            return t * t;
                        },
                        easeOutQuad: function (t) {
                            return -t * (t - 2);
                        },
                        easeInOutQuad: function (t) {
                            if ((t /= 0.5) < 1) {
                                return 0.5 * t * t;
                            }
                            return -0.5 * (--t * (t - 2) - 1);
                        },
                        easeInCubic: function (t) {
                            return t * t * t;
                        },
                        easeOutCubic: function (t) {
                            return (t = t - 1) * t * t + 1;
                        },
                        easeInOutCubic: function (t) {
                            if ((t /= 0.5) < 1) {
                                return 0.5 * t * t * t;
                            }
                            return 0.5 * ((t -= 2) * t * t + 2);
                        },
                        easeInQuart: function (t) {
                            return t * t * t * t;
                        },
                        easeOutQuart: function (t) {
                            return -((t = t - 1) * t * t * t - 1);
                        },
                        easeInOutQuart: function (t) {
                            if ((t /= 0.5) < 1) {
                                return 0.5 * t * t * t * t;
                            }
                            return -0.5 * ((t -= 2) * t * t * t - 2);
                        },
                        easeInQuint: function (t) {
                            return t * t * t * t * t;
                        },
                        easeOutQuint: function (t) {
                            return (t = t - 1) * t * t * t * t + 1;
                        },
                        easeInOutQuint: function (t) {
                            if ((t /= 0.5) < 1) {
                                return 0.5 * t * t * t * t * t;
                            }
                            return 0.5 * ((t -= 2) * t * t * t * t + 2);
                        },
                        easeInSine: function (t) {
                            return -Math.cos(t * (Math.PI / 2)) + 1;
                        },
                        easeOutSine: function (t) {
                            return Math.sin(t * (Math.PI / 2));
                        },
                        easeInOutSine: function (t) {
                            return -0.5 * (Math.cos(Math.PI * t) - 1);
                        },
                        easeInExpo: function (t) {
                            return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));
                        },
                        easeOutExpo: function (t) {
                            return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;
                        },
                        easeInOutExpo: function (t) {
                            if (t === 0) {
                                return 0;
                            }
                            if (t === 1) {
                                return 1;
                            }
                            if ((t /= 0.5) < 1) {
                                return 0.5 * Math.pow(2, 10 * (t - 1));
                            }
                            return 0.5 * (-Math.pow(2, -10 * --t) + 2);
                        },
                        easeInCirc: function (t) {
                            if (t >= 1) {
                                return t;
                            }
                            return -(Math.sqrt(1 - t * t) - 1);
                        },
                        easeOutCirc: function (t) {
                            return Math.sqrt(1 - (t = t - 1) * t);
                        },
                        easeInOutCirc: function (t) {
                            if ((t /= 0.5) < 1) {
                                return -0.5 * (Math.sqrt(1 - t * t) - 1);
                            }
                            return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
                        },
                        easeInElastic: function (t) {
                            var s = 1.70158;
                            var p = 0;
                            var a = 1;
                            if (t === 0) {
                                return 0;
                            }
                            if (t === 1) {
                                return 1;
                            }
                            if (!p) {
                                p = 0.3;
                            }
                            if (a < 1) {
                                a = 1;
                                s = p / 4;
                            } else {
                                s = (p / (2 * Math.PI)) * Math.asin(1 / a);
                            }
                            return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin(((t - s) * (2 * Math.PI)) / p));
                        },
                        easeOutElastic: function (t) {
                            var s = 1.70158;
                            var p = 0;
                            var a = 1;
                            if (t === 0) {
                                return 0;
                            }
                            if (t === 1) {
                                return 1;
                            }
                            if (!p) {
                                p = 0.3;
                            }
                            if (a < 1) {
                                a = 1;
                                s = p / 4;
                            } else {
                                s = (p / (2 * Math.PI)) * Math.asin(1 / a);
                            }
                            return a * Math.pow(2, -10 * t) * Math.sin(((t - s) * (2 * Math.PI)) / p) + 1;
                        },
                        easeInOutElastic: function (t) {
                            var s = 1.70158;
                            var p = 0;
                            var a = 1;
                            if (t === 0) {
                                return 0;
                            }
                            if ((t /= 0.5) === 2) {
                                return 1;
                            }
                            if (!p) {
                                p = 0.45;
                            }
                            if (a < 1) {
                                a = 1;
                                s = p / 4;
                            } else {
                                s = (p / (2 * Math.PI)) * Math.asin(1 / a);
                            }
                            if (t < 1) {
                                return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin(((t - s) * (2 * Math.PI)) / p));
                            }
                            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin(((t - s) * (2 * Math.PI)) / p) * 0.5 + 1;
                        },
                        easeInBack: function (t) {
                            var s = 1.70158;
                            return t * t * ((s + 1) * t - s);
                        },
                        easeOutBack: function (t) {
                            var s = 1.70158;
                            return (t = t - 1) * t * ((s + 1) * t + s) + 1;
                        },
                        easeInOutBack: function (t) {
                            var s = 1.70158;
                            if ((t /= 0.5) < 1) {
                                return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
                            }
                            return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
                        },
                        easeInBounce: function (t) {
                            return 1 - effects.easeOutBounce(1 - t);
                        },
                        easeOutBounce: function (t) {
                            if (t < 1 / 2.75) {
                                return 7.5625 * t * t;
                            }
                            if (t < 2 / 2.75) {
                                return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
                            }
                            if (t < 2.5 / 2.75) {
                                return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
                            }
                            return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
                        },
                        easeInOutBounce: function (t) {
                            if (t < 0.5) {
                                return effects.easeInBounce(t * 2) * 0.5;
                            }
                            return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
                        },
                    };
                    var helpers_easing = { effects: effects };
                    helpers_core.easingEffects = effects;
                    var PI = Math.PI;
                    var RAD_PER_DEG = PI / 180;
                    var DOUBLE_PI = PI * 2;
                    var HALF_PI = PI / 2;
                    var QUARTER_PI = PI / 4;
                    var TWO_THIRDS_PI = (PI * 2) / 3;
                    var exports$1 = {
                        clear: function (chart) {
                            chart.ctx.clearRect(0, 0, chart.width, chart.height);
                        },
                        roundedRect: function (ctx, x, y, width, height, radius) {
                            if (radius) {
                                var r = Math.min(radius, height / 2, width / 2);
                                var left = x + r;
                                var top = y + r;
                                var right = x + width - r;
                                var bottom = y + height - r;
                                ctx.moveTo(x, top);
                                if (left < right && top < bottom) {
                                    ctx.arc(left, top, r, -PI, -HALF_PI);
                                    ctx.arc(right, top, r, -HALF_PI, 0);
                                    ctx.arc(right, bottom, r, 0, HALF_PI);
                                    ctx.arc(left, bottom, r, HALF_PI, PI);
                                } else if (left < right) {
                                    ctx.moveTo(left, y);
                                    ctx.arc(right, top, r, -HALF_PI, HALF_PI);
                                    ctx.arc(left, top, r, HALF_PI, PI + HALF_PI);
                                } else if (top < bottom) {
                                    ctx.arc(left, top, r, -PI, 0);
                                    ctx.arc(left, bottom, r, 0, PI);
                                } else {
                                    ctx.arc(left, top, r, -PI, PI);
                                }
                                ctx.closePath();
                                ctx.moveTo(x, y);
                            } else {
                                ctx.rect(x, y, width, height);
                            }
                        },
                        drawPoint: function (ctx, style, radius, x, y, rotation) {
                            var type, xOffset, yOffset, size, cornerRadius;
                            var rad = (rotation || 0) * RAD_PER_DEG;
                            if (style && typeof style === "object") {
                                type = style.toString();
                                if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
                                    ctx.save();
                                    ctx.translate(x, y);
                                    ctx.rotate(rad);
                                    ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
                                    ctx.restore();
                                    return;
                                }
                            }
                            if (isNaN(radius) || radius <= 0) {
                                return;
                            }
                            ctx.beginPath();
                            switch (style) {
                                default:
                                    ctx.arc(x, y, radius, 0, DOUBLE_PI);
                                    ctx.closePath();
                                    break;
                                case "triangle":
                                    ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
                                    rad += TWO_THIRDS_PI;
                                    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
                                    rad += TWO_THIRDS_PI;
                                    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
                                    ctx.closePath();
                                    break;
                                case "rectRounded":
                                    cornerRadius = radius * 0.516;
                                    size = radius - cornerRadius;
                                    xOffset = Math.cos(rad + QUARTER_PI) * size;
                                    yOffset = Math.sin(rad + QUARTER_PI) * size;
                                    ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
                                    ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
                                    ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
                                    ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
                                    ctx.closePath();
                                    break;
                                case "rect":
                                    if (!rotation) {
                                        size = Math.SQRT1_2 * radius;
                                        ctx.rect(x - size, y - size, 2 * size, 2 * size);
                                        break;
                                    }
                                    rad += QUARTER_PI;
                                case "rectRot":
                                    xOffset = Math.cos(rad) * radius;
                                    yOffset = Math.sin(rad) * radius;
                                    ctx.moveTo(x - xOffset, y - yOffset);
                                    ctx.lineTo(x + yOffset, y - xOffset);
                                    ctx.lineTo(x + xOffset, y + yOffset);
                                    ctx.lineTo(x - yOffset, y + xOffset);
                                    ctx.closePath();
                                    break;
                                case "crossRot":
                                    rad += QUARTER_PI;
                                case "cross":
                                    xOffset = Math.cos(rad) * radius;
                                    yOffset = Math.sin(rad) * radius;
                                    ctx.moveTo(x - xOffset, y - yOffset);
                                    ctx.lineTo(x + xOffset, y + yOffset);
                                    ctx.moveTo(x + yOffset, y - xOffset);
                                    ctx.lineTo(x - yOffset, y + xOffset);
                                    break;
                                case "star":
                                    xOffset = Math.cos(rad) * radius;
                                    yOffset = Math.sin(rad) * radius;
                                    ctx.moveTo(x - xOffset, y - yOffset);
                                    ctx.lineTo(x + xOffset, y + yOffset);
                                    ctx.moveTo(x + yOffset, y - xOffset);
                                    ctx.lineTo(x - yOffset, y + xOffset);
                                    rad += QUARTER_PI;
                                    xOffset = Math.cos(rad) * radius;
                                    yOffset = Math.sin(rad) * radius;
                                    ctx.moveTo(x - xOffset, y - yOffset);
                                    ctx.lineTo(x + xOffset, y + yOffset);
                                    ctx.moveTo(x + yOffset, y - xOffset);
                                    ctx.lineTo(x - yOffset, y + xOffset);
                                    break;
                                case "line":
                                    xOffset = Math.cos(rad) * radius;
                                    yOffset = Math.sin(rad) * radius;
                                    ctx.moveTo(x - xOffset, y - yOffset);
                                    ctx.lineTo(x + xOffset, y + yOffset);
                                    break;
                                case "dash":
                                    ctx.moveTo(x, y);
                                    ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
                                    break;
                            }
                            ctx.fill();
                            ctx.stroke();
                        },
                        _isPointInArea: function (point, area) {
                            var epsilon = 1e-6;
                            return point.x > area.left - epsilon && point.x < area.right + epsilon && point.y > area.top - epsilon && point.y < area.bottom + epsilon;
                        },
                        clipArea: function (ctx, area) {
                            ctx.save();
                            ctx.beginPath();
                            ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
                            ctx.clip();
                        },
                        unclipArea: function (ctx) {
                            ctx.restore();
                        },
                        lineTo: function (ctx, previous, target, flip) {
                            var stepped = target.steppedLine;
                            if (stepped) {
                                if (stepped === "middle") {
                                    var midpoint = (previous.x + target.x) / 2;
                                    ctx.lineTo(midpoint, flip ? target.y : previous.y);
                                    ctx.lineTo(midpoint, flip ? previous.y : target.y);
                                } else if ((stepped === "after" && !flip) || (stepped !== "after" && flip)) {
                                    ctx.lineTo(previous.x, target.y);
                                } else {
                                    ctx.lineTo(target.x, previous.y);
                                }
                                ctx.lineTo(target.x, target.y);
                                return;
                            }
                            if (!target.tension) {
                                ctx.lineTo(target.x, target.y);
                                return;
                            }
                            ctx.bezierCurveTo(
                                flip ? previous.controlPointPreviousX : previous.controlPointNextX,
                                flip ? previous.controlPointPreviousY : previous.controlPointNextY,
                                flip ? target.controlPointNextX : target.controlPointPreviousX,
                                flip ? target.controlPointNextY : target.controlPointPreviousY,
                                target.x,
                                target.y
                            );
                        },
                    };
                    var helpers_canvas = exports$1;
                    helpers_core.clear = exports$1.clear;
                    helpers_core.drawRoundedRectangle = function (ctx) {
                        ctx.beginPath();
                        exports$1.roundedRect.apply(exports$1, arguments);
                    };
                    var defaults = {
                        _set: function (scope, values) {
                            return helpers_core.merge(this[scope] || (this[scope] = {}), values);
                        },
                    };
                    defaults._set("global", {
                        defaultColor: "rgba(0,0,0,0.1)",
                        defaultFontColor: "#666",
                        defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
                        defaultFontSize: 12,
                        defaultFontStyle: "normal",
                        defaultLineHeight: 1.2,
                        showLines: true,
                    });
                    var core_defaults = defaults;
                    var valueOrDefault = helpers_core.valueOrDefault;
                    function toFontString(font) {
                        if (!font || helpers_core.isNullOrUndef(font.size) || helpers_core.isNullOrUndef(font.family)) {
                            return null;
                        }
                        return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
                    }
                    var helpers_options = {
                        toLineHeight: function (value, size) {
                            var matches = ("" + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
                            if (!matches || matches[1] === "normal") {
                                return size * 1.2;
                            }
                            value = +matches[2];
                            switch (matches[3]) {
                                case "px":
                                    return value;
                                case "%":
                                    value /= 100;
                                    break;
                            }
                            return size * value;
                        },
                        toPadding: function (value) {
                            var t, r, b, l;
                            if (helpers_core.isObject(value)) {
                                t = +value.top || 0;
                                r = +value.right || 0;
                                b = +value.bottom || 0;
                                l = +value.left || 0;
                            } else {
                                t = r = b = l = +value || 0;
                            }
                            return { top: t, right: r, bottom: b, left: l, height: t + b, width: l + r };
                        },
                        _parseFont: function (options) {
                            var globalDefaults = core_defaults.global;
                            var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
                            var font = {
                                family: valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily),
                                lineHeight: helpers_core.options.toLineHeight(valueOrDefault(options.lineHeight, globalDefaults.defaultLineHeight), size),
                                size: size,
                                style: valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle),
                                weight: null,
                                string: "",
                            };
                            font.string = toFontString(font);
                            return font;
                        },
                        resolve: function (inputs, context, index, info) {
                            var cacheable = true;
                            var i, ilen, value;
                            for (i = 0, ilen = inputs.length; i < ilen; ++i) {
                                value = inputs[i];
                                if (value === undefined) {
                                    continue;
                                }
                                if (context !== undefined && typeof value === "function") {
                                    value = value(context);
                                    cacheable = false;
                                }
                                if (index !== undefined && helpers_core.isArray(value)) {
                                    value = value[index];
                                    cacheable = false;
                                }
                                if (value !== undefined) {
                                    if (info && !cacheable) {
                                        info.cacheable = false;
                                    }
                                    return value;
                                }
                            }
                        },
                    };
                    var exports$2 = {
                        _factorize: function (value) {
                            var result = [];
                            var sqrt = Math.sqrt(value);
                            var i;
                            for (i = 1; i < sqrt; i++) {
                                if (value % i === 0) {
                                    result.push(i);
                                    result.push(value / i);
                                }
                            }
                            if (sqrt === (sqrt | 0)) {
                                result.push(sqrt);
                            }
                            result
                                .sort(function (a, b) {
                                    return a - b;
                                })
                                .pop();
                            return result;
                        },
                        log10:
                            Math.log10 ||
                            function (x) {
                                var exponent = Math.log(x) * Math.LOG10E;
                                var powerOf10 = Math.round(exponent);
                                var isPowerOf10 = x === Math.pow(10, powerOf10);
                                return isPowerOf10 ? powerOf10 : exponent;
                            },
                    };
                    var helpers_math = exports$2;
                    helpers_core.log10 = exports$2.log10;
                    var getRtlAdapter = function (rectX, width) {
                        return {
                            x: function (x) {
                                return rectX + rectX + width - x;
                            },
                            setWidth: function (w) {
                                width = w;
                            },
                            textAlign: function (align) {
                                if (align === "center") {
                                    return align;
                                }
                                return align === "right" ? "left" : "right";
                            },
                            xPlus: function (x, value) {
                                return x - value;
                            },
                            leftForLtr: function (x, itemWidth) {
                                return x - itemWidth;
                            },
                        };
                    };
                    var getLtrAdapter = function () {
                        return {
                            x: function (x) {
                                return x;
                            },
                            setWidth: function (w) {},
                            textAlign: function (align) {
                                return align;
                            },
                            xPlus: function (x, value) {
                                return x + value;
                            },
                            leftForLtr: function (x, _itemWidth) {
                                return x;
                            },
                        };
                    };
                    var getAdapter = function (rtl, rectX, width) {
                        return rtl ? getRtlAdapter(rectX, width) : getLtrAdapter();
                    };
                    var overrideTextDirection = function (ctx, direction) {
                        var style, original;
                        if (direction === "ltr" || direction === "rtl") {
                            style = ctx.canvas.style;
                            original = [style.getPropertyValue("direction"), style.getPropertyPriority("direction")];
                            style.setProperty("direction", direction, "important");
                            ctx.prevTextDirection = original;
                        }
                    };
                    var restoreTextDirection = function (ctx) {
                        var original = ctx.prevTextDirection;
                        if (original !== undefined) {
                            delete ctx.prevTextDirection;
                            ctx.canvas.style.setProperty("direction", original[0], original[1]);
                        }
                    };
                    var helpers_rtl = { getRtlAdapter: getAdapter, overrideTextDirection: overrideTextDirection, restoreTextDirection: restoreTextDirection };
                    var helpers$1 = helpers_core;
                    var easing = helpers_easing;
                    var canvas = helpers_canvas;
                    var options = helpers_options;
                    var math = helpers_math;
                    var rtl = helpers_rtl;
                    helpers$1.easing = easing;
                    helpers$1.canvas = canvas;
                    helpers$1.options = options;
                    helpers$1.math = math;
                    helpers$1.rtl = rtl;
                    function interpolate(start, view, model, ease) {
                        var keys = Object.keys(model);
                        var i, ilen, key, actual, origin, target, type, c0, c1;
                        for (i = 0, ilen = keys.length; i < ilen; ++i) {
                            key = keys[i];
                            target = model[key];
                            if (!view.hasOwnProperty(key)) {
                                view[key] = target;
                            }
                            actual = view[key];
                            if (actual === target || key[0] === "_") {
                                continue;
                            }
                            if (!start.hasOwnProperty(key)) {
                                start[key] = actual;
                            }
                            origin = start[key];
                            type = typeof target;
                            if (type === typeof origin) {
                                if (type === "string") {
                                    c0 = chartjsColor(origin);
                                    if (c0.valid) {
                                        c1 = chartjsColor(target);
                                        if (c1.valid) {
                                            view[key] = c1.mix(c0, ease).rgbString();
                                            continue;
                                        }
                                    }
                                } else if (helpers$1.isFinite(origin) && helpers$1.isFinite(target)) {
                                    view[key] = origin + (target - origin) * ease;
                                    continue;
                                }
                            }
                            view[key] = target;
                        }
                    }
                    var Element = function (configuration) {
                        helpers$1.extend(this, configuration);
                        this.initialize.apply(this, arguments);
                    };
                    helpers$1.extend(Element.prototype, {
                        _type: undefined,
                        initialize: function () {
                            this.hidden = false;
                        },
                        pivot: function () {
                            var me = this;
                            if (!me._view) {
                                me._view = helpers$1.extend({}, me._model);
                            }
                            me._start = {};
                            return me;
                        },
                        transition: function (ease) {
                            var me = this;
                            var model = me._model;
                            var start = me._start;
                            var view = me._view;
                            if (!model || ease === 1) {
                                me._view = helpers$1.extend({}, model);
                                me._start = null;
                                return me;
                            }
                            if (!view) {
                                view = me._view = {};
                            }
                            if (!start) {
                                start = me._start = {};
                            }
                            interpolate(start, view, model, ease);
                            return me;
                        },
                        tooltipPosition: function () {
                            return { x: this._model.x, y: this._model.y };
                        },
                        hasValue: function () {
                            return helpers$1.isNumber(this._model.x) && helpers$1.isNumber(this._model.y);
                        },
                    });
                    Element.extend = helpers$1.inherits;
                    var core_element = Element;
                    var exports$3 = core_element.extend({ chart: null, currentStep: 0, numSteps: 60, easing: "", render: null, onAnimationProgress: null, onAnimationComplete: null });
                    var core_animation = exports$3;
                    Object.defineProperty(exports$3.prototype, "animationObject", {
                        get: function () {
                            return this;
                        },
                    });
                    Object.defineProperty(exports$3.prototype, "chartInstance", {
                        get: function () {
                            return this.chart;
                        },
                        set: function (value) {
                            this.chart = value;
                        },
                    });
                    core_defaults._set("global", { animation: { duration: 1e3, easing: "easeOutQuart", onProgress: helpers$1.noop, onComplete: helpers$1.noop } });
                    var core_animations = {
                        animations: [],
                        request: null,
                        addAnimation: function (chart, animation, duration, lazy) {
                            var animations = this.animations;
                            var i, ilen;
                            animation.chart = chart;
                            animation.startTime = Date.now();
                            animation.duration = duration;
                            if (!lazy) {
                                chart.animating = true;
                            }
                            for (i = 0, ilen = animations.length; i < ilen; ++i) {
                                if (animations[i].chart === chart) {
                                    animations[i] = animation;
                                    return;
                                }
                            }
                            animations.push(animation);
                            if (animations.length === 1) {
                                this.requestAnimationFrame();
                            }
                        },
                        cancelAnimation: function (chart) {
                            var index = helpers$1.findIndex(this.animations, function (animation) {
                                return animation.chart === chart;
                            });
                            if (index !== -1) {
                                this.animations.splice(index, 1);
                                chart.animating = false;
                            }
                        },
                        requestAnimationFrame: function () {
                            var me = this;
                            if (me.request === null) {
                                me.request = helpers$1.requestAnimFrame.call(window, function () {
                                    me.request = null;
                                    me.startDigest();
                                });
                            }
                        },
                        startDigest: function () {
                            var me = this;
                            me.advance();
                            if (me.animations.length > 0) {
                                me.requestAnimationFrame();
                            }
                        },
                        advance: function () {
                            var animations = this.animations;
                            var animation, chart, numSteps, nextStep;
                            var i = 0;
                            while (i < animations.length) {
                                animation = animations[i];
                                chart = animation.chart;
                                numSteps = animation.numSteps;
                                nextStep = Math.floor(((Date.now() - animation.startTime) / animation.duration) * numSteps) + 1;
                                animation.currentStep = Math.min(nextStep, numSteps);
                                helpers$1.callback(animation.render, [chart, animation], chart);
                                helpers$1.callback(animation.onAnimationProgress, [animation], chart);
                                if (animation.currentStep >= numSteps) {
                                    helpers$1.callback(animation.onAnimationComplete, [animation], chart);
                                    chart.animating = false;
                                    animations.splice(i, 1);
                                } else {
                                    ++i;
                                }
                            }
                        },
                    };
                    var resolve = helpers$1.options.resolve;
                    var arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
                    function listenArrayEvents(array, listener) {
                        if (array._chartjs) {
                            array._chartjs.listeners.push(listener);
                            return;
                        }
                        Object.defineProperty(array, "_chartjs", { configurable: true, enumerable: false, value: { listeners: [listener] } });
                        arrayEvents.forEach(function (key) {
                            var method = "onData" + key.charAt(0).toUpperCase() + key.slice(1);
                            var base = array[key];
                            Object.defineProperty(array, key, {
                                configurable: true,
                                enumerable: false,
                                value: function () {
                                    var args = Array.prototype.slice.call(arguments);
                                    var res = base.apply(this, args);
                                    helpers$1.each(array._chartjs.listeners, function (object) {
                                        if (typeof object[method] === "function") {
                                            object[method].apply(object, args);
                                        }
                                    });
                                    return res;
                                },
                            });
                        });
                    }
                    function unlistenArrayEvents(array, listener) {
                        var stub = array._chartjs;
                        if (!stub) {
                            return;
                        }
                        var listeners = stub.listeners;
                        var index = listeners.indexOf(listener);
                        if (index !== -1) {
                            listeners.splice(index, 1);
                        }
                        if (listeners.length > 0) {
                            return;
                        }
                        arrayEvents.forEach(function (key) {
                            delete array[key];
                        });
                        delete array._chartjs;
                    }
                    var DatasetController = function (chart, datasetIndex) {
                        this.initialize(chart, datasetIndex);
                    };
                    helpers$1.extend(DatasetController.prototype, {
                        datasetElementType: null,
                        dataElementType: null,
                        _datasetElementOptions: ["backgroundColor", "borderCapStyle", "borderColor", "borderDash", "borderDashOffset", "borderJoinStyle", "borderWidth"],
                        _dataElementOptions: ["backgroundColor", "borderColor", "borderWidth", "pointStyle"],
                        initialize: function (chart, datasetIndex) {
                            var me = this;
                            me.chart = chart;
                            me.index = datasetIndex;
                            me.linkScales();
                            me.addElements();
                            me._type = me.getMeta().type;
                        },
                        updateIndex: function (datasetIndex) {
                            this.index = datasetIndex;
                        },
                        linkScales: function () {
                            var me = this;
                            var meta = me.getMeta();
                            var chart = me.chart;
                            var scales = chart.scales;
                            var dataset = me.getDataset();
                            var scalesOpts = chart.options.scales;
                            if (meta.xAxisID === null || !(meta.xAxisID in scales) || dataset.xAxisID) {
                                meta.xAxisID = dataset.xAxisID || scalesOpts.xAxes[0].id;
                            }
                            if (meta.yAxisID === null || !(meta.yAxisID in scales) || dataset.yAxisID) {
                                meta.yAxisID = dataset.yAxisID || scalesOpts.yAxes[0].id;
                            }
                        },
                        getDataset: function () {
                            return this.chart.data.datasets[this.index];
                        },
                        getMeta: function () {
                            return this.chart.getDatasetMeta(this.index);
                        },
                        getScaleForId: function (scaleID) {
                            return this.chart.scales[scaleID];
                        },
                        _getValueScaleId: function () {
                            return this.getMeta().yAxisID;
                        },
                        _getIndexScaleId: function () {
                            return this.getMeta().xAxisID;
                        },
                        _getValueScale: function () {
                            return this.getScaleForId(this._getValueScaleId());
                        },
                        _getIndexScale: function () {
                            return this.getScaleForId(this._getIndexScaleId());
                        },
                        reset: function () {
                            this._update(true);
                        },
                        destroy: function () {
                            if (this._data) {
                                unlistenArrayEvents(this._data, this);
                            }
                        },
                        createMetaDataset: function () {
                            var me = this;
                            var type = me.datasetElementType;
                            return type && new type({ _chart: me.chart, _datasetIndex: me.index });
                        },
                        createMetaData: function (index) {
                            var me = this;
                            var type = me.dataElementType;
                            return type && new type({ _chart: me.chart, _datasetIndex: me.index, _index: index });
                        },
                        addElements: function () {
                            var me = this;
                            var meta = me.getMeta();
                            var data = me.getDataset().data || [];
                            var metaData = meta.data;
                            var i, ilen;
                            for (i = 0, ilen = data.length; i < ilen; ++i) {
                                metaData[i] = metaData[i] || me.createMetaData(i);
                            }
                            meta.dataset = meta.dataset || me.createMetaDataset();
                        },
                        addElementAndReset: function (index) {
                            var element = this.createMetaData(index);
                            this.getMeta().data.splice(index, 0, element);
                            this.updateElement(element, index, true);
                        },
                        buildOrUpdateElements: function () {
                            var me = this;
                            var dataset = me.getDataset();
                            var data = dataset.data || (dataset.data = []);
                            if (me._data !== data) {
                                if (me._data) {
                                    unlistenArrayEvents(me._data, me);
                                }
                                if (data && Object.isExtensible(data)) {
                                    listenArrayEvents(data, me);
                                }
                                me._data = data;
                            }
                            me.resyncElements();
                        },
                        _configure: function () {
                            var me = this;
                            me._config = helpers$1.merge(Object.create(null), [me.chart.options.datasets[me._type], me.getDataset()], {
                                merger: function (key, target, source) {
                                    if (key !== "_meta" && key !== "data") {
                                        helpers$1._merger(key, target, source);
                                    }
                                },
                            });
                        },
                        _update: function (reset) {
                            var me = this;
                            me._configure();
                            me._cachedDataOpts = null;
                            me.update(reset);
                        },
                        update: helpers$1.noop,
                        transition: function (easingValue) {
                            var meta = this.getMeta();
                            var elements = meta.data || [];
                            var ilen = elements.length;
                            var i = 0;
                            for (; i < ilen; ++i) {
                                elements[i].transition(easingValue);
                            }
                            if (meta.dataset) {
                                meta.dataset.transition(easingValue);
                            }
                        },
                        draw: function () {
                            var meta = this.getMeta();
                            var elements = meta.data || [];
                            var ilen = elements.length;
                            var i = 0;
                            if (meta.dataset) {
                                meta.dataset.draw();
                            }
                            for (; i < ilen; ++i) {
                                elements[i].draw();
                            }
                        },
                        getStyle: function (index) {
                            var me = this;
                            var meta = me.getMeta();
                            var dataset = meta.dataset;
                            var style;
                            me._configure();
                            if (dataset && index === undefined) {
                                style = me._resolveDatasetElementOptions(dataset || {});
                            } else {
                                index = index || 0;
                                style = me._resolveDataElementOptions(meta.data[index] || {}, index);
                            }
                            if (style.fill === false || style.fill === null) {
                                style.backgroundColor = style.borderColor;
                            }
                            return style;
                        },
                        _resolveDatasetElementOptions: function (element, hover) {
                            var me = this;
                            var chart = me.chart;
                            var datasetOpts = me._config;
                            var custom = element.custom || {};
                            var options = chart.options.elements[me.datasetElementType.prototype._type] || {};
                            var elementOptions = me._datasetElementOptions;
                            var values = {};
                            var i, ilen, key, readKey;
                            var context = { chart: chart, dataset: me.getDataset(), datasetIndex: me.index, hover: hover };
                            for (i = 0, ilen = elementOptions.length; i < ilen; ++i) {
                                key = elementOptions[i];
                                readKey = hover ? "hover" + key.charAt(0).toUpperCase() + key.slice(1) : key;
                                values[key] = resolve([custom[readKey], datasetOpts[readKey], options[readKey]], context);
                            }
                            return values;
                        },
                        _resolveDataElementOptions: function (element, index) {
                            var me = this;
                            var custom = element && element.custom;
                            var cached = me._cachedDataOpts;
                            if (cached && !custom) {
                                return cached;
                            }
                            var chart = me.chart;
                            var datasetOpts = me._config;
                            var options = chart.options.elements[me.dataElementType.prototype._type] || {};
                            var elementOptions = me._dataElementOptions;
                            var values = {};
                            var context = { chart: chart, dataIndex: index, dataset: me.getDataset(), datasetIndex: me.index };
                            var info = { cacheable: !custom };
                            var keys, i, ilen, key;
                            custom = custom || {};
                            if (helpers$1.isArray(elementOptions)) {
                                for (i = 0, ilen = elementOptions.length; i < ilen; ++i) {
                                    key = elementOptions[i];
                                    values[key] = resolve([custom[key], datasetOpts[key], options[key]], context, index, info);
                                }
                            } else {
                                keys = Object.keys(elementOptions);
                                for (i = 0, ilen = keys.length; i < ilen; ++i) {
                                    key = keys[i];
                                    values[key] = resolve([custom[key], datasetOpts[elementOptions[key]], datasetOpts[key], options[key]], context, index, info);
                                }
                            }
                            if (info.cacheable) {
                                me._cachedDataOpts = Object.freeze(values);
                            }
                            return values;
                        },
                        removeHoverStyle: function (element) {
                            helpers$1.merge(element._model, element.$previousStyle || {});
                            delete element.$previousStyle;
                        },
                        setHoverStyle: function (element) {
                            var dataset = this.chart.data.datasets[element._datasetIndex];
                            var index = element._index;
                            var custom = element.custom || {};
                            var model = element._model;
                            var getHoverColor = helpers$1.getHoverColor;
                            element.$previousStyle = { backgroundColor: model.backgroundColor, borderColor: model.borderColor, borderWidth: model.borderWidth };
                            model.backgroundColor = resolve([custom.hoverBackgroundColor, dataset.hoverBackgroundColor, getHoverColor(model.backgroundColor)], undefined, index);
                            model.borderColor = resolve([custom.hoverBorderColor, dataset.hoverBorderColor, getHoverColor(model.borderColor)], undefined, index);
                            model.borderWidth = resolve([custom.hoverBorderWidth, dataset.hoverBorderWidth, model.borderWidth], undefined, index);
                        },
                        _removeDatasetHoverStyle: function () {
                            var element = this.getMeta().dataset;
                            if (element) {
                                this.removeHoverStyle(element);
                            }
                        },
                        _setDatasetHoverStyle: function () {
                            var element = this.getMeta().dataset;
                            var prev = {};
                            var i, ilen, key, keys, hoverOptions, model;
                            if (!element) {
                                return;
                            }
                            model = element._model;
                            hoverOptions = this._resolveDatasetElementOptions(element, true);
                            keys = Object.keys(hoverOptions);
                            for (i = 0, ilen = keys.length; i < ilen; ++i) {
                                key = keys[i];
                                prev[key] = model[key];
                                model[key] = hoverOptions[key];
                            }
                            element.$previousStyle = prev;
                        },
                        resyncElements: function () {
                            var me = this;
                            var meta = me.getMeta();
                            var data = me.getDataset().data;
                            var numMeta = meta.data.length;
                            var numData = data.length;
                            if (numData < numMeta) {
                                meta.data.splice(numData, numMeta - numData);
                            } else if (numData > numMeta) {
                                me.insertElements(numMeta, numData - numMeta);
                            }
                        },
                        insertElements: function (start, count) {
                            for (var i = 0; i < count; ++i) {
                                this.addElementAndReset(start + i);
                            }
                        },
                        onDataPush: function () {
                            var count = arguments.length;
                            this.insertElements(this.getDataset().data.length - count, count);
                        },
                        onDataPop: function () {
                            this.getMeta().data.pop();
                        },
                        onDataShift: function () {
                            this.getMeta().data.shift();
                        },
                        onDataSplice: function (start, count) {
                            this.getMeta().data.splice(start, count);
                            this.insertElements(start, arguments.length - 2);
                        },
                        onDataUnshift: function () {
                            this.insertElements(0, arguments.length);
                        },
                    });
                    DatasetController.extend = helpers$1.inherits;
                    var core_datasetController = DatasetController;
                    var TAU = Math.PI * 2;
                    core_defaults._set("global", { elements: { arc: { backgroundColor: core_defaults.global.defaultColor, borderColor: "#fff", borderWidth: 2, borderAlign: "center" } } });
                    function clipArc(ctx, arc) {
                        var startAngle = arc.startAngle;
                        var endAngle = arc.endAngle;
                        var pixelMargin = arc.pixelMargin;
                        var angleMargin = pixelMargin / arc.outerRadius;
                        var x = arc.x;
                        var y = arc.y;
                        ctx.beginPath();
                        ctx.arc(x, y, arc.outerRadius, startAngle - angleMargin, endAngle + angleMargin);
                        if (arc.innerRadius > pixelMargin) {
                            angleMargin = pixelMargin / arc.innerRadius;
                            ctx.arc(x, y, arc.innerRadius - pixelMargin, endAngle + angleMargin, startAngle - angleMargin, true);
                        } else {
                            ctx.arc(x, y, pixelMargin, endAngle + Math.PI / 2, startAngle - Math.PI / 2);
                        }
                        ctx.closePath();
                        ctx.clip();
                    }
                    function drawFullCircleBorders(ctx, vm, arc, inner) {
                        var endAngle = arc.endAngle;
                        var i;
                        if (inner) {
                            arc.endAngle = arc.startAngle + TAU;
                            clipArc(ctx, arc);
                            arc.endAngle = endAngle;
                            if (arc.endAngle === arc.startAngle && arc.fullCircles) {
                                arc.endAngle += TAU;
                                arc.fullCircles--;
                            }
                        }
                        ctx.beginPath();
                        ctx.arc(arc.x, arc.y, arc.innerRadius, arc.startAngle + TAU, arc.startAngle, true);
                        for (i = 0; i < arc.fullCircles; ++i) {
                            ctx.stroke();
                        }
                        ctx.beginPath();
                        ctx.arc(arc.x, arc.y, vm.outerRadius, arc.startAngle, arc.startAngle + TAU);
                        for (i = 0; i < arc.fullCircles; ++i) {
                            ctx.stroke();
                        }
                    }
                    function drawBorder(ctx, vm, arc) {
                        var inner = vm.borderAlign === "inner";
                        if (inner) {
                            ctx.lineWidth = vm.borderWidth * 2;
                            ctx.lineJoin = "round";
                        } else {
                            ctx.lineWidth = vm.borderWidth;
                            ctx.lineJoin = "bevel";
                        }
                        if (arc.fullCircles) {
                            drawFullCircleBorders(ctx, vm, arc, inner);
                        }
                        if (inner) {
                            clipArc(ctx, arc);
                        }
                        ctx.beginPath();
                        ctx.arc(arc.x, arc.y, vm.outerRadius, arc.startAngle, arc.endAngle);
                        ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
                        ctx.closePath();
                        ctx.stroke();
                    }
                    var element_arc = core_element.extend({
                        _type: "arc",
                        inLabelRange: function (mouseX) {
                            var vm = this._view;
                            if (vm) {
                                return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);
                            }
                            return false;
                        },
                        inRange: function (chartX, chartY) {
                            var vm = this._view;
                            if (vm) {
                                var pointRelativePosition = helpers$1.getAngleFromPoint(vm, { x: chartX, y: chartY });
                                var angle = pointRelativePosition.angle;
                                var distance = pointRelativePosition.distance;
                                var startAngle = vm.startAngle;
                                var endAngle = vm.endAngle;
                                while (endAngle < startAngle) {
                                    endAngle += TAU;
                                }
                                while (angle > endAngle) {
                                    angle -= TAU;
                                }
                                while (angle < startAngle) {
                                    angle += TAU;
                                }
                                var betweenAngles = angle >= startAngle && angle <= endAngle;
                                var withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;
                                return betweenAngles && withinRadius;
                            }
                            return false;
                        },
                        getCenterPoint: function () {
                            var vm = this._view;
                            var halfAngle = (vm.startAngle + vm.endAngle) / 2;
                            var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
                            return { x: vm.x + Math.cos(halfAngle) * halfRadius, y: vm.y + Math.sin(halfAngle) * halfRadius };
                        },
                        getArea: function () {
                            var vm = this._view;
                            return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
                        },
                        tooltipPosition: function () {
                            var vm = this._view;
                            var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2;
                            var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
                            return { x: vm.x + Math.cos(centreAngle) * rangeFromCentre, y: vm.y + Math.sin(centreAngle) * rangeFromCentre };
                        },
                        draw: function () {
                            var ctx = this._chart.ctx;
                            var vm = this._view;
                            var pixelMargin = vm.borderAlign === "inner" ? 0.33 : 0;
                            var arc = {
                                x: vm.x,
                                y: vm.y,
                                innerRadius: vm.innerRadius,
                                outerRadius: Math.max(vm.outerRadius - pixelMargin, 0),
                                pixelMargin: pixelMargin,
                                startAngle: vm.startAngle,
                                endAngle: vm.endAngle,
                                fullCircles: Math.floor(vm.circumference / TAU),
                            };
                            var i;
                            ctx.save();
                            ctx.fillStyle = vm.backgroundColor;
                            ctx.strokeStyle = vm.borderColor;
                            if (arc.fullCircles) {
                                arc.endAngle = arc.startAngle + TAU;
                                ctx.beginPath();
                                ctx.arc(arc.x, arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);
                                ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
                                ctx.closePath();
                                for (i = 0; i < arc.fullCircles; ++i) {
                                    ctx.fill();
                                }
                                arc.endAngle = arc.startAngle + (vm.circumference % TAU);
                            }
                            ctx.beginPath();
                            ctx.arc(arc.x, arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);
                            ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
                            ctx.closePath();
                            ctx.fill();
                            if (vm.borderWidth) {
                                drawBorder(ctx, vm, arc);
                            }
                            ctx.restore();
                        },
                    });
                    var valueOrDefault$1 = helpers$1.valueOrDefault;
                    var defaultColor = core_defaults.global.defaultColor;
                    core_defaults._set("global", {
                        elements: {
                            line: {
                                tension: 0.4,
                                backgroundColor: defaultColor,
                                borderWidth: 3,
                                borderColor: defaultColor,
                                borderCapStyle: "butt",
                                borderDash: [],
                                borderDashOffset: 0,
                                borderJoinStyle: "miter",
                                capBezierPoints: true,
                                fill: true,
                            },
                        },
                    });
                    var element_line = core_element.extend({
                        _type: "line",
                        draw: function () {
                            var me = this;
                            var vm = me._view;
                            var ctx = me._chart.ctx;
                            var spanGaps = vm.spanGaps;
                            var points = me._children.slice();
                            var globalDefaults = core_defaults.global;
                            var globalOptionLineElements = globalDefaults.elements.line;
                            var lastDrawnIndex = -1;
                            var closePath = me._loop;
                            var index, previous, currentVM;
                            if (!points.length) {
                                return;
                            }
                            if (me._loop) {
                                for (index = 0; index < points.length; ++index) {
                                    previous = helpers$1.previousItem(points, index);
                                    if (!points[index]._view.skip && previous._view.skip) {
                                        points = points.slice(index).concat(points.slice(0, index));
                                        closePath = spanGaps;
                                        break;
                                    }
                                }
                                if (closePath) {
                                    points.push(points[0]);
                                }
                            }
                            ctx.save();
                            ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;
                            if (ctx.setLineDash) {
                                ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
                            }
                            ctx.lineDashOffset = valueOrDefault$1(vm.borderDashOffset, globalOptionLineElements.borderDashOffset);
                            ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
                            ctx.lineWidth = valueOrDefault$1(vm.borderWidth, globalOptionLineElements.borderWidth);
                            ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;
                            ctx.beginPath();
                            currentVM = points[0]._view;
                            if (!currentVM.skip) {
                                ctx.moveTo(currentVM.x, currentVM.y);
                                lastDrawnIndex = 0;
                            }
                            for (index = 1; index < points.length; ++index) {
                                currentVM = points[index]._view;
                                previous = lastDrawnIndex === -1 ? helpers$1.previousItem(points, index) : points[lastDrawnIndex];
                                if (!currentVM.skip) {
                                    if ((lastDrawnIndex !== index - 1 && !spanGaps) || lastDrawnIndex === -1) {
                                        ctx.moveTo(currentVM.x, currentVM.y);
                                    } else {
                                        helpers$1.canvas.lineTo(ctx, previous._view, currentVM);
                                    }
                                    lastDrawnIndex = index;
                                }
                            }
                            if (closePath) {
                                ctx.closePath();
                            }
                            ctx.stroke();
                            ctx.restore();
                        },
                    });
                    var valueOrDefault$2 = helpers$1.valueOrDefault;
                    var defaultColor$1 = core_defaults.global.defaultColor;
                    core_defaults._set("global", { elements: { point: { radius: 3, pointStyle: "circle", backgroundColor: defaultColor$1, borderColor: defaultColor$1, borderWidth: 1, hitRadius: 1, hoverRadius: 4, hoverBorderWidth: 1 } } });
                    function xRange(mouseX) {
                        var vm = this._view;
                        return vm ? Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius : false;
                    }
                    function yRange(mouseY) {
                        var vm = this._view;
                        return vm ? Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius : false;
                    }
                    var element_point = core_element.extend({
                        _type: "point",
                        inRange: function (mouseX, mouseY) {
                            var vm = this._view;
                            return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;
                        },
                        inLabelRange: xRange,
                        inXRange: xRange,
                        inYRange: yRange,
                        getCenterPoint: function () {
                            var vm = this._view;
                            return { x: vm.x, y: vm.y };
                        },
                        getArea: function () {
                            return Math.PI * Math.pow(this._view.radius, 2);
                        },
                        tooltipPosition: function () {
                            var vm = this._view;
                            return { x: vm.x, y: vm.y, padding: vm.radius + vm.borderWidth };
                        },
                        draw: function (chartArea) {
                            var vm = this._view;
                            var ctx = this._chart.ctx;
                            var pointStyle = vm.pointStyle;
                            var rotation = vm.rotation;
                            var radius = vm.radius;
                            var x = vm.x;
                            var y = vm.y;
                            var globalDefaults = core_defaults.global;
                            var defaultColor = globalDefaults.defaultColor;
                            if (vm.skip) {
                                return;
                            }
                            if (chartArea === undefined || helpers$1.canvas._isPointInArea(vm, chartArea)) {
                                ctx.strokeStyle = vm.borderColor || defaultColor;
                                ctx.lineWidth = valueOrDefault$2(vm.borderWidth, globalDefaults.elements.point.borderWidth);
                                ctx.fillStyle = vm.backgroundColor || defaultColor;
                                helpers$1.canvas.drawPoint(ctx, pointStyle, radius, x, y, rotation);
                            }
                        },
                    });
                    var defaultColor$2 = core_defaults.global.defaultColor;
                    core_defaults._set("global", { elements: { rectangle: { backgroundColor: defaultColor$2, borderColor: defaultColor$2, borderSkipped: "bottom", borderWidth: 0 } } });
                    function isVertical(vm) {
                        return vm && vm.width !== undefined;
                    }
                    function getBarBounds(vm) {
                        var x1, x2, y1, y2, half;
                        if (isVertical(vm)) {
                            half = vm.width / 2;
                            x1 = vm.x - half;
                            x2 = vm.x + half;
                            y1 = Math.min(vm.y, vm.base);
                            y2 = Math.max(vm.y, vm.base);
                        } else {
                            half = vm.height / 2;
                            x1 = Math.min(vm.x, vm.base);
                            x2 = Math.max(vm.x, vm.base);
                            y1 = vm.y - half;
                            y2 = vm.y + half;
                        }
                        return { left: x1, top: y1, right: x2, bottom: y2 };
                    }
                    function swap(orig, v1, v2) {
                        return orig === v1 ? v2 : orig === v2 ? v1 : orig;
                    }
                    function parseBorderSkipped(vm) {
                        var edge = vm.borderSkipped;
                        var res = {};
                        if (!edge) {
                            return res;
                        }
                        if (vm.horizontal) {
                            if (vm.base > vm.x) {
                                edge = swap(edge, "left", "right");
                            }
                        } else if (vm.base < vm.y) {
                            edge = swap(edge, "bottom", "top");
                        }
                        res[edge] = true;
                        return res;
                    }
                    function parseBorderWidth(vm, maxW, maxH) {
                        var value = vm.borderWidth;
                        var skip = parseBorderSkipped(vm);
                        var t, r, b, l;
                        if (helpers$1.isObject(value)) {
                            t = +value.top || 0;
                            r = +value.right || 0;
                            b = +value.bottom || 0;
                            l = +value.left || 0;
                        } else {
                            t = r = b = l = +value || 0;
                        }
                        return { t: skip.top || t < 0 ? 0 : t > maxH ? maxH : t, r: skip.right || r < 0 ? 0 : r > maxW ? maxW : r, b: skip.bottom || b < 0 ? 0 : b > maxH ? maxH : b, l: skip.left || l < 0 ? 0 : l > maxW ? maxW : l };
                    }
                    function boundingRects(vm) {
                        var bounds = getBarBounds(vm);
                        var width = bounds.right - bounds.left;
                        var height = bounds.bottom - bounds.top;
                        var border = parseBorderWidth(vm, width / 2, height / 2);
                        return { outer: { x: bounds.left, y: bounds.top, w: width, h: height }, inner: { x: bounds.left + border.l, y: bounds.top + border.t, w: width - border.l - border.r, h: height - border.t - border.b } };
                    }
                    function inRange(vm, x, y) {
                        var skipX = x === null;
                        var skipY = y === null;
                        var bounds = !vm || (skipX && skipY) ? false : getBarBounds(vm);
                        return bounds && (skipX || (x >= bounds.left && x <= bounds.right)) && (skipY || (y >= bounds.top && y <= bounds.bottom));
                    }
                    var element_rectangle = core_element.extend({
                        _type: "rectangle",
                        draw: function () {
                            var ctx = this._chart.ctx;
                            var vm = this._view;
                            var rects = boundingRects(vm);
                            var outer = rects.outer;
                            var inner = rects.inner;
                            ctx.fillStyle = vm.backgroundColor;
                            ctx.fillRect(outer.x, outer.y, outer.w, outer.h);
                            if (outer.w === inner.w && outer.h === inner.h) {
                                return;
                            }
                            ctx.save();
                            ctx.beginPath();
                            ctx.rect(outer.x, outer.y, outer.w, outer.h);
                            ctx.clip();
                            ctx.fillStyle = vm.borderColor;
                            ctx.rect(inner.x, inner.y, inner.w, inner.h);
                            ctx.fill("evenodd");
                            ctx.restore();
                        },
                        height: function () {
                            var vm = this._view;
                            return vm.base - vm.y;
                        },
                        inRange: function (mouseX, mouseY) {
                            return inRange(this._view, mouseX, mouseY);
                        },
                        inLabelRange: function (mouseX, mouseY) {
                            var vm = this._view;
                            return isVertical(vm) ? inRange(vm, mouseX, null) : inRange(vm, null, mouseY);
                        },
                        inXRange: function (mouseX) {
                            return inRange(this._view, mouseX, null);
                        },
                        inYRange: function (mouseY) {
                            return inRange(this._view, null, mouseY);
                        },
                        getCenterPoint: function () {
                            var vm = this._view;
                            var x, y;
                            if (isVertical(vm)) {
                                x = vm.x;
                                y = (vm.y + vm.base) / 2;
                            } else {
                                x = (vm.x + vm.base) / 2;
                                y = vm.y;
                            }
                            return { x: x, y: y };
                        },
                        getArea: function () {
                            var vm = this._view;
                            return isVertical(vm) ? vm.width * Math.abs(vm.y - vm.base) : vm.height * Math.abs(vm.x - vm.base);
                        },
                        tooltipPosition: function () {
                            var vm = this._view;
                            return { x: vm.x, y: vm.y };
                        },
                    });
                    var elements = {};
                    var Arc = element_arc;
                    var Line = element_line;
                    var Point = element_point;
                    var Rectangle = element_rectangle;
                    elements.Arc = Arc;
                    elements.Line = Line;
                    elements.Point = Point;
                    elements.Rectangle = Rectangle;
                    var deprecated = helpers$1._deprecated;
                    var valueOrDefault$3 = helpers$1.valueOrDefault;
                    core_defaults._set("bar", { hover: { mode: "label" }, scales: { xAxes: [{ type: "category", offset: true, gridLines: { offsetGridLines: true } }], yAxes: [{ type: "linear" }] } });
                    core_defaults._set("global", { datasets: { bar: { categoryPercentage: 0.8, barPercentage: 0.9 } } });
                    function computeMinSampleSize(scale, pixels) {
                        var min = scale._length;
                        var prev, curr, i, ilen;
                        for (i = 1, ilen = pixels.length; i < ilen; ++i) {
                            min = Math.min(min, Math.abs(pixels[i] - pixels[i - 1]));
                        }
                        for (i = 0, ilen = scale.getTicks().length; i < ilen; ++i) {
                            curr = scale.getPixelForTick(i);
                            min = i > 0 ? Math.min(min, Math.abs(curr - prev)) : min;
                            prev = curr;
                        }
                        return min;
                    }
                    function computeFitCategoryTraits(index, ruler, options) {
                        var thickness = options.barThickness;
                        var count = ruler.stackCount;
                        var curr = ruler.pixels[index];
                        var min = helpers$1.isNullOrUndef(thickness) ? computeMinSampleSize(ruler.scale, ruler.pixels) : -1;
                        var size, ratio;
                        if (helpers$1.isNullOrUndef(thickness)) {
                            size = min * options.categoryPercentage;
                            ratio = options.barPercentage;
                        } else {
                            size = thickness * count;
                            ratio = 1;
                        }
                        return { chunk: size / count, ratio: ratio, start: curr - size / 2 };
                    }
                    function computeFlexCategoryTraits(index, ruler, options) {
                        var pixels = ruler.pixels;
                        var curr = pixels[index];
                        var prev = index > 0 ? pixels[index - 1] : null;
                        var next = index < pixels.length - 1 ? pixels[index + 1] : null;
                        var percent = options.categoryPercentage;
                        var start, size;
                        if (prev === null) {
                            prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
                        }
                        if (next === null) {
                            next = curr + curr - prev;
                        }
                        start = curr - ((curr - Math.min(prev, next)) / 2) * percent;
                        size = (Math.abs(next - prev) / 2) * percent;
                        return { chunk: size / ruler.stackCount, ratio: options.barPercentage, start: start };
                    }
                    var controller_bar = core_datasetController.extend({
                        dataElementType: elements.Rectangle,
                        _dataElementOptions: ["backgroundColor", "borderColor", "borderSkipped", "borderWidth", "barPercentage", "barThickness", "categoryPercentage", "maxBarThickness", "minBarLength"],
                        initialize: function () {
                            var me = this;
                            var meta, scaleOpts;
                            core_datasetController.prototype.initialize.apply(me, arguments);
                            meta = me.getMeta();
                            meta.stack = me.getDataset().stack;
                            meta.bar = true;
                            scaleOpts = me._getIndexScale().options;
                            deprecated("bar chart", scaleOpts.barPercentage, "scales.[x/y]Axes.barPercentage", "dataset.barPercentage");
                            deprecated("bar chart", scaleOpts.barThickness, "scales.[x/y]Axes.barThickness", "dataset.barThickness");
                            deprecated("bar chart", scaleOpts.categoryPercentage, "scales.[x/y]Axes.categoryPercentage", "dataset.categoryPercentage");
                            deprecated("bar chart", me._getValueScale().options.minBarLength, "scales.[x/y]Axes.minBarLength", "dataset.minBarLength");
                            deprecated("bar chart", scaleOpts.maxBarThickness, "scales.[x/y]Axes.maxBarThickness", "dataset.maxBarThickness");
                        },
                        update: function (reset) {
                            var me = this;
                            var rects = me.getMeta().data;
                            var i, ilen;
                            me._ruler = me.getRuler();
                            for (i = 0, ilen = rects.length; i < ilen; ++i) {
                                me.updateElement(rects[i], i, reset);
                            }
                        },
                        updateElement: function (rectangle, index, reset) {
                            var me = this;
                            var meta = me.getMeta();
                            var dataset = me.getDataset();
                            var options = me._resolveDataElementOptions(rectangle, index);
                            rectangle._xScale = me.getScaleForId(meta.xAxisID);
                            rectangle._yScale = me.getScaleForId(meta.yAxisID);
                            rectangle._datasetIndex = me.index;
                            rectangle._index = index;
                            rectangle._model = {
                                backgroundColor: options.backgroundColor,
                                borderColor: options.borderColor,
                                borderSkipped: options.borderSkipped,
                                borderWidth: options.borderWidth,
                                datasetLabel: dataset.label,
                                label: me.chart.data.labels[index],
                            };
                            if (helpers$1.isArray(dataset.data[index])) {
                                rectangle._model.borderSkipped = null;
                            }
                            me._updateElementGeometry(rectangle, index, reset, options);
                            rectangle.pivot();
                        },
                        _updateElementGeometry: function (rectangle, index, reset, options) {
                            var me = this;
                            var model = rectangle._model;
                            var vscale = me._getValueScale();
                            var base = vscale.getBasePixel();
                            var horizontal = vscale.isHorizontal();
                            var ruler = me._ruler || me.getRuler();
                            var vpixels = me.calculateBarValuePixels(me.index, index, options);
                            var ipixels = me.calculateBarIndexPixels(me.index, index, ruler, options);
                            model.horizontal = horizontal;
                            model.base = reset ? base : vpixels.base;
                            model.x = horizontal ? (reset ? base : vpixels.head) : ipixels.center;
                            model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
                            model.height = horizontal ? ipixels.size : undefined;
                            model.width = horizontal ? undefined : ipixels.size;
                        },
                        _getStacks: function (last) {
                            var me = this;
                            var scale = me._getIndexScale();
                            var metasets = scale._getMatchingVisibleMetas(me._type);
                            var stacked = scale.options.stacked;
                            var ilen = metasets.length;
                            var stacks = [];
                            var i, meta;
                            for (i = 0; i < ilen; ++i) {
                                meta = metasets[i];
                                if (stacked === false || stacks.indexOf(meta.stack) === -1 || (stacked === undefined && meta.stack === undefined)) {
                                    stacks.push(meta.stack);
                                }
                                if (meta.index === last) {
                                    break;
                                }
                            }
                            return stacks;
                        },
                        getStackCount: function () {
                            return this._getStacks().length;
                        },
                        getStackIndex: function (datasetIndex, name) {
                            var stacks = this._getStacks(datasetIndex);
                            var index = name !== undefined ? stacks.indexOf(name) : -1;
                            return index === -1 ? stacks.length - 1 : index;
                        },
                        getRuler: function () {
                            var me = this;
                            var scale = me._getIndexScale();
                            var pixels = [];
                            var i, ilen;
                            for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
                                pixels.push(scale.getPixelForValue(null, i, me.index));
                            }
                            return { pixels: pixels, start: scale._startPixel, end: scale._endPixel, stackCount: me.getStackCount(), scale: scale };
                        },
                        calculateBarValuePixels: function (datasetIndex, index, options) {
                            var me = this;
                            var chart = me.chart;
                            var scale = me._getValueScale();
                            var isHorizontal = scale.isHorizontal();
                            var datasets = chart.data.datasets;
                            var metasets = scale._getMatchingVisibleMetas(me._type);
                            var value = scale._parseValue(datasets[datasetIndex].data[index]);
                            var minBarLength = options.minBarLength;
                            var stacked = scale.options.stacked;
                            var stack = me.getMeta().stack;
                            var start = value.start === undefined ? 0 : value.max >= 0 && value.min >= 0 ? value.min : value.max;
                            var length = value.start === undefined ? value.end : value.max >= 0 && value.min >= 0 ? value.max - value.min : value.min - value.max;
                            var ilen = metasets.length;
                            var i, imeta, ivalue, base, head, size, stackLength;
                            if (stacked || (stacked === undefined && stack !== undefined)) {
                                for (i = 0; i < ilen; ++i) {
                                    imeta = metasets[i];
                                    if (imeta.index === datasetIndex) {
                                        break;
                                    }
                                    if (imeta.stack === stack) {
                                        stackLength = scale._parseValue(datasets[imeta.index].data[index]);
                                        ivalue = stackLength.start === undefined ? stackLength.end : stackLength.min >= 0 && stackLength.max >= 0 ? stackLength.max : stackLength.min;
                                        if ((value.min < 0 && ivalue < 0) || (value.max >= 0 && ivalue > 0)) {
                                            start += ivalue;
                                        }
                                    }
                                }
                            }
                            base = scale.getPixelForValue(start);
                            head = scale.getPixelForValue(start + length);
                            size = head - base;
                            if (minBarLength !== undefined && Math.abs(size) < minBarLength) {
                                size = minBarLength;
                                if ((length >= 0 && !isHorizontal) || (length < 0 && isHorizontal)) {
                                    head = base - minBarLength;
                                } else {
                                    head = base + minBarLength;
                                }
                            }
                            return { size: size, base: base, head: head, center: head + size / 2 };
                        },
                        calculateBarIndexPixels: function (datasetIndex, index, ruler, options) {
                            var me = this;
                            var range = options.barThickness === "flex" ? computeFlexCategoryTraits(index, ruler, options) : computeFitCategoryTraits(index, ruler, options);
                            var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);
                            var center = range.start + range.chunk * stackIndex + range.chunk / 2;
                            var size = Math.min(valueOrDefault$3(options.maxBarThickness, Infinity), range.chunk * range.ratio);
                            return { base: center - size / 2, head: center + size / 2, center: center, size: size };
                        },
                        draw: function () {
                            var me = this;
                            var chart = me.chart;
                            var scale = me._getValueScale();
                            var rects = me.getMeta().data;
                            var dataset = me.getDataset();
                            var ilen = rects.length;
                            var i = 0;
                            helpers$1.canvas.clipArea(chart.ctx, chart.chartArea);
                            for (; i < ilen; ++i) {
                                var val = scale._parseValue(dataset.data[i]);
                                if (!isNaN(val.min) && !isNaN(val.max)) {
                                    rects[i].draw();
                                }
                            }
                            helpers$1.canvas.unclipArea(chart.ctx);
                        },
                        _resolveDataElementOptions: function () {
                            var me = this;
                            var values = helpers$1.extend({}, core_datasetController.prototype._resolveDataElementOptions.apply(me, arguments));
                            var indexOpts = me._getIndexScale().options;
                            var valueOpts = me._getValueScale().options;
                            values.barPercentage = valueOrDefault$3(indexOpts.barPercentage, values.barPercentage);
                            values.barThickness = valueOrDefault$3(indexOpts.barThickness, values.barThickness);
                            values.categoryPercentage = valueOrDefault$3(indexOpts.categoryPercentage, values.categoryPercentage);
                            values.maxBarThickness = valueOrDefault$3(indexOpts.maxBarThickness, values.maxBarThickness);
                            values.minBarLength = valueOrDefault$3(valueOpts.minBarLength, values.minBarLength);
                            return values;
                        },
                    });
                    var valueOrDefault$4 = helpers$1.valueOrDefault;
                    var resolve$1 = helpers$1.options.resolve;
                    core_defaults._set("bubble", {
                        hover: { mode: "single" },
                        scales: { xAxes: [{ type: "linear", position: "bottom", id: "x-axis-0" }], yAxes: [{ type: "linear", position: "left", id: "y-axis-0" }] },
                        tooltips: {
                            callbacks: {
                                title: function () {
                                    return "";
                                },
                                label: function (item, data) {
                                    var datasetLabel = data.datasets[item.datasetIndex].label || "";
                                    var dataPoint = data.datasets[item.datasetIndex].data[item.index];
                                    return datasetLabel + ": (" + item.xLabel + ", " + item.yLabel + ", " + dataPoint.r + ")";
                                },
                            },
                        },
                    });
                    var controller_bubble = core_datasetController.extend({
                        dataElementType: elements.Point,
                        _dataElementOptions: ["backgroundColor", "borderColor", "borderWidth", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth", "hoverRadius", "hitRadius", "pointStyle", "rotation"],
                        update: function (reset) {
                            var me = this;
                            var meta = me.getMeta();
                            var points = meta.data;
                            helpers$1.each(points, function (point, index) {
                                me.updateElement(point, index, reset);
                            });
                        },
                        updateElement: function (point, index, reset) {
                            var me = this;
                            var meta = me.getMeta();
                            var custom = point.custom || {};
                            var xScale = me.getScaleForId(meta.xAxisID);
                            var yScale = me.getScaleForId(meta.yAxisID);
                            var options = me._resolveDataElementOptions(point, index);
                            var data = me.getDataset().data[index];
                            var dsIndex = me.index;
                            var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === "object" ? data : NaN, index, dsIndex);
                            var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);
                            point._xScale = xScale;
                            point._yScale = yScale;
                            point._options = options;
                            point._datasetIndex = dsIndex;
                            point._index = index;
                            point._model = {
                                backgroundColor: options.backgroundColor,
                                borderColor: options.borderColor,
                                borderWidth: options.borderWidth,
                                hitRadius: options.hitRadius,
                                pointStyle: options.pointStyle,
                                rotation: options.rotation,
                                radius: reset ? 0 : options.radius,
                                skip: custom.skip || isNaN(x) || isNaN(y),
                                x: x,
                                y: y,
                            };
                            point.pivot();
                        },
                        setHoverStyle: function (point) {
                            var model = point._model;
                            var options = point._options;
                            var getHoverColor = helpers$1.getHoverColor;
                            point.$previousStyle = { backgroundColor: model.backgroundColor, borderColor: model.borderColor, borderWidth: model.borderWidth, radius: model.radius };
                            model.backgroundColor = valueOrDefault$4(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
                            model.borderColor = valueOrDefault$4(options.hoverBorderColor, getHoverColor(options.borderColor));
                            model.borderWidth = valueOrDefault$4(options.hoverBorderWidth, options.borderWidth);
                            model.radius = options.radius + options.hoverRadius;
                        },
                        _resolveDataElementOptions: function (point, index) {
                            var me = this;
                            var chart = me.chart;
                            var dataset = me.getDataset();
                            var custom = point.custom || {};
                            var data = dataset.data[index] || {};
                            var values = core_datasetController.prototype._resolveDataElementOptions.apply(me, arguments);
                            var context = { chart: chart, dataIndex: index, dataset: dataset, datasetIndex: me.index };
                            if (me._cachedDataOpts === values) {
                                values = helpers$1.extend({}, values);
                            }
                            values.radius = resolve$1([custom.radius, data.r, me._config.radius, chart.options.elements.point.radius], context, index);
                            return values;
                        },
                    });
                    var valueOrDefault$5 = helpers$1.valueOrDefault;
                    var PI$1 = Math.PI;
                    var DOUBLE_PI$1 = PI$1 * 2;
                    var HALF_PI$1 = PI$1 / 2;
                    core_defaults._set("doughnut", {
                        animation: { animateRotate: true, animateScale: false },
                        hover: { mode: "single" },
                        legendCallback: function (chart) {
                            var list = document.createElement("ul");
                            var data = chart.data;
                            var datasets = data.datasets;
                            var labels = data.labels;
                            var i, ilen, listItem, listItemSpan;
                            list.setAttribute("class", chart.id + "-legend");
                            if (datasets.length) {
                                for (i = 0, ilen = datasets[0].data.length; i < ilen; ++i) {
                                    listItem = list.appendChild(document.createElement("li"));
                                    listItemSpan = listItem.appendChild(document.createElement("span"));
                                    listItemSpan.style.backgroundColor = datasets[0].backgroundColor[i];
                                    if (labels[i]) {
                                        listItem.appendChild(document.createTextNode(labels[i]));
                                    }
                                }
                            }
                            return list.outerHTML;
                        },
                        legend: {
                            labels: {
                                generateLabels: function (chart) {
                                    var data = chart.data;
                                    if (data.labels.length && data.datasets.length) {
                                        return data.labels.map(function (label, i) {
                                            var meta = chart.getDatasetMeta(0);
                                            var style = meta.controller.getStyle(i);
                                            return { text: label, fillStyle: style.backgroundColor, strokeStyle: style.borderColor, lineWidth: style.borderWidth, hidden: isNaN(data.datasets[0].data[i]) || meta.data[i].hidden, index: i };
                                        });
                                    }
                                    return [];
                                },
                            },
                            onClick: function (e, legendItem) {
                                var index = legendItem.index;
                                var chart = this.chart;
                                var i, ilen, meta;
                                for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
                                    meta = chart.getDatasetMeta(i);
                                    if (meta.data[index]) {
                                        meta.data[index].hidden = !meta.data[index].hidden;
                                    }
                                }
                                chart.update();
                            },
                        },
                        cutoutPercentage: 50,
                        rotation: -HALF_PI$1,
                        circumference: DOUBLE_PI$1,
                        tooltips: {
                            callbacks: {
                                title: function () {
                                    return "";
                                },
                                label: function (tooltipItem, data) {
                                    var dataLabel = data.labels[tooltipItem.index];
                                    var value = ": " + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
                                    if (helpers$1.isArray(dataLabel)) {
                                        dataLabel = dataLabel.slice();
                                        dataLabel[0] += value;
                                    } else {
                                        dataLabel += value;
                                    }
                                    return dataLabel;
                                },
                            },
                        },
                    });
                    var controller_doughnut = core_datasetController.extend({
                        dataElementType: elements.Arc,
                        linkScales: helpers$1.noop,
                        _dataElementOptions: ["backgroundColor", "borderColor", "borderWidth", "borderAlign", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth"],
                        getRingIndex: function (datasetIndex) {
                            var ringIndex = 0;
                            for (var j = 0; j < datasetIndex; ++j) {
                                if (this.chart.isDatasetVisible(j)) {
                                    ++ringIndex;
                                }
                            }
                            return ringIndex;
                        },
                        update: function (reset) {
                            var me = this;
                            var chart = me.chart;
                            var chartArea = chart.chartArea;
                            var opts = chart.options;
                            var ratioX = 1;
                            var ratioY = 1;
                            var offsetX = 0;
                            var offsetY = 0;
                            var meta = me.getMeta();
                            var arcs = meta.data;
                            var cutout = opts.cutoutPercentage / 100 || 0;
                            var circumference = opts.circumference;
                            var chartWeight = me._getRingWeight(me.index);
                            var maxWidth, maxHeight, i, ilen;
                            if (circumference < DOUBLE_PI$1) {
                                var startAngle = opts.rotation % DOUBLE_PI$1;
                                startAngle += startAngle >= PI$1 ? -DOUBLE_PI$1 : startAngle < -PI$1 ? DOUBLE_PI$1 : 0;
                                var endAngle = startAngle + circumference;
                                var startX = Math.cos(startAngle);
                                var startY = Math.sin(startAngle);
                                var endX = Math.cos(endAngle);
                                var endY = Math.sin(endAngle);
                                var contains0 = (startAngle <= 0 && endAngle >= 0) || endAngle >= DOUBLE_PI$1;
                                var contains90 = (startAngle <= HALF_PI$1 && endAngle >= HALF_PI$1) || endAngle >= DOUBLE_PI$1 + HALF_PI$1;
                                var contains180 = startAngle === -PI$1 || endAngle >= PI$1;
                                var contains270 = (startAngle <= -HALF_PI$1 && endAngle >= -HALF_PI$1) || endAngle >= PI$1 + HALF_PI$1;
                                var minX = contains180 ? -1 : Math.min(startX, startX * cutout, endX, endX * cutout);
                                var minY = contains270 ? -1 : Math.min(startY, startY * cutout, endY, endY * cutout);
                                var maxX = contains0 ? 1 : Math.max(startX, startX * cutout, endX, endX * cutout);
                                var maxY = contains90 ? 1 : Math.max(startY, startY * cutout, endY, endY * cutout);
                                ratioX = (maxX - minX) / 2;
                                ratioY = (maxY - minY) / 2;
                                offsetX = -(maxX + minX) / 2;
                                offsetY = -(maxY + minY) / 2;
                            }
                            for (i = 0, ilen = arcs.length; i < ilen; ++i) {
                                arcs[i]._options = me._resolveDataElementOptions(arcs[i], i);
                            }
                            chart.borderWidth = me.getMaxBorderWidth();
                            maxWidth = (chartArea.right - chartArea.left - chart.borderWidth) / ratioX;
                            maxHeight = (chartArea.bottom - chartArea.top - chart.borderWidth) / ratioY;
                            chart.outerRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
                            chart.innerRadius = Math.max(chart.outerRadius * cutout, 0);
                            chart.radiusLength = (chart.outerRadius - chart.innerRadius) / (me._getVisibleDatasetWeightTotal() || 1);
                            chart.offsetX = offsetX * chart.outerRadius;
                            chart.offsetY = offsetY * chart.outerRadius;
                            meta.total = me.calculateTotal();
                            me.outerRadius = chart.outerRadius - chart.radiusLength * me._getRingWeightOffset(me.index);
                            me.innerRadius = Math.max(me.outerRadius - chart.radiusLength * chartWeight, 0);
                            for (i = 0, ilen = arcs.length; i < ilen; ++i) {
                                me.updateElement(arcs[i], i, reset);
                            }
                        },
                        updateElement: function (arc, index, reset) {
                            var me = this;
                            var chart = me.chart;
                            var chartArea = chart.chartArea;
                            var opts = chart.options;
                            var animationOpts = opts.animation;
                            var centerX = (chartArea.left + chartArea.right) / 2;
                            var centerY = (chartArea.top + chartArea.bottom) / 2;
                            var startAngle = opts.rotation;
                            var endAngle = opts.rotation;
                            var dataset = me.getDataset();
                            var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / DOUBLE_PI$1);
                            var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
                            var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
                            var options = arc._options || {};
                            helpers$1.extend(arc, {
                                _datasetIndex: me.index,
                                _index: index,
                                _model: {
                                    backgroundColor: options.backgroundColor,
                                    borderColor: options.borderColor,
                                    borderWidth: options.borderWidth,
                                    borderAlign: options.borderAlign,
                                    x: centerX + chart.offsetX,
                                    y: centerY + chart.offsetY,
                                    startAngle: startAngle,
                                    endAngle: endAngle,
                                    circumference: circumference,
                                    outerRadius: outerRadius,
                                    innerRadius: innerRadius,
                                    label: helpers$1.valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index]),
                                },
                            });
                            var model = arc._model;
                            if (!reset || !animationOpts.animateRotate) {
                                if (index === 0) {
                                    model.startAngle = opts.rotation;
                                } else {
                                    model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
                                }
                                model.endAngle = model.startAngle + model.circumference;
                            }
                            arc.pivot();
                        },
                        calculateTotal: function () {
                            var dataset = this.getDataset();
                            var meta = this.getMeta();
                            var total = 0;
                            var value;
                            helpers$1.each(meta.data, function (element, index) {
                                value = dataset.data[index];
                                if (!isNaN(value) && !element.hidden) {
                                    total += Math.abs(value);
                                }
                            });
                            return total;
                        },
                        calculateCircumference: function (value) {
                            var total = this.getMeta().total;
                            if (total > 0 && !isNaN(value)) {
                                return DOUBLE_PI$1 * (Math.abs(value) / total);
                            }
                            return 0;
                        },
                        getMaxBorderWidth: function (arcs) {
                            var me = this;
                            var max = 0;
                            var chart = me.chart;
                            var i, ilen, meta, arc, controller, options, borderWidth, hoverWidth;
                            if (!arcs) {
                                for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
                                    if (chart.isDatasetVisible(i)) {
                                        meta = chart.getDatasetMeta(i);
                                        arcs = meta.data;
                                        if (i !== me.index) {
                                            controller = meta.controller;
                                        }
                                        break;
                                    }
                                }
                            }
                            if (!arcs) {
                                return 0;
                            }
                            for (i = 0, ilen = arcs.length; i < ilen; ++i) {
                                arc = arcs[i];
                                if (controller) {
                                    controller._configure();
                                    options = controller._resolveDataElementOptions(arc, i);
                                } else {
                                    options = arc._options;
                                }
                                if (options.borderAlign !== "inner") {
                                    borderWidth = options.borderWidth;
                                    hoverWidth = options.hoverBorderWidth;
                                    max = borderWidth > max ? borderWidth : max;
                                    max = hoverWidth > max ? hoverWidth : max;
                                }
                            }
                            return max;
                        },
                        setHoverStyle: function (arc) {
                            var model = arc._model;
                            var options = arc._options;
                            var getHoverColor = helpers$1.getHoverColor;
                            arc.$previousStyle = { backgroundColor: model.backgroundColor, borderColor: model.borderColor, borderWidth: model.borderWidth };
                            model.backgroundColor = valueOrDefault$5(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
                            model.borderColor = valueOrDefault$5(options.hoverBorderColor, getHoverColor(options.borderColor));
                            model.borderWidth = valueOrDefault$5(options.hoverBorderWidth, options.borderWidth);
                        },
                        _getRingWeightOffset: function (datasetIndex) {
                            var ringWeightOffset = 0;
                            for (var i = 0; i < datasetIndex; ++i) {
                                if (this.chart.isDatasetVisible(i)) {
                                    ringWeightOffset += this._getRingWeight(i);
                                }
                            }
                            return ringWeightOffset;
                        },
                        _getRingWeight: function (dataSetIndex) {
                            return Math.max(valueOrDefault$5(this.chart.data.datasets[dataSetIndex].weight, 1), 0);
                        },
                        _getVisibleDatasetWeightTotal: function () {
                            return this._getRingWeightOffset(this.chart.data.datasets.length);
                        },
                    });
                    core_defaults._set("horizontalBar", {
                        hover: { mode: "index", axis: "y" },
                        scales: { xAxes: [{ type: "linear", position: "bottom" }], yAxes: [{ type: "category", position: "left", offset: true, gridLines: { offsetGridLines: true } }] },
                        elements: { rectangle: { borderSkipped: "left" } },
                        tooltips: { mode: "index", axis: "y" },
                    });
                    core_defaults._set("global", { datasets: { horizontalBar: { categoryPercentage: 0.8, barPercentage: 0.9 } } });
                    var controller_horizontalBar = controller_bar.extend({
                        _getValueScaleId: function () {
                            return this.getMeta().xAxisID;
                        },
                        _getIndexScaleId: function () {
                            return this.getMeta().yAxisID;
                        },
                    });
                    var valueOrDefault$6 = helpers$1.valueOrDefault;
                    var resolve$2 = helpers$1.options.resolve;
                    var isPointInArea = helpers$1.canvas._isPointInArea;
                    core_defaults._set("line", { showLines: true, spanGaps: false, hover: { mode: "label" }, scales: { xAxes: [{ type: "category", id: "x-axis-0" }], yAxes: [{ type: "linear", id: "y-axis-0" }] } });
                    function scaleClip(scale, halfBorderWidth) {
                        var tickOpts = (scale && scale.options.ticks) || {};
                        var reverse = tickOpts.reverse;
                        var min = tickOpts.min === undefined ? halfBorderWidth : 0;
                        var max = tickOpts.max === undefined ? halfBorderWidth : 0;
                        return { start: reverse ? max : min, end: reverse ? min : max };
                    }
                    function defaultClip(xScale, yScale, borderWidth) {
                        var halfBorderWidth = borderWidth / 2;
                        var x = scaleClip(xScale, halfBorderWidth);
                        var y = scaleClip(yScale, halfBorderWidth);
                        return { top: y.end, right: x.end, bottom: y.start, left: x.start };
                    }
                    function toClip(value) {
                        var t, r, b, l;
                        if (helpers$1.isObject(value)) {
                            t = value.top;
                            r = value.right;
                            b = value.bottom;
                            l = value.left;
                        } else {
                            t = r = b = l = value;
                        }
                        return { top: t, right: r, bottom: b, left: l };
                    }
                    var controller_line = core_datasetController.extend({
                        datasetElementType: elements.Line,
                        dataElementType: elements.Point,
                        _datasetElementOptions: ["backgroundColor", "borderCapStyle", "borderColor", "borderDash", "borderDashOffset", "borderJoinStyle", "borderWidth", "cubicInterpolationMode", "fill"],
                        _dataElementOptions: {
                            backgroundColor: "pointBackgroundColor",
                            borderColor: "pointBorderColor",
                            borderWidth: "pointBorderWidth",
                            hitRadius: "pointHitRadius",
                            hoverBackgroundColor: "pointHoverBackgroundColor",
                            hoverBorderColor: "pointHoverBorderColor",
                            hoverBorderWidth: "pointHoverBorderWidth",
                            hoverRadius: "pointHoverRadius",
                            pointStyle: "pointStyle",
                            radius: "pointRadius",
                            rotation: "pointRotation",
                        },
                        update: function (reset) {
                            var me = this;
                            var meta = me.getMeta();
                            var line = meta.dataset;
                            var points = meta.data || [];
                            var options = me.chart.options;
                            var config = me._config;
                            var showLine = (me._showLine = valueOrDefault$6(config.showLine, options.showLines));
                            var i, ilen;
                            me._xScale = me.getScaleForId(meta.xAxisID);
                            me._yScale = me.getScaleForId(meta.yAxisID);
                            if (showLine) {
                                if (config.tension !== undefined && config.lineTension === undefined) {
                                    config.lineTension = config.tension;
                                }
                                line._scale = me._yScale;
                                line._datasetIndex = me.index;
                                line._children = points;
                                line._model = me._resolveDatasetElementOptions(line);
                                line.pivot();
                            }
                            for (i = 0, ilen = points.length; i < ilen; ++i) {
                                me.updateElement(points[i], i, reset);
                            }
                            if (showLine && line._model.tension !== 0) {
                                me.updateBezierControlPoints();
                            }
                            for (i = 0, ilen = points.length; i < ilen; ++i) {
                                points[i].pivot();
                            }
                        },
                        updateElement: function (point, index, reset) {
                            var me = this;
                            var meta = me.getMeta();
                            var custom = point.custom || {};
                            var dataset = me.getDataset();
                            var datasetIndex = me.index;
                            var value = dataset.data[index];
                            var xScale = me._xScale;
                            var yScale = me._yScale;
                            var lineModel = meta.dataset._model;
                            var x, y;
                            var options = me._resolveDataElementOptions(point, index);
                            x = xScale.getPixelForValue(typeof value === "object" ? value : NaN, index, datasetIndex);
                            y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);
                            point._xScale = xScale;
                            point._yScale = yScale;
                            point._options = options;
                            point._datasetIndex = datasetIndex;
                            point._index = index;
                            point._model = {
                                x: x,
                                y: y,
                                skip: custom.skip || isNaN(x) || isNaN(y),
                                radius: options.radius,
                                pointStyle: options.pointStyle,
                                rotation: options.rotation,
                                backgroundColor: options.backgroundColor,
                                borderColor: options.borderColor,
                                borderWidth: options.borderWidth,
                                tension: valueOrDefault$6(custom.tension, lineModel ? lineModel.tension : 0),
                                steppedLine: lineModel ? lineModel.steppedLine : false,
                                hitRadius: options.hitRadius,
                            };
                        },
                        _resolveDatasetElementOptions: function (element) {
                            var me = this;
                            var config = me._config;
                            var custom = element.custom || {};
                            var options = me.chart.options;
                            var lineOptions = options.elements.line;
                            var values = core_datasetController.prototype._resolveDatasetElementOptions.apply(me, arguments);
                            values.spanGaps = valueOrDefault$6(config.spanGaps, options.spanGaps);
                            values.tension = valueOrDefault$6(config.lineTension, lineOptions.tension);
                            values.steppedLine = resolve$2([custom.steppedLine, config.steppedLine, lineOptions.stepped]);
                            values.clip = toClip(valueOrDefault$6(config.clip, defaultClip(me._xScale, me._yScale, values.borderWidth)));
                            return values;
                        },
                        calculatePointY: function (value, index, datasetIndex) {
                            var me = this;
                            var chart = me.chart;
                            var yScale = me._yScale;
                            var sumPos = 0;
                            var sumNeg = 0;
                            var i, ds, dsMeta, stackedRightValue, rightValue, metasets, ilen;
                            if (yScale.options.stacked) {
                                rightValue = +yScale.getRightValue(value);
                                metasets = chart._getSortedVisibleDatasetMetas();
                                ilen = metasets.length;
                                for (i = 0; i < ilen; ++i) {
                                    dsMeta = metasets[i];
                                    if (dsMeta.index === datasetIndex) {
                                        break;
                                    }
                                    ds = chart.data.datasets[dsMeta.index];
                                    if (dsMeta.type === "line" && dsMeta.yAxisID === yScale.id) {
                                        stackedRightValue = +yScale.getRightValue(ds.data[index]);
                                        if (stackedRightValue < 0) {
                                            sumNeg += stackedRightValue || 0;
                                        } else {
                                            sumPos += stackedRightValue || 0;
                                        }
                                    }
                                }
                                if (rightValue < 0) {
                                    return yScale.getPixelForValue(sumNeg + rightValue);
                                }
                                return yScale.getPixelForValue(sumPos + rightValue);
                            }
                            return yScale.getPixelForValue(value);
                        },
                        updateBezierControlPoints: function () {
                            var me = this;
                            var chart = me.chart;
                            var meta = me.getMeta();
                            var lineModel = meta.dataset._model;
                            var area = chart.chartArea;
                            var points = meta.data || [];
                            var i, ilen, model, controlPoints;
                            if (lineModel.spanGaps) {
                                points = points.filter(function (pt) {
                                    return !pt._model.skip;
                                });
                            }
                            function capControlPoint(pt, min, max) {
                                return Math.max(Math.min(pt, max), min);
                            }
                            if (lineModel.cubicInterpolationMode === "monotone") {
                                helpers$1.splineCurveMonotone(points);
                            } else {
                                for (i = 0, ilen = points.length; i < ilen; ++i) {
                                    model = points[i]._model;
                                    controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i)._model, model, helpers$1.nextItem(points, i)._model, lineModel.tension);
                                    model.controlPointPreviousX = controlPoints.previous.x;
                                    model.controlPointPreviousY = controlPoints.previous.y;
                                    model.controlPointNextX = controlPoints.next.x;
                                    model.controlPointNextY = controlPoints.next.y;
                                }
                            }
                            if (chart.options.elements.line.capBezierPoints) {
                                for (i = 0, ilen = points.length; i < ilen; ++i) {
                                    model = points[i]._model;
                                    if (isPointInArea(model, area)) {
                                        if (i > 0 && isPointInArea(points[i - 1]._model, area)) {
                                            model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
                                            model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
                                        }
                                        if (i < points.length - 1 && isPointInArea(points[i + 1]._model, area)) {
                                            model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
                                            model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
                                        }
                                    }
                                }
                            }
                        },
                        draw: function () {
                            var me = this;
                            var chart = me.chart;
                            var meta = me.getMeta();
                            var points = meta.data || [];
                            var area = chart.chartArea;
                            var canvas = chart.canvas;
                            var i = 0;
                            var ilen = points.length;
                            var clip;
                            if (me._showLine) {
                                clip = meta.dataset._model.clip;
                                helpers$1.canvas.clipArea(chart.ctx, {
                                    left: clip.left === false ? 0 : area.left - clip.left,
                                    right: clip.right === false ? canvas.width : area.right + clip.right,
                                    top: clip.top === false ? 0 : area.top - clip.top,
                                    bottom: clip.bottom === false ? canvas.height : area.bottom + clip.bottom,
                                });
                                meta.dataset.draw();
                                helpers$1.canvas.unclipArea(chart.ctx);
                            }
                            for (; i < ilen; ++i) {
                                points[i].draw(area);
                            }
                        },
                        setHoverStyle: function (point) {
                            var model = point._model;
                            var options = point._options;
                            var getHoverColor = helpers$1.getHoverColor;
                            point.$previousStyle = { backgroundColor: model.backgroundColor, borderColor: model.borderColor, borderWidth: model.borderWidth, radius: model.radius };
                            model.backgroundColor = valueOrDefault$6(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
                            model.borderColor = valueOrDefault$6(options.hoverBorderColor, getHoverColor(options.borderColor));
                            model.borderWidth = valueOrDefault$6(options.hoverBorderWidth, options.borderWidth);
                            model.radius = valueOrDefault$6(options.hoverRadius, options.radius);
                        },
                    });
                    var resolve$3 = helpers$1.options.resolve;
                    core_defaults._set("polarArea", {
                        scale: { type: "radialLinear", angleLines: { display: false }, gridLines: { circular: true }, pointLabels: { display: false }, ticks: { beginAtZero: true } },
                        animation: { animateRotate: true, animateScale: true },
                        startAngle: -0.5 * Math.PI,
                        legendCallback: function (chart) {
                            var list = document.createElement("ul");
                            var data = chart.data;
                            var datasets = data.datasets;
                            var labels = data.labels;
                            var i, ilen, listItem, listItemSpan;
                            list.setAttribute("class", chart.id + "-legend");
                            if (datasets.length) {
                                for (i = 0, ilen = datasets[0].data.length; i < ilen; ++i) {
                                    listItem = list.appendChild(document.createElement("li"));
                                    listItemSpan = listItem.appendChild(document.createElement("span"));
                                    listItemSpan.style.backgroundColor = datasets[0].backgroundColor[i];
                                    if (labels[i]) {
                                        listItem.appendChild(document.createTextNode(labels[i]));
                                    }
                                }
                            }
                            return list.outerHTML;
                        },
                        legend: {
                            labels: {
                                generateLabels: function (chart) {
                                    var data = chart.data;
                                    if (data.labels.length && data.datasets.length) {
                                        return data.labels.map(function (label, i) {
                                            var meta = chart.getDatasetMeta(0);
                                            var style = meta.controller.getStyle(i);
                                            return { text: label, fillStyle: style.backgroundColor, strokeStyle: style.borderColor, lineWidth: style.borderWidth, hidden: isNaN(data.datasets[0].data[i]) || meta.data[i].hidden, index: i };
                                        });
                                    }
                                    return [];
                                },
                            },
                            onClick: function (e, legendItem) {
                                var index = legendItem.index;
                                var chart = this.chart;
                                var i, ilen, meta;
                                for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
                                    meta = chart.getDatasetMeta(i);
                                    meta.data[index].hidden = !meta.data[index].hidden;
                                }
                                chart.update();
                            },
                        },
                        tooltips: {
                            callbacks: {
                                title: function () {
                                    return "";
                                },
                                label: function (item, data) {
                                    return data.labels[item.index] + ": " + item.yLabel;
                                },
                            },
                        },
                    });
                    var controller_polarArea = core_datasetController.extend({
                        dataElementType: elements.Arc,
                        linkScales: helpers$1.noop,
                        _dataElementOptions: ["backgroundColor", "borderColor", "borderWidth", "borderAlign", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth"],
                        _getIndexScaleId: function () {
                            return this.chart.scale.id;
                        },
                        _getValueScaleId: function () {
                            return this.chart.scale.id;
                        },
                        update: function (reset) {
                            var me = this;
                            var dataset = me.getDataset();
                            var meta = me.getMeta();
                            var start = me.chart.options.startAngle || 0;
                            var starts = (me._starts = []);
                            var angles = (me._angles = []);
                            var arcs = meta.data;
                            var i, ilen, angle;
                            me._updateRadius();
                            meta.count = me.countVisibleElements();
                            for (i = 0, ilen = dataset.data.length; i < ilen; i++) {
                                starts[i] = start;
                                angle = me._computeAngle(i);
                                angles[i] = angle;
                                start += angle;
                            }
                            for (i = 0, ilen = arcs.length; i < ilen; ++i) {
                                arcs[i]._options = me._resolveDataElementOptions(arcs[i], i);
                                me.updateElement(arcs[i], i, reset);
                            }
                        },
                        _updateRadius: function () {
                            var me = this;
                            var chart = me.chart;
                            var chartArea = chart.chartArea;
                            var opts = chart.options;
                            var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
                            chart.outerRadius = Math.max(minSize / 2, 0);
                            chart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * opts.cutoutPercentage : 1, 0);
                            chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
                            me.outerRadius = chart.outerRadius - chart.radiusLength * me.index;
                            me.innerRadius = me.outerRadius - chart.radiusLength;
                        },
                        updateElement: function (arc, index, reset) {
                            var me = this;
                            var chart = me.chart;
                            var dataset = me.getDataset();
                            var opts = chart.options;
                            var animationOpts = opts.animation;
                            var scale = chart.scale;
                            var labels = chart.data.labels;
                            var centerX = scale.xCenter;
                            var centerY = scale.yCenter;
                            var datasetStartAngle = opts.startAngle;
                            var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
                            var startAngle = me._starts[index];
                            var endAngle = startAngle + (arc.hidden ? 0 : me._angles[index]);
                            var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
                            var options = arc._options || {};
                            helpers$1.extend(arc, {
                                _datasetIndex: me.index,
                                _index: index,
                                _scale: scale,
                                _model: {
                                    backgroundColor: options.backgroundColor,
                                    borderColor: options.borderColor,
                                    borderWidth: options.borderWidth,
                                    borderAlign: options.borderAlign,
                                    x: centerX,
                                    y: centerY,
                                    innerRadius: 0,
                                    outerRadius: reset ? resetRadius : distance,
                                    startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
                                    endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
                                    label: helpers$1.valueAtIndexOrDefault(labels, index, labels[index]),
                                },
                            });
                            arc.pivot();
                        },
                        countVisibleElements: function () {
                            var dataset = this.getDataset();
                            var meta = this.getMeta();
                            var count = 0;
                            helpers$1.each(meta.data, function (element, index) {
                                if (!isNaN(dataset.data[index]) && !element.hidden) {
                                    count++;
                                }
                            });
                            return count;
                        },
                        setHoverStyle: function (arc) {
                            var model = arc._model;
                            var options = arc._options;
                            var getHoverColor = helpers$1.getHoverColor;
                            var valueOrDefault = helpers$1.valueOrDefault;
                            arc.$previousStyle = { backgroundColor: model.backgroundColor, borderColor: model.borderColor, borderWidth: model.borderWidth };
                            model.backgroundColor = valueOrDefault(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
                            model.borderColor = valueOrDefault(options.hoverBorderColor, getHoverColor(options.borderColor));
                            model.borderWidth = valueOrDefault(options.hoverBorderWidth, options.borderWidth);
                        },
                        _computeAngle: function (index) {
                            var me = this;
                            var count = this.getMeta().count;
                            var dataset = me.getDataset();
                            var meta = me.getMeta();
                            if (isNaN(dataset.data[index]) || meta.data[index].hidden) {
                                return 0;
                            }
                            var context = { chart: me.chart, dataIndex: index, dataset: dataset, datasetIndex: me.index };
                            return resolve$3([me.chart.options.elements.arc.angle, (2 * Math.PI) / count], context, index);
                        },
                    });
                    core_defaults._set("pie", helpers$1.clone(core_defaults.doughnut));
                    core_defaults._set("pie", { cutoutPercentage: 0 });
                    var controller_pie = controller_doughnut;
                    var valueOrDefault$7 = helpers$1.valueOrDefault;
                    core_defaults._set("radar", { spanGaps: false, scale: { type: "radialLinear" }, elements: { line: { fill: "start", tension: 0 } } });
                    var controller_radar = core_datasetController.extend({
                        datasetElementType: elements.Line,
                        dataElementType: elements.Point,
                        linkScales: helpers$1.noop,
                        _datasetElementOptions: ["backgroundColor", "borderWidth", "borderColor", "borderCapStyle", "borderDash", "borderDashOffset", "borderJoinStyle", "fill"],
                        _dataElementOptions: {
                            backgroundColor: "pointBackgroundColor",
                            borderColor: "pointBorderColor",
                            borderWidth: "pointBorderWidth",
                            hitRadius: "pointHitRadius",
                            hoverBackgroundColor: "pointHoverBackgroundColor",
                            hoverBorderColor: "pointHoverBorderColor",
                            hoverBorderWidth: "pointHoverBorderWidth",
                            hoverRadius: "pointHoverRadius",
                            pointStyle: "pointStyle",
                            radius: "pointRadius",
                            rotation: "pointRotation",
                        },
                        _getIndexScaleId: function () {
                            return this.chart.scale.id;
                        },
                        _getValueScaleId: function () {
                            return this.chart.scale.id;
                        },
                        update: function (reset) {
                            var me = this;
                            var meta = me.getMeta();
                            var line = meta.dataset;
                            var points = meta.data || [];
                            var scale = me.chart.scale;
                            var config = me._config;
                            var i, ilen;
                            if (config.tension !== undefined && config.lineTension === undefined) {
                                config.lineTension = config.tension;
                            }
                            line._scale = scale;
                            line._datasetIndex = me.index;
                            line._children = points;
                            line._loop = true;
                            line._model = me._resolveDatasetElementOptions(line);
                            line.pivot();
                            for (i = 0, ilen = points.length; i < ilen; ++i) {
                                me.updateElement(points[i], i, reset);
                            }
                            me.updateBezierControlPoints();
                            for (i = 0, ilen = points.length; i < ilen; ++i) {
                                points[i].pivot();
                            }
                        },
                        updateElement: function (point, index, reset) {
                            var me = this;
                            var custom = point.custom || {};
                            var dataset = me.getDataset();
                            var scale = me.chart.scale;
                            var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);
                            var options = me._resolveDataElementOptions(point, index);
                            var lineModel = me.getMeta().dataset._model;
                            var x = reset ? scale.xCenter : pointPosition.x;
                            var y = reset ? scale.yCenter : pointPosition.y;
                            point._scale = scale;
                            point._options = options;
                            point._datasetIndex = me.index;
                            point._index = index;
                            point._model = {
                                x: x,
                                y: y,
                                skip: custom.skip || isNaN(x) || isNaN(y),
                                radius: options.radius,
                                pointStyle: options.pointStyle,
                                rotation: options.rotation,
                                backgroundColor: options.backgroundColor,
                                borderColor: options.borderColor,
                                borderWidth: options.borderWidth,
                                tension: valueOrDefault$7(custom.tension, lineModel ? lineModel.tension : 0),
                                hitRadius: options.hitRadius,
                            };
                        },
                        _resolveDatasetElementOptions: function () {
                            var me = this;
                            var config = me._config;
                            var options = me.chart.options;
                            var values = core_datasetController.prototype._resolveDatasetElementOptions.apply(me, arguments);
                            values.spanGaps = valueOrDefault$7(config.spanGaps, options.spanGaps);
                            values.tension = valueOrDefault$7(config.lineTension, options.elements.line.tension);
                            return values;
                        },
                        updateBezierControlPoints: function () {
                            var me = this;
                            var meta = me.getMeta();
                            var area = me.chart.chartArea;
                            var points = meta.data || [];
                            var i, ilen, model, controlPoints;
                            if (meta.dataset._model.spanGaps) {
                                points = points.filter(function (pt) {
                                    return !pt._model.skip;
                                });
                            }
                            function capControlPoint(pt, min, max) {
                                return Math.max(Math.min(pt, max), min);
                            }
                            for (i = 0, ilen = points.length; i < ilen; ++i) {
                                model = points[i]._model;
                                controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i, true)._model, model, helpers$1.nextItem(points, i, true)._model, model.tension);
                                model.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area.left, area.right);
                                model.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area.top, area.bottom);
                                model.controlPointNextX = capControlPoint(controlPoints.next.x, area.left, area.right);
                                model.controlPointNextY = capControlPoint(controlPoints.next.y, area.top, area.bottom);
                            }
                        },
                        setHoverStyle: function (point) {
                            var model = point._model;
                            var options = point._options;
                            var getHoverColor = helpers$1.getHoverColor;
                            point.$previousStyle = { backgroundColor: model.backgroundColor, borderColor: model.borderColor, borderWidth: model.borderWidth, radius: model.radius };
                            model.backgroundColor = valueOrDefault$7(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
                            model.borderColor = valueOrDefault$7(options.hoverBorderColor, getHoverColor(options.borderColor));
                            model.borderWidth = valueOrDefault$7(options.hoverBorderWidth, options.borderWidth);
                            model.radius = valueOrDefault$7(options.hoverRadius, options.radius);
                        },
                    });
                    core_defaults._set("scatter", {
                        hover: { mode: "single" },
                        scales: { xAxes: [{ id: "x-axis-1", type: "linear", position: "bottom" }], yAxes: [{ id: "y-axis-1", type: "linear", position: "left" }] },
                        tooltips: {
                            callbacks: {
                                title: function () {
                                    return "";
                                },
                                label: function (item) {
                                    return "(" + item.xLabel + ", " + item.yLabel + ")";
                                },
                            },
                        },
                    });
                    core_defaults._set("global", { datasets: { scatter: { showLine: false } } });
                    var controller_scatter = controller_line;
                    var controllers = {
                        bar: controller_bar,
                        bubble: controller_bubble,
                        doughnut: controller_doughnut,
                        horizontalBar: controller_horizontalBar,
                        line: controller_line,
                        polarArea: controller_polarArea,
                        pie: controller_pie,
                        radar: controller_radar,
                        scatter: controller_scatter,
                    };
                    function getRelativePosition(e, chart) {
                        if (e.native) {
                            return { x: e.x, y: e.y };
                        }
                        return helpers$1.getRelativePosition(e, chart);
                    }
                    function parseVisibleItems(chart, handler) {
                        var metasets = chart._getSortedVisibleDatasetMetas();
                        var metadata, i, j, ilen, jlen, element;
                        for (i = 0, ilen = metasets.length; i < ilen; ++i) {
                            metadata = metasets[i].data;
                            for (j = 0, jlen = metadata.length; j < jlen; ++j) {
                                element = metadata[j];
                                if (!element._view.skip) {
                                    handler(element);
                                }
                            }
                        }
                    }
                    function getIntersectItems(chart, position) {
                        var elements = [];
                        parseVisibleItems(chart, function (element) {
                            if (element.inRange(position.x, position.y)) {
                                elements.push(element);
                            }
                        });
                        return elements;
                    }
                    function getNearestItems(chart, position, intersect, distanceMetric) {
                        var minDistance = Number.POSITIVE_INFINITY;
                        var nearestItems = [];
                        parseVisibleItems(chart, function (element) {
                            if (intersect && !element.inRange(position.x, position.y)) {
                                return;
                            }
                            var center = element.getCenterPoint();
                            var distance = distanceMetric(position, center);
                            if (distance < minDistance) {
                                nearestItems = [element];
                                minDistance = distance;
                            } else if (distance === minDistance) {
                                nearestItems.push(element);
                            }
                        });
                        return nearestItems;
                    }
                    function getDistanceMetricForAxis(axis) {
                        var useX = axis.indexOf("x") !== -1;
                        var useY = axis.indexOf("y") !== -1;
                        return function (pt1, pt2) {
                            var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
                            var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
                            return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
                        };
                    }
                    function indexMode(chart, e, options) {
                        var position = getRelativePosition(e, chart);
                        options.axis = options.axis || "x";
                        var distanceMetric = getDistanceMetricForAxis(options.axis);
                        var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
                        var elements = [];
                        if (!items.length) {
                            return [];
                        }
                        chart._getSortedVisibleDatasetMetas().forEach(function (meta) {
                            var element = meta.data[items[0]._index];
                            if (element && !element._view.skip) {
                                elements.push(element);
                            }
                        });
                        return elements;
                    }
                    var core_interaction = {
                        modes: {
                            single: function (chart, e) {
                                var position = getRelativePosition(e, chart);
                                var elements = [];
                                parseVisibleItems(chart, function (element) {
                                    if (element.inRange(position.x, position.y)) {
                                        elements.push(element);
                                        return elements;
                                    }
                                });
                                return elements.slice(0, 1);
                            },
                            label: indexMode,
                            index: indexMode,
                            dataset: function (chart, e, options) {
                                var position = getRelativePosition(e, chart);
                                options.axis = options.axis || "xy";
                                var distanceMetric = getDistanceMetricForAxis(options.axis);
                                var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
                                if (items.length > 0) {
                                    items = chart.getDatasetMeta(items[0]._datasetIndex).data;
                                }
                                return items;
                            },
                            "x-axis": function (chart, e) {
                                return indexMode(chart, e, { intersect: false });
                            },
                            point: function (chart, e) {
                                var position = getRelativePosition(e, chart);
                                return getIntersectItems(chart, position);
                            },
                            nearest: function (chart, e, options) {
                                var position = getRelativePosition(e, chart);
                                options.axis = options.axis || "xy";
                                var distanceMetric = getDistanceMetricForAxis(options.axis);
                                return getNearestItems(chart, position, options.intersect, distanceMetric);
                            },
                            x: function (chart, e, options) {
                                var position = getRelativePosition(e, chart);
                                var items = [];
                                var intersectsItem = false;
                                parseVisibleItems(chart, function (element) {
                                    if (element.inXRange(position.x)) {
                                        items.push(element);
                                    }
                                    if (element.inRange(position.x, position.y)) {
                                        intersectsItem = true;
                                    }
                                });
                                if (options.intersect && !intersectsItem) {
                                    items = [];
                                }
                                return items;
                            },
                            y: function (chart, e, options) {
                                var position = getRelativePosition(e, chart);
                                var items = [];
                                var intersectsItem = false;
                                parseVisibleItems(chart, function (element) {
                                    if (element.inYRange(position.y)) {
                                        items.push(element);
                                    }
                                    if (element.inRange(position.x, position.y)) {
                                        intersectsItem = true;
                                    }
                                });
                                if (options.intersect && !intersectsItem) {
                                    items = [];
                                }
                                return items;
                            },
                        },
                    };
                    var extend = helpers$1.extend;
                    function filterByPosition(array, position) {
                        return helpers$1.where(array, function (v) {
                            return v.pos === position;
                        });
                    }
                    function sortByWeight(array, reverse) {
                        return array.sort(function (a, b) {
                            var v0 = reverse ? b : a;
                            var v1 = reverse ? a : b;
                            return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
                        });
                    }
                    function wrapBoxes(boxes) {
                        var layoutBoxes = [];
                        var i, ilen, box;
                        for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
                            box = boxes[i];
                            layoutBoxes.push({ index: i, box: box, pos: box.position, horizontal: box.isHorizontal(), weight: box.weight });
                        }
                        return layoutBoxes;
                    }
                    function setLayoutDims(layouts, params) {
                        var i, ilen, layout;
                        for (i = 0, ilen = layouts.length; i < ilen; ++i) {
                            layout = layouts[i];
                            layout.width = layout.horizontal ? layout.box.fullWidth && params.availableWidth : params.vBoxMaxWidth;
                            layout.height = layout.horizontal && params.hBoxMaxHeight;
                        }
                    }
                    function buildLayoutBoxes(boxes) {
                        var layoutBoxes = wrapBoxes(boxes);
                        var left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
                        var right = sortByWeight(filterByPosition(layoutBoxes, "right"));
                        var top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
                        var bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
                        return { leftAndTop: left.concat(top), rightAndBottom: right.concat(bottom), chartArea: filterByPosition(layoutBoxes, "chartArea"), vertical: left.concat(right), horizontal: top.concat(bottom) };
                    }
                    function getCombinedMax(maxPadding, chartArea, a, b) {
                        return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
                    }
                    function updateDims(chartArea, params, layout) {
                        var box = layout.box;
                        var maxPadding = chartArea.maxPadding;
                        var newWidth, newHeight;
                        if (layout.size) {
                            chartArea[layout.pos] -= layout.size;
                        }
                        layout.size = layout.horizontal ? box.height : box.width;
                        chartArea[layout.pos] += layout.size;
                        if (box.getPadding) {
                            var boxPadding = box.getPadding();
                            maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
                            maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
                            maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
                            maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
                        }
                        newWidth = params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right");
                        newHeight = params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom");
                        if (newWidth !== chartArea.w || newHeight !== chartArea.h) {
                            chartArea.w = newWidth;
                            chartArea.h = newHeight;
                            var sizes = layout.horizontal ? [newWidth, chartArea.w] : [newHeight, chartArea.h];
                            return sizes[0] !== sizes[1] && (!isNaN(sizes[0]) || !isNaN(sizes[1]));
                        }
                    }
                    function handleMaxPadding(chartArea) {
                        var maxPadding = chartArea.maxPadding;
                        function updatePos(pos) {
                            var change = Math.max(maxPadding[pos] - chartArea[pos], 0);
                            chartArea[pos] += change;
                            return change;
                        }
                        chartArea.y += updatePos("top");
                        chartArea.x += updatePos("left");
                        updatePos("right");
                        updatePos("bottom");
                    }
                    function getMargins(horizontal, chartArea) {
                        var maxPadding = chartArea.maxPadding;
                        function marginForPositions(positions) {
                            var margin = { left: 0, top: 0, right: 0, bottom: 0 };
                            positions.forEach(function (pos) {
                                margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
                            });
                            return margin;
                        }
                        return horizontal ? marginForPositions(["left", "right"]) : marginForPositions(["top", "bottom"]);
                    }
                    function fitBoxes(boxes, chartArea, params) {
                        var refitBoxes = [];
                        var i, ilen, layout, box, refit, changed;
                        for (i = 0, ilen = boxes.length; i < ilen; ++i) {
                            layout = boxes[i];
                            box = layout.box;
                            box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
                            if (updateDims(chartArea, params, layout)) {
                                changed = true;
                                if (refitBoxes.length) {
                                    refit = true;
                                }
                            }
                            if (!box.fullWidth) {
                                refitBoxes.push(layout);
                            }
                        }
                        return refit ? fitBoxes(refitBoxes, chartArea, params) || changed : changed;
                    }
                    function placeBoxes(boxes, chartArea, params) {
                        var userPadding = params.padding;
                        var x = chartArea.x;
                        var y = chartArea.y;
                        var i, ilen, layout, box;
                        for (i = 0, ilen = boxes.length; i < ilen; ++i) {
                            layout = boxes[i];
                            box = layout.box;
                            if (layout.horizontal) {
                                box.left = box.fullWidth ? userPadding.left : chartArea.left;
                                box.right = box.fullWidth ? params.outerWidth - userPadding.right : chartArea.left + chartArea.w;
                                box.top = y;
                                box.bottom = y + box.height;
                                box.width = box.right - box.left;
                                y = box.bottom;
                            } else {
                                box.left = x;
                                box.right = x + box.width;
                                box.top = chartArea.top;
                                box.bottom = chartArea.top + chartArea.h;
                                box.height = box.bottom - box.top;
                                x = box.right;
                            }
                        }
                        chartArea.x = x;
                        chartArea.y = y;
                    }
                    core_defaults._set("global", { layout: { padding: { top: 0, right: 0, bottom: 0, left: 0 } } });
                    var core_layouts = {
                        defaults: {},
                        addBox: function (chart, item) {
                            if (!chart.boxes) {
                                chart.boxes = [];
                            }
                            item.fullWidth = item.fullWidth || false;
                            item.position = item.position || "top";
                            item.weight = item.weight || 0;
                            item._layers =
                                item._layers ||
                                function () {
                                    return [
                                        {
                                            z: 0,
                                            draw: function () {
                                                item.draw.apply(item, arguments);
                                            },
                                        },
                                    ];
                                };
                            chart.boxes.push(item);
                        },
                        removeBox: function (chart, layoutItem) {
                            var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
                            if (index !== -1) {
                                chart.boxes.splice(index, 1);
                            }
                        },
                        configure: function (chart, item, options) {
                            var props = ["fullWidth", "position", "weight"];
                            var ilen = props.length;
                            var i = 0;
                            var prop;
                            for (; i < ilen; ++i) {
                                prop = props[i];
                                if (options.hasOwnProperty(prop)) {
                                    item[prop] = options[prop];
                                }
                            }
                        },
                        update: function (chart, width, height) {
                            if (!chart) {
                                return;
                            }
                            var layoutOptions = chart.options.layout || {};
                            var padding = helpers$1.options.toPadding(layoutOptions.padding);
                            var availableWidth = width - padding.width;
                            var availableHeight = height - padding.height;
                            var boxes = buildLayoutBoxes(chart.boxes);
                            var verticalBoxes = boxes.vertical;
                            var horizontalBoxes = boxes.horizontal;
                            var params = Object.freeze({
                                outerWidth: width,
                                outerHeight: height,
                                padding: padding,
                                availableWidth: availableWidth,
                                vBoxMaxWidth: availableWidth / 2 / verticalBoxes.length,
                                hBoxMaxHeight: availableHeight / 2,
                            });
                            var chartArea = extend({ maxPadding: extend({}, padding), w: availableWidth, h: availableHeight, x: padding.left, y: padding.top }, padding);
                            setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
                            fitBoxes(verticalBoxes, chartArea, params);
                            if (fitBoxes(horizontalBoxes, chartArea, params)) {
                                fitBoxes(verticalBoxes, chartArea, params);
                            }
                            handleMaxPadding(chartArea);
                            placeBoxes(boxes.leftAndTop, chartArea, params);
                            chartArea.x += chartArea.w;
                            chartArea.y += chartArea.h;
                            placeBoxes(boxes.rightAndBottom, chartArea, params);
                            chart.chartArea = { left: chartArea.left, top: chartArea.top, right: chartArea.left + chartArea.w, bottom: chartArea.top + chartArea.h };
                            helpers$1.each(boxes.chartArea, function (layout) {
                                var box = layout.box;
                                extend(box, chart.chartArea);
                                box.update(chartArea.w, chartArea.h);
                            });
                        },
                    };
                    var platform_basic = {
                        acquireContext: function (item) {
                            if (item && item.canvas) {
                                item = item.canvas;
                            }
                            return (item && item.getContext("2d")) || null;
                        },
                    };
                    var platform_dom =
                        "/*\r\n * DOM element rendering detection\r\n * https://davidwalsh.name/detect-node-insertion\r\n */\r\n@keyframes chartjs-render-animation {\r\n\tfrom { opacity: 0.99; }\r\n\tto { opacity: 1; }\r\n}\r\n\r\n.chartjs-render-monitor {\r\n\tanimation: chartjs-render-animation 0.001s;\r\n}\r\n\r\n/*\r\n * DOM element resizing detection\r\n * https://github.com/marcj/css-element-queries\r\n */\r\n.chartjs-size-monitor,\r\n.chartjs-size-monitor-expand,\r\n.chartjs-size-monitor-shrink {\r\n\tposition: absolute;\r\n\tdirection: ltr;\r\n\tleft: 0;\r\n\ttop: 0;\r\n\tright: 0;\r\n\tbottom: 0;\r\n\toverflow: hidden;\r\n\tpointer-events: none;\r\n\tvisibility: hidden;\r\n\tz-index: -1;\r\n}\r\n\r\n.chartjs-size-monitor-expand > div {\r\n\tposition: absolute;\r\n\twidth: 1000000px;\r\n\theight: 1000000px;\r\n\tleft: 0;\r\n\ttop: 0;\r\n}\r\n\r\n.chartjs-size-monitor-shrink > div {\r\n\tposition: absolute;\r\n\twidth: 200%;\r\n\theight: 200%;\r\n\tleft: 0;\r\n\ttop: 0;\r\n}\r\n";
                    var platform_dom$1 = Object.freeze({ __proto__: null, default: platform_dom });
                    var stylesheet = getCjsExportFromNamespace(platform_dom$1);
                    var EXPANDO_KEY = "$chartjs";
                    var CSS_PREFIX = "chartjs-";
                    var CSS_SIZE_MONITOR = CSS_PREFIX + "size-monitor";
                    var CSS_RENDER_MONITOR = CSS_PREFIX + "render-monitor";
                    var CSS_RENDER_ANIMATION = CSS_PREFIX + "render-animation";
                    var ANIMATION_START_EVENTS = ["animationstart", "webkitAnimationStart"];
                    var EVENT_TYPES = {
                        touchstart: "mousedown",
                        touchmove: "mousemove",
                        touchend: "mouseup",
                        pointerenter: "mouseenter",
                        pointerdown: "mousedown",
                        pointermove: "mousemove",
                        pointerup: "mouseup",
                        pointerleave: "mouseout",
                        pointerout: "mouseout",
                    };
                    function readUsedSize(element, property) {
                        var value = helpers$1.getStyle(element, property);
                        var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
                        return matches ? Number(matches[1]) : undefined;
                    }
                    function initCanvas(canvas, config) {
                        var style = canvas.style;
                        var renderHeight = canvas.getAttribute("height");
                        var renderWidth = canvas.getAttribute("width");
                        canvas[EXPANDO_KEY] = { initial: { height: renderHeight, width: renderWidth, style: { display: style.display, height: style.height, width: style.width } } };
                        style.display = style.display || "block";
                        if (renderWidth === null || renderWidth === "") {
                            var displayWidth = readUsedSize(canvas, "width");
                            if (displayWidth !== undefined) {
                                canvas.width = displayWidth;
                            }
                        }
                        if (renderHeight === null || renderHeight === "") {
                            if (canvas.style.height === "") {
                                canvas.height = canvas.width / (config.options.aspectRatio || 2);
                            } else {
                                var displayHeight = readUsedSize(canvas, "height");
                                if (displayWidth !== undefined) {
                                    canvas.height = displayHeight;
                                }
                            }
                        }
                        return canvas;
                    }
                    var supportsEventListenerOptions = (function () {
                        var supports = false;
                        try {
                            var options = Object.defineProperty({}, "passive", {
                                get: function () {
                                    supports = true;
                                },
                            });
                            window.addEventListener("e", null, options);
                        } catch (e) {}
                        return supports;
                    })();
                    var eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;
                    function addListener(node, type, listener) {
                        node.addEventListener(type, listener, eventListenerOptions);
                    }
                    function removeListener(node, type, listener) {
                        node.removeEventListener(type, listener, eventListenerOptions);
                    }
                    function createEvent(type, chart, x, y, nativeEvent) {
                        return { type: type, chart: chart, native: nativeEvent || null, x: x !== undefined ? x : null, y: y !== undefined ? y : null };
                    }
                    function fromNativeEvent(event, chart) {
                        var type = EVENT_TYPES[event.type] || event.type;
                        var pos = helpers$1.getRelativePosition(event, chart);
                        return createEvent(type, chart, pos.x, pos.y, event);
                    }
                    function throttled(fn, thisArg) {
                        var ticking = false;
                        var args = [];
                        return function () {
                            args = Array.prototype.slice.call(arguments);
                            thisArg = thisArg || this;
                            if (!ticking) {
                                ticking = true;
                                helpers$1.requestAnimFrame.call(window, function () {
                                    ticking = false;
                                    fn.apply(thisArg, args);
                                });
                            }
                        };
                    }
                    function createDiv(cls) {
                        var el = document.createElement("div");
                        el.className = cls || "";
                        return el;
                    }
                    function createResizer(handler) {
                        var maxSize = 1e6;
                        var resizer = createDiv(CSS_SIZE_MONITOR);
                        var expand = createDiv(CSS_SIZE_MONITOR + "-expand");
                        var shrink = createDiv(CSS_SIZE_MONITOR + "-shrink");
                        expand.appendChild(createDiv());
                        shrink.appendChild(createDiv());
                        resizer.appendChild(expand);
                        resizer.appendChild(shrink);
                        resizer._reset = function () {
                            expand.scrollLeft = maxSize;
                            expand.scrollTop = maxSize;
                            shrink.scrollLeft = maxSize;
                            shrink.scrollTop = maxSize;
                        };
                        var onScroll = function () {
                            resizer._reset();
                            handler();
                        };
                        addListener(expand, "scroll", onScroll.bind(expand, "expand"));
                        addListener(shrink, "scroll", onScroll.bind(shrink, "shrink"));
                        return resizer;
                    }
                    function watchForRender(node, handler) {
                        var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
                        var proxy = (expando.renderProxy = function (e) {
                            if (e.animationName === CSS_RENDER_ANIMATION) {
                                handler();
                            }
                        });
                        helpers$1.each(ANIMATION_START_EVENTS, function (type) {
                            addListener(node, type, proxy);
                        });
                        expando.reflow = !!node.offsetParent;
                        node.classList.add(CSS_RENDER_MONITOR);
                    }
                    function unwatchForRender(node) {
                        var expando = node[EXPANDO_KEY] || {};
                        var proxy = expando.renderProxy;
                        if (proxy) {
                            helpers$1.each(ANIMATION_START_EVENTS, function (type) {
                                removeListener(node, type, proxy);
                            });
                            delete expando.renderProxy;
                        }
                        node.classList.remove(CSS_RENDER_MONITOR);
                    }
                    function addResizeListener(node, listener, chart) {
                        var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
                        var resizer = (expando.resizer = createResizer(
                            throttled(function () {
                                if (expando.resizer) {
                                    var container = chart.options.maintainAspectRatio && node.parentNode;
                                    var w = container ? container.clientWidth : 0;
                                    listener(createEvent("resize", chart));
                                    if (container && container.clientWidth < w && chart.canvas) {
                                        listener(createEvent("resize", chart));
                                    }
                                }
                            })
                        ));
                        watchForRender(node, function () {
                            if (expando.resizer) {
                                var container = node.parentNode;
                                if (container && container !== resizer.parentNode) {
                                    container.insertBefore(resizer, container.firstChild);
                                }
                                resizer._reset();
                            }
                        });
                    }
                    function removeResizeListener(node) {
                        var expando = node[EXPANDO_KEY] || {};
                        var resizer = expando.resizer;
                        delete expando.resizer;
                        unwatchForRender(node);
                        if (resizer && resizer.parentNode) {
                            resizer.parentNode.removeChild(resizer);
                        }
                    }
                    function injectCSS(rootNode, css) {
                        var expando = rootNode[EXPANDO_KEY] || (rootNode[EXPANDO_KEY] = {});
                        if (!expando.containsStyles) {
                            expando.containsStyles = true;
                            css = "/* Chart.js */\n" + css;
                            var style = document.createElement("style");
                            style.setAttribute("type", "text/css");
                            style.appendChild(document.createTextNode(css));
                            rootNode.appendChild(style);
                        }
                    }
                    var platform_dom$2 = {
                        disableCSSInjection: false,
                        _enabled: typeof window !== "undefined" && typeof document !== "undefined",
                        _ensureLoaded: function (canvas) {
                            if (!this.disableCSSInjection) {
                                var root = canvas.getRootNode ? canvas.getRootNode() : document;
                                var targetNode = root.host ? root : document.head;
                                injectCSS(targetNode, stylesheet);
                            }
                        },
                        acquireContext: function (item, config) {
                            if (typeof item === "string") {
                                item = document.getElementById(item);
                            } else if (item.length) {
                                item = item[0];
                            }
                            if (item && item.canvas) {
                                item = item.canvas;
                            }
                            var context = item && item.getContext && item.getContext("2d");
                            if (context && context.canvas === item) {
                                this._ensureLoaded(item);
                                initCanvas(item, config);
                                return context;
                            }
                            return null;
                        },
                        releaseContext: function (context) {
                            var canvas = context.canvas;
                            if (!canvas[EXPANDO_KEY]) {
                                return;
                            }
                            var initial = canvas[EXPANDO_KEY].initial;
                            ["height", "width"].forEach(function (prop) {
                                var value = initial[prop];
                                if (helpers$1.isNullOrUndef(value)) {
                                    canvas.removeAttribute(prop);
                                } else {
                                    canvas.setAttribute(prop, value);
                                }
                            });
                            helpers$1.each(initial.style || {}, function (value, key) {
                                canvas.style[key] = value;
                            });
                            canvas.width = canvas.width;
                            delete canvas[EXPANDO_KEY];
                        },
                        addEventListener: function (chart, type, listener) {
                            var canvas = chart.canvas;
                            if (type === "resize") {
                                addResizeListener(canvas, listener, chart);
                                return;
                            }
                            var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
                            var proxies = expando.proxies || (expando.proxies = {});
                            var proxy = (proxies[chart.id + "_" + type] = function (event) {
                                listener(fromNativeEvent(event, chart));
                            });
                            addListener(canvas, type, proxy);
                        },
                        removeEventListener: function (chart, type, listener) {
                            var canvas = chart.canvas;
                            if (type === "resize") {
                                removeResizeListener(canvas);
                                return;
                            }
                            var expando = listener[EXPANDO_KEY] || {};
                            var proxies = expando.proxies || {};
                            var proxy = proxies[chart.id + "_" + type];
                            if (!proxy) {
                                return;
                            }
                            removeListener(canvas, type, proxy);
                        },
                    };
                    helpers$1.addEvent = addListener;
                    helpers$1.removeEvent = removeListener;
                    var implementation = platform_dom$2._enabled ? platform_dom$2 : platform_basic;
                    var platform = helpers$1.extend({ initialize: function () {}, acquireContext: function () {}, releaseContext: function () {}, addEventListener: function () {}, removeEventListener: function () {} }, implementation);
                    core_defaults._set("global", { plugins: {} });
                    var core_plugins = {
                        _plugins: [],
                        _cacheId: 0,
                        register: function (plugins) {
                            var p = this._plugins;
                            [].concat(plugins).forEach(function (plugin) {
                                if (p.indexOf(plugin) === -1) {
                                    p.push(plugin);
                                }
                            });
                            this._cacheId++;
                        },
                        unregister: function (plugins) {
                            var p = this._plugins;
                            [].concat(plugins).forEach(function (plugin) {
                                var idx = p.indexOf(plugin);
                                if (idx !== -1) {
                                    p.splice(idx, 1);
                                }
                            });
                            this._cacheId++;
                        },
                        clear: function () {
                            this._plugins = [];
                            this._cacheId++;
                        },
                        count: function () {
                            return this._plugins.length;
                        },
                        getAll: function () {
                            return this._plugins;
                        },
                        notify: function (chart, hook, args) {
                            var descriptors = this.descriptors(chart);
                            var ilen = descriptors.length;
                            var i, descriptor, plugin, params, method;
                            for (i = 0; i < ilen; ++i) {
                                descriptor = descriptors[i];
                                plugin = descriptor.plugin;
                                method = plugin[hook];
                                if (typeof method === "function") {
                                    params = [chart].concat(args || []);
                                    params.push(descriptor.options);
                                    if (method.apply(plugin, params) === false) {
                                        return false;
                                    }
                                }
                            }
                            return true;
                        },
                        descriptors: function (chart) {
                            var cache = chart.$plugins || (chart.$plugins = {});
                            if (cache.id === this._cacheId) {
                                return cache.descriptors;
                            }
                            var plugins = [];
                            var descriptors = [];
                            var config = (chart && chart.config) || {};
                            var options = (config.options && config.options.plugins) || {};
                            this._plugins.concat(config.plugins || []).forEach(function (plugin) {
                                var idx = plugins.indexOf(plugin);
                                if (idx !== -1) {
                                    return;
                                }
                                var id = plugin.id;
                                var opts = options[id];
                                if (opts === false) {
                                    return;
                                }
                                if (opts === true) {
                                    opts = helpers$1.clone(core_defaults.global.plugins[id]);
                                }
                                plugins.push(plugin);
                                descriptors.push({ plugin: plugin, options: opts || {} });
                            });
                            cache.descriptors = descriptors;
                            cache.id = this._cacheId;
                            return descriptors;
                        },
                        _invalidate: function (chart) {
                            delete chart.$plugins;
                        },
                    };
                    var core_scaleService = {
                        constructors: {},
                        defaults: {},
                        registerScaleType: function (type, scaleConstructor, scaleDefaults) {
                            this.constructors[type] = scaleConstructor;
                            this.defaults[type] = helpers$1.clone(scaleDefaults);
                        },
                        getScaleConstructor: function (type) {
                            return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
                        },
                        getScaleDefaults: function (type) {
                            return this.defaults.hasOwnProperty(type) ? helpers$1.merge(Object.create(null), [core_defaults.scale, this.defaults[type]]) : {};
                        },
                        updateScaleDefaults: function (type, additions) {
                            var me = this;
                            if (me.defaults.hasOwnProperty(type)) {
                                me.defaults[type] = helpers$1.extend(me.defaults[type], additions);
                            }
                        },
                        addScalesToLayout: function (chart) {
                            helpers$1.each(chart.scales, function (scale) {
                                scale.fullWidth = scale.options.fullWidth;
                                scale.position = scale.options.position;
                                scale.weight = scale.options.weight;
                                core_layouts.addBox(chart, scale);
                            });
                        },
                    };
                    var valueOrDefault$8 = helpers$1.valueOrDefault;
                    var getRtlHelper = helpers$1.rtl.getRtlAdapter;
                    core_defaults._set("global", {
                        tooltips: {
                            enabled: true,
                            custom: null,
                            mode: "nearest",
                            position: "average",
                            intersect: true,
                            backgroundColor: "rgba(0,0,0,0.8)",
                            titleFontStyle: "bold",
                            titleSpacing: 2,
                            titleMarginBottom: 6,
                            titleFontColor: "#fff",
                            titleAlign: "left",
                            bodySpacing: 2,
                            bodyFontColor: "#fff",
                            bodyAlign: "left",
                            footerFontStyle: "bold",
                            footerSpacing: 2,
                            footerMarginTop: 6,
                            footerFontColor: "#fff",
                            footerAlign: "left",
                            yPadding: 6,
                            xPadding: 6,
                            caretPadding: 2,
                            caretSize: 5,
                            cornerRadius: 6,
                            multiKeyBackground: "#fff",
                            displayColors: true,
                            borderColor: "rgba(0,0,0,0)",
                            borderWidth: 0,
                            callbacks: {
                                beforeTitle: helpers$1.noop,
                                title: function (tooltipItems, data) {
                                    var title = "";
                                    var labels = data.labels;
                                    var labelCount = labels ? labels.length : 0;
                                    if (tooltipItems.length > 0) {
                                        var item = tooltipItems[0];
                                        if (item.label) {
                                            title = item.label;
                                        } else if (item.xLabel) {
                                            title = item.xLabel;
                                        } else if (labelCount > 0 && item.index < labelCount) {
                                            title = labels[item.index];
                                        }
                                    }
                                    return title;
                                },
                                afterTitle: helpers$1.noop,
                                beforeBody: helpers$1.noop,
                                beforeLabel: helpers$1.noop,
                                label: function (tooltipItem, data) {
                                    var label = data.datasets[tooltipItem.datasetIndex].label || "";
                                    if (label) {
                                        label += ": ";
                                    }
                                    if (!helpers$1.isNullOrUndef(tooltipItem.value)) {
                                        label += tooltipItem.value;
                                    } else {
                                        label += tooltipItem.yLabel;
                                    }
                                    return label;
                                },
                                labelColor: function (tooltipItem, chart) {
                                    var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
                                    var activeElement = meta.data[tooltipItem.index];
                                    var view = activeElement._view;
                                    return { borderColor: view.borderColor, backgroundColor: view.backgroundColor };
                                },
                                labelTextColor: function () {
                                    return this._options.bodyFontColor;
                                },
                                afterLabel: helpers$1.noop,
                                afterBody: helpers$1.noop,
                                beforeFooter: helpers$1.noop,
                                footer: helpers$1.noop,
                                afterFooter: helpers$1.noop,
                            },
                        },
                    });
                    var positioners = {
                        average: function (elements) {
                            if (!elements.length) {
                                return false;
                            }
                            var i, len;
                            var x = 0;
                            var y = 0;
                            var count = 0;
                            for (i = 0, len = elements.length; i < len; ++i) {
                                var el = elements[i];
                                if (el && el.hasValue()) {
                                    var pos = el.tooltipPosition();
                                    x += pos.x;
                                    y += pos.y;
                                    ++count;
                                }
                            }
                            return { x: x / count, y: y / count };
                        },
                        nearest: function (elements, eventPosition) {
                            var x = eventPosition.x;
                            var y = eventPosition.y;
                            var minDistance = Number.POSITIVE_INFINITY;
                            var i, len, nearestElement;
                            for (i = 0, len = elements.length; i < len; ++i) {
                                var el = elements[i];
                                if (el && el.hasValue()) {
                                    var center = el.getCenterPoint();
                                    var d = helpers$1.distanceBetweenPoints(eventPosition, center);
                                    if (d < minDistance) {
                                        minDistance = d;
                                        nearestElement = el;
                                    }
                                }
                            }
                            if (nearestElement) {
                                var tp = nearestElement.tooltipPosition();
                                x = tp.x;
                                y = tp.y;
                            }
                            return { x: x, y: y };
                        },
                    };
                    function pushOrConcat(base, toPush) {
                        if (toPush) {
                            if (helpers$1.isArray(toPush)) {
                                Array.prototype.push.apply(base, toPush);
                            } else {
                                base.push(toPush);
                            }
                        }
                        return base;
                    }
                    function splitNewlines(str) {
                        if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
                            return str.split("\n");
                        }
                        return str;
                    }
                    function createTooltipItem(element) {
                        var xScale = element._xScale;
                        var yScale = element._yScale || element._scale;
                        var index = element._index;
                        var datasetIndex = element._datasetIndex;
                        var controller = element._chart.getDatasetMeta(datasetIndex).controller;
                        var indexScale = controller._getIndexScale();
                        var valueScale = controller._getValueScale();
                        return {
                            xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : "",
                            yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : "",
                            label: indexScale ? "" + indexScale.getLabelForIndex(index, datasetIndex) : "",
                            value: valueScale ? "" + valueScale.getLabelForIndex(index, datasetIndex) : "",
                            index: index,
                            datasetIndex: datasetIndex,
                            x: element._model.x,
                            y: element._model.y,
                        };
                    }
                    function getBaseModel(tooltipOpts) {
                        var globalDefaults = core_defaults.global;
                        return {
                            xPadding: tooltipOpts.xPadding,
                            yPadding: tooltipOpts.yPadding,
                            xAlign: tooltipOpts.xAlign,
                            yAlign: tooltipOpts.yAlign,
                            rtl: tooltipOpts.rtl,
                            textDirection: tooltipOpts.textDirection,
                            bodyFontColor: tooltipOpts.bodyFontColor,
                            _bodyFontFamily: valueOrDefault$8(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
                            _bodyFontStyle: valueOrDefault$8(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
                            _bodyAlign: tooltipOpts.bodyAlign,
                            bodyFontSize: valueOrDefault$8(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
                            bodySpacing: tooltipOpts.bodySpacing,
                            titleFontColor: tooltipOpts.titleFontColor,
                            _titleFontFamily: valueOrDefault$8(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
                            _titleFontStyle: valueOrDefault$8(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
                            titleFontSize: valueOrDefault$8(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
                            _titleAlign: tooltipOpts.titleAlign,
                            titleSpacing: tooltipOpts.titleSpacing,
                            titleMarginBottom: tooltipOpts.titleMarginBottom,
                            footerFontColor: tooltipOpts.footerFontColor,
                            _footerFontFamily: valueOrDefault$8(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
                            _footerFontStyle: valueOrDefault$8(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
                            footerFontSize: valueOrDefault$8(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
                            _footerAlign: tooltipOpts.footerAlign,
                            footerSpacing: tooltipOpts.footerSpacing,
                            footerMarginTop: tooltipOpts.footerMarginTop,
                            caretSize: tooltipOpts.caretSize,
                            cornerRadius: tooltipOpts.cornerRadius,
                            backgroundColor: tooltipOpts.backgroundColor,
                            opacity: 0,
                            legendColorBackground: tooltipOpts.multiKeyBackground,
                            displayColors: tooltipOpts.displayColors,
                            borderColor: tooltipOpts.borderColor,
                            borderWidth: tooltipOpts.borderWidth,
                        };
                    }
                    function getTooltipSize(tooltip, model) {
                        var ctx = tooltip._chart.ctx;
                        var height = model.yPadding * 2;
                        var width = 0;
                        var body = model.body;
                        var combinedBodyLength = body.reduce(function (count, bodyItem) {
                            return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
                        }, 0);
                        combinedBodyLength += model.beforeBody.length + model.afterBody.length;
                        var titleLineCount = model.title.length;
                        var footerLineCount = model.footer.length;
                        var titleFontSize = model.titleFontSize;
                        var bodyFontSize = model.bodyFontSize;
                        var footerFontSize = model.footerFontSize;
                        height += titleLineCount * titleFontSize;
                        height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0;
                        height += titleLineCount ? model.titleMarginBottom : 0;
                        height += combinedBodyLength * bodyFontSize;
                        height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0;
                        height += footerLineCount ? model.footerMarginTop : 0;
                        height += footerLineCount * footerFontSize;
                        height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0;
                        var widthPadding = 0;
                        var maxLineWidth = function (line) {
                            width = Math.max(width, ctx.measureText(line).width + widthPadding);
                        };
                        ctx.font = helpers$1.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
                        helpers$1.each(model.title, maxLineWidth);
                        ctx.font = helpers$1.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
                        helpers$1.each(model.beforeBody.concat(model.afterBody), maxLineWidth);
                        widthPadding = model.displayColors ? bodyFontSize + 2 : 0;
                        helpers$1.each(body, function (bodyItem) {
                            helpers$1.each(bodyItem.before, maxLineWidth);
                            helpers$1.each(bodyItem.lines, maxLineWidth);
                            helpers$1.each(bodyItem.after, maxLineWidth);
                        });
                        widthPadding = 0;
                        ctx.font = helpers$1.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
                        helpers$1.each(model.footer, maxLineWidth);
                        width += 2 * model.xPadding;
                        return { width: width, height: height };
                    }
                    function determineAlignment(tooltip, size) {
                        var model = tooltip._model;
                        var chart = tooltip._chart;
                        var chartArea = tooltip._chart.chartArea;
                        var xAlign = "center";
                        var yAlign = "center";
                        if (model.y < size.height) {
                            yAlign = "top";
                        } else if (model.y > chart.height - size.height) {
                            yAlign = "bottom";
                        }
                        var lf, rf;
                        var olf, orf;
                        var yf;
                        var midX = (chartArea.left + chartArea.right) / 2;
                        var midY = (chartArea.top + chartArea.bottom) / 2;
                        if (yAlign === "center") {
                            lf = function (x) {
                                return x <= midX;
                            };
                            rf = function (x) {
                                return x > midX;
                            };
                        } else {
                            lf = function (x) {
                                return x <= size.width / 2;
                            };
                            rf = function (x) {
                                return x >= chart.width - size.width / 2;
                            };
                        }
                        olf = function (x) {
                            return x + size.width + model.caretSize + model.caretPadding > chart.width;
                        };
                        orf = function (x) {
                            return x - size.width - model.caretSize - model.caretPadding < 0;
                        };
                        yf = function (y) {
                            return y <= midY ? "top" : "bottom";
                        };
                        if (lf(model.x)) {
                            xAlign = "left";
                            if (olf(model.x)) {
                                xAlign = "center";
                                yAlign = yf(model.y);
                            }
                        } else if (rf(model.x)) {
                            xAlign = "right";
                            if (orf(model.x)) {
                                xAlign = "center";
                                yAlign = yf(model.y);
                            }
                        }
                        var opts = tooltip._options;
                        return { xAlign: opts.xAlign ? opts.xAlign : xAlign, yAlign: opts.yAlign ? opts.yAlign : yAlign };
                    }
                    function getBackgroundPoint(vm, size, alignment, chart) {
                        var x = vm.x;
                        var y = vm.y;
                        var caretSize = vm.caretSize;
                        var caretPadding = vm.caretPadding;
                        var cornerRadius = vm.cornerRadius;
                        var xAlign = alignment.xAlign;
                        var yAlign = alignment.yAlign;
                        var paddingAndSize = caretSize + caretPadding;
                        var radiusAndPadding = cornerRadius + caretPadding;
                        if (xAlign === "right") {
                            x -= size.width;
                        } else if (xAlign === "center") {
                            x -= size.width / 2;
                            if (x + size.width > chart.width) {
                                x = chart.width - size.width;
                            }
                            if (x < 0) {
                                x = 0;
                            }
                        }
                        if (yAlign === "top") {
                            y += paddingAndSize;
                        } else if (yAlign === "bottom") {
                            y -= size.height + paddingAndSize;
                        } else {
                            y -= size.height / 2;
                        }
                        if (yAlign === "center") {
                            if (xAlign === "left") {
                                x += paddingAndSize;
                            } else if (xAlign === "right") {
                                x -= paddingAndSize;
                            }
                        } else if (xAlign === "left") {
                            x -= radiusAndPadding;
                        } else if (xAlign === "right") {
                            x += radiusAndPadding;
                        }
                        return { x: x, y: y };
                    }
                    function getAlignedX(vm, align) {
                        return align === "center" ? vm.x + vm.width / 2 : align === "right" ? vm.x + vm.width - vm.xPadding : vm.x + vm.xPadding;
                    }
                    function getBeforeAfterBodyLines(callback) {
                        return pushOrConcat([], splitNewlines(callback));
                    }
                    var exports$4 = core_element.extend({
                        initialize: function () {
                            this._model = getBaseModel(this._options);
                            this._lastActive = [];
                        },
                        getTitle: function () {
                            var me = this;
                            var opts = me._options;
                            var callbacks = opts.callbacks;
                            var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
                            var title = callbacks.title.apply(me, arguments);
                            var afterTitle = callbacks.afterTitle.apply(me, arguments);
                            var lines = [];
                            lines = pushOrConcat(lines, splitNewlines(beforeTitle));
                            lines = pushOrConcat(lines, splitNewlines(title));
                            lines = pushOrConcat(lines, splitNewlines(afterTitle));
                            return lines;
                        },
                        getBeforeBody: function () {
                            return getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));
                        },
                        getBody: function (tooltipItems, data) {
                            var me = this;
                            var callbacks = me._options.callbacks;
                            var bodyItems = [];
                            helpers$1.each(tooltipItems, function (tooltipItem) {
                                var bodyItem = { before: [], lines: [], after: [] };
                                pushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));
                                pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
                                pushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));
                                bodyItems.push(bodyItem);
                            });
                            return bodyItems;
                        },
                        getAfterBody: function () {
                            return getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));
                        },
                        getFooter: function () {
                            var me = this;
                            var callbacks = me._options.callbacks;
                            var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
                            var footer = callbacks.footer.apply(me, arguments);
                            var afterFooter = callbacks.afterFooter.apply(me, arguments);
                            var lines = [];
                            lines = pushOrConcat(lines, splitNewlines(beforeFooter));
                            lines = pushOrConcat(lines, splitNewlines(footer));
                            lines = pushOrConcat(lines, splitNewlines(afterFooter));
                            return lines;
                        },
                        update: function (changed) {
                            var me = this;
                            var opts = me._options;
                            var existingModel = me._model;
                            var model = (me._model = getBaseModel(opts));
                            var active = me._active;
                            var data = me._data;
                            var alignment = { xAlign: existingModel.xAlign, yAlign: existingModel.yAlign };
                            var backgroundPoint = { x: existingModel.x, y: existingModel.y };
                            var tooltipSize = { width: existingModel.width, height: existingModel.height };
                            var tooltipPosition = { x: existingModel.caretX, y: existingModel.caretY };
                            var i, len;
                            if (active.length) {
                                model.opacity = 1;
                                var labelColors = [];
                                var labelTextColors = [];
                                tooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);
                                var tooltipItems = [];
                                for (i = 0, len = active.length; i < len; ++i) {
                                    tooltipItems.push(createTooltipItem(active[i]));
                                }
                                if (opts.filter) {
                                    tooltipItems = tooltipItems.filter(function (a) {
                                        return opts.filter(a, data);
                                    });
                                }
                                if (opts.itemSort) {
                                    tooltipItems = tooltipItems.sort(function (a, b) {
                                        return opts.itemSort(a, b, data);
                                    });
                                }
                                helpers$1.each(tooltipItems, function (tooltipItem) {
                                    labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
                                    labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
                                });
                                model.title = me.getTitle(tooltipItems, data);
                                model.beforeBody = me.getBeforeBody(tooltipItems, data);
                                model.body = me.getBody(tooltipItems, data);
                                model.afterBody = me.getAfterBody(tooltipItems, data);
                                model.footer = me.getFooter(tooltipItems, data);
                                model.x = tooltipPosition.x;
                                model.y = tooltipPosition.y;
                                model.caretPadding = opts.caretPadding;
                                model.labelColors = labelColors;
                                model.labelTextColors = labelTextColors;
                                model.dataPoints = tooltipItems;
                                tooltipSize = getTooltipSize(this, model);
                                alignment = determineAlignment(this, tooltipSize);
                                backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);
                            } else {
                                model.opacity = 0;
                            }
                            model.xAlign = alignment.xAlign;
                            model.yAlign = alignment.yAlign;
                            model.x = backgroundPoint.x;
                            model.y = backgroundPoint.y;
                            model.width = tooltipSize.width;
                            model.height = tooltipSize.height;
                            model.caretX = tooltipPosition.x;
                            model.caretY = tooltipPosition.y;
                            me._model = model;
                            if (changed && opts.custom) {
                                opts.custom.call(me, model);
                            }
                            return me;
                        },
                        drawCaret: function (tooltipPoint, size) {
                            var ctx = this._chart.ctx;
                            var vm = this._view;
                            var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);
                            ctx.lineTo(caretPosition.x1, caretPosition.y1);
                            ctx.lineTo(caretPosition.x2, caretPosition.y2);
                            ctx.lineTo(caretPosition.x3, caretPosition.y3);
                        },
                        getCaretPosition: function (tooltipPoint, size, vm) {
                            var x1, x2, x3, y1, y2, y3;
                            var caretSize = vm.caretSize;
                            var cornerRadius = vm.cornerRadius;
                            var xAlign = vm.xAlign;
                            var yAlign = vm.yAlign;
                            var ptX = tooltipPoint.x;
                            var ptY = tooltipPoint.y;
                            var width = size.width;
                            var height = size.height;
                            if (yAlign === "center") {
                                y2 = ptY + height / 2;
                                if (xAlign === "left") {
                                    x1 = ptX;
                                    x2 = x1 - caretSize;
                                    x3 = x1;
                                    y1 = y2 + caretSize;
                                    y3 = y2 - caretSize;
                                } else {
                                    x1 = ptX + width;
                                    x2 = x1 + caretSize;
                                    x3 = x1;
                                    y1 = y2 - caretSize;
                                    y3 = y2 + caretSize;
                                }
                            } else {
                                if (xAlign === "left") {
                                    x2 = ptX + cornerRadius + caretSize;
                                    x1 = x2 - caretSize;
                                    x3 = x2 + caretSize;
                                } else if (xAlign === "right") {
                                    x2 = ptX + width - cornerRadius - caretSize;
                                    x1 = x2 - caretSize;
                                    x3 = x2 + caretSize;
                                } else {
                                    x2 = vm.caretX;
                                    x1 = x2 - caretSize;
                                    x3 = x2 + caretSize;
                                }
                                if (yAlign === "top") {
                                    y1 = ptY;
                                    y2 = y1 - caretSize;
                                    y3 = y1;
                                } else {
                                    y1 = ptY + height;
                                    y2 = y1 + caretSize;
                                    y3 = y1;
                                    var tmp = x3;
                                    x3 = x1;
                                    x1 = tmp;
                                }
                            }
                            return { x1: x1, x2: x2, x3: x3, y1: y1, y2: y2, y3: y3 };
                        },
                        drawTitle: function (pt, vm, ctx) {
                            var title = vm.title;
                            var length = title.length;
                            var titleFontSize, titleSpacing, i;
                            if (length) {
                                var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);
                                pt.x = getAlignedX(vm, vm._titleAlign);
                                ctx.textAlign = rtlHelper.textAlign(vm._titleAlign);
                                ctx.textBaseline = "middle";
                                titleFontSize = vm.titleFontSize;
                                titleSpacing = vm.titleSpacing;
                                ctx.fillStyle = vm.titleFontColor;
                                ctx.font = helpers$1.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
                                for (i = 0; i < length; ++i) {
                                    ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFontSize / 2);
                                    pt.y += titleFontSize + titleSpacing;
                                    if (i + 1 === length) {
                                        pt.y += vm.titleMarginBottom - titleSpacing;
                                    }
                                }
                            }
                        },
                        drawBody: function (pt, vm, ctx) {
                            var bodyFontSize = vm.bodyFontSize;
                            var bodySpacing = vm.bodySpacing;
                            var bodyAlign = vm._bodyAlign;
                            var body = vm.body;
                            var drawColorBoxes = vm.displayColors;
                            var xLinePadding = 0;
                            var colorX = drawColorBoxes ? getAlignedX(vm, "left") : 0;
                            var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);
                            var fillLineOfText = function (line) {
                                ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyFontSize / 2);
                                pt.y += bodyFontSize + bodySpacing;
                            };
                            var bodyItem, textColor, labelColors, lines, i, j, ilen, jlen;
                            var bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
                            ctx.textAlign = bodyAlign;
                            ctx.textBaseline = "middle";
                            ctx.font = helpers$1.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
                            pt.x = getAlignedX(vm, bodyAlignForCalculation);
                            ctx.fillStyle = vm.bodyFontColor;
                            helpers$1.each(vm.beforeBody, fillLineOfText);
                            xLinePadding = drawColorBoxes && bodyAlignForCalculation !== "right" ? (bodyAlign === "center" ? bodyFontSize / 2 + 1 : bodyFontSize + 2) : 0;
                            for (i = 0, ilen = body.length; i < ilen; ++i) {
                                bodyItem = body[i];
                                textColor = vm.labelTextColors[i];
                                labelColors = vm.labelColors[i];
                                ctx.fillStyle = textColor;
                                helpers$1.each(bodyItem.before, fillLineOfText);
                                lines = bodyItem.lines;
                                for (j = 0, jlen = lines.length; j < jlen; ++j) {
                                    if (drawColorBoxes) {
                                        var rtlColorX = rtlHelper.x(colorX);
                                        ctx.fillStyle = vm.legendColorBackground;
                                        ctx.fillRect(rtlHelper.leftForLtr(rtlColorX, bodyFontSize), pt.y, bodyFontSize, bodyFontSize);
                                        ctx.lineWidth = 1;
                                        ctx.strokeStyle = labelColors.borderColor;
                                        ctx.strokeRect(rtlHelper.leftForLtr(rtlColorX, bodyFontSize), pt.y, bodyFontSize, bodyFontSize);
                                        ctx.fillStyle = labelColors.backgroundColor;
                                        ctx.fillRect(rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), bodyFontSize - 2), pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
                                        ctx.fillStyle = textColor;
                                    }
                                    fillLineOfText(lines[j]);
                                }
                                helpers$1.each(bodyItem.after, fillLineOfText);
                            }
                            xLinePadding = 0;
                            helpers$1.each(vm.afterBody, fillLineOfText);
                            pt.y -= bodySpacing;
                        },
                        drawFooter: function (pt, vm, ctx) {
                            var footer = vm.footer;
                            var length = footer.length;
                            var footerFontSize, i;
                            if (length) {
                                var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);
                                pt.x = getAlignedX(vm, vm._footerAlign);
                                pt.y += vm.footerMarginTop;
                                ctx.textAlign = rtlHelper.textAlign(vm._footerAlign);
                                ctx.textBaseline = "middle";
                                footerFontSize = vm.footerFontSize;
                                ctx.fillStyle = vm.footerFontColor;
                                ctx.font = helpers$1.fontString(footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
                                for (i = 0; i < length; ++i) {
                                    ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFontSize / 2);
                                    pt.y += footerFontSize + vm.footerSpacing;
                                }
                            }
                        },
                        drawBackground: function (pt, vm, ctx, tooltipSize) {
                            ctx.fillStyle = vm.backgroundColor;
                            ctx.strokeStyle = vm.borderColor;
                            ctx.lineWidth = vm.borderWidth;
                            var xAlign = vm.xAlign;
                            var yAlign = vm.yAlign;
                            var x = pt.x;
                            var y = pt.y;
                            var width = tooltipSize.width;
                            var height = tooltipSize.height;
                            var radius = vm.cornerRadius;
                            ctx.beginPath();
                            ctx.moveTo(x + radius, y);
                            if (yAlign === "top") {
                                this.drawCaret(pt, tooltipSize);
                            }
                            ctx.lineTo(x + width - radius, y);
                            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                            if (yAlign === "center" && xAlign === "right") {
                                this.drawCaret(pt, tooltipSize);
                            }
                            ctx.lineTo(x + width, y + height - radius);
                            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                            if (yAlign === "bottom") {
                                this.drawCaret(pt, tooltipSize);
                            }
                            ctx.lineTo(x + radius, y + height);
                            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                            if (yAlign === "center" && xAlign === "left") {
                                this.drawCaret(pt, tooltipSize);
                            }
                            ctx.lineTo(x, y + radius);
                            ctx.quadraticCurveTo(x, y, x + radius, y);
                            ctx.closePath();
                            ctx.fill();
                            if (vm.borderWidth > 0) {
                                ctx.stroke();
                            }
                        },
                        draw: function () {
                            var ctx = this._chart.ctx;
                            var vm = this._view;
                            if (vm.opacity === 0) {
                                return;
                            }
                            var tooltipSize = { width: vm.width, height: vm.height };
                            var pt = { x: vm.x, y: vm.y };
                            var opacity = Math.abs(vm.opacity < 0.001) ? 0 : vm.opacity;
                            var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;
                            if (this._options.enabled && hasTooltipContent) {
                                ctx.save();
                                ctx.globalAlpha = opacity;
                                this.drawBackground(pt, vm, ctx, tooltipSize);
                                pt.y += vm.yPadding;
                                helpers$1.rtl.overrideTextDirection(ctx, vm.textDirection);
                                this.drawTitle(pt, vm, ctx);
                                this.drawBody(pt, vm, ctx);
                                this.drawFooter(pt, vm, ctx);
                                helpers$1.rtl.restoreTextDirection(ctx, vm.textDirection);
                                ctx.restore();
                            }
                        },
                        handleEvent: function (e) {
                            var me = this;
                            var options = me._options;
                            var changed = false;
                            me._lastActive = me._lastActive || [];
                            if (e.type === "mouseout") {
                                me._active = [];
                            } else {
                                me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);
                                if (options.reverse) {
                                    me._active.reverse();
                                }
                            }
                            changed = !helpers$1.arrayEquals(me._active, me._lastActive);
                            if (changed) {
                                me._lastActive = me._active;
                                if (options.enabled || options.custom) {
                                    me._eventPosition = { x: e.x, y: e.y };
                                    me.update(true);
                                    me.pivot();
                                }
                            }
                            return changed;
                        },
                    });
                    var positioners_1 = positioners;
                    var core_tooltip = exports$4;
                    core_tooltip.positioners = positioners_1;
                    var valueOrDefault$9 = helpers$1.valueOrDefault;
                    core_defaults._set("global", {
                        elements: {},
                        events: ["mousemove", "mouseout", "click", "touchstart", "touchmove"],
                        hover: { onHover: null, mode: "nearest", intersect: true, animationDuration: 400 },
                        onClick: null,
                        maintainAspectRatio: true,
                        responsive: true,
                        responsiveAnimationDuration: 0,
                    });
                    function mergeScaleConfig() {
                        return helpers$1.merge(Object.create(null), [].slice.call(arguments), {
                            merger: function (key, target, source, options) {
                                if (key === "xAxes" || key === "yAxes") {
                                    var slen = source[key].length;
                                    var i, type, scale;
                                    if (!target[key]) {
                                        target[key] = [];
                                    }
                                    for (i = 0; i < slen; ++i) {
                                        scale = source[key][i];
                                        type = valueOrDefault$9(scale.type, key === "xAxes" ? "category" : "linear");
                                        if (i >= target[key].length) {
                                            target[key].push({});
                                        }
                                        if (!target[key][i].type || (scale.type && scale.type !== target[key][i].type)) {
                                            helpers$1.merge(target[key][i], [core_scaleService.getScaleDefaults(type), scale]);
                                        } else {
                                            helpers$1.merge(target[key][i], scale);
                                        }
                                    }
                                } else {
                                    helpers$1._merger(key, target, source, options);
                                }
                            },
                        });
                    }
                    function mergeConfig() {
                        return helpers$1.merge(Object.create(null), [].slice.call(arguments), {
                            merger: function (key, target, source, options) {
                                var tval = target[key] || Object.create(null);
                                var sval = source[key];
                                if (key === "scales") {
                                    target[key] = mergeScaleConfig(tval, sval);
                                } else if (key === "scale") {
                                    target[key] = helpers$1.merge(tval, [core_scaleService.getScaleDefaults(sval.type), sval]);
                                } else {
                                    helpers$1._merger(key, target, source, options);
                                }
                            },
                        });
                    }
                    function initConfig(config) {
                        config = config || Object.create(null);
                        var data = (config.data = config.data || {});
                        data.datasets = data.datasets || [];
                        data.labels = data.labels || [];
                        config.options = mergeConfig(core_defaults.global, core_defaults[config.type], config.options || {});
                        return config;
                    }
                    function updateConfig(chart) {
                        var newOptions = chart.options;
                        helpers$1.each(chart.scales, function (scale) {
                            core_layouts.removeBox(chart, scale);
                        });
                        newOptions = mergeConfig(core_defaults.global, core_defaults[chart.config.type], newOptions);
                        chart.options = chart.config.options = newOptions;
                        chart.ensureScalesHaveIDs();
                        chart.buildOrUpdateScales();
                        chart.tooltip._options = newOptions.tooltips;
                        chart.tooltip.initialize();
                    }
                    function nextAvailableScaleId(axesOpts, prefix, index) {
                        var id;
                        var hasId = function (obj) {
                            return obj.id === id;
                        };
                        do {
                            id = prefix + index++;
                        } while (helpers$1.findIndex(axesOpts, hasId) >= 0);
                        return id;
                    }
                    function positionIsHorizontal(position) {
                        return position === "top" || position === "bottom";
                    }
                    function compare2Level(l1, l2) {
                        return function (a, b) {
                            return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
                        };
                    }
                    var Chart = function (item, config) {
                        this.construct(item, config);
                        return this;
                    };
                    helpers$1.extend(Chart.prototype, {
                        construct: function (item, config) {
                            var me = this;
                            config = initConfig(config);
                            var context = platform.acquireContext(item, config);
                            var canvas = context && context.canvas;
                            var height = canvas && canvas.height;
                            var width = canvas && canvas.width;
                            me.id = helpers$1.uid();
                            me.ctx = context;
                            me.canvas = canvas;
                            me.config = config;
                            me.width = width;
                            me.height = height;
                            me.aspectRatio = height ? width / height : null;
                            me.options = config.options;
                            me._bufferedRender = false;
                            me._layers = [];
                            me.chart = me;
                            me.controller = me;
                            Chart.instances[me.id] = me;
                            Object.defineProperty(me, "data", {
                                get: function () {
                                    return me.config.data;
                                },
                                set: function (value) {
                                    me.config.data = value;
                                },
                            });
                            if (!context || !canvas) {
                                console.error("Failed to create chart: can't acquire context from the given item");
                                return;
                            }
                            me.initialize();
                            me.update();
                        },
                        initialize: function () {
                            var me = this;
                            core_plugins.notify(me, "beforeInit");
                            helpers$1.retinaScale(me, me.options.devicePixelRatio);
                            me.bindEvents();
                            if (me.options.responsive) {
                                me.resize(true);
                            }
                            me.initToolTip();
                            core_plugins.notify(me, "afterInit");
                            return me;
                        },
                        clear: function () {
                            helpers$1.canvas.clear(this);
                            return this;
                        },
                        stop: function () {
                            core_animations.cancelAnimation(this);
                            return this;
                        },
                        resize: function (silent) {
                            var me = this;
                            var options = me.options;
                            var canvas = me.canvas;
                            var aspectRatio = (options.maintainAspectRatio && me.aspectRatio) || null;
                            var newWidth = Math.max(0, Math.floor(helpers$1.getMaximumWidth(canvas)));
                            var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers$1.getMaximumHeight(canvas)));
                            if (me.width === newWidth && me.height === newHeight) {
                                return;
                            }
                            canvas.width = me.width = newWidth;
                            canvas.height = me.height = newHeight;
                            canvas.style.width = newWidth + "px";
                            canvas.style.height = newHeight + "px";
                            helpers$1.retinaScale(me, options.devicePixelRatio);
                            if (!silent) {
                                var newSize = { width: newWidth, height: newHeight };
                                core_plugins.notify(me, "resize", [newSize]);
                                if (options.onResize) {
                                    options.onResize(me, newSize);
                                }
                                me.stop();
                                me.update({ duration: options.responsiveAnimationDuration });
                            }
                        },
                        ensureScalesHaveIDs: function () {
                            var options = this.options;
                            var scalesOptions = options.scales || {};
                            var scaleOptions = options.scale;
                            helpers$1.each(scalesOptions.xAxes, function (xAxisOptions, index) {
                                if (!xAxisOptions.id) {
                                    xAxisOptions.id = nextAvailableScaleId(scalesOptions.xAxes, "x-axis-", index);
                                }
                            });
                            helpers$1.each(scalesOptions.yAxes, function (yAxisOptions, index) {
                                if (!yAxisOptions.id) {
                                    yAxisOptions.id = nextAvailableScaleId(scalesOptions.yAxes, "y-axis-", index);
                                }
                            });
                            if (scaleOptions) {
                                scaleOptions.id = scaleOptions.id || "scale";
                            }
                        },
                        buildOrUpdateScales: function () {
                            var me = this;
                            var options = me.options;
                            var scales = me.scales || {};
                            var items = [];
                            var updated = Object.keys(scales).reduce(function (obj, id) {
                                obj[id] = false;
                                return obj;
                            }, {});
                            if (options.scales) {
                                items = items.concat(
                                    (options.scales.xAxes || []).map(function (xAxisOptions) {
                                        return { options: xAxisOptions, dtype: "category", dposition: "bottom" };
                                    }),
                                    (options.scales.yAxes || []).map(function (yAxisOptions) {
                                        return { options: yAxisOptions, dtype: "linear", dposition: "left" };
                                    })
                                );
                            }
                            if (options.scale) {
                                items.push({ options: options.scale, dtype: "radialLinear", isDefault: true, dposition: "chartArea" });
                            }
                            helpers$1.each(items, function (item) {
                                var scaleOptions = item.options;
                                var id = scaleOptions.id;
                                var scaleType = valueOrDefault$9(scaleOptions.type, item.dtype);
                                if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
                                    scaleOptions.position = item.dposition;
                                }
                                updated[id] = true;
                                var scale = null;
                                if (id in scales && scales[id].type === scaleType) {
                                    scale = scales[id];
                                    scale.options = scaleOptions;
                                    scale.ctx = me.ctx;
                                    scale.chart = me;
                                } else {
                                    var scaleClass = core_scaleService.getScaleConstructor(scaleType);
                                    if (!scaleClass) {
                                        return;
                                    }
                                    scale = new scaleClass({ id: id, type: scaleType, options: scaleOptions, ctx: me.ctx, chart: me });
                                    scales[scale.id] = scale;
                                }
                                scale.mergeTicksOptions();
                                if (item.isDefault) {
                                    me.scale = scale;
                                }
                            });
                            helpers$1.each(updated, function (hasUpdated, id) {
                                if (!hasUpdated) {
                                    delete scales[id];
                                }
                            });
                            me.scales = scales;
                            core_scaleService.addScalesToLayout(this);
                        },
                        buildOrUpdateControllers: function () {
                            var me = this;
                            var newControllers = [];
                            var datasets = me.data.datasets;
                            var i, ilen;
                            for (i = 0, ilen = datasets.length; i < ilen; i++) {
                                var dataset = datasets[i];
                                var meta = me.getDatasetMeta(i);
                                var type = dataset.type || me.config.type;
                                if (meta.type && meta.type !== type) {
                                    me.destroyDatasetMeta(i);
                                    meta = me.getDatasetMeta(i);
                                }
                                meta.type = type;
                                meta.order = dataset.order || 0;
                                meta.index = i;
                                if (meta.controller) {
                                    meta.controller.updateIndex(i);
                                    meta.controller.linkScales();
                                } else {
                                    var ControllerClass = controllers[meta.type];
                                    if (ControllerClass === undefined) {
                                        throw new Error('"' + meta.type + '" is not a chart type.');
                                    }
                                    meta.controller = new ControllerClass(me, i);
                                    newControllers.push(meta.controller);
                                }
                            }
                            return newControllers;
                        },
                        resetElements: function () {
                            var me = this;
                            helpers$1.each(
                                me.data.datasets,
                                function (dataset, datasetIndex) {
                                    me.getDatasetMeta(datasetIndex).controller.reset();
                                },
                                me
                            );
                        },
                        reset: function () {
                            this.resetElements();
                            this.tooltip.initialize();
                        },
                        update: function (config) {
                            var me = this;
                            var i, ilen;
                            if (!config || typeof config !== "object") {
                                config = { duration: config, lazy: arguments[1] };
                            }
                            updateConfig(me);
                            core_plugins._invalidate(me);
                            if (core_plugins.notify(me, "beforeUpdate") === false) {
                                return;
                            }
                            me.tooltip._data = me.data;
                            var newControllers = me.buildOrUpdateControllers();
                            for (i = 0, ilen = me.data.datasets.length; i < ilen; i++) {
                                me.getDatasetMeta(i).controller.buildOrUpdateElements();
                            }
                            me.updateLayout();
                            if (me.options.animation && me.options.animation.duration) {
                                helpers$1.each(newControllers, function (controller) {
                                    controller.reset();
                                });
                            }
                            me.updateDatasets();
                            me.tooltip.initialize();
                            me.lastActive = [];
                            core_plugins.notify(me, "afterUpdate");
                            me._layers.sort(compare2Level("z", "_idx"));
                            if (me._bufferedRender) {
                                me._bufferedRequest = { duration: config.duration, easing: config.easing, lazy: config.lazy };
                            } else {
                                me.render(config);
                            }
                        },
                        updateLayout: function () {
                            var me = this;
                            if (core_plugins.notify(me, "beforeLayout") === false) {
                                return;
                            }
                            core_layouts.update(this, this.width, this.height);
                            me._layers = [];
                            helpers$1.each(
                                me.boxes,
                                function (box) {
                                    if (box._configure) {
                                        box._configure();
                                    }
                                    me._layers.push.apply(me._layers, box._layers());
                                },
                                me
                            );
                            me._layers.forEach(function (item, index) {
                                item._idx = index;
                            });
                            core_plugins.notify(me, "afterScaleUpdate");
                            core_plugins.notify(me, "afterLayout");
                        },
                        updateDatasets: function () {
                            var me = this;
                            if (core_plugins.notify(me, "beforeDatasetsUpdate") === false) {
                                return;
                            }
                            for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
                                me.updateDataset(i);
                            }
                            core_plugins.notify(me, "afterDatasetsUpdate");
                        },
                        updateDataset: function (index) {
                            var me = this;
                            var meta = me.getDatasetMeta(index);
                            var args = { meta: meta, index: index };
                            if (core_plugins.notify(me, "beforeDatasetUpdate", [args]) === false) {
                                return;
                            }
                            meta.controller._update();
                            core_plugins.notify(me, "afterDatasetUpdate", [args]);
                        },
                        render: function (config) {
                            var me = this;
                            if (!config || typeof config !== "object") {
                                config = { duration: config, lazy: arguments[1] };
                            }
                            var animationOptions = me.options.animation;
                            var duration = valueOrDefault$9(config.duration, animationOptions && animationOptions.duration);
                            var lazy = config.lazy;
                            if (core_plugins.notify(me, "beforeRender") === false) {
                                return;
                            }
                            var onComplete = function (animation) {
                                core_plugins.notify(me, "afterRender");
                                helpers$1.callback(animationOptions && animationOptions.onComplete, [animation], me);
                            };
                            if (animationOptions && duration) {
                                var animation = new core_animation({
                                    numSteps: duration / 16.66,
                                    easing: config.easing || animationOptions.easing,
                                    render: function (chart, animationObject) {
                                        var easingFunction = helpers$1.easing.effects[animationObject.easing];
                                        var currentStep = animationObject.currentStep;
                                        var stepDecimal = currentStep / animationObject.numSteps;
                                        chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
                                    },
                                    onAnimationProgress: animationOptions.onProgress,
                                    onAnimationComplete: onComplete,
                                });
                                core_animations.addAnimation(me, animation, duration, lazy);
                            } else {
                                me.draw();
                                onComplete(new core_animation({ numSteps: 0, chart: me }));
                            }
                            return me;
                        },
                        draw: function (easingValue) {
                            var me = this;
                            var i, layers;
                            me.clear();
                            if (helpers$1.isNullOrUndef(easingValue)) {
                                easingValue = 1;
                            }
                            me.transition(easingValue);
                            if (me.width <= 0 || me.height <= 0) {
                                return;
                            }
                            if (core_plugins.notify(me, "beforeDraw", [easingValue]) === false) {
                                return;
                            }
                            layers = me._layers;
                            for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
                                layers[i].draw(me.chartArea);
                            }
                            me.drawDatasets(easingValue);
                            for (; i < layers.length; ++i) {
                                layers[i].draw(me.chartArea);
                            }
                            me._drawTooltip(easingValue);
                            core_plugins.notify(me, "afterDraw", [easingValue]);
                        },
                        transition: function (easingValue) {
                            var me = this;
                            for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
                                if (me.isDatasetVisible(i)) {
                                    me.getDatasetMeta(i).controller.transition(easingValue);
                                }
                            }
                            me.tooltip.transition(easingValue);
                        },
                        _getSortedDatasetMetas: function (filterVisible) {
                            var me = this;
                            var datasets = me.data.datasets || [];
                            var result = [];
                            var i, ilen;
                            for (i = 0, ilen = datasets.length; i < ilen; ++i) {
                                if (!filterVisible || me.isDatasetVisible(i)) {
                                    result.push(me.getDatasetMeta(i));
                                }
                            }
                            result.sort(compare2Level("order", "index"));
                            return result;
                        },
                        _getSortedVisibleDatasetMetas: function () {
                            return this._getSortedDatasetMetas(true);
                        },
                        drawDatasets: function (easingValue) {
                            var me = this;
                            var metasets, i;
                            if (core_plugins.notify(me, "beforeDatasetsDraw", [easingValue]) === false) {
                                return;
                            }
                            metasets = me._getSortedVisibleDatasetMetas();
                            for (i = metasets.length - 1; i >= 0; --i) {
                                me.drawDataset(metasets[i], easingValue);
                            }
                            core_plugins.notify(me, "afterDatasetsDraw", [easingValue]);
                        },
                        drawDataset: function (meta, easingValue) {
                            var me = this;
                            var args = { meta: meta, index: meta.index, easingValue: easingValue };
                            if (core_plugins.notify(me, "beforeDatasetDraw", [args]) === false) {
                                return;
                            }
                            meta.controller.draw(easingValue);
                            core_plugins.notify(me, "afterDatasetDraw", [args]);
                        },
                        _drawTooltip: function (easingValue) {
                            var me = this;
                            var tooltip = me.tooltip;
                            var args = { tooltip: tooltip, easingValue: easingValue };
                            if (core_plugins.notify(me, "beforeTooltipDraw", [args]) === false) {
                                return;
                            }
                            tooltip.draw();
                            core_plugins.notify(me, "afterTooltipDraw", [args]);
                        },
                        getElementAtEvent: function (e) {
                            return core_interaction.modes.single(this, e);
                        },
                        getElementsAtEvent: function (e) {
                            return core_interaction.modes.label(this, e, { intersect: true });
                        },
                        getElementsAtXAxis: function (e) {
                            return core_interaction.modes["x-axis"](this, e, { intersect: true });
                        },
                        getElementsAtEventForMode: function (e, mode, options) {
                            var method = core_interaction.modes[mode];
                            if (typeof method === "function") {
                                return method(this, e, options);
                            }
                            return [];
                        },
                        getDatasetAtEvent: function (e) {
                            return core_interaction.modes.dataset(this, e, { intersect: true });
                        },
                        getDatasetMeta: function (datasetIndex) {
                            var me = this;
                            var dataset = me.data.datasets[datasetIndex];
                            if (!dataset._meta) {
                                dataset._meta = {};
                            }
                            var meta = dataset._meta[me.id];
                            if (!meta) {
                                meta = dataset._meta[me.id] = { type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null, order: dataset.order || 0, index: datasetIndex };
                            }
                            return meta;
                        },
                        getVisibleDatasetCount: function () {
                            var count = 0;
                            for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
                                if (this.isDatasetVisible(i)) {
                                    count++;
                                }
                            }
                            return count;
                        },
                        isDatasetVisible: function (datasetIndex) {
                            var meta = this.getDatasetMeta(datasetIndex);
                            return typeof meta.hidden === "boolean" ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
                        },
                        generateLegend: function () {
                            return this.options.legendCallback(this);
                        },
                        destroyDatasetMeta: function (datasetIndex) {
                            var id = this.id;
                            var dataset = this.data.datasets[datasetIndex];
                            var meta = dataset._meta && dataset._meta[id];
                            if (meta) {
                                meta.controller.destroy();
                                delete dataset._meta[id];
                            }
                        },
                        destroy: function () {
                            var me = this;
                            var canvas = me.canvas;
                            var i, ilen;
                            me.stop();
                            for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
                                me.destroyDatasetMeta(i);
                            }
                            if (canvas) {
                                me.unbindEvents();
                                helpers$1.canvas.clear(me);
                                platform.releaseContext(me.ctx);
                                me.canvas = null;
                                me.ctx = null;
                            }
                            core_plugins.notify(me, "destroy");
                            delete Chart.instances[me.id];
                        },
                        toBase64Image: function () {
                            return this.canvas.toDataURL.apply(this.canvas, arguments);
                        },
                        initToolTip: function () {
                            var me = this;
                            me.tooltip = new core_tooltip({ _chart: me, _chartInstance: me, _data: me.data, _options: me.options.tooltips }, me);
                        },
                        bindEvents: function () {
                            var me = this;
                            var listeners = (me._listeners = {});
                            var listener = function () {
                                me.eventHandler.apply(me, arguments);
                            };
                            helpers$1.each(me.options.events, function (type) {
                                platform.addEventListener(me, type, listener);
                                listeners[type] = listener;
                            });
                            if (me.options.responsive) {
                                listener = function () {
                                    me.resize();
                                };
                                platform.addEventListener(me, "resize", listener);
                                listeners.resize = listener;
                            }
                        },
                        unbindEvents: function () {
                            var me = this;
                            var listeners = me._listeners;
                            if (!listeners) {
                                return;
                            }
                            delete me._listeners;
                            helpers$1.each(listeners, function (listener, type) {
                                platform.removeEventListener(me, type, listener);
                            });
                        },
                        updateHoverStyle: function (elements, mode, enabled) {
                            var prefix = enabled ? "set" : "remove";
                            var element, i, ilen;
                            for (i = 0, ilen = elements.length; i < ilen; ++i) {
                                element = elements[i];
                                if (element) {
                                    this.getDatasetMeta(element._datasetIndex).controller[prefix + "HoverStyle"](element);
                                }
                            }
                            if (mode === "dataset") {
                                this.getDatasetMeta(elements[0]._datasetIndex).controller["_" + prefix + "DatasetHoverStyle"]();
                            }
                        },
                        eventHandler: function (e) {
                            var me = this;
                            var tooltip = me.tooltip;
                            if (core_plugins.notify(me, "beforeEvent", [e]) === false) {
                                return;
                            }
                            me._bufferedRender = true;
                            me._bufferedRequest = null;
                            var changed = me.handleEvent(e);
                            if (tooltip) {
                                changed = tooltip._start ? tooltip.handleEvent(e) : changed | tooltip.handleEvent(e);
                            }
                            core_plugins.notify(me, "afterEvent", [e]);
                            var bufferedRequest = me._bufferedRequest;
                            if (bufferedRequest) {
                                me.render(bufferedRequest);
                            } else if (changed && !me.animating) {
                                me.stop();
                                me.render({ duration: me.options.hover.animationDuration, lazy: true });
                            }
                            me._bufferedRender = false;
                            me._bufferedRequest = null;
                            return me;
                        },
                        handleEvent: function (e) {
                            var me = this;
                            var options = me.options || {};
                            var hoverOptions = options.hover;
                            var changed = false;
                            me.lastActive = me.lastActive || [];
                            if (e.type === "mouseout") {
                                me.active = [];
                            } else {
                                me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
                            }
                            helpers$1.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);
                            if (e.type === "mouseup" || e.type === "click") {
                                if (options.onClick) {
                                    options.onClick.call(me, e.native, me.active);
                                }
                            }
                            if (me.lastActive.length) {
                                me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
                            }
                            if (me.active.length && hoverOptions.mode) {
                                me.updateHoverStyle(me.active, hoverOptions.mode, true);
                            }
                            changed = !helpers$1.arrayEquals(me.active, me.lastActive);
                            me.lastActive = me.active;
                            return changed;
                        },
                    });
                    Chart.instances = {};
                    var core_controller = Chart;
                    Chart.Controller = Chart;
                    Chart.types = {};
                    helpers$1.configMerge = mergeConfig;
                    helpers$1.scaleMerge = mergeScaleConfig;
                    var core_helpers = function () {
                        helpers$1.where = function (collection, filterCallback) {
                            if (helpers$1.isArray(collection) && Array.prototype.filter) {
                                return collection.filter(filterCallback);
                            }
                            var filtered = [];
                            helpers$1.each(collection, function (item) {
                                if (filterCallback(item)) {
                                    filtered.push(item);
                                }
                            });
                            return filtered;
                        };
                        helpers$1.findIndex = Array.prototype.findIndex
                            ? function (array, callback, scope) {
                                  return array.findIndex(callback, scope);
                              }
                            : function (array, callback, scope) {
                                  scope = scope === undefined ? array : scope;
                                  for (var i = 0, ilen = array.length; i < ilen; ++i) {
                                      if (callback.call(scope, array[i], i, array)) {
                                          return i;
                                      }
                                  }
                                  return -1;
                              };
                        helpers$1.findNextWhere = function (arrayToSearch, filterCallback, startIndex) {
                            if (helpers$1.isNullOrUndef(startIndex)) {
                                startIndex = -1;
                            }
                            for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
                                var currentItem = arrayToSearch[i];
                                if (filterCallback(currentItem)) {
                                    return currentItem;
                                }
                            }
                        };
                        helpers$1.findPreviousWhere = function (arrayToSearch, filterCallback, startIndex) {
                            if (helpers$1.isNullOrUndef(startIndex)) {
                                startIndex = arrayToSearch.length;
                            }
                            for (var i = startIndex - 1; i >= 0; i--) {
                                var currentItem = arrayToSearch[i];
                                if (filterCallback(currentItem)) {
                                    return currentItem;
                                }
                            }
                        };
                        helpers$1.isNumber = function (n) {
                            return !isNaN(parseFloat(n)) && isFinite(n);
                        };
                        helpers$1.almostEquals = function (x, y, epsilon) {
                            return Math.abs(x - y) < epsilon;
                        };
                        helpers$1.almostWhole = function (x, epsilon) {
                            var rounded = Math.round(x);
                            return rounded - epsilon <= x && rounded + epsilon >= x;
                        };
                        helpers$1.max = function (array) {
                            return array.reduce(function (max, value) {
                                if (!isNaN(value)) {
                                    return Math.max(max, value);
                                }
                                return max;
                            }, Number.NEGATIVE_INFINITY);
                        };
                        helpers$1.min = function (array) {
                            return array.reduce(function (min, value) {
                                if (!isNaN(value)) {
                                    return Math.min(min, value);
                                }
                                return min;
                            }, Number.POSITIVE_INFINITY);
                        };
                        helpers$1.sign = Math.sign
                            ? function (x) {
                                  return Math.sign(x);
                              }
                            : function (x) {
                                  x = +x;
                                  if (x === 0 || isNaN(x)) {
                                      return x;
                                  }
                                  return x > 0 ? 1 : -1;
                              };
                        helpers$1.toRadians = function (degrees) {
                            return degrees * (Math.PI / 180);
                        };
                        helpers$1.toDegrees = function (radians) {
                            return radians * (180 / Math.PI);
                        };
                        helpers$1._decimalPlaces = function (x) {
                            if (!helpers$1.isFinite(x)) {
                                return;
                            }
                            var e = 1;
                            var p = 0;
                            while (Math.round(x * e) / e !== x) {
                                e *= 10;
                                p++;
                            }
                            return p;
                        };
                        helpers$1.getAngleFromPoint = function (centrePoint, anglePoint) {
                            var distanceFromXCenter = anglePoint.x - centrePoint.x;
                            var distanceFromYCenter = anglePoint.y - centrePoint.y;
                            var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
                            var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
                            if (angle < -0.5 * Math.PI) {
                                angle += 2 * Math.PI;
                            }
                            return { angle: angle, distance: radialDistanceFromCenter };
                        };
                        helpers$1.distanceBetweenPoints = function (pt1, pt2) {
                            return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
                        };
                        helpers$1.aliasPixel = function (pixelWidth) {
                            return pixelWidth % 2 === 0 ? 0 : 0.5;
                        };
                        helpers$1._alignPixel = function (chart, pixel, width) {
                            var devicePixelRatio = chart.currentDevicePixelRatio;
                            var halfWidth = width / 2;
                            return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
                        };
                        helpers$1.splineCurve = function (firstPoint, middlePoint, afterPoint, t) {
                            var previous = firstPoint.skip ? middlePoint : firstPoint;
                            var current = middlePoint;
                            var next = afterPoint.skip ? middlePoint : afterPoint;
                            var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
                            var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));
                            var s01 = d01 / (d01 + d12);
                            var s12 = d12 / (d01 + d12);
                            s01 = isNaN(s01) ? 0 : s01;
                            s12 = isNaN(s12) ? 0 : s12;
                            var fa = t * s01;
                            var fb = t * s12;
                            return { previous: { x: current.x - fa * (next.x - previous.x), y: current.y - fa * (next.y - previous.y) }, next: { x: current.x + fb * (next.x - previous.x), y: current.y + fb * (next.y - previous.y) } };
                        };
                        helpers$1.EPSILON = Number.EPSILON || 1e-14;
                        helpers$1.splineCurveMonotone = function (points) {
                            var pointsWithTangents = (points || []).map(function (point) {
                                return { model: point._model, deltaK: 0, mK: 0 };
                            });
                            var pointsLen = pointsWithTangents.length;
                            var i, pointBefore, pointCurrent, pointAfter;
                            for (i = 0; i < pointsLen; ++i) {
                                pointCurrent = pointsWithTangents[i];
                                if (pointCurrent.model.skip) {
                                    continue;
                                }
                                pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
                                pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
                                if (pointAfter && !pointAfter.model.skip) {
                                    var slopeDeltaX = pointAfter.model.x - pointCurrent.model.x;
                                    pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
                                }
                                if (!pointBefore || pointBefore.model.skip) {
                                    pointCurrent.mK = pointCurrent.deltaK;
                                } else if (!pointAfter || pointAfter.model.skip) {
                                    pointCurrent.mK = pointBefore.deltaK;
                                } else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
                                    pointCurrent.mK = 0;
                                } else {
                                    pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
                                }
                            }
                            var alphaK, betaK, tauK, squaredMagnitude;
                            for (i = 0; i < pointsLen - 1; ++i) {
                                pointCurrent = pointsWithTangents[i];
                                pointAfter = pointsWithTangents[i + 1];
                                if (pointCurrent.model.skip || pointAfter.model.skip) {
                                    continue;
                                }
                                if (helpers$1.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
                                    pointCurrent.mK = pointAfter.mK = 0;
                                    continue;
                                }
                                alphaK = pointCurrent.mK / pointCurrent.deltaK;
                                betaK = pointAfter.mK / pointCurrent.deltaK;
                                squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
                                if (squaredMagnitude <= 9) {
                                    continue;
                                }
                                tauK = 3 / Math.sqrt(squaredMagnitude);
                                pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
                                pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
                            }
                            var deltaX;
                            for (i = 0; i < pointsLen; ++i) {
                                pointCurrent = pointsWithTangents[i];
                                if (pointCurrent.model.skip) {
                                    continue;
                                }
                                pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
                                pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
                                if (pointBefore && !pointBefore.model.skip) {
                                    deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
                                    pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
                                    pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
                                }
                                if (pointAfter && !pointAfter.model.skip) {
                                    deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
                                    pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
                                    pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
                                }
                            }
                        };
                        helpers$1.nextItem = function (collection, index, loop) {
                            if (loop) {
                                return index >= collection.length - 1 ? collection[0] : collection[index + 1];
                            }
                            return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
                        };
                        helpers$1.previousItem = function (collection, index, loop) {
                            if (loop) {
                                return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
                            }
                            return index <= 0 ? collection[0] : collection[index - 1];
                        };
                        helpers$1.niceNum = function (range, round) {
                            var exponent = Math.floor(helpers$1.log10(range));
                            var fraction = range / Math.pow(10, exponent);
                            var niceFraction;
                            if (round) {
                                if (fraction < 1.5) {
                                    niceFraction = 1;
                                } else if (fraction < 3) {
                                    niceFraction = 2;
                                } else if (fraction < 7) {
                                    niceFraction = 5;
                                } else {
                                    niceFraction = 10;
                                }
                            } else if (fraction <= 1) {
                                niceFraction = 1;
                            } else if (fraction <= 2) {
                                niceFraction = 2;
                            } else if (fraction <= 5) {
                                niceFraction = 5;
                            } else {
                                niceFraction = 10;
                            }
                            return niceFraction * Math.pow(10, exponent);
                        };
                        helpers$1.requestAnimFrame = (function () {
                            if (typeof window === "undefined") {
                                return function (callback) {
                                    callback();
                                };
                            }
                            return (
                                window.requestAnimationFrame ||
                                window.webkitRequestAnimationFrame ||
                                window.mozRequestAnimationFrame ||
                                window.oRequestAnimationFrame ||
                                window.msRequestAnimationFrame ||
                                function (callback) {
                                    return window.setTimeout(callback, 1e3 / 60);
                                }
                            );
                        })();
                        helpers$1.getRelativePosition = function (evt, chart) {
                            var mouseX, mouseY;
                            var e = evt.originalEvent || evt;
                            var canvas = evt.target || evt.srcElement;
                            var boundingRect = canvas.getBoundingClientRect();
                            var touches = e.touches;
                            if (touches && touches.length > 0) {
                                mouseX = touches[0].clientX;
                                mouseY = touches[0].clientY;
                            } else {
                                mouseX = e.clientX;
                                mouseY = e.clientY;
                            }
                            var paddingLeft = parseFloat(helpers$1.getStyle(canvas, "padding-left"));
                            var paddingTop = parseFloat(helpers$1.getStyle(canvas, "padding-top"));
                            var paddingRight = parseFloat(helpers$1.getStyle(canvas, "padding-right"));
                            var paddingBottom = parseFloat(helpers$1.getStyle(canvas, "padding-bottom"));
                            var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
                            var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;
                            mouseX = Math.round((((mouseX - boundingRect.left - paddingLeft) / width) * canvas.width) / chart.currentDevicePixelRatio);
                            mouseY = Math.round((((mouseY - boundingRect.top - paddingTop) / height) * canvas.height) / chart.currentDevicePixelRatio);
                            return { x: mouseX, y: mouseY };
                        };
                        function parseMaxStyle(styleValue, node, parentProperty) {
                            var valueInPixels;
                            if (typeof styleValue === "string") {
                                valueInPixels = parseInt(styleValue, 10);
                                if (styleValue.indexOf("%") !== -1) {
                                    valueInPixels = (valueInPixels / 100) * node.parentNode[parentProperty];
                                }
                            } else {
                                valueInPixels = styleValue;
                            }
                            return valueInPixels;
                        }
                        function isConstrainedValue(value) {
                            return value !== undefined && value !== null && value !== "none";
                        }
                        function getConstraintDimension(domNode, maxStyle, percentageProperty) {
                            var view = document.defaultView;
                            var parentNode = helpers$1._getParentNode(domNode);
                            var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
                            var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
                            var hasCNode = isConstrainedValue(constrainedNode);
                            var hasCContainer = isConstrainedValue(constrainedContainer);
                            var infinity = Number.POSITIVE_INFINITY;
                            if (hasCNode || hasCContainer) {
                                return Math.min(hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity, hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
                            }
                            return "none";
                        }
                        helpers$1.getConstraintWidth = function (domNode) {
                            return getConstraintDimension(domNode, "max-width", "clientWidth");
                        };
                        helpers$1.getConstraintHeight = function (domNode) {
                            return getConstraintDimension(domNode, "max-height", "clientHeight");
                        };
                        helpers$1._calculatePadding = function (container, padding, parentDimension) {
                            padding = helpers$1.getStyle(container, padding);
                            return padding.indexOf("%") > -1 ? (parentDimension * parseInt(padding, 10)) / 100 : parseInt(padding, 10);
                        };
                        helpers$1._getParentNode = function (domNode) {
                            var parent = domNode.parentNode;
                            if (parent && parent.toString() === "[object ShadowRoot]") {
                                parent = parent.host;
                            }
                            return parent;
                        };
                        helpers$1.getMaximumWidth = function (domNode) {
                            var container = helpers$1._getParentNode(domNode);
                            if (!container) {
                                return domNode.clientWidth;
                            }
                            var clientWidth = container.clientWidth;
                            var paddingLeft = helpers$1._calculatePadding(container, "padding-left", clientWidth);
                            var paddingRight = helpers$1._calculatePadding(container, "padding-right", clientWidth);
                            var w = clientWidth - paddingLeft - paddingRight;
                            var cw = helpers$1.getConstraintWidth(domNode);
                            return isNaN(cw) ? w : Math.min(w, cw);
                        };
                        helpers$1.getMaximumHeight = function (domNode) {
                            var container = helpers$1._getParentNode(domNode);
                            if (!container) {
                                return domNode.clientHeight;
                            }
                            var clientHeight = container.clientHeight;
                            var paddingTop = helpers$1._calculatePadding(container, "padding-top", clientHeight);
                            var paddingBottom = helpers$1._calculatePadding(container, "padding-bottom", clientHeight);
                            var h = clientHeight - paddingTop - paddingBottom;
                            var ch = helpers$1.getConstraintHeight(domNode);
                            return isNaN(ch) ? h : Math.min(h, ch);
                        };
                        helpers$1.getStyle = function (el, property) {
                            return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
                        };
                        helpers$1.retinaScale = function (chart, forceRatio) {
                            var pixelRatio = (chart.currentDevicePixelRatio = forceRatio || (typeof window !== "undefined" && window.devicePixelRatio) || 1);
                            if (pixelRatio === 1) {
                                return;
                            }
                            var canvas = chart.canvas;
                            var height = chart.height;
                            var width = chart.width;
                            canvas.height = height * pixelRatio;
                            canvas.width = width * pixelRatio;
                            chart.ctx.scale(pixelRatio, pixelRatio);
                            if (!canvas.style.height && !canvas.style.width) {
                                canvas.style.height = height + "px";
                                canvas.style.width = width + "px";
                            }
                        };
                        helpers$1.fontString = function (pixelSize, fontStyle, fontFamily) {
                            return fontStyle + " " + pixelSize + "px " + fontFamily;
                        };
                        helpers$1.longestText = function (ctx, font, arrayOfThings, cache) {
                            cache = cache || {};
                            var data = (cache.data = cache.data || {});
                            var gc = (cache.garbageCollect = cache.garbageCollect || []);
                            if (cache.font !== font) {
                                data = cache.data = {};
                                gc = cache.garbageCollect = [];
                                cache.font = font;
                            }
                            ctx.font = font;
                            var longest = 0;
                            var ilen = arrayOfThings.length;
                            var i, j, jlen, thing, nestedThing;
                            for (i = 0; i < ilen; i++) {
                                thing = arrayOfThings[i];
                                if (thing !== undefined && thing !== null && helpers$1.isArray(thing) !== true) {
                                    longest = helpers$1.measureText(ctx, data, gc, longest, thing);
                                } else if (helpers$1.isArray(thing)) {
                                    for (j = 0, jlen = thing.length; j < jlen; j++) {
                                        nestedThing = thing[j];
                                        if (nestedThing !== undefined && nestedThing !== null && !helpers$1.isArray(nestedThing)) {
                                            longest = helpers$1.measureText(ctx, data, gc, longest, nestedThing);
                                        }
                                    }
                                }
                            }
                            var gcLen = gc.length / 2;
                            if (gcLen > arrayOfThings.length) {
                                for (i = 0; i < gcLen; i++) {
                                    delete data[gc[i]];
                                }
                                gc.splice(0, gcLen);
                            }
                            return longest;
                        };
                        helpers$1.measureText = function (ctx, data, gc, longest, string) {
                            var textWidth = data[string];
                            if (!textWidth) {
                                textWidth = data[string] = ctx.measureText(string).width;
                                gc.push(string);
                            }
                            if (textWidth > longest) {
                                longest = textWidth;
                            }
                            return longest;
                        };
                        helpers$1.numberOfLabelLines = function (arrayOfThings) {
                            var numberOfLines = 1;
                            helpers$1.each(arrayOfThings, function (thing) {
                                if (helpers$1.isArray(thing)) {
                                    if (thing.length > numberOfLines) {
                                        numberOfLines = thing.length;
                                    }
                                }
                            });
                            return numberOfLines;
                        };
                        helpers$1.color = !chartjsColor
                            ? function (value) {
                                  console.error("Color.js not found!");
                                  return value;
                              }
                            : function (value) {
                                  if (value instanceof CanvasGradient) {
                                      value = core_defaults.global.defaultColor;
                                  }
                                  return chartjsColor(value);
                              };
                        helpers$1.getHoverColor = function (colorValue) {
                            return colorValue instanceof CanvasPattern || colorValue instanceof CanvasGradient ? colorValue : helpers$1.color(colorValue).saturate(0.5).darken(0.1).rgbString();
                        };
                    };
                    function abstract() {
                        throw new Error("This method is not implemented: either no adapter can " + "be found or an incomplete integration was provided.");
                    }
                    function DateAdapter(options) {
                        this.options = options || {};
                    }
                    helpers$1.extend(DateAdapter.prototype, {
                        formats: abstract,
                        parse: abstract,
                        format: abstract,
                        add: abstract,
                        diff: abstract,
                        startOf: abstract,
                        endOf: abstract,
                        _create: function (value) {
                            return value;
                        },
                    });
                    DateAdapter.override = function (members) {
                        helpers$1.extend(DateAdapter.prototype, members);
                    };
                    var _date = DateAdapter;
                    var core_adapters = { _date: _date };
                    var core_ticks = {
                        formatters: {
                            values: function (value) {
                                return helpers$1.isArray(value) ? value : "" + value;
                            },
                            linear: function (tickValue, index, ticks) {
                                var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];
                                if (Math.abs(delta) > 1) {
                                    if (tickValue !== Math.floor(tickValue)) {
                                        delta = tickValue - Math.floor(tickValue);
                                    }
                                }
                                var logDelta = helpers$1.log10(Math.abs(delta));
                                var tickString = "";
                                if (tickValue !== 0) {
                                    var maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));
                                    if (maxTick < 1e-4) {
                                        var logTick = helpers$1.log10(Math.abs(tickValue));
                                        var numExponential = Math.floor(logTick) - Math.floor(logDelta);
                                        numExponential = Math.max(Math.min(numExponential, 20), 0);
                                        tickString = tickValue.toExponential(numExponential);
                                    } else {
                                        var numDecimal = -1 * Math.floor(logDelta);
                                        numDecimal = Math.max(Math.min(numDecimal, 20), 0);
                                        tickString = tickValue.toFixed(numDecimal);
                                    }
                                } else {
                                    tickString = "0";
                                }
                                return tickString;
                            },
                            logarithmic: function (tickValue, index, ticks) {
                                var remain = tickValue / Math.pow(10, Math.floor(helpers$1.log10(tickValue)));
                                if (tickValue === 0) {
                                    return "0";
                                } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
                                    return tickValue.toExponential();
                                }
                                return "";
                            },
                        },
                    };
                    var isArray = helpers$1.isArray;
                    var isNullOrUndef = helpers$1.isNullOrUndef;
                    var valueOrDefault$a = helpers$1.valueOrDefault;
                    var valueAtIndexOrDefault = helpers$1.valueAtIndexOrDefault;
                    core_defaults._set("scale", {
                        display: true,
                        position: "left",
                        offset: false,
                        gridLines: {
                            display: true,
                            color: "rgba(0,0,0,0.1)",
                            lineWidth: 1,
                            drawBorder: true,
                            drawOnChartArea: true,
                            drawTicks: true,
                            tickMarkLength: 10,
                            zeroLineWidth: 1,
                            zeroLineColor: "rgba(0,0,0,0.25)",
                            zeroLineBorderDash: [],
                            zeroLineBorderDashOffset: 0,
                            offsetGridLines: false,
                            borderDash: [],
                            borderDashOffset: 0,
                        },
                        scaleLabel: { display: false, labelString: "", padding: { top: 4, bottom: 4 } },
                        ticks: {
                            beginAtZero: false,
                            minRotation: 0,
                            maxRotation: 50,
                            mirror: false,
                            padding: 0,
                            reverse: false,
                            display: true,
                            autoSkip: true,
                            autoSkipPadding: 0,
                            labelOffset: 0,
                            callback: core_ticks.formatters.values,
                            minor: {},
                            major: {},
                        },
                    });
                    function sample(arr, numItems) {
                        var result = [];
                        var increment = arr.length / numItems;
                        var i = 0;
                        var len = arr.length;
                        for (; i < len; i += increment) {
                            result.push(arr[Math.floor(i)]);
                        }
                        return result;
                    }
                    function getPixelForGridLine(scale, index, offsetGridLines) {
                        var length = scale.getTicks().length;
                        var validIndex = Math.min(index, length - 1);
                        var lineValue = scale.getPixelForTick(validIndex);
                        var start = scale._startPixel;
                        var end = scale._endPixel;
                        var epsilon = 1e-6;
                        var offset;
                        if (offsetGridLines) {
                            if (length === 1) {
                                offset = Math.max(lineValue - start, end - lineValue);
                            } else if (index === 0) {
                                offset = (scale.getPixelForTick(1) - lineValue) / 2;
                            } else {
                                offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;
                            }
                            lineValue += validIndex < index ? offset : -offset;
                            if (lineValue < start - epsilon || lineValue > end + epsilon) {
                                return;
                            }
                        }
                        return lineValue;
                    }
                    function garbageCollect(caches, length) {
                        helpers$1.each(caches, function (cache) {
                            var gc = cache.gc;
                            var gcLen = gc.length / 2;
                            var i;
                            if (gcLen > length) {
                                for (i = 0; i < gcLen; ++i) {
                                    delete cache.data[gc[i]];
                                }
                                gc.splice(0, gcLen);
                            }
                        });
                    }
                    function computeLabelSizes(ctx, tickFonts, ticks, caches) {
                        var length = ticks.length;
                        var widths = [];
                        var heights = [];
                        var offsets = [];
                        var widestLabelSize = 0;
                        var highestLabelSize = 0;
                        var i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel, widest, highest;
                        for (i = 0; i < length; ++i) {
                            label = ticks[i].label;
                            tickFont = ticks[i].major ? tickFonts.major : tickFonts.minor;
                            ctx.font = fontString = tickFont.string;
                            cache = caches[fontString] = caches[fontString] || { data: {}, gc: [] };
                            lineHeight = tickFont.lineHeight;
                            width = height = 0;
                            if (!isNullOrUndef(label) && !isArray(label)) {
                                width = helpers$1.measureText(ctx, cache.data, cache.gc, width, label);
                                height = lineHeight;
                            } else if (isArray(label)) {
                                for (j = 0, jlen = label.length; j < jlen; ++j) {
                                    nestedLabel = label[j];
                                    if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
                                        width = helpers$1.measureText(ctx, cache.data, cache.gc, width, nestedLabel);
                                        height += lineHeight;
                                    }
                                }
                            }
                            widths.push(width);
                            heights.push(height);
                            offsets.push(lineHeight / 2);
                            widestLabelSize = Math.max(width, widestLabelSize);
                            highestLabelSize = Math.max(height, highestLabelSize);
                        }
                        garbageCollect(caches, length);
                        widest = widths.indexOf(widestLabelSize);
                        highest = heights.indexOf(highestLabelSize);
                        function valueAt(idx) {
                            return { width: widths[idx] || 0, height: heights[idx] || 0, offset: offsets[idx] || 0 };
                        }
                        return { first: valueAt(0), last: valueAt(length - 1), widest: valueAt(widest), highest: valueAt(highest) };
                    }
                    function getTickMarkLength(options) {
                        return options.drawTicks ? options.tickMarkLength : 0;
                    }
                    function getScaleLabelHeight(options) {
                        var font, padding;
                        if (!options.display) {
                            return 0;
                        }
                        font = helpers$1.options._parseFont(options);
                        padding = helpers$1.options.toPadding(options.padding);
                        return font.lineHeight + padding.height;
                    }
                    function parseFontOptions(options, nestedOpts) {
                        return helpers$1.extend(
                            helpers$1.options._parseFont({
                                fontFamily: valueOrDefault$a(nestedOpts.fontFamily, options.fontFamily),
                                fontSize: valueOrDefault$a(nestedOpts.fontSize, options.fontSize),
                                fontStyle: valueOrDefault$a(nestedOpts.fontStyle, options.fontStyle),
                                lineHeight: valueOrDefault$a(nestedOpts.lineHeight, options.lineHeight),
                            }),
                            { color: helpers$1.options.resolve([nestedOpts.fontColor, options.fontColor, core_defaults.global.defaultFontColor]) }
                        );
                    }
                    function parseTickFontOptions(options) {
                        var minor = parseFontOptions(options, options.minor);
                        var major = options.major.enabled ? parseFontOptions(options, options.major) : minor;
                        return { minor: minor, major: major };
                    }
                    function nonSkipped(ticksToFilter) {
                        var filtered = [];
                        var item, index, len;
                        for (index = 0, len = ticksToFilter.length; index < len; ++index) {
                            item = ticksToFilter[index];
                            if (typeof item._index !== "undefined") {
                                filtered.push(item);
                            }
                        }
                        return filtered;
                    }
                    function getEvenSpacing(arr) {
                        var len = arr.length;
                        var i, diff;
                        if (len < 2) {
                            return false;
                        }
                        for (diff = arr[0], i = 1; i < len; ++i) {
                            if (arr[i] - arr[i - 1] !== diff) {
                                return false;
                            }
                        }
                        return diff;
                    }
                    function calculateSpacing(majorIndices, ticks, axisLength, ticksLimit) {
                        var evenMajorSpacing = getEvenSpacing(majorIndices);
                        var spacing = (ticks.length - 1) / ticksLimit;
                        var factors, factor, i, ilen;
                        if (!evenMajorSpacing) {
                            return Math.max(spacing, 1);
                        }
                        factors = helpers$1.math._factorize(evenMajorSpacing);
                        for (i = 0, ilen = factors.length - 1; i < ilen; i++) {
                            factor = factors[i];
                            if (factor > spacing) {
                                return factor;
                            }
                        }
                        return Math.max(spacing, 1);
                    }
                    function getMajorIndices(ticks) {
                        var result = [];
                        var i, ilen;
                        for (i = 0, ilen = ticks.length; i < ilen; i++) {
                            if (ticks[i].major) {
                                result.push(i);
                            }
                        }
                        return result;
                    }
                    function skipMajors(ticks, majorIndices, spacing) {
                        var count = 0;
                        var next = majorIndices[0];
                        var i, tick;
                        spacing = Math.ceil(spacing);
                        for (i = 0; i < ticks.length; i++) {
                            tick = ticks[i];
                            if (i === next) {
                                tick._index = i;
                                count++;
                                next = majorIndices[count * spacing];
                            } else {
                                delete tick.label;
                            }
                        }
                    }
                    function skip(ticks, spacing, majorStart, majorEnd) {
                        var start = valueOrDefault$a(majorStart, 0);
                        var end = Math.min(valueOrDefault$a(majorEnd, ticks.length), ticks.length);
                        var count = 0;
                        var length, i, tick, next;
                        spacing = Math.ceil(spacing);
                        if (majorEnd) {
                            length = majorEnd - majorStart;
                            spacing = length / Math.floor(length / spacing);
                        }
                        next = start;
                        while (next < 0) {
                            count++;
                            next = Math.round(start + count * spacing);
                        }
                        for (i = Math.max(start, 0); i < end; i++) {
                            tick = ticks[i];
                            if (i === next) {
                                tick._index = i;
                                count++;
                                next = Math.round(start + count * spacing);
                            } else {
                                delete tick.label;
                            }
                        }
                    }
                    var Scale = core_element.extend({
                        zeroLineIndex: 0,
                        getPadding: function () {
                            var me = this;
                            return { left: me.paddingLeft || 0, top: me.paddingTop || 0, right: me.paddingRight || 0, bottom: me.paddingBottom || 0 };
                        },
                        getTicks: function () {
                            return this._ticks;
                        },
                        _getLabels: function () {
                            var data = this.chart.data;
                            return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
                        },
                        mergeTicksOptions: function () {},
                        beforeUpdate: function () {
                            helpers$1.callback(this.options.beforeUpdate, [this]);
                        },
                        update: function (maxWidth, maxHeight, margins) {
                            var me = this;
                            var tickOpts = me.options.ticks;
                            var sampleSize = tickOpts.sampleSize;
                            var i, ilen, labels, ticks, samplingEnabled;
                            me.beforeUpdate();
                            me.maxWidth = maxWidth;
                            me.maxHeight = maxHeight;
                            me.margins = helpers$1.extend({ left: 0, right: 0, top: 0, bottom: 0 }, margins);
                            me._ticks = null;
                            me.ticks = null;
                            me._labelSizes = null;
                            me._maxLabelLines = 0;
                            me.longestLabelWidth = 0;
                            me.longestTextCache = me.longestTextCache || {};
                            me._gridLineItems = null;
                            me._labelItems = null;
                            me.beforeSetDimensions();
                            me.setDimensions();
                            me.afterSetDimensions();
                            me.beforeDataLimits();
                            me.determineDataLimits();
                            me.afterDataLimits();
                            me.beforeBuildTicks();
                            ticks = me.buildTicks() || [];
                            ticks = me.afterBuildTicks(ticks) || ticks;
                            if ((!ticks || !ticks.length) && me.ticks) {
                                ticks = [];
                                for (i = 0, ilen = me.ticks.length; i < ilen; ++i) {
                                    ticks.push({ value: me.ticks[i], major: false });
                                }
                            }
                            me._ticks = ticks;
                            samplingEnabled = sampleSize < ticks.length;
                            labels = me._convertTicksToLabels(samplingEnabled ? sample(ticks, sampleSize) : ticks);
                            me._configure();
                            me.beforeCalculateTickRotation();
                            me.calculateTickRotation();
                            me.afterCalculateTickRotation();
                            me.beforeFit();
                            me.fit();
                            me.afterFit();
                            me._ticksToDraw = tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto") ? me._autoSkip(ticks) : ticks;
                            if (samplingEnabled) {
                                labels = me._convertTicksToLabels(me._ticksToDraw);
                            }
                            me.ticks = labels;
                            me.afterUpdate();
                            return me.minSize;
                        },
                        _configure: function () {
                            var me = this;
                            var reversePixels = me.options.ticks.reverse;
                            var startPixel, endPixel;
                            if (me.isHorizontal()) {
                                startPixel = me.left;
                                endPixel = me.right;
                            } else {
                                startPixel = me.top;
                                endPixel = me.bottom;
                                reversePixels = !reversePixels;
                            }
                            me._startPixel = startPixel;
                            me._endPixel = endPixel;
                            me._reversePixels = reversePixels;
                            me._length = endPixel - startPixel;
                        },
                        afterUpdate: function () {
                            helpers$1.callback(this.options.afterUpdate, [this]);
                        },
                        beforeSetDimensions: function () {
                            helpers$1.callback(this.options.beforeSetDimensions, [this]);
                        },
                        setDimensions: function () {
                            var me = this;
                            if (me.isHorizontal()) {
                                me.width = me.maxWidth;
                                me.left = 0;
                                me.right = me.width;
                            } else {
                                me.height = me.maxHeight;
                                me.top = 0;
                                me.bottom = me.height;
                            }
                            me.paddingLeft = 0;
                            me.paddingTop = 0;
                            me.paddingRight = 0;
                            me.paddingBottom = 0;
                        },
                        afterSetDimensions: function () {
                            helpers$1.callback(this.options.afterSetDimensions, [this]);
                        },
                        beforeDataLimits: function () {
                            helpers$1.callback(this.options.beforeDataLimits, [this]);
                        },
                        determineDataLimits: helpers$1.noop,
                        afterDataLimits: function () {
                            helpers$1.callback(this.options.afterDataLimits, [this]);
                        },
                        beforeBuildTicks: function () {
                            helpers$1.callback(this.options.beforeBuildTicks, [this]);
                        },
                        buildTicks: helpers$1.noop,
                        afterBuildTicks: function (ticks) {
                            var me = this;
                            if (isArray(ticks) && ticks.length) {
                                return helpers$1.callback(me.options.afterBuildTicks, [me, ticks]);
                            }
                            me.ticks = helpers$1.callback(me.options.afterBuildTicks, [me, me.ticks]) || me.ticks;
                            return ticks;
                        },
                        beforeTickToLabelConversion: function () {
                            helpers$1.callback(this.options.beforeTickToLabelConversion, [this]);
                        },
                        convertTicksToLabels: function () {
                            var me = this;
                            var tickOpts = me.options.ticks;
                            me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
                        },
                        afterTickToLabelConversion: function () {
                            helpers$1.callback(this.options.afterTickToLabelConversion, [this]);
                        },
                        beforeCalculateTickRotation: function () {
                            helpers$1.callback(this.options.beforeCalculateTickRotation, [this]);
                        },
                        calculateTickRotation: function () {
                            var me = this;
                            var options = me.options;
                            var tickOpts = options.ticks;
                            var numTicks = me.getTicks().length;
                            var minRotation = tickOpts.minRotation || 0;
                            var maxRotation = tickOpts.maxRotation;
                            var labelRotation = minRotation;
                            var labelSizes, maxLabelWidth, maxLabelHeight, maxWidth, tickWidth, maxHeight, maxLabelDiagonal;
                            if (!me._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !me.isHorizontal()) {
                                me.labelRotation = minRotation;
                                return;
                            }
                            labelSizes = me._getLabelSizes();
                            maxLabelWidth = labelSizes.widest.width;
                            maxLabelHeight = labelSizes.highest.height - labelSizes.highest.offset;
                            maxWidth = Math.min(me.maxWidth, me.chart.width - maxLabelWidth);
                            tickWidth = options.offset ? me.maxWidth / numTicks : maxWidth / (numTicks - 1);
                            if (maxLabelWidth + 6 > tickWidth) {
                                tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
                                maxHeight = me.maxHeight - getTickMarkLength(options.gridLines) - tickOpts.padding - getScaleLabelHeight(options.scaleLabel);
                                maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
                                labelRotation = helpers$1.toDegrees(
                                    Math.min(Math.asin(Math.min((labelSizes.highest.height + 6) / tickWidth, 1)), Math.asin(Math.min(maxHeight / maxLabelDiagonal, 1)) - Math.asin(maxLabelHeight / maxLabelDiagonal))
                                );
                                labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
                            }
                            me.labelRotation = labelRotation;
                        },
                        afterCalculateTickRotation: function () {
                            helpers$1.callback(this.options.afterCalculateTickRotation, [this]);
                        },
                        beforeFit: function () {
                            helpers$1.callback(this.options.beforeFit, [this]);
                        },
                        fit: function () {
                            var me = this;
                            var minSize = (me.minSize = { width: 0, height: 0 });
                            var chart = me.chart;
                            var opts = me.options;
                            var tickOpts = opts.ticks;
                            var scaleLabelOpts = opts.scaleLabel;
                            var gridLineOpts = opts.gridLines;
                            var display = me._isVisible();
                            var isBottom = opts.position === "bottom";
                            var isHorizontal = me.isHorizontal();
                            if (isHorizontal) {
                                minSize.width = me.maxWidth;
                            } else if (display) {
                                minSize.width = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);
                            }
                            if (!isHorizontal) {
                                minSize.height = me.maxHeight;
                            } else if (display) {
                                minSize.height = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);
                            }
                            if (tickOpts.display && display) {
                                var tickFonts = parseTickFontOptions(tickOpts);
                                var labelSizes = me._getLabelSizes();
                                var firstLabelSize = labelSizes.first;
                                var lastLabelSize = labelSizes.last;
                                var widestLabelSize = labelSizes.widest;
                                var highestLabelSize = labelSizes.highest;
                                var lineSpace = tickFonts.minor.lineHeight * 0.4;
                                var tickPadding = tickOpts.padding;
                                if (isHorizontal) {
                                    var isRotated = me.labelRotation !== 0;
                                    var angleRadians = helpers$1.toRadians(me.labelRotation);
                                    var cosRotation = Math.cos(angleRadians);
                                    var sinRotation = Math.sin(angleRadians);
                                    var labelHeight = sinRotation * widestLabelSize.width + cosRotation * (highestLabelSize.height - (isRotated ? highestLabelSize.offset : 0)) + (isRotated ? 0 : lineSpace);
                                    minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);
                                    var offsetLeft = me.getPixelForTick(0) - me.left;
                                    var offsetRight = me.right - me.getPixelForTick(me.getTicks().length - 1);
                                    var paddingLeft, paddingRight;
                                    if (isRotated) {
                                        paddingLeft = isBottom ? cosRotation * firstLabelSize.width + sinRotation * firstLabelSize.offset : sinRotation * (firstLabelSize.height - firstLabelSize.offset);
                                        paddingRight = isBottom ? sinRotation * (lastLabelSize.height - lastLabelSize.offset) : cosRotation * lastLabelSize.width + sinRotation * lastLabelSize.offset;
                                    } else {
                                        paddingLeft = firstLabelSize.width / 2;
                                        paddingRight = lastLabelSize.width / 2;
                                    }
                                    me.paddingLeft = Math.max(((paddingLeft - offsetLeft) * me.width) / (me.width - offsetLeft), 0) + 3;
                                    me.paddingRight = Math.max(((paddingRight - offsetRight) * me.width) / (me.width - offsetRight), 0) + 3;
                                } else {
                                    var labelWidth = tickOpts.mirror ? 0 : widestLabelSize.width + tickPadding + lineSpace;
                                    minSize.width = Math.min(me.maxWidth, minSize.width + labelWidth);
                                    me.paddingTop = firstLabelSize.height / 2;
                                    me.paddingBottom = lastLabelSize.height / 2;
                                }
                            }
                            me.handleMargins();
                            if (isHorizontal) {
                                me.width = me._length = chart.width - me.margins.left - me.margins.right;
                                me.height = minSize.height;
                            } else {
                                me.width = minSize.width;
                                me.height = me._length = chart.height - me.margins.top - me.margins.bottom;
                            }
                        },
                        handleMargins: function () {
                            var me = this;
                            if (me.margins) {
                                me.margins.left = Math.max(me.paddingLeft, me.margins.left);
                                me.margins.top = Math.max(me.paddingTop, me.margins.top);
                                me.margins.right = Math.max(me.paddingRight, me.margins.right);
                                me.margins.bottom = Math.max(me.paddingBottom, me.margins.bottom);
                            }
                        },
                        afterFit: function () {
                            helpers$1.callback(this.options.afterFit, [this]);
                        },
                        isHorizontal: function () {
                            var pos = this.options.position;
                            return pos === "top" || pos === "bottom";
                        },
                        isFullWidth: function () {
                            return this.options.fullWidth;
                        },
                        getRightValue: function (rawValue) {
                            if (isNullOrUndef(rawValue)) {
                                return NaN;
                            }
                            if ((typeof rawValue === "number" || rawValue instanceof Number) && !isFinite(rawValue)) {
                                return NaN;
                            }
                            if (rawValue) {
                                if (this.isHorizontal()) {
                                    if (rawValue.x !== undefined) {
                                        return this.getRightValue(rawValue.x);
                                    }
                                } else if (rawValue.y !== undefined) {
                                    return this.getRightValue(rawValue.y);
                                }
                            }
                            return rawValue;
                        },
                        _convertTicksToLabels: function (ticks) {
                            var me = this;
                            var labels, i, ilen;
                            me.ticks = ticks.map(function (tick) {
                                return tick.value;
                            });
                            me.beforeTickToLabelConversion();
                            labels = me.convertTicksToLabels(ticks) || me.ticks;
                            me.afterTickToLabelConversion();
                            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
                                ticks[i].label = labels[i];
                            }
                            return labels;
                        },
                        _getLabelSizes: function () {
                            var me = this;
                            var labelSizes = me._labelSizes;
                            if (!labelSizes) {
                                me._labelSizes = labelSizes = computeLabelSizes(me.ctx, parseTickFontOptions(me.options.ticks), me.getTicks(), me.longestTextCache);
                                me.longestLabelWidth = labelSizes.widest.width;
                            }
                            return labelSizes;
                        },
                        _parseValue: function (value) {
                            var start, end, min, max;
                            if (isArray(value)) {
                                start = +this.getRightValue(value[0]);
                                end = +this.getRightValue(value[1]);
                                min = Math.min(start, end);
                                max = Math.max(start, end);
                            } else {
                                value = +this.getRightValue(value);
                                start = undefined;
                                end = value;
                                min = value;
                                max = value;
                            }
                            return { min: min, max: max, start: start, end: end };
                        },
                        _getScaleLabel: function (rawValue) {
                            var v = this._parseValue(rawValue);
                            if (v.start !== undefined) {
                                return "[" + v.start + ", " + v.end + "]";
                            }
                            return +this.getRightValue(rawValue);
                        },
                        getLabelForIndex: helpers$1.noop,
                        getPixelForValue: helpers$1.noop,
                        getValueForPixel: helpers$1.noop,
                        getPixelForTick: function (index) {
                            var me = this;
                            var offset = me.options.offset;
                            var numTicks = me._ticks.length;
                            var tickWidth = 1 / Math.max(numTicks - (offset ? 0 : 1), 1);
                            return index < 0 || index > numTicks - 1 ? null : me.getPixelForDecimal(index * tickWidth + (offset ? tickWidth / 2 : 0));
                        },
                        getPixelForDecimal: function (decimal) {
                            var me = this;
                            if (me._reversePixels) {
                                decimal = 1 - decimal;
                            }
                            return me._startPixel + decimal * me._length;
                        },
                        getDecimalForPixel: function (pixel) {
                            var decimal = (pixel - this._startPixel) / this._length;
                            return this._reversePixels ? 1 - decimal : decimal;
                        },
                        getBasePixel: function () {
                            return this.getPixelForValue(this.getBaseValue());
                        },
                        getBaseValue: function () {
                            var me = this;
                            var min = me.min;
                            var max = me.max;
                            return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
                        },
                        _autoSkip: function (ticks) {
                            var me = this;
                            var tickOpts = me.options.ticks;
                            var axisLength = me._length;
                            var ticksLimit = tickOpts.maxTicksLimit || axisLength / me._tickSize() + 1;
                            var majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
                            var numMajorIndices = majorIndices.length;
                            var first = majorIndices[0];
                            var last = majorIndices[numMajorIndices - 1];
                            var i, ilen, spacing, avgMajorSpacing;
                            if (numMajorIndices > ticksLimit) {
                                skipMajors(ticks, majorIndices, numMajorIndices / ticksLimit);
                                return nonSkipped(ticks);
                            }
                            spacing = calculateSpacing(majorIndices, ticks, axisLength, ticksLimit);
                            if (numMajorIndices > 0) {
                                for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
                                    skip(ticks, spacing, majorIndices[i], majorIndices[i + 1]);
                                }
                                avgMajorSpacing = numMajorIndices > 1 ? (last - first) / (numMajorIndices - 1) : null;
                                skip(ticks, spacing, helpers$1.isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
                                skip(ticks, spacing, last, helpers$1.isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
                                return nonSkipped(ticks);
                            }
                            skip(ticks, spacing);
                            return nonSkipped(ticks);
                        },
                        _tickSize: function () {
                            var me = this;
                            var optionTicks = me.options.ticks;
                            var rot = helpers$1.toRadians(me.labelRotation);
                            var cos = Math.abs(Math.cos(rot));
                            var sin = Math.abs(Math.sin(rot));
                            var labelSizes = me._getLabelSizes();
                            var padding = optionTicks.autoSkipPadding || 0;
                            var w = labelSizes ? labelSizes.widest.width + padding : 0;
                            var h = labelSizes ? labelSizes.highest.height + padding : 0;
                            return me.isHorizontal() ? (h * cos > w * sin ? w / cos : h / sin) : h * sin < w * cos ? h / cos : w / sin;
                        },
                        _isVisible: function () {
                            var me = this;
                            var chart = me.chart;
                            var display = me.options.display;
                            var i, ilen, meta;
                            if (display !== "auto") {
                                return !!display;
                            }
                            for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
                                if (chart.isDatasetVisible(i)) {
                                    meta = chart.getDatasetMeta(i);
                                    if (meta.xAxisID === me.id || meta.yAxisID === me.id) {
                                        return true;
                                    }
                                }
                            }
                            return false;
                        },
                        _computeGridLineItems: function (chartArea) {
                            var me = this;
                            var chart = me.chart;
                            var options = me.options;
                            var gridLines = options.gridLines;
                            var position = options.position;
                            var offsetGridLines = gridLines.offsetGridLines;
                            var isHorizontal = me.isHorizontal();
                            var ticks = me._ticksToDraw;
                            var ticksLength = ticks.length + (offsetGridLines ? 1 : 0);
                            var tl = getTickMarkLength(gridLines);
                            var items = [];
                            var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
                            var axisHalfWidth = axisWidth / 2;
                            var alignPixel = helpers$1._alignPixel;
                            var alignBorderValue = function (pixel) {
                                return alignPixel(chart, pixel, axisWidth);
                            };
                            var borderValue, i, tick, lineValue, alignedLineValue;
                            var tx1, ty1, tx2, ty2, x1, y1, x2, y2, lineWidth, lineColor, borderDash, borderDashOffset;
                            if (position === "top") {
                                borderValue = alignBorderValue(me.bottom);
                                ty1 = me.bottom - tl;
                                ty2 = borderValue - axisHalfWidth;
                                y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
                                y2 = chartArea.bottom;
                            } else if (position === "bottom") {
                                borderValue = alignBorderValue(me.top);
                                y1 = chartArea.top;
                                y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
                                ty1 = borderValue + axisHalfWidth;
                                ty2 = me.top + tl;
                            } else if (position === "left") {
                                borderValue = alignBorderValue(me.right);
                                tx1 = me.right - tl;
                                tx2 = borderValue - axisHalfWidth;
                                x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
                                x2 = chartArea.right;
                            } else {
                                borderValue = alignBorderValue(me.left);
                                x1 = chartArea.left;
                                x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
                                tx1 = borderValue + axisHalfWidth;
                                tx2 = me.left + tl;
                            }
                            for (i = 0; i < ticksLength; ++i) {
                                tick = ticks[i] || {};
                                if (isNullOrUndef(tick.label) && i < ticks.length) {
                                    continue;
                                }
                                if (i === me.zeroLineIndex && options.offset === offsetGridLines) {
                                    lineWidth = gridLines.zeroLineWidth;
                                    lineColor = gridLines.zeroLineColor;
                                    borderDash = gridLines.zeroLineBorderDash || [];
                                    borderDashOffset = gridLines.zeroLineBorderDashOffset || 0;
                                } else {
                                    lineWidth = valueAtIndexOrDefault(gridLines.lineWidth, i, 1);
                                    lineColor = valueAtIndexOrDefault(gridLines.color, i, "rgba(0,0,0,0.1)");
                                    borderDash = gridLines.borderDash || [];
                                    borderDashOffset = gridLines.borderDashOffset || 0;
                                }
                                lineValue = getPixelForGridLine(me, tick._index || i, offsetGridLines);
                                if (lineValue === undefined) {
                                    continue;
                                }
                                alignedLineValue = alignPixel(chart, lineValue, lineWidth);
                                if (isHorizontal) {
                                    tx1 = tx2 = x1 = x2 = alignedLineValue;
                                } else {
                                    ty1 = ty2 = y1 = y2 = alignedLineValue;
                                }
                                items.push({ tx1: tx1, ty1: ty1, tx2: tx2, ty2: ty2, x1: x1, y1: y1, x2: x2, y2: y2, width: lineWidth, color: lineColor, borderDash: borderDash, borderDashOffset: borderDashOffset });
                            }
                            items.ticksLength = ticksLength;
                            items.borderValue = borderValue;
                            return items;
                        },
                        _computeLabelItems: function () {
                            var me = this;
                            var options = me.options;
                            var optionTicks = options.ticks;
                            var position = options.position;
                            var isMirrored = optionTicks.mirror;
                            var isHorizontal = me.isHorizontal();
                            var ticks = me._ticksToDraw;
                            var fonts = parseTickFontOptions(optionTicks);
                            var tickPadding = optionTicks.padding;
                            var tl = getTickMarkLength(options.gridLines);
                            var rotation = -helpers$1.toRadians(me.labelRotation);
                            var items = [];
                            var i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
                            if (position === "top") {
                                y = me.bottom - tl - tickPadding;
                                textAlign = !rotation ? "center" : "left";
                            } else if (position === "bottom") {
                                y = me.top + tl + tickPadding;
                                textAlign = !rotation ? "center" : "right";
                            } else if (position === "left") {
                                x = me.right - (isMirrored ? 0 : tl) - tickPadding;
                                textAlign = isMirrored ? "left" : "right";
                            } else {
                                x = me.left + (isMirrored ? 0 : tl) + tickPadding;
                                textAlign = isMirrored ? "right" : "left";
                            }
                            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
                                tick = ticks[i];
                                label = tick.label;
                                if (isNullOrUndef(label)) {
                                    continue;
                                }
                                pixel = me.getPixelForTick(tick._index || i) + optionTicks.labelOffset;
                                font = tick.major ? fonts.major : fonts.minor;
                                lineHeight = font.lineHeight;
                                lineCount = isArray(label) ? label.length : 1;
                                if (isHorizontal) {
                                    x = pixel;
                                    textOffset = position === "top" ? ((!rotation ? 0.5 : 1) - lineCount) * lineHeight : (!rotation ? 0.5 : 0) * lineHeight;
                                } else {
                                    y = pixel;
                                    textOffset = ((1 - lineCount) * lineHeight) / 2;
                                }
                                items.push({ x: x, y: y, rotation: rotation, label: label, font: font, textOffset: textOffset, textAlign: textAlign });
                            }
                            return items;
                        },
                        _drawGrid: function (chartArea) {
                            var me = this;
                            var gridLines = me.options.gridLines;
                            if (!gridLines.display) {
                                return;
                            }
                            var ctx = me.ctx;
                            var chart = me.chart;
                            var alignPixel = helpers$1._alignPixel;
                            var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
                            var items = me._gridLineItems || (me._gridLineItems = me._computeGridLineItems(chartArea));
                            var width, color, i, ilen, item;
                            for (i = 0, ilen = items.length; i < ilen; ++i) {
                                item = items[i];
                                width = item.width;
                                color = item.color;
                                if (width && color) {
                                    ctx.save();
                                    ctx.lineWidth = width;
                                    ctx.strokeStyle = color;
                                    if (ctx.setLineDash) {
                                        ctx.setLineDash(item.borderDash);
                                        ctx.lineDashOffset = item.borderDashOffset;
                                    }
                                    ctx.beginPath();
                                    if (gridLines.drawTicks) {
                                        ctx.moveTo(item.tx1, item.ty1);
                                        ctx.lineTo(item.tx2, item.ty2);
                                    }
                                    if (gridLines.drawOnChartArea) {
                                        ctx.moveTo(item.x1, item.y1);
                                        ctx.lineTo(item.x2, item.y2);
                                    }
                                    ctx.stroke();
                                    ctx.restore();
                                }
                            }
                            if (axisWidth) {
                                var firstLineWidth = axisWidth;
                                var lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth, items.ticksLength - 1, 1);
                                var borderValue = items.borderValue;
                                var x1, x2, y1, y2;
                                if (me.isHorizontal()) {
                                    x1 = alignPixel(chart, me.left, firstLineWidth) - firstLineWidth / 2;
                                    x2 = alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;
                                    y1 = y2 = borderValue;
                                } else {
                                    y1 = alignPixel(chart, me.top, firstLineWidth) - firstLineWidth / 2;
                                    y2 = alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;
                                    x1 = x2 = borderValue;
                                }
                                ctx.lineWidth = axisWidth;
                                ctx.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);
                                ctx.beginPath();
                                ctx.moveTo(x1, y1);
                                ctx.lineTo(x2, y2);
                                ctx.stroke();
                            }
                        },
                        _drawLabels: function () {
                            var me = this;
                            var optionTicks = me.options.ticks;
                            if (!optionTicks.display) {
                                return;
                            }
                            var ctx = me.ctx;
                            var items = me._labelItems || (me._labelItems = me._computeLabelItems());
                            var i, j, ilen, jlen, item, tickFont, label, y;
                            for (i = 0, ilen = items.length; i < ilen; ++i) {
                                item = items[i];
                                tickFont = item.font;
                                ctx.save();
                                ctx.translate(item.x, item.y);
                                ctx.rotate(item.rotation);
                                ctx.font = tickFont.string;
                                ctx.fillStyle = tickFont.color;
                                ctx.textBaseline = "middle";
                                ctx.textAlign = item.textAlign;
                                label = item.label;
                                y = item.textOffset;
                                if (isArray(label)) {
                                    for (j = 0, jlen = label.length; j < jlen; ++j) {
                                        ctx.fillText("" + label[j], 0, y);
                                        y += tickFont.lineHeight;
                                    }
                                } else {
                                    ctx.fillText(label, 0, y);
                                }
                                ctx.restore();
                            }
                        },
                        _drawTitle: function () {
                            var me = this;
                            var ctx = me.ctx;
                            var options = me.options;
                            var scaleLabel = options.scaleLabel;
                            if (!scaleLabel.display) {
                                return;
                            }
                            var scaleLabelFontColor = valueOrDefault$a(scaleLabel.fontColor, core_defaults.global.defaultFontColor);
                            var scaleLabelFont = helpers$1.options._parseFont(scaleLabel);
                            var scaleLabelPadding = helpers$1.options.toPadding(scaleLabel.padding);
                            var halfLineHeight = scaleLabelFont.lineHeight / 2;
                            var position = options.position;
                            var rotation = 0;
                            var scaleLabelX, scaleLabelY;
                            if (me.isHorizontal()) {
                                scaleLabelX = me.left + me.width / 2;
                                scaleLabelY = position === "bottom" ? me.bottom - halfLineHeight - scaleLabelPadding.bottom : me.top + halfLineHeight + scaleLabelPadding.top;
                            } else {
                                var isLeft = position === "left";
                                scaleLabelX = isLeft ? me.left + halfLineHeight + scaleLabelPadding.top : me.right - halfLineHeight - scaleLabelPadding.top;
                                scaleLabelY = me.top + me.height / 2;
                                rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
                            }
                            ctx.save();
                            ctx.translate(scaleLabelX, scaleLabelY);
                            ctx.rotate(rotation);
                            ctx.textAlign = "center";
                            ctx.textBaseline = "middle";
                            ctx.fillStyle = scaleLabelFontColor;
                            ctx.font = scaleLabelFont.string;
                            ctx.fillText(scaleLabel.labelString, 0, 0);
                            ctx.restore();
                        },
                        draw: function (chartArea) {
                            var me = this;
                            if (!me._isVisible()) {
                                return;
                            }
                            me._drawGrid(chartArea);
                            me._drawTitle();
                            me._drawLabels();
                        },
                        _layers: function () {
                            var me = this;
                            var opts = me.options;
                            var tz = (opts.ticks && opts.ticks.z) || 0;
                            var gz = (opts.gridLines && opts.gridLines.z) || 0;
                            if (!me._isVisible() || tz === gz || me.draw !== me._draw) {
                                return [
                                    {
                                        z: tz,
                                        draw: function () {
                                            me.draw.apply(me, arguments);
                                        },
                                    },
                                ];
                            }
                            return [
                                {
                                    z: gz,
                                    draw: function () {
                                        me._drawGrid.apply(me, arguments);
                                        me._drawTitle.apply(me, arguments);
                                    },
                                },
                                {
                                    z: tz,
                                    draw: function () {
                                        me._drawLabels.apply(me, arguments);
                                    },
                                },
                            ];
                        },
                        _getMatchingVisibleMetas: function (type) {
                            var me = this;
                            var isHorizontal = me.isHorizontal();
                            return me.chart._getSortedVisibleDatasetMetas().filter(function (meta) {
                                return (!type || meta.type === type) && (isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id);
                            });
                        },
                    });
                    Scale.prototype._draw = Scale.prototype.draw;
                    var core_scale = Scale;
                    var isNullOrUndef$1 = helpers$1.isNullOrUndef;
                    var defaultConfig = { position: "bottom" };
                    var scale_category = core_scale.extend({
                        determineDataLimits: function () {
                            var me = this;
                            var labels = me._getLabels();
                            var ticksOpts = me.options.ticks;
                            var min = ticksOpts.min;
                            var max = ticksOpts.max;
                            var minIndex = 0;
                            var maxIndex = labels.length - 1;
                            var findIndex;
                            if (min !== undefined) {
                                findIndex = labels.indexOf(min);
                                if (findIndex >= 0) {
                                    minIndex = findIndex;
                                }
                            }
                            if (max !== undefined) {
                                findIndex = labels.indexOf(max);
                                if (findIndex >= 0) {
                                    maxIndex = findIndex;
                                }
                            }
                            me.minIndex = minIndex;
                            me.maxIndex = maxIndex;
                            me.min = labels[minIndex];
                            me.max = labels[maxIndex];
                        },
                        buildTicks: function () {
                            var me = this;
                            var labels = me._getLabels();
                            var minIndex = me.minIndex;
                            var maxIndex = me.maxIndex;
                            me.ticks = minIndex === 0 && maxIndex === labels.length - 1 ? labels : labels.slice(minIndex, maxIndex + 1);
                        },
                        getLabelForIndex: function (index, datasetIndex) {
                            var me = this;
                            var chart = me.chart;
                            if (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me.id) {
                                return me.getRightValue(chart.data.datasets[datasetIndex].data[index]);
                            }
                            return me._getLabels()[index];
                        },
                        _configure: function () {
                            var me = this;
                            var offset = me.options.offset;
                            var ticks = me.ticks;
                            core_scale.prototype._configure.call(me);
                            if (!me.isHorizontal()) {
                                me._reversePixels = !me._reversePixels;
                            }
                            if (!ticks) {
                                return;
                            }
                            me._startValue = me.minIndex - (offset ? 0.5 : 0);
                            me._valueRange = Math.max(ticks.length - (offset ? 0 : 1), 1);
                        },
                        getPixelForValue: function (value, index, datasetIndex) {
                            var me = this;
                            var valueCategory, labels, idx;
                            if (!isNullOrUndef$1(index) && !isNullOrUndef$1(datasetIndex)) {
                                value = me.chart.data.datasets[datasetIndex].data[index];
                            }
                            if (!isNullOrUndef$1(value)) {
                                valueCategory = me.isHorizontal() ? value.x : value.y;
                            }
                            if (valueCategory !== undefined || (value !== undefined && isNaN(index))) {
                                labels = me._getLabels();
                                value = helpers$1.valueOrDefault(valueCategory, value);
                                idx = labels.indexOf(value);
                                index = idx !== -1 ? idx : index;
                                if (isNaN(index)) {
                                    index = value;
                                }
                            }
                            return me.getPixelForDecimal((index - me._startValue) / me._valueRange);
                        },
                        getPixelForTick: function (index) {
                            var ticks = this.ticks;
                            return index < 0 || index > ticks.length - 1 ? null : this.getPixelForValue(ticks[index], index + this.minIndex);
                        },
                        getValueForPixel: function (pixel) {
                            var me = this;
                            var value = Math.round(me._startValue + me.getDecimalForPixel(pixel) * me._valueRange);
                            return Math.min(Math.max(value, 0), me.ticks.length - 1);
                        },
                        getBasePixel: function () {
                            return this.bottom;
                        },
                    });
                    var _defaults = defaultConfig;
                    scale_category._defaults = _defaults;
                    var noop = helpers$1.noop;
                    var isNullOrUndef$2 = helpers$1.isNullOrUndef;
                    function generateTicks(generationOptions, dataRange) {
                        var ticks = [];
                        var MIN_SPACING = 1e-14;
                        var stepSize = generationOptions.stepSize;
                        var unit = stepSize || 1;
                        var maxNumSpaces = generationOptions.maxTicks - 1;
                        var min = generationOptions.min;
                        var max = generationOptions.max;
                        var precision = generationOptions.precision;
                        var rmin = dataRange.min;
                        var rmax = dataRange.max;
                        var spacing = helpers$1.niceNum((rmax - rmin) / maxNumSpaces / unit) * unit;
                        var factor, niceMin, niceMax, numSpaces;
                        if (spacing < MIN_SPACING && isNullOrUndef$2(min) && isNullOrUndef$2(max)) {
                            return [rmin, rmax];
                        }
                        numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
                        if (numSpaces > maxNumSpaces) {
                            spacing = helpers$1.niceNum((numSpaces * spacing) / maxNumSpaces / unit) * unit;
                        }
                        if (stepSize || isNullOrUndef$2(precision)) {
                            factor = Math.pow(10, helpers$1._decimalPlaces(spacing));
                        } else {
                            factor = Math.pow(10, precision);
                            spacing = Math.ceil(spacing * factor) / factor;
                        }
                        niceMin = Math.floor(rmin / spacing) * spacing;
                        niceMax = Math.ceil(rmax / spacing) * spacing;
                        if (stepSize) {
                            if (!isNullOrUndef$2(min) && helpers$1.almostWhole(min / spacing, spacing / 1e3)) {
                                niceMin = min;
                            }
                            if (!isNullOrUndef$2(max) && helpers$1.almostWhole(max / spacing, spacing / 1e3)) {
                                niceMax = max;
                            }
                        }
                        numSpaces = (niceMax - niceMin) / spacing;
                        if (helpers$1.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
                            numSpaces = Math.round(numSpaces);
                        } else {
                            numSpaces = Math.ceil(numSpaces);
                        }
                        niceMin = Math.round(niceMin * factor) / factor;
                        niceMax = Math.round(niceMax * factor) / factor;
                        ticks.push(isNullOrUndef$2(min) ? niceMin : min);
                        for (var j = 1; j < numSpaces; ++j) {
                            ticks.push(Math.round((niceMin + j * spacing) * factor) / factor);
                        }
                        ticks.push(isNullOrUndef$2(max) ? niceMax : max);
                        return ticks;
                    }
                    var scale_linearbase = core_scale.extend({
                        getRightValue: function (value) {
                            if (typeof value === "string") {
                                return +value;
                            }
                            return core_scale.prototype.getRightValue.call(this, value);
                        },
                        handleTickRangeOptions: function () {
                            var me = this;
                            var opts = me.options;
                            var tickOpts = opts.ticks;
                            if (tickOpts.beginAtZero) {
                                var minSign = helpers$1.sign(me.min);
                                var maxSign = helpers$1.sign(me.max);
                                if (minSign < 0 && maxSign < 0) {
                                    me.max = 0;
                                } else if (minSign > 0 && maxSign > 0) {
                                    me.min = 0;
                                }
                            }
                            var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;
                            var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;
                            if (tickOpts.min !== undefined) {
                                me.min = tickOpts.min;
                            } else if (tickOpts.suggestedMin !== undefined) {
                                if (me.min === null) {
                                    me.min = tickOpts.suggestedMin;
                                } else {
                                    me.min = Math.min(me.min, tickOpts.suggestedMin);
                                }
                            }
                            if (tickOpts.max !== undefined) {
                                me.max = tickOpts.max;
                            } else if (tickOpts.suggestedMax !== undefined) {
                                if (me.max === null) {
                                    me.max = tickOpts.suggestedMax;
                                } else {
                                    me.max = Math.max(me.max, tickOpts.suggestedMax);
                                }
                            }
                            if (setMin !== setMax) {
                                if (me.min >= me.max) {
                                    if (setMin) {
                                        me.max = me.min + 1;
                                    } else {
                                        me.min = me.max - 1;
                                    }
                                }
                            }
                            if (me.min === me.max) {
                                me.max++;
                                if (!tickOpts.beginAtZero) {
                                    me.min--;
                                }
                            }
                        },
                        getTickLimit: function () {
                            var me = this;
                            var tickOpts = me.options.ticks;
                            var stepSize = tickOpts.stepSize;
                            var maxTicksLimit = tickOpts.maxTicksLimit;
                            var maxTicks;
                            if (stepSize) {
                                maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;
                            } else {
                                maxTicks = me._computeTickLimit();
                                maxTicksLimit = maxTicksLimit || 11;
                            }
                            if (maxTicksLimit) {
                                maxTicks = Math.min(maxTicksLimit, maxTicks);
                            }
                            return maxTicks;
                        },
                        _computeTickLimit: function () {
                            return Number.POSITIVE_INFINITY;
                        },
                        handleDirectionalChanges: noop,
                        buildTicks: function () {
                            var me = this;
                            var opts = me.options;
                            var tickOpts = opts.ticks;
                            var maxTicks = me.getTickLimit();
                            maxTicks = Math.max(2, maxTicks);
                            var numericGeneratorOptions = { maxTicks: maxTicks, min: tickOpts.min, max: tickOpts.max, precision: tickOpts.precision, stepSize: helpers$1.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize) };
                            var ticks = (me.ticks = generateTicks(numericGeneratorOptions, me));
                            me.handleDirectionalChanges();
                            me.max = helpers$1.max(ticks);
                            me.min = helpers$1.min(ticks);
                            if (tickOpts.reverse) {
                                ticks.reverse();
                                me.start = me.max;
                                me.end = me.min;
                            } else {
                                me.start = me.min;
                                me.end = me.max;
                            }
                        },
                        convertTicksToLabels: function () {
                            var me = this;
                            me.ticksAsNumbers = me.ticks.slice();
                            me.zeroLineIndex = me.ticks.indexOf(0);
                            core_scale.prototype.convertTicksToLabels.call(me);
                        },
                        _configure: function () {
                            var me = this;
                            var ticks = me.getTicks();
                            var start = me.min;
                            var end = me.max;
                            var offset;
                            core_scale.prototype._configure.call(me);
                            if (me.options.offset && ticks.length) {
                                offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
                                start -= offset;
                                end += offset;
                            }
                            me._startValue = start;
                            me._endValue = end;
                            me._valueRange = end - start;
                        },
                    });
                    var defaultConfig$1 = { position: "left", ticks: { callback: core_ticks.formatters.linear } };
                    var DEFAULT_MIN = 0;
                    var DEFAULT_MAX = 1;
                    function getOrCreateStack(stacks, stacked, meta) {
                        var key = [meta.type, stacked === undefined && meta.stack === undefined ? meta.index : "", meta.stack].join(".");
                        if (stacks[key] === undefined) {
                            stacks[key] = { pos: [], neg: [] };
                        }
                        return stacks[key];
                    }
                    function stackData(scale, stacks, meta, data) {
                        var opts = scale.options;
                        var stacked = opts.stacked;
                        var stack = getOrCreateStack(stacks, stacked, meta);
                        var pos = stack.pos;
                        var neg = stack.neg;
                        var ilen = data.length;
                        var i, value;
                        for (i = 0; i < ilen; ++i) {
                            value = scale._parseValue(data[i]);
                            if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden) {
                                continue;
                            }
                            pos[i] = pos[i] || 0;
                            neg[i] = neg[i] || 0;
                            if (opts.relativePoints) {
                                pos[i] = 100;
                            } else if (value.min < 0 || value.max < 0) {
                                neg[i] += value.min;
                            } else {
                                pos[i] += value.max;
                            }
                        }
                    }
                    function updateMinMax(scale, meta, data) {
                        var ilen = data.length;
                        var i, value;
                        for (i = 0; i < ilen; ++i) {
                            value = scale._parseValue(data[i]);
                            if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden) {
                                continue;
                            }
                            scale.min = Math.min(scale.min, value.min);
                            scale.max = Math.max(scale.max, value.max);
                        }
                    }
                    var scale_linear = scale_linearbase.extend({
                        determineDataLimits: function () {
                            var me = this;
                            var opts = me.options;
                            var chart = me.chart;
                            var datasets = chart.data.datasets;
                            var metasets = me._getMatchingVisibleMetas();
                            var hasStacks = opts.stacked;
                            var stacks = {};
                            var ilen = metasets.length;
                            var i, meta, data, values;
                            me.min = Number.POSITIVE_INFINITY;
                            me.max = Number.NEGATIVE_INFINITY;
                            if (hasStacks === undefined) {
                                for (i = 0; !hasStacks && i < ilen; ++i) {
                                    meta = metasets[i];
                                    hasStacks = meta.stack !== undefined;
                                }
                            }
                            for (i = 0; i < ilen; ++i) {
                                meta = metasets[i];
                                data = datasets[meta.index].data;
                                if (hasStacks) {
                                    stackData(me, stacks, meta, data);
                                } else {
                                    updateMinMax(me, meta, data);
                                }
                            }
                            helpers$1.each(stacks, function (stackValues) {
                                values = stackValues.pos.concat(stackValues.neg);
                                me.min = Math.min(me.min, helpers$1.min(values));
                                me.max = Math.max(me.max, helpers$1.max(values));
                            });
                            me.min = helpers$1.isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
                            me.max = helpers$1.isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;
                            me.handleTickRangeOptions();
                        },
                        _computeTickLimit: function () {
                            var me = this;
                            var tickFont;
                            if (me.isHorizontal()) {
                                return Math.ceil(me.width / 40);
                            }
                            tickFont = helpers$1.options._parseFont(me.options.ticks);
                            return Math.ceil(me.height / tickFont.lineHeight);
                        },
                        handleDirectionalChanges: function () {
                            if (!this.isHorizontal()) {
                                this.ticks.reverse();
                            }
                        },
                        getLabelForIndex: function (index, datasetIndex) {
                            return this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index]);
                        },
                        getPixelForValue: function (value) {
                            var me = this;
                            return me.getPixelForDecimal((+me.getRightValue(value) - me._startValue) / me._valueRange);
                        },
                        getValueForPixel: function (pixel) {
                            return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
                        },
                        getPixelForTick: function (index) {
                            var ticks = this.ticksAsNumbers;
                            if (index < 0 || index > ticks.length - 1) {
                                return null;
                            }
                            return this.getPixelForValue(ticks[index]);
                        },
                    });
                    var _defaults$1 = defaultConfig$1;
                    scale_linear._defaults = _defaults$1;
                    var valueOrDefault$b = helpers$1.valueOrDefault;
                    var log10 = helpers$1.math.log10;
                    function generateTicks$1(generationOptions, dataRange) {
                        var ticks = [];
                        var tickVal = valueOrDefault$b(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
                        var endExp = Math.floor(log10(dataRange.max));
                        var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
                        var exp, significand;
                        if (tickVal === 0) {
                            exp = Math.floor(log10(dataRange.minNotZero));
                            significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));
                            ticks.push(tickVal);
                            tickVal = significand * Math.pow(10, exp);
                        } else {
                            exp = Math.floor(log10(tickVal));
                            significand = Math.floor(tickVal / Math.pow(10, exp));
                        }
                        var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
                        do {
                            ticks.push(tickVal);
                            ++significand;
                            if (significand === 10) {
                                significand = 1;
                                ++exp;
                                precision = exp >= 0 ? 1 : precision;
                            }
                            tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
                        } while (exp < endExp || (exp === endExp && significand < endSignificand));
                        var lastTick = valueOrDefault$b(generationOptions.max, tickVal);
                        ticks.push(lastTick);
                        return ticks;
                    }
                    var defaultConfig$2 = { position: "left", ticks: { callback: core_ticks.formatters.logarithmic } };
                    function nonNegativeOrDefault(value, defaultValue) {
                        return helpers$1.isFinite(value) && value >= 0 ? value : defaultValue;
                    }
                    var scale_logarithmic = core_scale.extend({
                        determineDataLimits: function () {
                            var me = this;
                            var opts = me.options;
                            var chart = me.chart;
                            var datasets = chart.data.datasets;
                            var isHorizontal = me.isHorizontal();
                            function IDMatches(meta) {
                                return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
                            }
                            var datasetIndex, meta, value, data, i, ilen;
                            me.min = Number.POSITIVE_INFINITY;
                            me.max = Number.NEGATIVE_INFINITY;
                            me.minNotZero = Number.POSITIVE_INFINITY;
                            var hasStacks = opts.stacked;
                            if (hasStacks === undefined) {
                                for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
                                    meta = chart.getDatasetMeta(datasetIndex);
                                    if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
                                        hasStacks = true;
                                        break;
                                    }
                                }
                            }
                            if (opts.stacked || hasStacks) {
                                var valuesPerStack = {};
                                for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
                                    meta = chart.getDatasetMeta(datasetIndex);
                                    var key = [meta.type, opts.stacked === undefined && meta.stack === undefined ? datasetIndex : "", meta.stack].join(".");
                                    if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                                        if (valuesPerStack[key] === undefined) {
                                            valuesPerStack[key] = [];
                                        }
                                        data = datasets[datasetIndex].data;
                                        for (i = 0, ilen = data.length; i < ilen; i++) {
                                            var values = valuesPerStack[key];
                                            value = me._parseValue(data[i]);
                                            if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden || value.min < 0 || value.max < 0) {
                                                continue;
                                            }
                                            values[i] = values[i] || 0;
                                            values[i] += value.max;
                                        }
                                    }
                                }
                                helpers$1.each(valuesPerStack, function (valuesForType) {
                                    if (valuesForType.length > 0) {
                                        var minVal = helpers$1.min(valuesForType);
                                        var maxVal = helpers$1.max(valuesForType);
                                        me.min = Math.min(me.min, minVal);
                                        me.max = Math.max(me.max, maxVal);
                                    }
                                });
                            } else {
                                for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
                                    meta = chart.getDatasetMeta(datasetIndex);
                                    if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                                        data = datasets[datasetIndex].data;
                                        for (i = 0, ilen = data.length; i < ilen; i++) {
                                            value = me._parseValue(data[i]);
                                            if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden || value.min < 0 || value.max < 0) {
                                                continue;
                                            }
                                            me.min = Math.min(value.min, me.min);
                                            me.max = Math.max(value.max, me.max);
                                            if (value.min !== 0) {
                                                me.minNotZero = Math.min(value.min, me.minNotZero);
                                            }
                                        }
                                    }
                                }
                            }
                            me.min = helpers$1.isFinite(me.min) ? me.min : null;
                            me.max = helpers$1.isFinite(me.max) ? me.max : null;
                            me.minNotZero = helpers$1.isFinite(me.minNotZero) ? me.minNotZero : null;
                            this.handleTickRangeOptions();
                        },
                        handleTickRangeOptions: function () {
                            var me = this;
                            var tickOpts = me.options.ticks;
                            var DEFAULT_MIN = 1;
                            var DEFAULT_MAX = 10;
                            me.min = nonNegativeOrDefault(tickOpts.min, me.min);
                            me.max = nonNegativeOrDefault(tickOpts.max, me.max);
                            if (me.min === me.max) {
                                if (me.min !== 0 && me.min !== null) {
                                    me.min = Math.pow(10, Math.floor(log10(me.min)) - 1);
                                    me.max = Math.pow(10, Math.floor(log10(me.max)) + 1);
                                } else {
                                    me.min = DEFAULT_MIN;
                                    me.max = DEFAULT_MAX;
                                }
                            }
                            if (me.min === null) {
                                me.min = Math.pow(10, Math.floor(log10(me.max)) - 1);
                            }
                            if (me.max === null) {
                                me.max = me.min !== 0 ? Math.pow(10, Math.floor(log10(me.min)) + 1) : DEFAULT_MAX;
                            }
                            if (me.minNotZero === null) {
                                if (me.min > 0) {
                                    me.minNotZero = me.min;
                                } else if (me.max < 1) {
                                    me.minNotZero = Math.pow(10, Math.floor(log10(me.max)));
                                } else {
                                    me.minNotZero = DEFAULT_MIN;
                                }
                            }
                        },
                        buildTicks: function () {
                            var me = this;
                            var tickOpts = me.options.ticks;
                            var reverse = !me.isHorizontal();
                            var generationOptions = { min: nonNegativeOrDefault(tickOpts.min), max: nonNegativeOrDefault(tickOpts.max) };
                            var ticks = (me.ticks = generateTicks$1(generationOptions, me));
                            me.max = helpers$1.max(ticks);
                            me.min = helpers$1.min(ticks);
                            if (tickOpts.reverse) {
                                reverse = !reverse;
                                me.start = me.max;
                                me.end = me.min;
                            } else {
                                me.start = me.min;
                                me.end = me.max;
                            }
                            if (reverse) {
                                ticks.reverse();
                            }
                        },
                        convertTicksToLabels: function () {
                            this.tickValues = this.ticks.slice();
                            core_scale.prototype.convertTicksToLabels.call(this);
                        },
                        getLabelForIndex: function (index, datasetIndex) {
                            return this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index]);
                        },
                        getPixelForTick: function (index) {
                            var ticks = this.tickValues;
                            if (index < 0 || index > ticks.length - 1) {
                                return null;
                            }
                            return this.getPixelForValue(ticks[index]);
                        },
                        _getFirstTickValue: function (value) {
                            var exp = Math.floor(log10(value));
                            var significand = Math.floor(value / Math.pow(10, exp));
                            return significand * Math.pow(10, exp);
                        },
                        _configure: function () {
                            var me = this;
                            var start = me.min;
                            var offset = 0;
                            core_scale.prototype._configure.call(me);
                            if (start === 0) {
                                start = me._getFirstTickValue(me.minNotZero);
                                offset = valueOrDefault$b(me.options.ticks.fontSize, core_defaults.global.defaultFontSize) / me._length;
                            }
                            me._startValue = log10(start);
                            me._valueOffset = offset;
                            me._valueRange = (log10(me.max) - log10(start)) / (1 - offset);
                        },
                        getPixelForValue: function (value) {
                            var me = this;
                            var decimal = 0;
                            value = +me.getRightValue(value);
                            if (value > me.min && value > 0) {
                                decimal = (log10(value) - me._startValue) / me._valueRange + me._valueOffset;
                            }
                            return me.getPixelForDecimal(decimal);
                        },
                        getValueForPixel: function (pixel) {
                            var me = this;
                            var decimal = me.getDecimalForPixel(pixel);
                            return decimal === 0 && me.min === 0 ? 0 : Math.pow(10, me._startValue + (decimal - me._valueOffset) * me._valueRange);
                        },
                    });
                    var _defaults$2 = defaultConfig$2;
                    scale_logarithmic._defaults = _defaults$2;
                    var valueOrDefault$c = helpers$1.valueOrDefault;
                    var valueAtIndexOrDefault$1 = helpers$1.valueAtIndexOrDefault;
                    var resolve$4 = helpers$1.options.resolve;
                    var defaultConfig$3 = {
                        display: true,
                        animate: true,
                        position: "chartArea",
                        angleLines: { display: true, color: "rgba(0,0,0,0.1)", lineWidth: 1, borderDash: [], borderDashOffset: 0 },
                        gridLines: { circular: false },
                        ticks: { showLabelBackdrop: true, backdropColor: "rgba(255,255,255,0.75)", backdropPaddingY: 2, backdropPaddingX: 2, callback: core_ticks.formatters.linear },
                        pointLabels: {
                            display: true,
                            fontSize: 10,
                            callback: function (label) {
                                return label;
                            },
                        },
                    };
                    function getTickBackdropHeight(opts) {
                        var tickOpts = opts.ticks;
                        if (tickOpts.display && opts.display) {
                            return valueOrDefault$c(tickOpts.fontSize, core_defaults.global.defaultFontSize) + tickOpts.backdropPaddingY * 2;
                        }
                        return 0;
                    }
                    function measureLabelSize(ctx, lineHeight, label) {
                        if (helpers$1.isArray(label)) {
                            return { w: helpers$1.longestText(ctx, ctx.font, label), h: label.length * lineHeight };
                        }
                        return { w: ctx.measureText(label).width, h: lineHeight };
                    }
                    function determineLimits(angle, pos, size, min, max) {
                        if (angle === min || angle === max) {
                            return { start: pos - size / 2, end: pos + size / 2 };
                        } else if (angle < min || angle > max) {
                            return { start: pos - size, end: pos };
                        }
                        return { start: pos, end: pos + size };
                    }
                    function fitWithPointLabels(scale) {
                        var plFont = helpers$1.options._parseFont(scale.options.pointLabels);
                        var furthestLimits = { l: 0, r: scale.width, t: 0, b: scale.height - scale.paddingTop };
                        var furthestAngles = {};
                        var i, textSize, pointPosition;
                        scale.ctx.font = plFont.string;
                        scale._pointLabelSizes = [];
                        var valueCount = scale.chart.data.labels.length;
                        for (i = 0; i < valueCount; i++) {
                            pointPosition = scale.getPointPosition(i, scale.drawingArea + 5);
                            textSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale.pointLabels[i]);
                            scale._pointLabelSizes[i] = textSize;
                            var angleRadians = scale.getIndexAngle(i);
                            var angle = helpers$1.toDegrees(angleRadians) % 360;
                            var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
                            var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
                            if (hLimits.start < furthestLimits.l) {
                                furthestLimits.l = hLimits.start;
                                furthestAngles.l = angleRadians;
                            }
                            if (hLimits.end > furthestLimits.r) {
                                furthestLimits.r = hLimits.end;
                                furthestAngles.r = angleRadians;
                            }
                            if (vLimits.start < furthestLimits.t) {
                                furthestLimits.t = vLimits.start;
                                furthestAngles.t = angleRadians;
                            }
                            if (vLimits.end > furthestLimits.b) {
                                furthestLimits.b = vLimits.end;
                                furthestAngles.b = angleRadians;
                            }
                        }
                        scale.setReductions(scale.drawingArea, furthestLimits, furthestAngles);
                    }
                    function getTextAlignForAngle(angle) {
                        if (angle === 0 || angle === 180) {
                            return "center";
                        } else if (angle < 180) {
                            return "left";
                        }
                        return "right";
                    }
                    function fillText(ctx, text, position, lineHeight) {
                        var y = position.y + lineHeight / 2;
                        var i, ilen;
                        if (helpers$1.isArray(text)) {
                            for (i = 0, ilen = text.length; i < ilen; ++i) {
                                ctx.fillText(text[i], position.x, y);
                                y += lineHeight;
                            }
                        } else {
                            ctx.fillText(text, position.x, y);
                        }
                    }
                    function adjustPointPositionForLabelHeight(angle, textSize, position) {
                        if (angle === 90 || angle === 270) {
                            position.y -= textSize.h / 2;
                        } else if (angle > 270 || angle < 90) {
                            position.y -= textSize.h;
                        }
                    }
                    function drawPointLabels(scale) {
                        var ctx = scale.ctx;
                        var opts = scale.options;
                        var pointLabelOpts = opts.pointLabels;
                        var tickBackdropHeight = getTickBackdropHeight(opts);
                        var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);
                        var plFont = helpers$1.options._parseFont(pointLabelOpts);
                        ctx.save();
                        ctx.font = plFont.string;
                        ctx.textBaseline = "middle";
                        for (var i = scale.chart.data.labels.length - 1; i >= 0; i--) {
                            var extra = i === 0 ? tickBackdropHeight / 2 : 0;
                            var pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + 5);
                            var pointLabelFontColor = valueAtIndexOrDefault$1(pointLabelOpts.fontColor, i, core_defaults.global.defaultFontColor);
                            ctx.fillStyle = pointLabelFontColor;
                            var angleRadians = scale.getIndexAngle(i);
                            var angle = helpers$1.toDegrees(angleRadians);
                            ctx.textAlign = getTextAlignForAngle(angle);
                            adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
                            fillText(ctx, scale.pointLabels[i], pointLabelPosition, plFont.lineHeight);
                        }
                        ctx.restore();
                    }
                    function drawRadiusLine(scale, gridLineOpts, radius, index) {
                        var ctx = scale.ctx;
                        var circular = gridLineOpts.circular;
                        var valueCount = scale.chart.data.labels.length;
                        var lineColor = valueAtIndexOrDefault$1(gridLineOpts.color, index - 1);
                        var lineWidth = valueAtIndexOrDefault$1(gridLineOpts.lineWidth, index - 1);
                        var pointPosition;
                        if ((!circular && !valueCount) || !lineColor || !lineWidth) {
                            return;
                        }
                        ctx.save();
                        ctx.strokeStyle = lineColor;
                        ctx.lineWidth = lineWidth;
                        if (ctx.setLineDash) {
                            ctx.setLineDash(gridLineOpts.borderDash || []);
                            ctx.lineDashOffset = gridLineOpts.borderDashOffset || 0;
                        }
                        ctx.beginPath();
                        if (circular) {
                            ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
                        } else {
                            pointPosition = scale.getPointPosition(0, radius);
                            ctx.moveTo(pointPosition.x, pointPosition.y);
                            for (var i = 1; i < valueCount; i++) {
                                pointPosition = scale.getPointPosition(i, radius);
                                ctx.lineTo(pointPosition.x, pointPosition.y);
                            }
                        }
                        ctx.closePath();
                        ctx.stroke();
                        ctx.restore();
                    }
                    function numberOrZero(param) {
                        return helpers$1.isNumber(param) ? param : 0;
                    }
                    var scale_radialLinear = scale_linearbase.extend({
                        setDimensions: function () {
                            var me = this;
                            me.width = me.maxWidth;
                            me.height = me.maxHeight;
                            me.paddingTop = getTickBackdropHeight(me.options) / 2;
                            me.xCenter = Math.floor(me.width / 2);
                            me.yCenter = Math.floor((me.height - me.paddingTop) / 2);
                            me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;
                        },
                        determineDataLimits: function () {
                            var me = this;
                            var chart = me.chart;
                            var min = Number.POSITIVE_INFINITY;
                            var max = Number.NEGATIVE_INFINITY;
                            helpers$1.each(chart.data.datasets, function (dataset, datasetIndex) {
                                if (chart.isDatasetVisible(datasetIndex)) {
                                    var meta = chart.getDatasetMeta(datasetIndex);
                                    helpers$1.each(dataset.data, function (rawValue, index) {
                                        var value = +me.getRightValue(rawValue);
                                        if (isNaN(value) || meta.data[index].hidden) {
                                            return;
                                        }
                                        min = Math.min(value, min);
                                        max = Math.max(value, max);
                                    });
                                }
                            });
                            me.min = min === Number.POSITIVE_INFINITY ? 0 : min;
                            me.max = max === Number.NEGATIVE_INFINITY ? 0 : max;
                            me.handleTickRangeOptions();
                        },
                        _computeTickLimit: function () {
                            return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
                        },
                        convertTicksToLabels: function () {
                            var me = this;
                            scale_linearbase.prototype.convertTicksToLabels.call(me);
                            me.pointLabels = me.chart.data.labels.map(function () {
                                var label = helpers$1.callback(me.options.pointLabels.callback, arguments, me);
                                return label || label === 0 ? label : "";
                            });
                        },
                        getLabelForIndex: function (index, datasetIndex) {
                            return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
                        },
                        fit: function () {
                            var me = this;
                            var opts = me.options;
                            if (opts.display && opts.pointLabels.display) {
                                fitWithPointLabels(me);
                            } else {
                                me.setCenterPoint(0, 0, 0, 0);
                            }
                        },
                        setReductions: function (largestPossibleRadius, furthestLimits, furthestAngles) {
                            var me = this;
                            var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
                            var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
                            var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
                            var radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);
                            radiusReductionLeft = numberOrZero(radiusReductionLeft);
                            radiusReductionRight = numberOrZero(radiusReductionRight);
                            radiusReductionTop = numberOrZero(radiusReductionTop);
                            radiusReductionBottom = numberOrZero(radiusReductionBottom);
                            me.drawingArea = Math.min(Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
                            me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
                        },
                        setCenterPoint: function (leftMovement, rightMovement, topMovement, bottomMovement) {
                            var me = this;
                            var maxRight = me.width - rightMovement - me.drawingArea;
                            var maxLeft = leftMovement + me.drawingArea;
                            var maxTop = topMovement + me.drawingArea;
                            var maxBottom = me.height - me.paddingTop - bottomMovement - me.drawingArea;
                            me.xCenter = Math.floor((maxLeft + maxRight) / 2 + me.left);
                            me.yCenter = Math.floor((maxTop + maxBottom) / 2 + me.top + me.paddingTop);
                        },
                        getIndexAngle: function (index) {
                            var chart = this.chart;
                            var angleMultiplier = 360 / chart.data.labels.length;
                            var options = chart.options || {};
                            var startAngle = options.startAngle || 0;
                            var angle = (index * angleMultiplier + startAngle) % 360;
                            return ((angle < 0 ? angle + 360 : angle) * Math.PI * 2) / 360;
                        },
                        getDistanceFromCenterForValue: function (value) {
                            var me = this;
                            if (helpers$1.isNullOrUndef(value)) {
                                return NaN;
                            }
                            var scalingFactor = me.drawingArea / (me.max - me.min);
                            if (me.options.ticks.reverse) {
                                return (me.max - value) * scalingFactor;
                            }
                            return (value - me.min) * scalingFactor;
                        },
                        getPointPosition: function (index, distanceFromCenter) {
                            var me = this;
                            var thisAngle = me.getIndexAngle(index) - Math.PI / 2;
                            return { x: Math.cos(thisAngle) * distanceFromCenter + me.xCenter, y: Math.sin(thisAngle) * distanceFromCenter + me.yCenter };
                        },
                        getPointPositionForValue: function (index, value) {
                            return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
                        },
                        getBasePosition: function (index) {
                            var me = this;
                            var min = me.min;
                            var max = me.max;
                            return me.getPointPositionForValue(index || 0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0);
                        },
                        _drawGrid: function () {
                            var me = this;
                            var ctx = me.ctx;
                            var opts = me.options;
                            var gridLineOpts = opts.gridLines;
                            var angleLineOpts = opts.angleLines;
                            var lineWidth = valueOrDefault$c(angleLineOpts.lineWidth, gridLineOpts.lineWidth);
                            var lineColor = valueOrDefault$c(angleLineOpts.color, gridLineOpts.color);
                            var i, offset, position;
                            if (opts.pointLabels.display) {
                                drawPointLabels(me);
                            }
                            if (gridLineOpts.display) {
                                helpers$1.each(me.ticks, function (label, index) {
                                    if (index !== 0) {
                                        offset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);
                                        drawRadiusLine(me, gridLineOpts, offset, index);
                                    }
                                });
                            }
                            if (angleLineOpts.display && lineWidth && lineColor) {
                                ctx.save();
                                ctx.lineWidth = lineWidth;
                                ctx.strokeStyle = lineColor;
                                if (ctx.setLineDash) {
                                    ctx.setLineDash(resolve$4([angleLineOpts.borderDash, gridLineOpts.borderDash, []]));
                                    ctx.lineDashOffset = resolve$4([angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset, 0]);
                                }
                                for (i = me.chart.data.labels.length - 1; i >= 0; i--) {
                                    offset = me.getDistanceFromCenterForValue(opts.ticks.reverse ? me.min : me.max);
                                    position = me.getPointPosition(i, offset);
                                    ctx.beginPath();
                                    ctx.moveTo(me.xCenter, me.yCenter);
                                    ctx.lineTo(position.x, position.y);
                                    ctx.stroke();
                                }
                                ctx.restore();
                            }
                        },
                        _drawLabels: function () {
                            var me = this;
                            var ctx = me.ctx;
                            var opts = me.options;
                            var tickOpts = opts.ticks;
                            if (!tickOpts.display) {
                                return;
                            }
                            var startAngle = me.getIndexAngle(0);
                            var tickFont = helpers$1.options._parseFont(tickOpts);
                            var tickFontColor = valueOrDefault$c(tickOpts.fontColor, core_defaults.global.defaultFontColor);
                            var offset, width;
                            ctx.save();
                            ctx.font = tickFont.string;
                            ctx.translate(me.xCenter, me.yCenter);
                            ctx.rotate(startAngle);
                            ctx.textAlign = "center";
                            ctx.textBaseline = "middle";
                            helpers$1.each(me.ticks, function (label, index) {
                                if (index === 0 && !tickOpts.reverse) {
                                    return;
                                }
                                offset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);
                                if (tickOpts.showLabelBackdrop) {
                                    width = ctx.measureText(label).width;
                                    ctx.fillStyle = tickOpts.backdropColor;
                                    ctx.fillRect(-width / 2 - tickOpts.backdropPaddingX, -offset - tickFont.size / 2 - tickOpts.backdropPaddingY, width + tickOpts.backdropPaddingX * 2, tickFont.size + tickOpts.backdropPaddingY * 2);
                                }
                                ctx.fillStyle = tickFontColor;
                                ctx.fillText(label, 0, -offset);
                            });
                            ctx.restore();
                        },
                        _drawTitle: helpers$1.noop,
                    });
                    var _defaults$3 = defaultConfig$3;
                    scale_radialLinear._defaults = _defaults$3;
                    var deprecated$1 = helpers$1._deprecated;
                    var resolve$5 = helpers$1.options.resolve;
                    var valueOrDefault$d = helpers$1.valueOrDefault;
                    var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
                    var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
                    var INTERVALS = {
                        millisecond: { common: true, size: 1, steps: 1e3 },
                        second: { common: true, size: 1e3, steps: 60 },
                        minute: { common: true, size: 6e4, steps: 60 },
                        hour: { common: true, size: 36e5, steps: 24 },
                        day: { common: true, size: 864e5, steps: 30 },
                        week: { common: false, size: 6048e5, steps: 4 },
                        month: { common: true, size: 2628e6, steps: 12 },
                        quarter: { common: false, size: 7884e6, steps: 4 },
                        year: { common: true, size: 3154e7 },
                    };
                    var UNITS = Object.keys(INTERVALS);
                    function sorter(a, b) {
                        return a - b;
                    }
                    function arrayUnique(items) {
                        var hash = {};
                        var out = [];
                        var i, ilen, item;
                        for (i = 0, ilen = items.length; i < ilen; ++i) {
                            item = items[i];
                            if (!hash[item]) {
                                hash[item] = true;
                                out.push(item);
                            }
                        }
                        return out;
                    }
                    function getMin(options) {
                        return helpers$1.valueOrDefault(options.time.min, options.ticks.min);
                    }
                    function getMax(options) {
                        return helpers$1.valueOrDefault(options.time.max, options.ticks.max);
                    }
                    function buildLookupTable(timestamps, min, max, distribution) {
                        if (distribution === "linear" || !timestamps.length) {
                            return [
                                { time: min, pos: 0 },
                                { time: max, pos: 1 },
                            ];
                        }
                        var table = [];
                        var items = [min];
                        var i, ilen, prev, curr, next;
                        for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
                            curr = timestamps[i];
                            if (curr > min && curr < max) {
                                items.push(curr);
                            }
                        }
                        items.push(max);
                        for (i = 0, ilen = items.length; i < ilen; ++i) {
                            next = items[i + 1];
                            prev = items[i - 1];
                            curr = items[i];
                            if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {
                                table.push({ time: curr, pos: i / (ilen - 1) });
                            }
                        }
                        return table;
                    }
                    function lookup(table, key, value) {
                        var lo = 0;
                        var hi = table.length - 1;
                        var mid, i0, i1;
                        while (lo >= 0 && lo <= hi) {
                            mid = (lo + hi) >> 1;
                            i0 = table[mid - 1] || null;
                            i1 = table[mid];
                            if (!i0) {
                                return { lo: null, hi: i1 };
                            } else if (i1[key] < value) {
                                lo = mid + 1;
                            } else if (i0[key] > value) {
                                hi = mid - 1;
                            } else {
                                return { lo: i0, hi: i1 };
                            }
                        }
                        return { lo: i1, hi: null };
                    }
                    function interpolate$1(table, skey, sval, tkey) {
                        var range = lookup(table, skey, sval);
                        var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
                        var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;
                        var span = next[skey] - prev[skey];
                        var ratio = span ? (sval - prev[skey]) / span : 0;
                        var offset = (next[tkey] - prev[tkey]) * ratio;
                        return prev[tkey] + offset;
                    }
                    function toTimestamp(scale, input) {
                        var adapter = scale._adapter;
                        var options = scale.options.time;
                        var parser = options.parser;
                        var format = parser || options.format;
                        var value = input;
                        if (typeof parser === "function") {
                            value = parser(value);
                        }
                        if (!helpers$1.isFinite(value)) {
                            value = typeof format === "string" ? adapter.parse(value, format) : adapter.parse(value);
                        }
                        if (value !== null) {
                            return +value;
                        }
                        if (!parser && typeof format === "function") {
                            value = format(input);
                            if (!helpers$1.isFinite(value)) {
                                value = adapter.parse(value);
                            }
                        }
                        return value;
                    }
                    function parse(scale, input) {
                        if (helpers$1.isNullOrUndef(input)) {
                            return null;
                        }
                        var options = scale.options.time;
                        var value = toTimestamp(scale, scale.getRightValue(input));
                        if (value === null) {
                            return value;
                        }
                        if (options.round) {
                            value = +scale._adapter.startOf(value, options.round);
                        }
                        return value;
                    }
                    function determineUnitForAutoTicks(minUnit, min, max, capacity) {
                        var ilen = UNITS.length;
                        var i, interval, factor;
                        for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
                            interval = INTERVALS[UNITS[i]];
                            factor = interval.steps ? interval.steps : MAX_INTEGER;
                            if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
                                return UNITS[i];
                            }
                        }
                        return UNITS[ilen - 1];
                    }
                    function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
                        var i, unit;
                        for (i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
                            unit = UNITS[i];
                            if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
                                return unit;
                            }
                        }
                        return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
                    }
                    function determineMajorUnit(unit) {
                        for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
                            if (INTERVALS[UNITS[i]].common) {
                                return UNITS[i];
                            }
                        }
                    }
                    function generate(scale, min, max, capacity) {
                        var adapter = scale._adapter;
                        var options = scale.options;
                        var timeOpts = options.time;
                        var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
                        var stepSize = resolve$5([timeOpts.stepSize, timeOpts.unitStepSize, 1]);
                        var weekday = minor === "week" ? timeOpts.isoWeekday : false;
                        var first = min;
                        var ticks = [];
                        var time;
                        if (weekday) {
                            first = +adapter.startOf(first, "isoWeek", weekday);
                        }
                        first = +adapter.startOf(first, weekday ? "day" : minor);
                        if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
                            throw min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor;
                        }
                        for (time = first; time < max; time = +adapter.add(time, stepSize, minor)) {
                            ticks.push(time);
                        }
                        if (time === max || options.bounds === "ticks") {
                            ticks.push(time);
                        }
                        return ticks;
                    }
                    function computeOffsets(table, ticks, min, max, options) {
                        var start = 0;
                        var end = 0;
                        var first, last;
                        if (options.offset && ticks.length) {
                            first = interpolate$1(table, "time", ticks[0], "pos");
                            if (ticks.length === 1) {
                                start = 1 - first;
                            } else {
                                start = (interpolate$1(table, "time", ticks[1], "pos") - first) / 2;
                            }
                            last = interpolate$1(table, "time", ticks[ticks.length - 1], "pos");
                            if (ticks.length === 1) {
                                end = last;
                            } else {
                                end = (last - interpolate$1(table, "time", ticks[ticks.length - 2], "pos")) / 2;
                            }
                        }
                        return { start: start, end: end, factor: 1 / (start + 1 + end) };
                    }
                    function setMajorTicks(scale, ticks, map, majorUnit) {
                        var adapter = scale._adapter;
                        var first = +adapter.startOf(ticks[0].value, majorUnit);
                        var last = ticks[ticks.length - 1].value;
                        var major, index;
                        for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
                            index = map[major];
                            if (index >= 0) {
                                ticks[index].major = true;
                            }
                        }
                        return ticks;
                    }
                    function ticksFromTimestamps(scale, values, majorUnit) {
                        var ticks = [];
                        var map = {};
                        var ilen = values.length;
                        var i, value;
                        for (i = 0; i < ilen; ++i) {
                            value = values[i];
                            map[value] = i;
                            ticks.push({ value: value, major: false });
                        }
                        return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);
                    }
                    var defaultConfig$4 = {
                        position: "bottom",
                        distribution: "linear",
                        bounds: "data",
                        adapters: {},
                        time: { parser: false, unit: false, round: false, displayFormat: false, isoWeekday: false, minUnit: "millisecond", displayFormats: {} },
                        ticks: { autoSkip: false, source: "auto", major: { enabled: false } },
                    };
                    var scale_time = core_scale.extend({
                        initialize: function () {
                            this.mergeTicksOptions();
                            core_scale.prototype.initialize.call(this);
                        },
                        update: function () {
                            var me = this;
                            var options = me.options;
                            var time = options.time || (options.time = {});
                            var adapter = (me._adapter = new core_adapters._date(options.adapters.date));
                            deprecated$1("time scale", time.format, "time.format", "time.parser");
                            deprecated$1("time scale", time.min, "time.min", "ticks.min");
                            deprecated$1("time scale", time.max, "time.max", "ticks.max");
                            helpers$1.mergeIf(time.displayFormats, adapter.formats());
                            return core_scale.prototype.update.apply(me, arguments);
                        },
                        getRightValue: function (rawValue) {
                            if (rawValue && rawValue.t !== undefined) {
                                rawValue = rawValue.t;
                            }
                            return core_scale.prototype.getRightValue.call(this, rawValue);
                        },
                        determineDataLimits: function () {
                            var me = this;
                            var chart = me.chart;
                            var adapter = me._adapter;
                            var options = me.options;
                            var unit = options.time.unit || "day";
                            var min = MAX_INTEGER;
                            var max = MIN_INTEGER;
                            var timestamps = [];
                            var datasets = [];
                            var labels = [];
                            var i, j, ilen, jlen, data, timestamp, labelsAdded;
                            var dataLabels = me._getLabels();
                            for (i = 0, ilen = dataLabels.length; i < ilen; ++i) {
                                labels.push(parse(me, dataLabels[i]));
                            }
                            for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
                                if (chart.isDatasetVisible(i)) {
                                    data = chart.data.datasets[i].data;
                                    if (helpers$1.isObject(data[0])) {
                                        datasets[i] = [];
                                        for (j = 0, jlen = data.length; j < jlen; ++j) {
                                            timestamp = parse(me, data[j]);
                                            timestamps.push(timestamp);
                                            datasets[i][j] = timestamp;
                                        }
                                    } else {
                                        datasets[i] = labels.slice(0);
                                        if (!labelsAdded) {
                                            timestamps = timestamps.concat(labels);
                                            labelsAdded = true;
                                        }
                                    }
                                } else {
                                    datasets[i] = [];
                                }
                            }
                            if (labels.length) {
                                min = Math.min(min, labels[0]);
                                max = Math.max(max, labels[labels.length - 1]);
                            }
                            if (timestamps.length) {
                                timestamps = ilen > 1 ? arrayUnique(timestamps).sort(sorter) : timestamps.sort(sorter);
                                min = Math.min(min, timestamps[0]);
                                max = Math.max(max, timestamps[timestamps.length - 1]);
                            }
                            min = parse(me, getMin(options)) || min;
                            max = parse(me, getMax(options)) || max;
                            min = min === MAX_INTEGER ? +adapter.startOf(Date.now(), unit) : min;
                            max = max === MIN_INTEGER ? +adapter.endOf(Date.now(), unit) + 1 : max;
                            me.min = Math.min(min, max);
                            me.max = Math.max(min + 1, max);
                            me._table = [];
                            me._timestamps = { data: timestamps, datasets: datasets, labels: labels };
                        },
                        buildTicks: function () {
                            var me = this;
                            var min = me.min;
                            var max = me.max;
                            var options = me.options;
                            var tickOpts = options.ticks;
                            var timeOpts = options.time;
                            var timestamps = me._timestamps;
                            var ticks = [];
                            var capacity = me.getLabelCapacity(min);
                            var source = tickOpts.source;
                            var distribution = options.distribution;
                            var i, ilen, timestamp;
                            if (source === "data" || (source === "auto" && distribution === "series")) {
                                timestamps = timestamps.data;
                            } else if (source === "labels") {
                                timestamps = timestamps.labels;
                            } else {
                                timestamps = generate(me, min, max, capacity);
                            }
                            if (options.bounds === "ticks" && timestamps.length) {
                                min = timestamps[0];
                                max = timestamps[timestamps.length - 1];
                            }
                            min = parse(me, getMin(options)) || min;
                            max = parse(me, getMax(options)) || max;
                            for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
                                timestamp = timestamps[i];
                                if (timestamp >= min && timestamp <= max) {
                                    ticks.push(timestamp);
                                }
                            }
                            me.min = min;
                            me.max = max;
                            me._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, me.min, me.max, capacity) : determineUnitForFormatting(me, ticks.length, timeOpts.minUnit, me.min, me.max));
                            me._majorUnit = !tickOpts.major.enabled || me._unit === "year" ? undefined : determineMajorUnit(me._unit);
                            me._table = buildLookupTable(me._timestamps.data, min, max, distribution);
                            me._offsets = computeOffsets(me._table, ticks, min, max, options);
                            if (tickOpts.reverse) {
                                ticks.reverse();
                            }
                            return ticksFromTimestamps(me, ticks, me._majorUnit);
                        },
                        getLabelForIndex: function (index, datasetIndex) {
                            var me = this;
                            var adapter = me._adapter;
                            var data = me.chart.data;
                            var timeOpts = me.options.time;
                            var label = data.labels && index < data.labels.length ? data.labels[index] : "";
                            var value = data.datasets[datasetIndex].data[index];
                            if (helpers$1.isObject(value)) {
                                label = me.getRightValue(value);
                            }
                            if (timeOpts.tooltipFormat) {
                                return adapter.format(toTimestamp(me, label), timeOpts.tooltipFormat);
                            }
                            if (typeof label === "string") {
                                return label;
                            }
                            return adapter.format(toTimestamp(me, label), timeOpts.displayFormats.datetime);
                        },
                        tickFormatFunction: function (time, index, ticks, format) {
                            var me = this;
                            var adapter = me._adapter;
                            var options = me.options;
                            var formats = options.time.displayFormats;
                            var minorFormat = formats[me._unit];
                            var majorUnit = me._majorUnit;
                            var majorFormat = formats[majorUnit];
                            var tick = ticks[index];
                            var tickOpts = options.ticks;
                            var major = majorUnit && majorFormat && tick && tick.major;
                            var label = adapter.format(time, format ? format : major ? majorFormat : minorFormat);
                            var nestedTickOpts = major ? tickOpts.major : tickOpts.minor;
                            var formatter = resolve$5([nestedTickOpts.callback, nestedTickOpts.userCallback, tickOpts.callback, tickOpts.userCallback]);
                            return formatter ? formatter(label, index, ticks) : label;
                        },
                        convertTicksToLabels: function (ticks) {
                            var labels = [];
                            var i, ilen;
                            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
                                labels.push(this.tickFormatFunction(ticks[i].value, i, ticks));
                            }
                            return labels;
                        },
                        getPixelForOffset: function (time) {
                            var me = this;
                            var offsets = me._offsets;
                            var pos = interpolate$1(me._table, "time", time, "pos");
                            return me.getPixelForDecimal((offsets.start + pos) * offsets.factor);
                        },
                        getPixelForValue: function (value, index, datasetIndex) {
                            var me = this;
                            var time = null;
                            if (index !== undefined && datasetIndex !== undefined) {
                                time = me._timestamps.datasets[datasetIndex][index];
                            }
                            if (time === null) {
                                time = parse(me, value);
                            }
                            if (time !== null) {
                                return me.getPixelForOffset(time);
                            }
                        },
                        getPixelForTick: function (index) {
                            var ticks = this.getTicks();
                            return index >= 0 && index < ticks.length ? this.getPixelForOffset(ticks[index].value) : null;
                        },
                        getValueForPixel: function (pixel) {
                            var me = this;
                            var offsets = me._offsets;
                            var pos = me.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
                            var time = interpolate$1(me._table, "pos", pos, "time");
                            return me._adapter._create(time);
                        },
                        _getLabelSize: function (label) {
                            var me = this;
                            var ticksOpts = me.options.ticks;
                            var tickLabelWidth = me.ctx.measureText(label).width;
                            var angle = helpers$1.toRadians(me.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
                            var cosRotation = Math.cos(angle);
                            var sinRotation = Math.sin(angle);
                            var tickFontSize = valueOrDefault$d(ticksOpts.fontSize, core_defaults.global.defaultFontSize);
                            return { w: tickLabelWidth * cosRotation + tickFontSize * sinRotation, h: tickLabelWidth * sinRotation + tickFontSize * cosRotation };
                        },
                        getLabelWidth: function (label) {
                            return this._getLabelSize(label).w;
                        },
                        getLabelCapacity: function (exampleTime) {
                            var me = this;
                            var timeOpts = me.options.time;
                            var displayFormats = timeOpts.displayFormats;
                            var format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
                            var exampleLabel = me.tickFormatFunction(exampleTime, 0, ticksFromTimestamps(me, [exampleTime], me._majorUnit), format);
                            var size = me._getLabelSize(exampleLabel);
                            var capacity = Math.floor(me.isHorizontal() ? me.width / size.w : me.height / size.h);
                            if (me.options.offset) {
                                capacity--;
                            }
                            return capacity > 0 ? capacity : 1;
                        },
                    });
                    var _defaults$4 = defaultConfig$4;
                    scale_time._defaults = _defaults$4;
                    var scales = { category: scale_category, linear: scale_linear, logarithmic: scale_logarithmic, radialLinear: scale_radialLinear, time: scale_time };
                    var FORMATS = { datetime: "MMM D, YYYY, h:mm:ss a", millisecond: "h:mm:ss.SSS a", second: "h:mm:ss a", minute: "h:mm a", hour: "hA", day: "MMM D", week: "ll", month: "MMM YYYY", quarter: "[Q]Q - YYYY", year: "YYYY" };
                    core_adapters._date.override(
                        typeof moment === "function"
                            ? {
                                  _id: "moment",
                                  formats: function () {
                                      return FORMATS;
                                  },
                                  parse: function (value, format) {
                                      if (typeof value === "string" && typeof format === "string") {
                                          value = moment(value, format);
                                      } else if (!(value instanceof moment)) {
                                          value = moment(value);
                                      }
                                      return value.isValid() ? value.valueOf() : null;
                                  },
                                  format: function (time, format) {
                                      return moment(time).format(format);
                                  },
                                  add: function (time, amount, unit) {
                                      return moment(time).add(amount, unit).valueOf();
                                  },
                                  diff: function (max, min, unit) {
                                      return moment(max).diff(moment(min), unit);
                                  },
                                  startOf: function (time, unit, weekday) {
                                      time = moment(time);
                                      if (unit === "isoWeek") {
                                          return time.isoWeekday(weekday).valueOf();
                                      }
                                      return time.startOf(unit).valueOf();
                                  },
                                  endOf: function (time, unit) {
                                      return moment(time).endOf(unit).valueOf();
                                  },
                                  _create: function (time) {
                                      return moment(time);
                                  },
                              }
                            : {}
                    );
                    core_defaults._set("global", { plugins: { filler: { propagate: true } } });
                    var mappers = {
                        dataset: function (source) {
                            var index = source.fill;
                            var chart = source.chart;
                            var meta = chart.getDatasetMeta(index);
                            var visible = meta && chart.isDatasetVisible(index);
                            var points = (visible && meta.dataset._children) || [];
                            var length = points.length || 0;
                            return !length
                                ? null
                                : function (point, i) {
                                      return (i < length && points[i]._view) || null;
                                  };
                        },
                        boundary: function (source) {
                            var boundary = source.boundary;
                            var x = boundary ? boundary.x : null;
                            var y = boundary ? boundary.y : null;
                            if (helpers$1.isArray(boundary)) {
                                return function (point, i) {
                                    return boundary[i];
                                };
                            }
                            return function (point) {
                                return { x: x === null ? point.x : x, y: y === null ? point.y : y };
                            };
                        },
                    };
                    function decodeFill(el, index, count) {
                        var model = el._model || {};
                        var fill = model.fill;
                        var target;
                        if (fill === undefined) {
                            fill = !!model.backgroundColor;
                        }
                        if (fill === false || fill === null) {
                            return false;
                        }
                        if (fill === true) {
                            return "origin";
                        }
                        target = parseFloat(fill, 10);
                        if (isFinite(target) && Math.floor(target) === target) {
                            if (fill[0] === "-" || fill[0] === "+") {
                                target = index + target;
                            }
                            if (target === index || target < 0 || target >= count) {
                                return false;
                            }
                            return target;
                        }
                        switch (fill) {
                            case "bottom":
                                return "start";
                            case "top":
                                return "end";
                            case "zero":
                                return "origin";
                            case "origin":
                            case "start":
                            case "end":
                                return fill;
                            default:
                                return false;
                        }
                    }
                    function computeLinearBoundary(source) {
                        var model = source.el._model || {};
                        var scale = source.el._scale || {};
                        var fill = source.fill;
                        var target = null;
                        var horizontal;
                        if (isFinite(fill)) {
                            return null;
                        }
                        if (fill === "start") {
                            target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;
                        } else if (fill === "end") {
                            target = model.scaleTop === undefined ? scale.top : model.scaleTop;
                        } else if (model.scaleZero !== undefined) {
                            target = model.scaleZero;
                        } else if (scale.getBasePixel) {
                            target = scale.getBasePixel();
                        }
                        if (target !== undefined && target !== null) {
                            if (target.x !== undefined && target.y !== undefined) {
                                return target;
                            }
                            if (helpers$1.isFinite(target)) {
                                horizontal = scale.isHorizontal();
                                return { x: horizontal ? target : null, y: horizontal ? null : target };
                            }
                        }
                        return null;
                    }
                    function computeCircularBoundary(source) {
                        var scale = source.el._scale;
                        var options = scale.options;
                        var length = scale.chart.data.labels.length;
                        var fill = source.fill;
                        var target = [];
                        var start, end, center, i, point;
                        if (!length) {
                            return null;
                        }
                        start = options.ticks.reverse ? scale.max : scale.min;
                        end = options.ticks.reverse ? scale.min : scale.max;
                        center = scale.getPointPositionForValue(0, start);
                        for (i = 0; i < length; ++i) {
                            point = fill === "start" || fill === "end" ? scale.getPointPositionForValue(i, fill === "start" ? start : end) : scale.getBasePosition(i);
                            if (options.gridLines.circular) {
                                point.cx = center.x;
                                point.cy = center.y;
                                point.angle = scale.getIndexAngle(i) - Math.PI / 2;
                            }
                            target.push(point);
                        }
                        return target;
                    }
                    function computeBoundary(source) {
                        var scale = source.el._scale || {};
                        if (scale.getPointPositionForValue) {
                            return computeCircularBoundary(source);
                        }
                        return computeLinearBoundary(source);
                    }
                    function resolveTarget(sources, index, propagate) {
                        var source = sources[index];
                        var fill = source.fill;
                        var visited = [index];
                        var target;
                        if (!propagate) {
                            return fill;
                        }
                        while (fill !== false && visited.indexOf(fill) === -1) {
                            if (!isFinite(fill)) {
                                return fill;
                            }
                            target = sources[fill];
                            if (!target) {
                                return false;
                            }
                            if (target.visible) {
                                return fill;
                            }
                            visited.push(fill);
                            fill = target.fill;
                        }
                        return false;
                    }
                    function createMapper(source) {
                        var fill = source.fill;
                        var type = "dataset";
                        if (fill === false) {
                            return null;
                        }
                        if (!isFinite(fill)) {
                            type = "boundary";
                        }
                        return mappers[type](source);
                    }
                    function isDrawable(point) {
                        return point && !point.skip;
                    }
                    function drawArea(ctx, curve0, curve1, len0, len1) {
                        var i, cx, cy, r;
                        if (!len0 || !len1) {
                            return;
                        }
                        ctx.moveTo(curve0[0].x, curve0[0].y);
                        for (i = 1; i < len0; ++i) {
                            helpers$1.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
                        }
                        if (curve1[0].angle !== undefined) {
                            cx = curve1[0].cx;
                            cy = curve1[0].cy;
                            r = Math.sqrt(Math.pow(curve1[0].x - cx, 2) + Math.pow(curve1[0].y - cy, 2));
                            for (i = len1 - 1; i > 0; --i) {
                                ctx.arc(cx, cy, r, curve1[i].angle, curve1[i - 1].angle, true);
                            }
                            return;
                        }
                        ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);
                        for (i = len1 - 1; i > 0; --i) {
                            helpers$1.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
                        }
                    }
                    function doFill(ctx, points, mapper, view, color, loop) {
                        var count = points.length;
                        var span = view.spanGaps;
                        var curve0 = [];
                        var curve1 = [];
                        var len0 = 0;
                        var len1 = 0;
                        var i, ilen, index, p0, p1, d0, d1, loopOffset;
                        ctx.beginPath();
                        for (i = 0, ilen = count; i < ilen; ++i) {
                            index = i % count;
                            p0 = points[index]._view;
                            p1 = mapper(p0, index, view);
                            d0 = isDrawable(p0);
                            d1 = isDrawable(p1);
                            if (loop && loopOffset === undefined && d0) {
                                loopOffset = i + 1;
                                ilen = count + loopOffset;
                            }
                            if (d0 && d1) {
                                len0 = curve0.push(p0);
                                len1 = curve1.push(p1);
                            } else if (len0 && len1) {
                                if (!span) {
                                    drawArea(ctx, curve0, curve1, len0, len1);
                                    len0 = len1 = 0;
                                    curve0 = [];
                                    curve1 = [];
                                } else {
                                    if (d0) {
                                        curve0.push(p0);
                                    }
                                    if (d1) {
                                        curve1.push(p1);
                                    }
                                }
                            }
                        }
                        drawArea(ctx, curve0, curve1, len0, len1);
                        ctx.closePath();
                        ctx.fillStyle = color;
                        ctx.fill();
                    }
                    var plugin_filler = {
                        id: "filler",
                        afterDatasetsUpdate: function (chart, options) {
                            var count = (chart.data.datasets || []).length;
                            var propagate = options.propagate;
                            var sources = [];
                            var meta, i, el, source;
                            for (i = 0; i < count; ++i) {
                                meta = chart.getDatasetMeta(i);
                                el = meta.dataset;
                                source = null;
                                if (el && el._model && el instanceof elements.Line) {
                                    source = { visible: chart.isDatasetVisible(i), fill: decodeFill(el, i, count), chart: chart, el: el };
                                }
                                meta.$filler = source;
                                sources.push(source);
                            }
                            for (i = 0; i < count; ++i) {
                                source = sources[i];
                                if (!source) {
                                    continue;
                                }
                                source.fill = resolveTarget(sources, i, propagate);
                                source.boundary = computeBoundary(source);
                                source.mapper = createMapper(source);
                            }
                        },
                        beforeDatasetsDraw: function (chart) {
                            var metasets = chart._getSortedVisibleDatasetMetas();
                            var ctx = chart.ctx;
                            var meta, i, el, view, points, mapper, color;
                            for (i = metasets.length - 1; i >= 0; --i) {
                                meta = metasets[i].$filler;
                                if (!meta || !meta.visible) {
                                    continue;
                                }
                                el = meta.el;
                                view = el._view;
                                points = el._children || [];
                                mapper = meta.mapper;
                                color = view.backgroundColor || core_defaults.global.defaultColor;
                                if (mapper && color && points.length) {
                                    helpers$1.canvas.clipArea(ctx, chart.chartArea);
                                    doFill(ctx, points, mapper, view, color, el._loop);
                                    helpers$1.canvas.unclipArea(ctx);
                                }
                            }
                        },
                    };
                    var getRtlHelper$1 = helpers$1.rtl.getRtlAdapter;
                    var noop$1 = helpers$1.noop;
                    var valueOrDefault$e = helpers$1.valueOrDefault;
                    core_defaults._set("global", {
                        legend: {
                            display: true,
                            position: "top",
                            align: "center",
                            fullWidth: true,
                            reverse: false,
                            weight: 1e3,
                            onClick: function (e, legendItem) {
                                var index = legendItem.datasetIndex;
                                var ci = this.chart;
                                var meta = ci.getDatasetMeta(index);
                                meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;
                                ci.update();
                            },
                            onHover: null,
                            onLeave: null,
                            labels: {
                                boxWidth: 40,
                                padding: 10,
                                generateLabels: function (chart) {
                                    var datasets = chart.data.datasets;
                                    var options = chart.options.legend || {};
                                    var usePointStyle = options.labels && options.labels.usePointStyle;
                                    return chart._getSortedDatasetMetas().map(function (meta) {
                                        var style = meta.controller.getStyle(usePointStyle ? 0 : undefined);
                                        return {
                                            text: datasets[meta.index].label,
                                            fillStyle: style.backgroundColor,
                                            hidden: !chart.isDatasetVisible(meta.index),
                                            lineCap: style.borderCapStyle,
                                            lineDash: style.borderDash,
                                            lineDashOffset: style.borderDashOffset,
                                            lineJoin: style.borderJoinStyle,
                                            lineWidth: style.borderWidth,
                                            strokeStyle: style.borderColor,
                                            pointStyle: style.pointStyle,
                                            rotation: style.rotation,
                                            datasetIndex: meta.index,
                                        };
                                    }, this);
                                },
                            },
                        },
                        legendCallback: function (chart) {
                            var list = document.createElement("ul");
                            var datasets = chart.data.datasets;
                            var i, ilen, listItem, listItemSpan;
                            list.setAttribute("class", chart.id + "-legend");
                            for (i = 0, ilen = datasets.length; i < ilen; i++) {
                                listItem = list.appendChild(document.createElement("li"));
                                listItemSpan = listItem.appendChild(document.createElement("span"));
                                listItemSpan.style.backgroundColor = datasets[i].backgroundColor;
                                if (datasets[i].label) {
                                    listItem.appendChild(document.createTextNode(datasets[i].label));
                                }
                            }
                            return list.outerHTML;
                        },
                    });
                    function getBoxWidth(labelOpts, fontSize) {
                        return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ? fontSize : labelOpts.boxWidth;
                    }
                    var Legend = core_element.extend({
                        initialize: function (config) {
                            var me = this;
                            helpers$1.extend(me, config);
                            me.legendHitBoxes = [];
                            me._hoveredItem = null;
                            me.doughnutMode = false;
                        },
                        beforeUpdate: noop$1,
                        update: function (maxWidth, maxHeight, margins) {
                            var me = this;
                            me.beforeUpdate();
                            me.maxWidth = maxWidth;
                            me.maxHeight = maxHeight;
                            me.margins = margins;
                            me.beforeSetDimensions();
                            me.setDimensions();
                            me.afterSetDimensions();
                            me.beforeBuildLabels();
                            me.buildLabels();
                            me.afterBuildLabels();
                            me.beforeFit();
                            me.fit();
                            me.afterFit();
                            me.afterUpdate();
                            return me.minSize;
                        },
                        afterUpdate: noop$1,
                        beforeSetDimensions: noop$1,
                        setDimensions: function () {
                            var me = this;
                            if (me.isHorizontal()) {
                                me.width = me.maxWidth;
                                me.left = 0;
                                me.right = me.width;
                            } else {
                                me.height = me.maxHeight;
                                me.top = 0;
                                me.bottom = me.height;
                            }
                            me.paddingLeft = 0;
                            me.paddingTop = 0;
                            me.paddingRight = 0;
                            me.paddingBottom = 0;
                            me.minSize = { width: 0, height: 0 };
                        },
                        afterSetDimensions: noop$1,
                        beforeBuildLabels: noop$1,
                        buildLabels: function () {
                            var me = this;
                            var labelOpts = me.options.labels || {};
                            var legendItems = helpers$1.callback(labelOpts.generateLabels, [me.chart], me) || [];
                            if (labelOpts.filter) {
                                legendItems = legendItems.filter(function (item) {
                                    return labelOpts.filter(item, me.chart.data);
                                });
                            }
                            if (me.options.reverse) {
                                legendItems.reverse();
                            }
                            me.legendItems = legendItems;
                        },
                        afterBuildLabels: noop$1,
                        beforeFit: noop$1,
                        fit: function () {
                            var me = this;
                            var opts = me.options;
                            var labelOpts = opts.labels;
                            var display = opts.display;
                            var ctx = me.ctx;
                            var labelFont = helpers$1.options._parseFont(labelOpts);
                            var fontSize = labelFont.size;
                            var hitboxes = (me.legendHitBoxes = []);
                            var minSize = me.minSize;
                            var isHorizontal = me.isHorizontal();
                            if (isHorizontal) {
                                minSize.width = me.maxWidth;
                                minSize.height = display ? 10 : 0;
                            } else {
                                minSize.width = display ? 10 : 0;
                                minSize.height = me.maxHeight;
                            }
                            if (!display) {
                                me.width = minSize.width = me.height = minSize.height = 0;
                                return;
                            }
                            ctx.font = labelFont.string;
                            if (isHorizontal) {
                                var lineWidths = (me.lineWidths = [0]);
                                var totalHeight = 0;
                                ctx.textAlign = "left";
                                ctx.textBaseline = "middle";
                                helpers$1.each(me.legendItems, function (legendItem, i) {
                                    var boxWidth = getBoxWidth(labelOpts, fontSize);
                                    var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
                                    if (i === 0 || lineWidths[lineWidths.length - 1] + width + 2 * labelOpts.padding > minSize.width) {
                                        totalHeight += fontSize + labelOpts.padding;
                                        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
                                    }
                                    hitboxes[i] = { left: 0, top: 0, width: width, height: fontSize };
                                    lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
                                });
                                minSize.height += totalHeight;
                            } else {
                                var vPadding = labelOpts.padding;
                                var columnWidths = (me.columnWidths = []);
                                var columnHeights = (me.columnHeights = []);
                                var totalWidth = labelOpts.padding;
                                var currentColWidth = 0;
                                var currentColHeight = 0;
                                helpers$1.each(me.legendItems, function (legendItem, i) {
                                    var boxWidth = getBoxWidth(labelOpts, fontSize);
                                    var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
                                    if (i > 0 && currentColHeight + fontSize + 2 * vPadding > minSize.height) {
                                        totalWidth += currentColWidth + labelOpts.padding;
                                        columnWidths.push(currentColWidth);
                                        columnHeights.push(currentColHeight);
                                        currentColWidth = 0;
                                        currentColHeight = 0;
                                    }
                                    currentColWidth = Math.max(currentColWidth, itemWidth);
                                    currentColHeight += fontSize + vPadding;
                                    hitboxes[i] = { left: 0, top: 0, width: itemWidth, height: fontSize };
                                });
                                totalWidth += currentColWidth;
                                columnWidths.push(currentColWidth);
                                columnHeights.push(currentColHeight);
                                minSize.width += totalWidth;
                            }
                            me.width = minSize.width;
                            me.height = minSize.height;
                        },
                        afterFit: noop$1,
                        isHorizontal: function () {
                            return this.options.position === "top" || this.options.position === "bottom";
                        },
                        draw: function () {
                            var me = this;
                            var opts = me.options;
                            var labelOpts = opts.labels;
                            var globalDefaults = core_defaults.global;
                            var defaultColor = globalDefaults.defaultColor;
                            var lineDefault = globalDefaults.elements.line;
                            var legendHeight = me.height;
                            var columnHeights = me.columnHeights;
                            var legendWidth = me.width;
                            var lineWidths = me.lineWidths;
                            if (!opts.display) {
                                return;
                            }
                            var rtlHelper = getRtlHelper$1(opts.rtl, me.left, me.minSize.width);
                            var ctx = me.ctx;
                            var fontColor = valueOrDefault$e(labelOpts.fontColor, globalDefaults.defaultFontColor);
                            var labelFont = helpers$1.options._parseFont(labelOpts);
                            var fontSize = labelFont.size;
                            var cursor;
                            ctx.textAlign = rtlHelper.textAlign("left");
                            ctx.textBaseline = "middle";
                            ctx.lineWidth = 0.5;
                            ctx.strokeStyle = fontColor;
                            ctx.fillStyle = fontColor;
                            ctx.font = labelFont.string;
                            var boxWidth = getBoxWidth(labelOpts, fontSize);
                            var hitboxes = me.legendHitBoxes;
                            var drawLegendBox = function (x, y, legendItem) {
                                if (isNaN(boxWidth) || boxWidth <= 0) {
                                    return;
                                }
                                ctx.save();
                                var lineWidth = valueOrDefault$e(legendItem.lineWidth, lineDefault.borderWidth);
                                ctx.fillStyle = valueOrDefault$e(legendItem.fillStyle, defaultColor);
                                ctx.lineCap = valueOrDefault$e(legendItem.lineCap, lineDefault.borderCapStyle);
                                ctx.lineDashOffset = valueOrDefault$e(legendItem.lineDashOffset, lineDefault.borderDashOffset);
                                ctx.lineJoin = valueOrDefault$e(legendItem.lineJoin, lineDefault.borderJoinStyle);
                                ctx.lineWidth = lineWidth;
                                ctx.strokeStyle = valueOrDefault$e(legendItem.strokeStyle, defaultColor);
                                if (ctx.setLineDash) {
                                    ctx.setLineDash(valueOrDefault$e(legendItem.lineDash, lineDefault.borderDash));
                                }
                                if (labelOpts && labelOpts.usePointStyle) {
                                    var radius = (boxWidth * Math.SQRT2) / 2;
                                    var centerX = rtlHelper.xPlus(x, boxWidth / 2);
                                    var centerY = y + fontSize / 2;
                                    helpers$1.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY, legendItem.rotation);
                                } else {
                                    ctx.fillRect(rtlHelper.leftForLtr(x, boxWidth), y, boxWidth, fontSize);
                                    if (lineWidth !== 0) {
                                        ctx.strokeRect(rtlHelper.leftForLtr(x, boxWidth), y, boxWidth, fontSize);
                                    }
                                }
                                ctx.restore();
                            };
                            var fillText = function (x, y, legendItem, textWidth) {
                                var halfFontSize = fontSize / 2;
                                var xLeft = rtlHelper.xPlus(x, boxWidth + halfFontSize);
                                var yMiddle = y + halfFontSize;
                                ctx.fillText(legendItem.text, xLeft, yMiddle);
                                if (legendItem.hidden) {
                                    ctx.beginPath();
                                    ctx.lineWidth = 2;
                                    ctx.moveTo(xLeft, yMiddle);
                                    ctx.lineTo(rtlHelper.xPlus(xLeft, textWidth), yMiddle);
                                    ctx.stroke();
                                }
                            };
                            var alignmentOffset = function (dimension, blockSize) {
                                switch (opts.align) {
                                    case "start":
                                        return labelOpts.padding;
                                    case "end":
                                        return dimension - blockSize;
                                    default:
                                        return (dimension - blockSize + labelOpts.padding) / 2;
                                }
                            };
                            var isHorizontal = me.isHorizontal();
                            if (isHorizontal) {
                                cursor = { x: me.left + alignmentOffset(legendWidth, lineWidths[0]), y: me.top + labelOpts.padding, line: 0 };
                            } else {
                                cursor = { x: me.left + labelOpts.padding, y: me.top + alignmentOffset(legendHeight, columnHeights[0]), line: 0 };
                            }
                            helpers$1.rtl.overrideTextDirection(me.ctx, opts.textDirection);
                            var itemHeight = fontSize + labelOpts.padding;
                            helpers$1.each(me.legendItems, function (legendItem, i) {
                                var textWidth = ctx.measureText(legendItem.text).width;
                                var width = boxWidth + fontSize / 2 + textWidth;
                                var x = cursor.x;
                                var y = cursor.y;
                                rtlHelper.setWidth(me.minSize.width);
                                if (isHorizontal) {
                                    if (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {
                                        y = cursor.y += itemHeight;
                                        cursor.line++;
                                        x = cursor.x = me.left + alignmentOffset(legendWidth, lineWidths[cursor.line]);
                                    }
                                } else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {
                                    x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
                                    cursor.line++;
                                    y = cursor.y = me.top + alignmentOffset(legendHeight, columnHeights[cursor.line]);
                                }
                                var realX = rtlHelper.x(x);
                                drawLegendBox(realX, y, legendItem);
                                hitboxes[i].left = rtlHelper.leftForLtr(realX, hitboxes[i].width);
                                hitboxes[i].top = y;
                                fillText(realX, y, legendItem, textWidth);
                                if (isHorizontal) {
                                    cursor.x += width + labelOpts.padding;
                                } else {
                                    cursor.y += itemHeight;
                                }
                            });
                            helpers$1.rtl.restoreTextDirection(me.ctx, opts.textDirection);
                        },
                        _getLegendItemAt: function (x, y) {
                            var me = this;
                            var i, hitBox, lh;
                            if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
                                lh = me.legendHitBoxes;
                                for (i = 0; i < lh.length; ++i) {
                                    hitBox = lh[i];
                                    if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
                                        return me.legendItems[i];
                                    }
                                }
                            }
                            return null;
                        },
                        handleEvent: function (e) {
                            var me = this;
                            var opts = me.options;
                            var type = e.type === "mouseup" ? "click" : e.type;
                            var hoveredItem;
                            if (type === "mousemove") {
                                if (!opts.onHover && !opts.onLeave) {
                                    return;
                                }
                            } else if (type === "click") {
                                if (!opts.onClick) {
                                    return;
                                }
                            } else {
                                return;
                            }
                            hoveredItem = me._getLegendItemAt(e.x, e.y);
                            if (type === "click") {
                                if (hoveredItem && opts.onClick) {
                                    opts.onClick.call(me, e.native, hoveredItem);
                                }
                            } else {
                                if (opts.onLeave && hoveredItem !== me._hoveredItem) {
                                    if (me._hoveredItem) {
                                        opts.onLeave.call(me, e.native, me._hoveredItem);
                                    }
                                    me._hoveredItem = hoveredItem;
                                }
                                if (opts.onHover && hoveredItem) {
                                    opts.onHover.call(me, e.native, hoveredItem);
                                }
                            }
                        },
                    });
                    function createNewLegendAndAttach(chart, legendOpts) {
                        var legend = new Legend({ ctx: chart.ctx, options: legendOpts, chart: chart });
                        core_layouts.configure(chart, legend, legendOpts);
                        core_layouts.addBox(chart, legend);
                        chart.legend = legend;
                    }
                    var plugin_legend = {
                        id: "legend",
                        _element: Legend,
                        beforeInit: function (chart) {
                            var legendOpts = chart.options.legend;
                            if (legendOpts) {
                                createNewLegendAndAttach(chart, legendOpts);
                            }
                        },
                        beforeUpdate: function (chart) {
                            var legendOpts = chart.options.legend;
                            var legend = chart.legend;
                            if (legendOpts) {
                                helpers$1.mergeIf(legendOpts, core_defaults.global.legend);
                                if (legend) {
                                    core_layouts.configure(chart, legend, legendOpts);
                                    legend.options = legendOpts;
                                } else {
                                    createNewLegendAndAttach(chart, legendOpts);
                                }
                            } else if (legend) {
                                core_layouts.removeBox(chart, legend);
                                delete chart.legend;
                            }
                        },
                        afterEvent: function (chart, e) {
                            var legend = chart.legend;
                            if (legend) {
                                legend.handleEvent(e);
                            }
                        },
                    };
                    var noop$2 = helpers$1.noop;
                    core_defaults._set("global", { title: { display: false, fontStyle: "bold", fullWidth: true, padding: 10, position: "top", text: "", weight: 2e3 } });
                    var Title = core_element.extend({
                        initialize: function (config) {
                            var me = this;
                            helpers$1.extend(me, config);
                            me.legendHitBoxes = [];
                        },
                        beforeUpdate: noop$2,
                        update: function (maxWidth, maxHeight, margins) {
                            var me = this;
                            me.beforeUpdate();
                            me.maxWidth = maxWidth;
                            me.maxHeight = maxHeight;
                            me.margins = margins;
                            me.beforeSetDimensions();
                            me.setDimensions();
                            me.afterSetDimensions();
                            me.beforeBuildLabels();
                            me.buildLabels();
                            me.afterBuildLabels();
                            me.beforeFit();
                            me.fit();
                            me.afterFit();
                            me.afterUpdate();
                            return me.minSize;
                        },
                        afterUpdate: noop$2,
                        beforeSetDimensions: noop$2,
                        setDimensions: function () {
                            var me = this;
                            if (me.isHorizontal()) {
                                me.width = me.maxWidth;
                                me.left = 0;
                                me.right = me.width;
                            } else {
                                me.height = me.maxHeight;
                                me.top = 0;
                                me.bottom = me.height;
                            }
                            me.paddingLeft = 0;
                            me.paddingTop = 0;
                            me.paddingRight = 0;
                            me.paddingBottom = 0;
                            me.minSize = { width: 0, height: 0 };
                        },
                        afterSetDimensions: noop$2,
                        beforeBuildLabels: noop$2,
                        buildLabels: noop$2,
                        afterBuildLabels: noop$2,
                        beforeFit: noop$2,
                        fit: function () {
                            var me = this;
                            var opts = me.options;
                            var minSize = (me.minSize = {});
                            var isHorizontal = me.isHorizontal();
                            var lineCount, textSize;
                            if (!opts.display) {
                                me.width = minSize.width = me.height = minSize.height = 0;
                                return;
                            }
                            lineCount = helpers$1.isArray(opts.text) ? opts.text.length : 1;
                            textSize = lineCount * helpers$1.options._parseFont(opts).lineHeight + opts.padding * 2;
                            me.width = minSize.width = isHorizontal ? me.maxWidth : textSize;
                            me.height = minSize.height = isHorizontal ? textSize : me.maxHeight;
                        },
                        afterFit: noop$2,
                        isHorizontal: function () {
                            var pos = this.options.position;
                            return pos === "top" || pos === "bottom";
                        },
                        draw: function () {
                            var me = this;
                            var ctx = me.ctx;
                            var opts = me.options;
                            if (!opts.display) {
                                return;
                            }
                            var fontOpts = helpers$1.options._parseFont(opts);
                            var lineHeight = fontOpts.lineHeight;
                            var offset = lineHeight / 2 + opts.padding;
                            var rotation = 0;
                            var top = me.top;
                            var left = me.left;
                            var bottom = me.bottom;
                            var right = me.right;
                            var maxWidth, titleX, titleY;
                            ctx.fillStyle = helpers$1.valueOrDefault(opts.fontColor, core_defaults.global.defaultFontColor);
                            ctx.font = fontOpts.string;
                            if (me.isHorizontal()) {
                                titleX = left + (right - left) / 2;
                                titleY = top + offset;
                                maxWidth = right - left;
                            } else {
                                titleX = opts.position === "left" ? left + offset : right - offset;
                                titleY = top + (bottom - top) / 2;
                                maxWidth = bottom - top;
                                rotation = Math.PI * (opts.position === "left" ? -0.5 : 0.5);
                            }
                            ctx.save();
                            ctx.translate(titleX, titleY);
                            ctx.rotate(rotation);
                            ctx.textAlign = "center";
                            ctx.textBaseline = "middle";
                            var text = opts.text;
                            if (helpers$1.isArray(text)) {
                                var y = 0;
                                for (var i = 0; i < text.length; ++i) {
                                    ctx.fillText(text[i], 0, y, maxWidth);
                                    y += lineHeight;
                                }
                            } else {
                                ctx.fillText(text, 0, 0, maxWidth);
                            }
                            ctx.restore();
                        },
                    });
                    function createNewTitleBlockAndAttach(chart, titleOpts) {
                        var title = new Title({ ctx: chart.ctx, options: titleOpts, chart: chart });
                        core_layouts.configure(chart, title, titleOpts);
                        core_layouts.addBox(chart, title);
                        chart.titleBlock = title;
                    }
                    var plugin_title = {
                        id: "title",
                        _element: Title,
                        beforeInit: function (chart) {
                            var titleOpts = chart.options.title;
                            if (titleOpts) {
                                createNewTitleBlockAndAttach(chart, titleOpts);
                            }
                        },
                        beforeUpdate: function (chart) {
                            var titleOpts = chart.options.title;
                            var titleBlock = chart.titleBlock;
                            if (titleOpts) {
                                helpers$1.mergeIf(titleOpts, core_defaults.global.title);
                                if (titleBlock) {
                                    core_layouts.configure(chart, titleBlock, titleOpts);
                                    titleBlock.options = titleOpts;
                                } else {
                                    createNewTitleBlockAndAttach(chart, titleOpts);
                                }
                            } else if (titleBlock) {
                                core_layouts.removeBox(chart, titleBlock);
                                delete chart.titleBlock;
                            }
                        },
                    };
                    var plugins = {};
                    var filler = plugin_filler;
                    var legend = plugin_legend;
                    var title = plugin_title;
                    plugins.filler = filler;
                    plugins.legend = legend;
                    plugins.title = title;
                    core_controller.helpers = helpers$1;
                    core_helpers();
                    core_controller._adapters = core_adapters;
                    core_controller.Animation = core_animation;
                    core_controller.animationService = core_animations;
                    core_controller.controllers = controllers;
                    core_controller.DatasetController = core_datasetController;
                    core_controller.defaults = core_defaults;
                    core_controller.Element = core_element;
                    core_controller.elements = elements;
                    core_controller.Interaction = core_interaction;
                    core_controller.layouts = core_layouts;
                    core_controller.platform = platform;
                    core_controller.plugins = core_plugins;
                    core_controller.Scale = core_scale;
                    core_controller.scaleService = core_scaleService;
                    core_controller.Ticks = core_ticks;
                    core_controller.Tooltip = core_tooltip;
                    core_controller.helpers.each(scales, function (scale, type) {
                        core_controller.scaleService.registerScaleType(type, scale, scale._defaults);
                    });
                    for (var k in plugins) {
                        if (plugins.hasOwnProperty(k)) {
                            core_controller.plugins.register(plugins[k]);
                        }
                    }
                    core_controller.platform.initialize();
                    var src = core_controller;
                    if (typeof window !== "undefined") {
                        window.Chart = core_controller;
                    }
                    core_controller.Chart = core_controller;
                    core_controller.Legend = plugins.legend._element;
                    core_controller.Title = plugins.title._element;
                    core_controller.pluginService = core_controller.plugins;
                    core_controller.PluginBase = core_controller.Element.extend({});
                    core_controller.canvasHelpers = core_controller.helpers.canvas;
                    core_controller.layoutService = core_controller.layouts;
                    core_controller.LinearScaleBase = scale_linearbase;
                    core_controller.helpers.each(["Bar", "Bubble", "Doughnut", "Line", "PolarArea", "Radar", "Scatter"], function (klass) {
                        core_controller[klass] = function (ctx, cfg) {
                            return new core_controller(ctx, core_controller.helpers.merge(cfg || {}, { type: klass.charAt(0).toLowerCase() + klass.slice(1) }));
                        };
                    });
                    return src;
                });
            },
            "./node_modules/jsonpack/main.js": function (module, exports, __webpack_require__) {
                var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
                (function (define) {
                    !((__WEBPACK_AMD_DEFINE_ARRAY__ = []),
                    (__WEBPACK_AMD_DEFINE_RESULT__ = function () {
                        var TOKEN_TRUE = -1;
                        var TOKEN_FALSE = -2;
                        var TOKEN_NULL = -3;
                        var TOKEN_EMPTY_STRING = -4;
                        var TOKEN_UNDEFINED = -5;
                        var pack = function (json, options) {
                            options = options || {};
                            var verbose = options.verbose || false;
                            verbose && console.log("Normalize the JSON Object");
                            json = typeof json === "string" ? this.JSON.parse(json) : json;
                            verbose && console.log("Creating a empty dictionary");
                            var dictionary = { strings: [], integers: [], floats: [] };
                            verbose && console.log("Creating the AST");
                            var ast = (function recursiveAstBuilder(item) {
                                verbose && console.log("Calling recursiveAstBuilder with " + this.JSON.stringify(item));
                                var type = typeof item;
                                if (item === null) {
                                    return { type: "null", index: TOKEN_NULL };
                                }
                                if (typeof item === "undefined") {
                                    return { type: "undefined", index: TOKEN_UNDEFINED };
                                }
                                if (item instanceof Array) {
                                    var ast = ["@"];
                                    for (var i in item) {
                                        if (!item.hasOwnProperty(i)) continue;
                                        ast.push(recursiveAstBuilder(item[i]));
                                    }
                                    return ast;
                                }
                                if (type === "object") {
                                    var ast = ["$"];
                                    for (var key in item) {
                                        if (!item.hasOwnProperty(key)) continue;
                                        ast.push(recursiveAstBuilder(key));
                                        ast.push(recursiveAstBuilder(item[key]));
                                    }
                                    return ast;
                                }
                                if (item === "") {
                                    return { type: "empty", index: TOKEN_EMPTY_STRING };
                                }
                                if (type === "string") {
                                    var index = _indexOf.call(dictionary.strings, item);
                                    if (index == -1) {
                                        dictionary.strings.push(_encode(item));
                                        index = dictionary.strings.length - 1;
                                    }
                                    return { type: "strings", index: index };
                                }
                                if (type === "number" && item % 1 === 0) {
                                    var index = _indexOf.call(dictionary.integers, item);
                                    if (index == -1) {
                                        dictionary.integers.push(_base10To36(item));
                                        index = dictionary.integers.length - 1;
                                    }
                                    return { type: "integers", index: index };
                                }
                                if (type === "number") {
                                    var index = _indexOf.call(dictionary.floats, item);
                                    if (index == -1) {
                                        dictionary.floats.push(item);
                                        index = dictionary.floats.length - 1;
                                    }
                                    return { type: "floats", index: index };
                                }
                                if (type === "boolean") {
                                    return { type: "boolean", index: item ? TOKEN_TRUE : TOKEN_FALSE };
                                }
                                throw new Error("Unexpected argument of type " + typeof item);
                            })(json);
                            var stringLength = dictionary.strings.length;
                            var integerLength = dictionary.integers.length;
                            var floatLength = dictionary.floats.length;
                            verbose && console.log("Parsing the dictionary");
                            var packed = dictionary.strings.join("|");
                            packed += "^" + dictionary.integers.join("|");
                            packed += "^" + dictionary.floats.join("|");
                            verbose && console.log("Parsing the structure");
                            packed +=
                                "^" +
                                (function recursiveParser(item) {
                                    verbose && console.log("Calling a recursiveParser with " + this.JSON.stringify(item));
                                    if (item instanceof Array) {
                                        var packed = item.shift();
                                        for (var i in item) {
                                            if (!item.hasOwnProperty(i)) continue;
                                            packed += recursiveParser(item[i]) + "|";
                                        }
                                        return (packed[packed.length - 1] === "|" ? packed.slice(0, -1) : packed) + "]";
                                    }
                                    var type = item.type,
                                        index = item.index;
                                    if (type === "strings") {
                                        return _base10To36(index);
                                    }
                                    if (type === "integers") {
                                        return _base10To36(stringLength + index);
                                    }
                                    if (type === "floats") {
                                        return _base10To36(stringLength + integerLength + index);
                                    }
                                    if (type === "boolean") {
                                        return item.index;
                                    }
                                    if (type === "null") {
                                        return TOKEN_NULL;
                                    }
                                    if (type === "undefined") {
                                        return TOKEN_UNDEFINED;
                                    }
                                    if (type === "empty") {
                                        return TOKEN_EMPTY_STRING;
                                    }
                                    throw new TypeError("The item is alien!");
                                })(ast);
                            verbose && console.log("Ending parser");
                            if (options.debug) return { dictionary: dictionary, ast: ast, packed: packed };
                            return packed;
                        };
                        var unpack = function (packed, options) {
                            options = options || {};
                            var rawBuffers = packed.split("^");
                            options.verbose && console.log("Building dictionary");
                            var dictionary = [];
                            var buffer = rawBuffers[0];
                            if (buffer !== "") {
                                buffer = buffer.split("|");
                                options.verbose && console.log("Parse the strings dictionary");
                                for (var i = 0, n = buffer.length; i < n; i++) {
                                    dictionary.push(_decode(buffer[i]));
                                }
                            }
                            buffer = rawBuffers[1];
                            if (buffer !== "") {
                                buffer = buffer.split("|");
                                options.verbose && console.log("Parse the integers dictionary");
                                for (var i = 0, n = buffer.length; i < n; i++) {
                                    dictionary.push(_base36To10(buffer[i]));
                                }
                            }
                            buffer = rawBuffers[2];
                            if (buffer !== "") {
                                buffer = buffer.split("|");
                                options.verbose && console.log("Parse the floats dictionary");
                                for (var i = 0, n = buffer.length; i < n; i++) {
                                    dictionary.push(parseFloat(buffer[i]));
                                }
                            }
                            buffer = null;
                            options.verbose && console.log("Tokenizing the structure");
                            var number36 = "";
                            var tokens = [];
                            var len = rawBuffers[3].length;
                            for (var i = 0; i < len; i++) {
                                var symbol = rawBuffers[3].charAt(i);
                                if (symbol === "|" || symbol === "$" || symbol === "@" || symbol === "]") {
                                    if (number36) {
                                        tokens.push(_base36To10(number36));
                                        number36 = "";
                                    }
                                    symbol !== "|" && tokens.push(symbol);
                                } else {
                                    number36 += symbol;
                                }
                            }
                            var tokensLength = tokens.length;
                            var tokensIndex = 0;
                            options.verbose && console.log("Starting recursive parser");
                            return (function recursiveUnpackerParser() {
                                var type = tokens[tokensIndex++];
                                options.verbose && console.log("Reading collection type " + (type === "$" ? "object" : "Array"));
                                if (type === "@") {
                                    var node = [];
                                    for (; tokensIndex < tokensLength; tokensIndex++) {
                                        var value = tokens[tokensIndex];
                                        options.verbose && console.log("Read " + value + " symbol");
                                        if (value === "]") return node;
                                        if (value === "@" || value === "$") {
                                            node.push(recursiveUnpackerParser());
                                        } else {
                                            switch (value) {
                                                case TOKEN_TRUE:
                                                    node.push(true);
                                                    break;
                                                case TOKEN_FALSE:
                                                    node.push(false);
                                                    break;
                                                case TOKEN_NULL:
                                                    node.push(null);
                                                    break;
                                                case TOKEN_UNDEFINED:
                                                    node.push(undefined);
                                                    break;
                                                case TOKEN_EMPTY_STRING:
                                                    node.push("");
                                                    break;
                                                default:
                                                    node.push(dictionary[value]);
                                            }
                                        }
                                    }
                                    options.verbose && console.log("Parsed " + this.JSON.stringify(node));
                                    return node;
                                }
                                if (type === "$") {
                                    var node = {};
                                    for (; tokensIndex < tokensLength; tokensIndex++) {
                                        var key = tokens[tokensIndex];
                                        if (key === "]") return node;
                                        if (key === TOKEN_EMPTY_STRING) key = "";
                                        else key = dictionary[key];
                                        var value = tokens[++tokensIndex];
                                        if (value === "@" || value === "$") {
                                            node[key] = recursiveUnpackerParser();
                                        } else {
                                            switch (value) {
                                                case TOKEN_TRUE:
                                                    node[key] = true;
                                                    break;
                                                case TOKEN_FALSE:
                                                    node[key] = false;
                                                    break;
                                                case TOKEN_NULL:
                                                    node[key] = null;
                                                    break;
                                                case TOKEN_UNDEFINED:
                                                    node[key] = undefined;
                                                    break;
                                                case TOKEN_EMPTY_STRING:
                                                    node[key] = "";
                                                    break;
                                                default:
                                                    node[key] = dictionary[value];
                                            }
                                        }
                                    }
                                    options.verbose && console.log("Parsed " + this.JSON.stringify(node));
                                    return node;
                                }
                                throw new TypeError("Bad token " + type + " isn't a type");
                            })();
                        };
                        var _indexOfDictionary = function (dictionary, value) {
                            var type = typeof value;
                            if (type === "boolean") return value ? TOKEN_TRUE : TOKEN_FALSE;
                            if (value === null) return TOKEN_NULL;
                            if (typeof value === "undefined") return TOKEN_UNDEFINED;
                            if (value === "") {
                                return TOKEN_EMPTY_STRING;
                            }
                            if (type === "string") {
                                value = _encode(value);
                                var index = _indexOf.call(dictionary.strings, value);
                                if (index === -1) {
                                    dictionary.strings.push(value);
                                    index = dictionary.strings.length - 1;
                                }
                            }
                            if (type !== "string" && type !== "number") {
                                throw new Error("The type is not a JSON type");
                            }
                            if (type === "string") {
                                value = _encode(value);
                            } else if (value % 1 === 0) {
                                value = _base10To36(value);
                            } else {
                            }
                            value = type === "number" ? _base10To36(value) : _encode(value);
                            var index = _indexOf.call(dictionary[type], value);
                            if (index === -1) {
                                dictionary[type].push(value);
                                index = dictionary[type].length - 1;
                            }
                            return type === "number" ? "+" + index : index;
                        };
                        var _encode = function (str) {
                            if (typeof str !== "string") return str;
                            return str.replace(/[\+ \|\^\%]/g, function (a) {
                                return { " ": "+", "+": "%2B", "|": "%7C", "^": "%5E", "%": "%25" }[a];
                            });
                        };
                        var _decode = function (str) {
                            if (typeof str !== "string") return str;
                            return str.replace(/\+|%2B|%7C|%5E|%25/g, function (a) {
                                return { "+": " ", "%2B": "+", "%7C": "|", "%5E": "^", "%25": "%" }[a];
                            });
                        };
                        var _base10To36 = function (number) {
                            return Number.prototype.toString.call(number, 36).toUpperCase();
                        };
                        var _base36To10 = function (number) {
                            return parseInt(number, 36);
                        };
                        var _indexOf =
                            Array.prototype.indexOf ||
                            function (obj, start) {
                                for (var i = start || 0, j = this.length; i < j; i++) {
                                    if (this[i] === obj) {
                                        return i;
                                    }
                                }
                                return -1;
                            };
                        return { JSON: JSON, pack: pack, unpack: unpack };
                    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                })(__webpack_require__("./node_modules/webpack/buildin/amd-define.js"));
            },
            "./node_modules/moment/locale sync recursive ^\\.\\/.*$": function (module, exports, __webpack_require__) {
                var map = {
                    "./af": "./node_modules/moment/locale/af.js",
                    "./af.js": "./node_modules/moment/locale/af.js",
                    "./ar": "./node_modules/moment/locale/ar.js",
                    "./ar-dz": "./node_modules/moment/locale/ar-dz.js",
                    "./ar-dz.js": "./node_modules/moment/locale/ar-dz.js",
                    "./ar-kw": "./node_modules/moment/locale/ar-kw.js",
                    "./ar-kw.js": "./node_modules/moment/locale/ar-kw.js",
                    "./ar-ly": "./node_modules/moment/locale/ar-ly.js",
                    "./ar-ly.js": "./node_modules/moment/locale/ar-ly.js",
                    "./ar-ma": "./node_modules/moment/locale/ar-ma.js",
                    "./ar-ma.js": "./node_modules/moment/locale/ar-ma.js",
                    "./ar-sa": "./node_modules/moment/locale/ar-sa.js",
                    "./ar-sa.js": "./node_modules/moment/locale/ar-sa.js",
                    "./ar-tn": "./node_modules/moment/locale/ar-tn.js",
                    "./ar-tn.js": "./node_modules/moment/locale/ar-tn.js",
                    "./ar.js": "./node_modules/moment/locale/ar.js",
                    "./az": "./node_modules/moment/locale/az.js",
                    "./az.js": "./node_modules/moment/locale/az.js",
                    "./be": "./node_modules/moment/locale/be.js",
                    "./be.js": "./node_modules/moment/locale/be.js",
                    "./bg": "./node_modules/moment/locale/bg.js",
                    "./bg.js": "./node_modules/moment/locale/bg.js",
                    "./bm": "./node_modules/moment/locale/bm.js",
                    "./bm.js": "./node_modules/moment/locale/bm.js",
                    "./bn": "./node_modules/moment/locale/bn.js",
                    "./bn-bd": "./node_modules/moment/locale/bn-bd.js",
                    "./bn-bd.js": "./node_modules/moment/locale/bn-bd.js",
                    "./bn.js": "./node_modules/moment/locale/bn.js",
                    "./bo": "./node_modules/moment/locale/bo.js",
                    "./bo.js": "./node_modules/moment/locale/bo.js",
                    "./br": "./node_modules/moment/locale/br.js",
                    "./br.js": "./node_modules/moment/locale/br.js",
                    "./bs": "./node_modules/moment/locale/bs.js",
                    "./bs.js": "./node_modules/moment/locale/bs.js",
                    "./ca": "./node_modules/moment/locale/ca.js",
                    "./ca.js": "./node_modules/moment/locale/ca.js",
                    "./cs": "./node_modules/moment/locale/cs.js",
                    "./cs.js": "./node_modules/moment/locale/cs.js",
                    "./cv": "./node_modules/moment/locale/cv.js",
                    "./cv.js": "./node_modules/moment/locale/cv.js",
                    "./cy": "./node_modules/moment/locale/cy.js",
                    "./cy.js": "./node_modules/moment/locale/cy.js",
                    "./da": "./node_modules/moment/locale/da.js",
                    "./da.js": "./node_modules/moment/locale/da.js",
                    "./de": "./node_modules/moment/locale/de.js",
                    "./de-at": "./node_modules/moment/locale/de-at.js",
                    "./de-at.js": "./node_modules/moment/locale/de-at.js",
                    "./de-ch": "./node_modules/moment/locale/de-ch.js",
                    "./de-ch.js": "./node_modules/moment/locale/de-ch.js",
                    "./de.js": "./node_modules/moment/locale/de.js",
                    "./dv": "./node_modules/moment/locale/dv.js",
                    "./dv.js": "./node_modules/moment/locale/dv.js",
                    "./el": "./node_modules/moment/locale/el.js",
                    "./el.js": "./node_modules/moment/locale/el.js",
                    "./en-au": "./node_modules/moment/locale/en-au.js",
                    "./en-au.js": "./node_modules/moment/locale/en-au.js",
                    "./en-ca": "./node_modules/moment/locale/en-ca.js",
                    "./en-ca.js": "./node_modules/moment/locale/en-ca.js",
                    "./en-gb": "./node_modules/moment/locale/en-gb.js",
                    "./en-gb.js": "./node_modules/moment/locale/en-gb.js",
                    "./en-ie": "./node_modules/moment/locale/en-ie.js",
                    "./en-ie.js": "./node_modules/moment/locale/en-ie.js",
                    "./en-il": "./node_modules/moment/locale/en-il.js",
                    "./en-il.js": "./node_modules/moment/locale/en-il.js",
                    "./en-in": "./node_modules/moment/locale/en-in.js",
                    "./en-in.js": "./node_modules/moment/locale/en-in.js",
                    "./en-nz": "./node_modules/moment/locale/en-nz.js",
                    "./en-nz.js": "./node_modules/moment/locale/en-nz.js",
                    "./en-sg": "./node_modules/moment/locale/en-sg.js",
                    "./en-sg.js": "./node_modules/moment/locale/en-sg.js",
                    "./eo": "./node_modules/moment/locale/eo.js",
                    "./eo.js": "./node_modules/moment/locale/eo.js",
                    "./es": "./node_modules/moment/locale/es.js",
                    "./es-do": "./node_modules/moment/locale/es-do.js",
                    "./es-do.js": "./node_modules/moment/locale/es-do.js",
                    "./es-mx": "./node_modules/moment/locale/es-mx.js",
                    "./es-mx.js": "./node_modules/moment/locale/es-mx.js",
                    "./es-us": "./node_modules/moment/locale/es-us.js",
                    "./es-us.js": "./node_modules/moment/locale/es-us.js",
                    "./es.js": "./node_modules/moment/locale/es.js",
                    "./et": "./node_modules/moment/locale/et.js",
                    "./et.js": "./node_modules/moment/locale/et.js",
                    "./eu": "./node_modules/moment/locale/eu.js",
                    "./eu.js": "./node_modules/moment/locale/eu.js",
                    "./fa": "./node_modules/moment/locale/fa.js",
                    "./fa.js": "./node_modules/moment/locale/fa.js",
                    "./fi": "./node_modules/moment/locale/fi.js",
                    "./fi.js": "./node_modules/moment/locale/fi.js",
                    "./fil": "./node_modules/moment/locale/fil.js",
                    "./fil.js": "./node_modules/moment/locale/fil.js",
                    "./fo": "./node_modules/moment/locale/fo.js",
                    "./fo.js": "./node_modules/moment/locale/fo.js",
                    "./fr": "./node_modules/moment/locale/fr.js",
                    "./fr-ca": "./node_modules/moment/locale/fr-ca.js",
                    "./fr-ca.js": "./node_modules/moment/locale/fr-ca.js",
                    "./fr-ch": "./node_modules/moment/locale/fr-ch.js",
                    "./fr-ch.js": "./node_modules/moment/locale/fr-ch.js",
                    "./fr.js": "./node_modules/moment/locale/fr.js",
                    "./fy": "./node_modules/moment/locale/fy.js",
                    "./fy.js": "./node_modules/moment/locale/fy.js",
                    "./ga": "./node_modules/moment/locale/ga.js",
                    "./ga.js": "./node_modules/moment/locale/ga.js",
                    "./gd": "./node_modules/moment/locale/gd.js",
                    "./gd.js": "./node_modules/moment/locale/gd.js",
                    "./gl": "./node_modules/moment/locale/gl.js",
                    "./gl.js": "./node_modules/moment/locale/gl.js",
                    "./gom-deva": "./node_modules/moment/locale/gom-deva.js",
                    "./gom-deva.js": "./node_modules/moment/locale/gom-deva.js",
                    "./gom-latn": "./node_modules/moment/locale/gom-latn.js",
                    "./gom-latn.js": "./node_modules/moment/locale/gom-latn.js",
                    "./gu": "./node_modules/moment/locale/gu.js",
                    "./gu.js": "./node_modules/moment/locale/gu.js",
                    "./he": "./node_modules/moment/locale/he.js",
                    "./he.js": "./node_modules/moment/locale/he.js",
                    "./hi": "./node_modules/moment/locale/hi.js",
                    "./hi.js": "./node_modules/moment/locale/hi.js",
                    "./hr": "./node_modules/moment/locale/hr.js",
                    "./hr.js": "./node_modules/moment/locale/hr.js",
                    "./hu": "./node_modules/moment/locale/hu.js",
                    "./hu.js": "./node_modules/moment/locale/hu.js",
                    "./hy-am": "./node_modules/moment/locale/hy-am.js",
                    "./hy-am.js": "./node_modules/moment/locale/hy-am.js",
                    "./id": "./node_modules/moment/locale/id.js",
                    "./id.js": "./node_modules/moment/locale/id.js",
                    "./is": "./node_modules/moment/locale/is.js",
                    "./is.js": "./node_modules/moment/locale/is.js",
                    "./it": "./node_modules/moment/locale/it.js",
                    "./it-ch": "./node_modules/moment/locale/it-ch.js",
                    "./it-ch.js": "./node_modules/moment/locale/it-ch.js",
                    "./it.js": "./node_modules/moment/locale/it.js",
                    "./ja": "./node_modules/moment/locale/ja.js",
                    "./ja.js": "./node_modules/moment/locale/ja.js",
                    "./jv": "./node_modules/moment/locale/jv.js",
                    "./jv.js": "./node_modules/moment/locale/jv.js",
                    "./ka": "./node_modules/moment/locale/ka.js",
                    "./ka.js": "./node_modules/moment/locale/ka.js",
                    "./kk": "./node_modules/moment/locale/kk.js",
                    "./kk.js": "./node_modules/moment/locale/kk.js",
                    "./km": "./node_modules/moment/locale/km.js",
                    "./km.js": "./node_modules/moment/locale/km.js",
                    "./kn": "./node_modules/moment/locale/kn.js",
                    "./kn.js": "./node_modules/moment/locale/kn.js",
                    "./ko": "./node_modules/moment/locale/ko.js",
                    "./ko.js": "./node_modules/moment/locale/ko.js",
                    "./ku": "./node_modules/moment/locale/ku.js",
                    "./ku.js": "./node_modules/moment/locale/ku.js",
                    "./ky": "./node_modules/moment/locale/ky.js",
                    "./ky.js": "./node_modules/moment/locale/ky.js",
                    "./lb": "./node_modules/moment/locale/lb.js",
                    "./lb.js": "./node_modules/moment/locale/lb.js",
                    "./lo": "./node_modules/moment/locale/lo.js",
                    "./lo.js": "./node_modules/moment/locale/lo.js",
                    "./lt": "./node_modules/moment/locale/lt.js",
                    "./lt.js": "./node_modules/moment/locale/lt.js",
                    "./lv": "./node_modules/moment/locale/lv.js",
                    "./lv.js": "./node_modules/moment/locale/lv.js",
                    "./me": "./node_modules/moment/locale/me.js",
                    "./me.js": "./node_modules/moment/locale/me.js",
                    "./mi": "./node_modules/moment/locale/mi.js",
                    "./mi.js": "./node_modules/moment/locale/mi.js",
                    "./mk": "./node_modules/moment/locale/mk.js",
                    "./mk.js": "./node_modules/moment/locale/mk.js",
                    "./ml": "./node_modules/moment/locale/ml.js",
                    "./ml.js": "./node_modules/moment/locale/ml.js",
                    "./mn": "./node_modules/moment/locale/mn.js",
                    "./mn.js": "./node_modules/moment/locale/mn.js",
                    "./mr": "./node_modules/moment/locale/mr.js",
                    "./mr.js": "./node_modules/moment/locale/mr.js",
                    "./ms": "./node_modules/moment/locale/ms.js",
                    "./ms-my": "./node_modules/moment/locale/ms-my.js",
                    "./ms-my.js": "./node_modules/moment/locale/ms-my.js",
                    "./ms.js": "./node_modules/moment/locale/ms.js",
                    "./mt": "./node_modules/moment/locale/mt.js",
                    "./mt.js": "./node_modules/moment/locale/mt.js",
                    "./my": "./node_modules/moment/locale/my.js",
                    "./my.js": "./node_modules/moment/locale/my.js",
                    "./nb": "./node_modules/moment/locale/nb.js",
                    "./nb.js": "./node_modules/moment/locale/nb.js",
                    "./ne": "./node_modules/moment/locale/ne.js",
                    "./ne.js": "./node_modules/moment/locale/ne.js",
                    "./nl": "./node_modules/moment/locale/nl.js",
                    "./nl-be": "./node_modules/moment/locale/nl-be.js",
                    "./nl-be.js": "./node_modules/moment/locale/nl-be.js",
                    "./nl.js": "./node_modules/moment/locale/nl.js",
                    "./nn": "./node_modules/moment/locale/nn.js",
                    "./nn.js": "./node_modules/moment/locale/nn.js",
                    "./oc-lnc": "./node_modules/moment/locale/oc-lnc.js",
                    "./oc-lnc.js": "./node_modules/moment/locale/oc-lnc.js",
                    "./pa-in": "./node_modules/moment/locale/pa-in.js",
                    "./pa-in.js": "./node_modules/moment/locale/pa-in.js",
                    "./pl": "./node_modules/moment/locale/pl.js",
                    "./pl.js": "./node_modules/moment/locale/pl.js",
                    "./pt": "./node_modules/moment/locale/pt.js",
                    "./pt-br": "./node_modules/moment/locale/pt-br.js",
                    "./pt-br.js": "./node_modules/moment/locale/pt-br.js",
                    "./pt.js": "./node_modules/moment/locale/pt.js",
                    "./ro": "./node_modules/moment/locale/ro.js",
                    "./ro.js": "./node_modules/moment/locale/ro.js",
                    "./ru": "./node_modules/moment/locale/ru.js",
                    "./ru.js": "./node_modules/moment/locale/ru.js",
                    "./sd": "./node_modules/moment/locale/sd.js",
                    "./sd.js": "./node_modules/moment/locale/sd.js",
                    "./se": "./node_modules/moment/locale/se.js",
                    "./se.js": "./node_modules/moment/locale/se.js",
                    "./si": "./node_modules/moment/locale/si.js",
                    "./si.js": "./node_modules/moment/locale/si.js",
                    "./sk": "./node_modules/moment/locale/sk.js",
                    "./sk.js": "./node_modules/moment/locale/sk.js",
                    "./sl": "./node_modules/moment/locale/sl.js",
                    "./sl.js": "./node_modules/moment/locale/sl.js",
                    "./sq": "./node_modules/moment/locale/sq.js",
                    "./sq.js": "./node_modules/moment/locale/sq.js",
                    "./sr": "./node_modules/moment/locale/sr.js",
                    "./sr-cyrl": "./node_modules/moment/locale/sr-cyrl.js",
                    "./sr-cyrl.js": "./node_modules/moment/locale/sr-cyrl.js",
                    "./sr.js": "./node_modules/moment/locale/sr.js",
                    "./ss": "./node_modules/moment/locale/ss.js",
                    "./ss.js": "./node_modules/moment/locale/ss.js",
                    "./sv": "./node_modules/moment/locale/sv.js",
                    "./sv.js": "./node_modules/moment/locale/sv.js",
                    "./sw": "./node_modules/moment/locale/sw.js",
                    "./sw.js": "./node_modules/moment/locale/sw.js",
                    "./ta": "./node_modules/moment/locale/ta.js",
                    "./ta.js": "./node_modules/moment/locale/ta.js",
                    "./te": "./node_modules/moment/locale/te.js",
                    "./te.js": "./node_modules/moment/locale/te.js",
                    "./tet": "./node_modules/moment/locale/tet.js",
                    "./tet.js": "./node_modules/moment/locale/tet.js",
                    "./tg": "./node_modules/moment/locale/tg.js",
                    "./tg.js": "./node_modules/moment/locale/tg.js",
                    "./th": "./node_modules/moment/locale/th.js",
                    "./th.js": "./node_modules/moment/locale/th.js",
                    "./tk": "./node_modules/moment/locale/tk.js",
                    "./tk.js": "./node_modules/moment/locale/tk.js",
                    "./tl-ph": "./node_modules/moment/locale/tl-ph.js",
                    "./tl-ph.js": "./node_modules/moment/locale/tl-ph.js",
                    "./tlh": "./node_modules/moment/locale/tlh.js",
                    "./tlh.js": "./node_modules/moment/locale/tlh.js",
                    "./tr": "./node_modules/moment/locale/tr.js",
                    "./tr.js": "./node_modules/moment/locale/tr.js",
                    "./tzl": "./node_modules/moment/locale/tzl.js",
                    "./tzl.js": "./node_modules/moment/locale/tzl.js",
                    "./tzm": "./node_modules/moment/locale/tzm.js",
                    "./tzm-latn": "./node_modules/moment/locale/tzm-latn.js",
                    "./tzm-latn.js": "./node_modules/moment/locale/tzm-latn.js",
                    "./tzm.js": "./node_modules/moment/locale/tzm.js",
                    "./ug-cn": "./node_modules/moment/locale/ug-cn.js",
                    "./ug-cn.js": "./node_modules/moment/locale/ug-cn.js",
                    "./uk": "./node_modules/moment/locale/uk.js",
                    "./uk.js": "./node_modules/moment/locale/uk.js",
                    "./ur": "./node_modules/moment/locale/ur.js",
                    "./ur.js": "./node_modules/moment/locale/ur.js",
                    "./uz": "./node_modules/moment/locale/uz.js",
                    "./uz-latn": "./node_modules/moment/locale/uz-latn.js",
                    "./uz-latn.js": "./node_modules/moment/locale/uz-latn.js",
                    "./uz.js": "./node_modules/moment/locale/uz.js",
                    "./vi": "./node_modules/moment/locale/vi.js",
                    "./vi.js": "./node_modules/moment/locale/vi.js",
                    "./x-pseudo": "./node_modules/moment/locale/x-pseudo.js",
                    "./x-pseudo.js": "./node_modules/moment/locale/x-pseudo.js",
                    "./yo": "./node_modules/moment/locale/yo.js",
                    "./yo.js": "./node_modules/moment/locale/yo.js",
                    "./zh-cn": "./node_modules/moment/locale/zh-cn.js",
                    "./zh-cn.js": "./node_modules/moment/locale/zh-cn.js",
                    "./zh-hk": "./node_modules/moment/locale/zh-hk.js",
                    "./zh-hk.js": "./node_modules/moment/locale/zh-hk.js",
                    "./zh-mo": "./node_modules/moment/locale/zh-mo.js",
                    "./zh-mo.js": "./node_modules/moment/locale/zh-mo.js",
                    "./zh-tw": "./node_modules/moment/locale/zh-tw.js",
                    "./zh-tw.js": "./node_modules/moment/locale/zh-tw.js",
                };
                function webpackContext(req) {
                    var id = webpackContextResolve(req);
                    return __webpack_require__(id);
                }
                function webpackContextResolve(req) {
                    if (!__webpack_require__.o(map, req)) {
                        var e = new Error("Cannot find module '" + req + "'");
                        e.code = "MODULE_NOT_FOUND";
                        throw e;
                    }
                    return map[req];
                }
                webpackContext.keys = function webpackContextKeys() {
                    return Object.keys(map);
                };
                webpackContext.resolve = webpackContextResolve;
                module.exports = webpackContext;
                webpackContext.id = "./node_modules/moment/locale sync recursive ^\\.\\/.*$";
            },
            "./node_modules/moment/locale/af.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var af = moment.defineLocale("af", {
                        months: "Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember".split("_"),
                        monthsShort: "Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des".split("_"),
                        weekdays: "Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag".split("_"),
                        weekdaysShort: "Son_Maa_Din_Woe_Don_Vry_Sat".split("_"),
                        weekdaysMin: "So_Ma_Di_Wo_Do_Vr_Sa".split("_"),
                        meridiemParse: /vm|nm/i,
                        isPM: function (input) {
                            return /^nm$/i.test(input);
                        },
                        meridiem: function (hours, minutes, isLower) {
                            if (hours < 12) {
                                return isLower ? "vm" : "VM";
                            } else {
                                return isLower ? "nm" : "NM";
                            }
                        },
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[Vandag om] LT", nextDay: "[Môre om] LT", nextWeek: "dddd [om] LT", lastDay: "[Gister om] LT", lastWeek: "[Laas] dddd [om] LT", sameElse: "L" },
                        relativeTime: {
                            future: "oor %s",
                            past: "%s gelede",
                            s: "'n paar sekondes",
                            ss: "%d sekondes",
                            m: "'n minuut",
                            mm: "%d minute",
                            h: "'n uur",
                            hh: "%d ure",
                            d: "'n dag",
                            dd: "%d dae",
                            M: "'n maand",
                            MM: "%d maande",
                            y: "'n jaar",
                            yy: "%d jaar",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
                        ordinal: function (number) {
                            return number + (number === 1 || number === 8 || number >= 20 ? "ste" : "de");
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return af;
                });
            },
            "./node_modules/moment/locale/ar-dz.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var pluralForm = function (n) {
                            return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
                        },
                        plurals = {
                            s: ["أقل من ثانية", "ثانية واحدة", ["ثانيتان", "ثانيتين"], "%d ثوان", "%d ثانية", "%d ثانية"],
                            m: ["أقل من دقيقة", "دقيقة واحدة", ["دقيقتان", "دقيقتين"], "%d دقائق", "%d دقيقة", "%d دقيقة"],
                            h: ["أقل من ساعة", "ساعة واحدة", ["ساعتان", "ساعتين"], "%d ساعات", "%d ساعة", "%d ساعة"],
                            d: ["أقل من يوم", "يوم واحد", ["يومان", "يومين"], "%d أيام", "%d يومًا", "%d يوم"],
                            M: ["أقل من شهر", "شهر واحد", ["شهران", "شهرين"], "%d أشهر", "%d شهرا", "%d شهر"],
                            y: ["أقل من عام", "عام واحد", ["عامان", "عامين"], "%d أعوام", "%d عامًا", "%d عام"],
                        },
                        pluralize = function (u) {
                            return function (number, withoutSuffix, string, isFuture) {
                                var f = pluralForm(number),
                                    str = plurals[u][pluralForm(number)];
                                if (f === 2) {
                                    str = str[withoutSuffix ? 0 : 1];
                                }
                                return str.replace(/%d/i, number);
                            };
                        },
                        months = ["جانفي", "فيفري", "مارس", "أفريل", "ماي", "جوان", "جويلية", "أوت", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
                    var arDz = moment.defineLocale("ar-dz", {
                        months: months,
                        monthsShort: months,
                        weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"),
                        weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"),
                        weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "D/‏M/‏YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" },
                        meridiemParse: /ص|م/,
                        isPM: function (input) {
                            return "م" === input;
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 12) {
                                return "ص";
                            } else {
                                return "م";
                            }
                        },
                        calendar: { sameDay: "[اليوم عند الساعة] LT", nextDay: "[غدًا عند الساعة] LT", nextWeek: "dddd [عند الساعة] LT", lastDay: "[أمس عند الساعة] LT", lastWeek: "dddd [عند الساعة] LT", sameElse: "L" },
                        relativeTime: {
                            future: "بعد %s",
                            past: "منذ %s",
                            s: pluralize("s"),
                            ss: pluralize("s"),
                            m: pluralize("m"),
                            mm: pluralize("m"),
                            h: pluralize("h"),
                            hh: pluralize("h"),
                            d: pluralize("d"),
                            dd: pluralize("d"),
                            M: pluralize("M"),
                            MM: pluralize("M"),
                            y: pluralize("y"),
                            yy: pluralize("y"),
                        },
                        postformat: function (string) {
                            return string.replace(/,/g, "،");
                        },
                        week: { dow: 0, doy: 4 },
                    });
                    return arDz;
                });
            },
            "./node_modules/moment/locale/ar-kw.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var arKw = moment.defineLocale("ar-kw", {
                        months: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"),
                        monthsShort: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"),
                        weekdays: "الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"),
                        weekdaysShort: "احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت".split("_"),
                        weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[اليوم على الساعة] LT", nextDay: "[غدا على الساعة] LT", nextWeek: "dddd [على الساعة] LT", lastDay: "[أمس على الساعة] LT", lastWeek: "dddd [على الساعة] LT", sameElse: "L" },
                        relativeTime: { future: "في %s", past: "منذ %s", s: "ثوان", ss: "%d ثانية", m: "دقيقة", mm: "%d دقائق", h: "ساعة", hh: "%d ساعات", d: "يوم", dd: "%d أيام", M: "شهر", MM: "%d أشهر", y: "سنة", yy: "%d سنوات" },
                        week: { dow: 0, doy: 12 },
                    });
                    return arKw;
                });
            },
            "./node_modules/moment/locale/ar-ly.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var symbolMap = { 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 0: "0" },
                        pluralForm = function (n) {
                            return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
                        },
                        plurals = {
                            s: ["أقل من ثانية", "ثانية واحدة", ["ثانيتان", "ثانيتين"], "%d ثوان", "%d ثانية", "%d ثانية"],
                            m: ["أقل من دقيقة", "دقيقة واحدة", ["دقيقتان", "دقيقتين"], "%d دقائق", "%d دقيقة", "%d دقيقة"],
                            h: ["أقل من ساعة", "ساعة واحدة", ["ساعتان", "ساعتين"], "%d ساعات", "%d ساعة", "%d ساعة"],
                            d: ["أقل من يوم", "يوم واحد", ["يومان", "يومين"], "%d أيام", "%d يومًا", "%d يوم"],
                            M: ["أقل من شهر", "شهر واحد", ["شهران", "شهرين"], "%d أشهر", "%d شهرا", "%d شهر"],
                            y: ["أقل من عام", "عام واحد", ["عامان", "عامين"], "%d أعوام", "%d عامًا", "%d عام"],
                        },
                        pluralize = function (u) {
                            return function (number, withoutSuffix, string, isFuture) {
                                var f = pluralForm(number),
                                    str = plurals[u][pluralForm(number)];
                                if (f === 2) {
                                    str = str[withoutSuffix ? 0 : 1];
                                }
                                return str.replace(/%d/i, number);
                            };
                        },
                        months = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
                    var arLy = moment.defineLocale("ar-ly", {
                        months: months,
                        monthsShort: months,
                        weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"),
                        weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"),
                        weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "D/‏M/‏YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" },
                        meridiemParse: /ص|م/,
                        isPM: function (input) {
                            return "م" === input;
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 12) {
                                return "ص";
                            } else {
                                return "م";
                            }
                        },
                        calendar: { sameDay: "[اليوم عند الساعة] LT", nextDay: "[غدًا عند الساعة] LT", nextWeek: "dddd [عند الساعة] LT", lastDay: "[أمس عند الساعة] LT", lastWeek: "dddd [عند الساعة] LT", sameElse: "L" },
                        relativeTime: {
                            future: "بعد %s",
                            past: "منذ %s",
                            s: pluralize("s"),
                            ss: pluralize("s"),
                            m: pluralize("m"),
                            mm: pluralize("m"),
                            h: pluralize("h"),
                            hh: pluralize("h"),
                            d: pluralize("d"),
                            dd: pluralize("d"),
                            M: pluralize("M"),
                            MM: pluralize("M"),
                            y: pluralize("y"),
                            yy: pluralize("y"),
                        },
                        preparse: function (string) {
                            return string.replace(/،/g, ",");
                        },
                        postformat: function (string) {
                            return string
                                .replace(/\d/g, function (match) {
                                    return symbolMap[match];
                                })
                                .replace(/,/g, "،");
                        },
                        week: { dow: 6, doy: 12 },
                    });
                    return arLy;
                });
            },
            "./node_modules/moment/locale/ar-ma.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var arMa = moment.defineLocale("ar-ma", {
                        months: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"),
                        monthsShort: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"),
                        weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"),
                        weekdaysShort: "احد_اثنين_ثلاثاء_اربعاء_خميس_جمعة_سبت".split("_"),
                        weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[اليوم على الساعة] LT", nextDay: "[غدا على الساعة] LT", nextWeek: "dddd [على الساعة] LT", lastDay: "[أمس على الساعة] LT", lastWeek: "dddd [على الساعة] LT", sameElse: "L" },
                        relativeTime: { future: "في %s", past: "منذ %s", s: "ثوان", ss: "%d ثانية", m: "دقيقة", mm: "%d دقائق", h: "ساعة", hh: "%d ساعات", d: "يوم", dd: "%d أيام", M: "شهر", MM: "%d أشهر", y: "سنة", yy: "%d سنوات" },
                        week: { dow: 1, doy: 4 },
                    });
                    return arMa;
                });
            },
            "./node_modules/moment/locale/ar-sa.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var symbolMap = { 1: "١", 2: "٢", 3: "٣", 4: "٤", 5: "٥", 6: "٦", 7: "٧", 8: "٨", 9: "٩", 0: "٠" },
                        numberMap = { "١": "1", "٢": "2", "٣": "3", "٤": "4", "٥": "5", "٦": "6", "٧": "7", "٨": "8", "٩": "9", "٠": "0" };
                    var arSa = moment.defineLocale("ar-sa", {
                        months: "يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر".split("_"),
                        monthsShort: "يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر".split("_"),
                        weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"),
                        weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"),
                        weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" },
                        meridiemParse: /ص|م/,
                        isPM: function (input) {
                            return "م" === input;
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 12) {
                                return "ص";
                            } else {
                                return "م";
                            }
                        },
                        calendar: { sameDay: "[اليوم على الساعة] LT", nextDay: "[غدا على الساعة] LT", nextWeek: "dddd [على الساعة] LT", lastDay: "[أمس على الساعة] LT", lastWeek: "dddd [على الساعة] LT", sameElse: "L" },
                        relativeTime: { future: "في %s", past: "منذ %s", s: "ثوان", ss: "%d ثانية", m: "دقيقة", mm: "%d دقائق", h: "ساعة", hh: "%d ساعات", d: "يوم", dd: "%d أيام", M: "شهر", MM: "%d أشهر", y: "سنة", yy: "%d سنوات" },
                        preparse: function (string) {
                            return string
                                .replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
                                    return numberMap[match];
                                })
                                .replace(/،/g, ",");
                        },
                        postformat: function (string) {
                            return string
                                .replace(/\d/g, function (match) {
                                    return symbolMap[match];
                                })
                                .replace(/,/g, "،");
                        },
                        week: { dow: 0, doy: 6 },
                    });
                    return arSa;
                });
            },
            "./node_modules/moment/locale/ar-tn.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var arTn = moment.defineLocale("ar-tn", {
                        months: "جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر".split("_"),
                        monthsShort: "جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر".split("_"),
                        weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"),
                        weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"),
                        weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[اليوم على الساعة] LT", nextDay: "[غدا على الساعة] LT", nextWeek: "dddd [على الساعة] LT", lastDay: "[أمس على الساعة] LT", lastWeek: "dddd [على الساعة] LT", sameElse: "L" },
                        relativeTime: { future: "في %s", past: "منذ %s", s: "ثوان", ss: "%d ثانية", m: "دقيقة", mm: "%d دقائق", h: "ساعة", hh: "%d ساعات", d: "يوم", dd: "%d أيام", M: "شهر", MM: "%d أشهر", y: "سنة", yy: "%d سنوات" },
                        week: { dow: 1, doy: 4 },
                    });
                    return arTn;
                });
            },
            "./node_modules/moment/locale/ar.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var symbolMap = { 1: "١", 2: "٢", 3: "٣", 4: "٤", 5: "٥", 6: "٦", 7: "٧", 8: "٨", 9: "٩", 0: "٠" },
                        numberMap = { "١": "1", "٢": "2", "٣": "3", "٤": "4", "٥": "5", "٦": "6", "٧": "7", "٨": "8", "٩": "9", "٠": "0" },
                        pluralForm = function (n) {
                            return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
                        },
                        plurals = {
                            s: ["أقل من ثانية", "ثانية واحدة", ["ثانيتان", "ثانيتين"], "%d ثوان", "%d ثانية", "%d ثانية"],
                            m: ["أقل من دقيقة", "دقيقة واحدة", ["دقيقتان", "دقيقتين"], "%d دقائق", "%d دقيقة", "%d دقيقة"],
                            h: ["أقل من ساعة", "ساعة واحدة", ["ساعتان", "ساعتين"], "%d ساعات", "%d ساعة", "%d ساعة"],
                            d: ["أقل من يوم", "يوم واحد", ["يومان", "يومين"], "%d أيام", "%d يومًا", "%d يوم"],
                            M: ["أقل من شهر", "شهر واحد", ["شهران", "شهرين"], "%d أشهر", "%d شهرا", "%d شهر"],
                            y: ["أقل من عام", "عام واحد", ["عامان", "عامين"], "%d أعوام", "%d عامًا", "%d عام"],
                        },
                        pluralize = function (u) {
                            return function (number, withoutSuffix, string, isFuture) {
                                var f = pluralForm(number),
                                    str = plurals[u][pluralForm(number)];
                                if (f === 2) {
                                    str = str[withoutSuffix ? 0 : 1];
                                }
                                return str.replace(/%d/i, number);
                            };
                        },
                        months = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
                    var ar = moment.defineLocale("ar", {
                        months: months,
                        monthsShort: months,
                        weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"),
                        weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"),
                        weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "D/‏M/‏YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" },
                        meridiemParse: /ص|م/,
                        isPM: function (input) {
                            return "م" === input;
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 12) {
                                return "ص";
                            } else {
                                return "م";
                            }
                        },
                        calendar: { sameDay: "[اليوم عند الساعة] LT", nextDay: "[غدًا عند الساعة] LT", nextWeek: "dddd [عند الساعة] LT", lastDay: "[أمس عند الساعة] LT", lastWeek: "dddd [عند الساعة] LT", sameElse: "L" },
                        relativeTime: {
                            future: "بعد %s",
                            past: "منذ %s",
                            s: pluralize("s"),
                            ss: pluralize("s"),
                            m: pluralize("m"),
                            mm: pluralize("m"),
                            h: pluralize("h"),
                            hh: pluralize("h"),
                            d: pluralize("d"),
                            dd: pluralize("d"),
                            M: pluralize("M"),
                            MM: pluralize("M"),
                            y: pluralize("y"),
                            yy: pluralize("y"),
                        },
                        preparse: function (string) {
                            return string
                                .replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
                                    return numberMap[match];
                                })
                                .replace(/،/g, ",");
                        },
                        postformat: function (string) {
                            return string
                                .replace(/\d/g, function (match) {
                                    return symbolMap[match];
                                })
                                .replace(/,/g, "،");
                        },
                        week: { dow: 6, doy: 12 },
                    });
                    return ar;
                });
            },
            "./node_modules/moment/locale/az.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var suffixes = {
                        1: "-inci",
                        5: "-inci",
                        8: "-inci",
                        70: "-inci",
                        80: "-inci",
                        2: "-nci",
                        7: "-nci",
                        20: "-nci",
                        50: "-nci",
                        3: "-üncü",
                        4: "-üncü",
                        100: "-üncü",
                        6: "-ncı",
                        9: "-uncu",
                        10: "-uncu",
                        30: "-uncu",
                        60: "-ıncı",
                        90: "-ıncı",
                    };
                    var az = moment.defineLocale("az", {
                        months: "yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr".split("_"),
                        monthsShort: "yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek".split("_"),
                        weekdays: "Bazar_Bazar ertəsi_Çərşənbə axşamı_Çərşənbə_Cümə axşamı_Cümə_Şənbə".split("_"),
                        weekdaysShort: "Baz_BzE_ÇAx_Çər_CAx_Cüm_Şən".split("_"),
                        weekdaysMin: "Bz_BE_ÇA_Çə_CA_Cü_Şə".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[bugün saat] LT", nextDay: "[sabah saat] LT", nextWeek: "[gələn həftə] dddd [saat] LT", lastDay: "[dünən] LT", lastWeek: "[keçən həftə] dddd [saat] LT", sameElse: "L" },
                        relativeTime: {
                            future: "%s sonra",
                            past: "%s əvvəl",
                            s: "bir neçə saniyə",
                            ss: "%d saniyə",
                            m: "bir dəqiqə",
                            mm: "%d dəqiqə",
                            h: "bir saat",
                            hh: "%d saat",
                            d: "bir gün",
                            dd: "%d gün",
                            M: "bir ay",
                            MM: "%d ay",
                            y: "bir il",
                            yy: "%d il",
                        },
                        meridiemParse: /gecə|səhər|gündüz|axşam/,
                        isPM: function (input) {
                            return /^(gündüz|axşam)$/.test(input);
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 4) {
                                return "gecə";
                            } else if (hour < 12) {
                                return "səhər";
                            } else if (hour < 17) {
                                return "gündüz";
                            } else {
                                return "axşam";
                            }
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}-(ıncı|inci|nci|üncü|ncı|uncu)/,
                        ordinal: function (number) {
                            if (number === 0) {
                                return number + "-ıncı";
                            }
                            var a = number % 10,
                                b = (number % 100) - a,
                                c = number >= 100 ? 100 : null;
                            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
                        },
                        week: { dow: 1, doy: 7 },
                    });
                    return az;
                });
            },
            "./node_modules/moment/locale/be.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    function plural(word, num) {
                        var forms = word.split("_");
                        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
                    }
                    function relativeTimeWithPlural(number, withoutSuffix, key) {
                        var format = {
                            ss: withoutSuffix ? "секунда_секунды_секунд" : "секунду_секунды_секунд",
                            mm: withoutSuffix ? "хвіліна_хвіліны_хвілін" : "хвіліну_хвіліны_хвілін",
                            hh: withoutSuffix ? "гадзіна_гадзіны_гадзін" : "гадзіну_гадзіны_гадзін",
                            dd: "дзень_дні_дзён",
                            MM: "месяц_месяцы_месяцаў",
                            yy: "год_гады_гадоў",
                        };
                        if (key === "m") {
                            return withoutSuffix ? "хвіліна" : "хвіліну";
                        } else if (key === "h") {
                            return withoutSuffix ? "гадзіна" : "гадзіну";
                        } else {
                            return number + " " + plural(format[key], +number);
                        }
                    }
                    var be = moment.defineLocale("be", {
                        months: {
                            format: "студзеня_лютага_сакавіка_красавіка_траўня_чэрвеня_ліпеня_жніўня_верасня_кастрычніка_лістапада_снежня".split("_"),
                            standalone: "студзень_люты_сакавік_красавік_травень_чэрвень_ліпень_жнівень_верасень_кастрычнік_лістапад_снежань".split("_"),
                        },
                        monthsShort: "студ_лют_сак_крас_трав_чэрв_ліп_жнів_вер_каст_ліст_снеж".split("_"),
                        weekdays: {
                            format: "нядзелю_панядзелак_аўторак_сераду_чацвер_пятніцу_суботу".split("_"),
                            standalone: "нядзеля_панядзелак_аўторак_серада_чацвер_пятніца_субота".split("_"),
                            isFormat: /\[ ?[Ууў] ?(?:мінулую|наступную)? ?\] ?dddd/,
                        },
                        weekdaysShort: "нд_пн_ат_ср_чц_пт_сб".split("_"),
                        weekdaysMin: "нд_пн_ат_ср_чц_пт_сб".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY г.", LLL: "D MMMM YYYY г., HH:mm", LLLL: "dddd, D MMMM YYYY г., HH:mm" },
                        calendar: {
                            sameDay: "[Сёння ў] LT",
                            nextDay: "[Заўтра ў] LT",
                            lastDay: "[Учора ў] LT",
                            nextWeek: function () {
                                return "[У] dddd [ў] LT";
                            },
                            lastWeek: function () {
                                switch (this.day()) {
                                    case 0:
                                    case 3:
                                    case 5:
                                    case 6:
                                        return "[У мінулую] dddd [ў] LT";
                                    case 1:
                                    case 2:
                                    case 4:
                                        return "[У мінулы] dddd [ў] LT";
                                }
                            },
                            sameElse: "L",
                        },
                        relativeTime: {
                            future: "праз %s",
                            past: "%s таму",
                            s: "некалькі секунд",
                            m: relativeTimeWithPlural,
                            mm: relativeTimeWithPlural,
                            h: relativeTimeWithPlural,
                            hh: relativeTimeWithPlural,
                            d: "дзень",
                            dd: relativeTimeWithPlural,
                            M: "месяц",
                            MM: relativeTimeWithPlural,
                            y: "год",
                            yy: relativeTimeWithPlural,
                        },
                        meridiemParse: /ночы|раніцы|дня|вечара/,
                        isPM: function (input) {
                            return /^(дня|вечара)$/.test(input);
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 4) {
                                return "ночы";
                            } else if (hour < 12) {
                                return "раніцы";
                            } else if (hour < 17) {
                                return "дня";
                            } else {
                                return "вечара";
                            }
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}-(і|ы|га)/,
                        ordinal: function (number, period) {
                            switch (period) {
                                case "M":
                                case "d":
                                case "DDD":
                                case "w":
                                case "W":
                                    return (number % 10 === 2 || number % 10 === 3) && number % 100 !== 12 && number % 100 !== 13 ? number + "-і" : number + "-ы";
                                case "D":
                                    return number + "-га";
                                default:
                                    return number;
                            }
                        },
                        week: { dow: 1, doy: 7 },
                    });
                    return be;
                });
            },
            "./node_modules/moment/locale/bg.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var bg = moment.defineLocale("bg", {
                        months: "януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември".split("_"),
                        monthsShort: "яну_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек".split("_"),
                        weekdays: "неделя_понеделник_вторник_сряда_четвъртък_петък_събота".split("_"),
                        weekdaysShort: "нед_пон_вто_сря_чет_пет_съб".split("_"),
                        weekdaysMin: "нд_пн_вт_ср_чт_пт_сб".split("_"),
                        longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "D.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY H:mm", LLLL: "dddd, D MMMM YYYY H:mm" },
                        calendar: {
                            sameDay: "[Днес в] LT",
                            nextDay: "[Утре в] LT",
                            nextWeek: "dddd [в] LT",
                            lastDay: "[Вчера в] LT",
                            lastWeek: function () {
                                switch (this.day()) {
                                    case 0:
                                    case 3:
                                    case 6:
                                        return "[Миналата] dddd [в] LT";
                                    case 1:
                                    case 2:
                                    case 4:
                                    case 5:
                                        return "[Миналия] dddd [в] LT";
                                }
                            },
                            sameElse: "L",
                        },
                        relativeTime: {
                            future: "след %s",
                            past: "преди %s",
                            s: "няколко секунди",
                            ss: "%d секунди",
                            m: "минута",
                            mm: "%d минути",
                            h: "час",
                            hh: "%d часа",
                            d: "ден",
                            dd: "%d дена",
                            w: "седмица",
                            ww: "%d седмици",
                            M: "месец",
                            MM: "%d месеца",
                            y: "година",
                            yy: "%d години",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
                        ordinal: function (number) {
                            var lastDigit = number % 10,
                                last2Digits = number % 100;
                            if (number === 0) {
                                return number + "-ев";
                            } else if (last2Digits === 0) {
                                return number + "-ен";
                            } else if (last2Digits > 10 && last2Digits < 20) {
                                return number + "-ти";
                            } else if (lastDigit === 1) {
                                return number + "-ви";
                            } else if (lastDigit === 2) {
                                return number + "-ри";
                            } else if (lastDigit === 7 || lastDigit === 8) {
                                return number + "-ми";
                            } else {
                                return number + "-ти";
                            }
                        },
                        week: { dow: 1, doy: 7 },
                    });
                    return bg;
                });
            },
            "./node_modules/moment/locale/bm.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var bm = moment.defineLocale("bm", {
                        months: "Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mɛkalo_Zuwɛnkalo_Zuluyekalo_Utikalo_Sɛtanburukalo_ɔkutɔburukalo_Nowanburukalo_Desanburukalo".split("_"),
                        monthsShort: "Zan_Few_Mar_Awi_Mɛ_Zuw_Zul_Uti_Sɛt_ɔku_Now_Des".split("_"),
                        weekdays: "Kari_Ntɛnɛn_Tarata_Araba_Alamisa_Juma_Sibiri".split("_"),
                        weekdaysShort: "Kar_Ntɛ_Tar_Ara_Ala_Jum_Sib".split("_"),
                        weekdaysMin: "Ka_Nt_Ta_Ar_Al_Ju_Si".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "MMMM [tile] D [san] YYYY", LLL: "MMMM [tile] D [san] YYYY [lɛrɛ] HH:mm", LLLL: "dddd MMMM [tile] D [san] YYYY [lɛrɛ] HH:mm" },
                        calendar: { sameDay: "[Bi lɛrɛ] LT", nextDay: "[Sini lɛrɛ] LT", nextWeek: "dddd [don lɛrɛ] LT", lastDay: "[Kunu lɛrɛ] LT", lastWeek: "dddd [tɛmɛnen lɛrɛ] LT", sameElse: "L" },
                        relativeTime: {
                            future: "%s kɔnɔ",
                            past: "a bɛ %s bɔ",
                            s: "sanga dama dama",
                            ss: "sekondi %d",
                            m: "miniti kelen",
                            mm: "miniti %d",
                            h: "lɛrɛ kelen",
                            hh: "lɛrɛ %d",
                            d: "tile kelen",
                            dd: "tile %d",
                            M: "kalo kelen",
                            MM: "kalo %d",
                            y: "san kelen",
                            yy: "san %d",
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return bm;
                });
            },
            "./node_modules/moment/locale/bn-bd.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var symbolMap = { 1: "১", 2: "২", 3: "৩", 4: "৪", 5: "৫", 6: "৬", 7: "৭", 8: "৮", 9: "৯", 0: "০" },
                        numberMap = { "১": "1", "২": "2", "৩": "3", "৪": "4", "৫": "5", "৬": "6", "৭": "7", "৮": "8", "৯": "9", "০": "0" };
                    var bnBd = moment.defineLocale("bn-bd", {
                        months: "জানুয়ারি_ফেব্রুয়ারি_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর".split("_"),
                        monthsShort: "জানু_ফেব্রু_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্ট_অক্টো_নভে_ডিসে".split("_"),
                        weekdays: "রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পতিবার_শুক্রবার_শনিবার".split("_"),
                        weekdaysShort: "রবি_সোম_মঙ্গল_বুধ_বৃহস্পতি_শুক্র_শনি".split("_"),
                        weekdaysMin: "রবি_সোম_মঙ্গল_বুধ_বৃহ_শুক্র_শনি".split("_"),
                        longDateFormat: { LT: "A h:mm সময়", LTS: "A h:mm:ss সময়", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm সময়", LLLL: "dddd, D MMMM YYYY, A h:mm সময়" },
                        calendar: { sameDay: "[আজ] LT", nextDay: "[আগামীকাল] LT", nextWeek: "dddd, LT", lastDay: "[গতকাল] LT", lastWeek: "[গত] dddd, LT", sameElse: "L" },
                        relativeTime: {
                            future: "%s পরে",
                            past: "%s আগে",
                            s: "কয়েক সেকেন্ড",
                            ss: "%d সেকেন্ড",
                            m: "এক মিনিট",
                            mm: "%d মিনিট",
                            h: "এক ঘন্টা",
                            hh: "%d ঘন্টা",
                            d: "এক দিন",
                            dd: "%d দিন",
                            M: "এক মাস",
                            MM: "%d মাস",
                            y: "এক বছর",
                            yy: "%d বছর",
                        },
                        preparse: function (string) {
                            return string.replace(/[১২৩৪৫৬৭৮৯০]/g, function (match) {
                                return numberMap[match];
                            });
                        },
                        postformat: function (string) {
                            return string.replace(/\d/g, function (match) {
                                return symbolMap[match];
                            });
                        },
                        meridiemParse: /রাত|ভোর|সকাল|দুপুর|বিকাল|সন্ধ্যা|রাত/,
                        meridiemHour: function (hour, meridiem) {
                            if (hour === 12) {
                                hour = 0;
                            }
                            if (meridiem === "রাত") {
                                return hour < 4 ? hour : hour + 12;
                            } else if (meridiem === "ভোর") {
                                return hour;
                            } else if (meridiem === "সকাল") {
                                return hour;
                            } else if (meridiem === "দুপুর") {
                                return hour >= 3 ? hour : hour + 12;
                            } else if (meridiem === "বিকাল") {
                                return hour + 12;
                            } else if (meridiem === "সন্ধ্যা") {
                                return hour + 12;
                            }
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 4) {
                                return "রাত";
                            } else if (hour < 6) {
                                return "ভোর";
                            } else if (hour < 12) {
                                return "সকাল";
                            } else if (hour < 15) {
                                return "দুপুর";
                            } else if (hour < 18) {
                                return "বিকাল";
                            } else if (hour < 20) {
                                return "সন্ধ্যা";
                            } else {
                                return "রাত";
                            }
                        },
                        week: { dow: 0, doy: 6 },
                    });
                    return bnBd;
                });
            },
            "./node_modules/moment/locale/bn.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var symbolMap = { 1: "১", 2: "২", 3: "৩", 4: "৪", 5: "৫", 6: "৬", 7: "৭", 8: "৮", 9: "৯", 0: "০" },
                        numberMap = { "১": "1", "২": "2", "৩": "3", "৪": "4", "৫": "5", "৬": "6", "৭": "7", "৮": "8", "৯": "9", "০": "0" };
                    var bn = moment.defineLocale("bn", {
                        months: "জানুয়ারি_ফেব্রুয়ারি_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর".split("_"),
                        monthsShort: "জানু_ফেব্রু_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্ট_অক্টো_নভে_ডিসে".split("_"),
                        weekdays: "রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পতিবার_শুক্রবার_শনিবার".split("_"),
                        weekdaysShort: "রবি_সোম_মঙ্গল_বুধ_বৃহস্পতি_শুক্র_শনি".split("_"),
                        weekdaysMin: "রবি_সোম_মঙ্গল_বুধ_বৃহ_শুক্র_শনি".split("_"),
                        longDateFormat: { LT: "A h:mm সময়", LTS: "A h:mm:ss সময়", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm সময়", LLLL: "dddd, D MMMM YYYY, A h:mm সময়" },
                        calendar: { sameDay: "[আজ] LT", nextDay: "[আগামীকাল] LT", nextWeek: "dddd, LT", lastDay: "[গতকাল] LT", lastWeek: "[গত] dddd, LT", sameElse: "L" },
                        relativeTime: {
                            future: "%s পরে",
                            past: "%s আগে",
                            s: "কয়েক সেকেন্ড",
                            ss: "%d সেকেন্ড",
                            m: "এক মিনিট",
                            mm: "%d মিনিট",
                            h: "এক ঘন্টা",
                            hh: "%d ঘন্টা",
                            d: "এক দিন",
                            dd: "%d দিন",
                            M: "এক মাস",
                            MM: "%d মাস",
                            y: "এক বছর",
                            yy: "%d বছর",
                        },
                        preparse: function (string) {
                            return string.replace(/[১২৩৪৫৬৭৮৯০]/g, function (match) {
                                return numberMap[match];
                            });
                        },
                        postformat: function (string) {
                            return string.replace(/\d/g, function (match) {
                                return symbolMap[match];
                            });
                        },
                        meridiemParse: /রাত|সকাল|দুপুর|বিকাল|রাত/,
                        meridiemHour: function (hour, meridiem) {
                            if (hour === 12) {
                                hour = 0;
                            }
                            if ((meridiem === "রাত" && hour >= 4) || (meridiem === "দুপুর" && hour < 5) || meridiem === "বিকাল") {
                                return hour + 12;
                            } else {
                                return hour;
                            }
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 4) {
                                return "রাত";
                            } else if (hour < 10) {
                                return "সকাল";
                            } else if (hour < 17) {
                                return "দুপুর";
                            } else if (hour < 20) {
                                return "বিকাল";
                            } else {
                                return "রাত";
                            }
                        },
                        week: { dow: 0, doy: 6 },
                    });
                    return bn;
                });
            },
            "./node_modules/moment/locale/bo.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var symbolMap = { 1: "༡", 2: "༢", 3: "༣", 4: "༤", 5: "༥", 6: "༦", 7: "༧", 8: "༨", 9: "༩", 0: "༠" },
                        numberMap = { "༡": "1", "༢": "2", "༣": "3", "༤": "4", "༥": "5", "༦": "6", "༧": "7", "༨": "8", "༩": "9", "༠": "0" };
                    var bo = moment.defineLocale("bo", {
                        months: "ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ".split("_"),
                        monthsShort: "ཟླ་1_ཟླ་2_ཟླ་3_ཟླ་4_ཟླ་5_ཟླ་6_ཟླ་7_ཟླ་8_ཟླ་9_ཟླ་10_ཟླ་11_ཟླ་12".split("_"),
                        monthsShortRegex: /^(ཟླ་\d{1,2})/,
                        monthsParseExact: true,
                        weekdays: "གཟའ་ཉི་མ་_གཟའ་ཟླ་བ་_གཟའ་མིག་དམར་_གཟའ་ལྷག་པ་_གཟའ་ཕུར་བུ_གཟའ་པ་སངས་_གཟའ་སྤེན་པ་".split("_"),
                        weekdaysShort: "ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་".split("_"),
                        weekdaysMin: "ཉི_ཟླ_མིག_ལྷག_ཕུར_སངས_སྤེན".split("_"),
                        longDateFormat: { LT: "A h:mm", LTS: "A h:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm", LLLL: "dddd, D MMMM YYYY, A h:mm" },
                        calendar: { sameDay: "[དི་རིང] LT", nextDay: "[སང་ཉིན] LT", nextWeek: "[བདུན་ཕྲག་རྗེས་མ], LT", lastDay: "[ཁ་སང] LT", lastWeek: "[བདུན་ཕྲག་མཐའ་མ] dddd, LT", sameElse: "L" },
                        relativeTime: {
                            future: "%s ལ་",
                            past: "%s སྔན་ལ",
                            s: "ལམ་སང",
                            ss: "%d སྐར་ཆ།",
                            m: "སྐར་མ་གཅིག",
                            mm: "%d སྐར་མ",
                            h: "ཆུ་ཚོད་གཅིག",
                            hh: "%d ཆུ་ཚོད",
                            d: "ཉིན་གཅིག",
                            dd: "%d ཉིན་",
                            M: "ཟླ་བ་གཅིག",
                            MM: "%d ཟླ་བ",
                            y: "ལོ་གཅིག",
                            yy: "%d ལོ",
                        },
                        preparse: function (string) {
                            return string.replace(/[༡༢༣༤༥༦༧༨༩༠]/g, function (match) {
                                return numberMap[match];
                            });
                        },
                        postformat: function (string) {
                            return string.replace(/\d/g, function (match) {
                                return symbolMap[match];
                            });
                        },
                        meridiemParse: /མཚན་མོ|ཞོགས་ཀས|ཉིན་གུང|དགོང་དག|མཚན་མོ/,
                        meridiemHour: function (hour, meridiem) {
                            if (hour === 12) {
                                hour = 0;
                            }
                            if ((meridiem === "མཚན་མོ" && hour >= 4) || (meridiem === "ཉིན་གུང" && hour < 5) || meridiem === "དགོང་དག") {
                                return hour + 12;
                            } else {
                                return hour;
                            }
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 4) {
                                return "མཚན་མོ";
                            } else if (hour < 10) {
                                return "ཞོགས་ཀས";
                            } else if (hour < 17) {
                                return "ཉིན་གུང";
                            } else if (hour < 20) {
                                return "དགོང་དག";
                            } else {
                                return "མཚན་མོ";
                            }
                        },
                        week: { dow: 0, doy: 6 },
                    });
                    return bo;
                });
            },
            "./node_modules/moment/locale/br.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    function relativeTimeWithMutation(number, withoutSuffix, key) {
                        var format = { mm: "munutenn", MM: "miz", dd: "devezh" };
                        return number + " " + mutation(format[key], number);
                    }
                    function specialMutationForYears(number) {
                        switch (lastNumber(number)) {
                            case 1:
                            case 3:
                            case 4:
                            case 5:
                            case 9:
                                return number + " bloaz";
                            default:
                                return number + " vloaz";
                        }
                    }
                    function lastNumber(number) {
                        if (number > 9) {
                            return lastNumber(number % 10);
                        }
                        return number;
                    }
                    function mutation(text, number) {
                        if (number === 2) {
                            return softMutation(text);
                        }
                        return text;
                    }
                    function softMutation(text) {
                        var mutationTable = { m: "v", b: "v", d: "z" };
                        if (mutationTable[text.charAt(0)] === undefined) {
                            return text;
                        }
                        return mutationTable[text.charAt(0)] + text.substring(1);
                    }
                    var monthsParse = [/^gen/i, /^c[ʼ\']hwe/i, /^meu/i, /^ebr/i, /^mae/i, /^(mez|eve)/i, /^gou/i, /^eos/i, /^gwe/i, /^her/i, /^du/i, /^ker/i],
                        monthsRegex = /^(genver|c[ʼ\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu|gen|c[ʼ\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i,
                        monthsStrictRegex = /^(genver|c[ʼ\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu)/i,
                        monthsShortStrictRegex = /^(gen|c[ʼ\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i,
                        fullWeekdaysParse = [/^sul/i, /^lun/i, /^meurzh/i, /^merc[ʼ\']her/i, /^yaou/i, /^gwener/i, /^sadorn/i],
                        shortWeekdaysParse = [/^Sul/i, /^Lun/i, /^Meu/i, /^Mer/i, /^Yao/i, /^Gwe/i, /^Sad/i],
                        minWeekdaysParse = [/^Su/i, /^Lu/i, /^Me([^r]|$)/i, /^Mer/i, /^Ya/i, /^Gw/i, /^Sa/i];
                    var br = moment.defineLocale("br", {
                        months: "Genver_Cʼhwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu".split("_"),
                        monthsShort: "Gen_Cʼhwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker".split("_"),
                        weekdays: "Sul_Lun_Meurzh_Mercʼher_Yaou_Gwener_Sadorn".split("_"),
                        weekdaysShort: "Sul_Lun_Meu_Mer_Yao_Gwe_Sad".split("_"),
                        weekdaysMin: "Su_Lu_Me_Mer_Ya_Gw_Sa".split("_"),
                        weekdaysParse: minWeekdaysParse,
                        fullWeekdaysParse: fullWeekdaysParse,
                        shortWeekdaysParse: shortWeekdaysParse,
                        minWeekdaysParse: minWeekdaysParse,
                        monthsRegex: monthsRegex,
                        monthsShortRegex: monthsRegex,
                        monthsStrictRegex: monthsStrictRegex,
                        monthsShortStrictRegex: monthsShortStrictRegex,
                        monthsParse: monthsParse,
                        longMonthsParse: monthsParse,
                        shortMonthsParse: monthsParse,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D [a viz] MMMM YYYY", LLL: "D [a viz] MMMM YYYY HH:mm", LLLL: "dddd, D [a viz] MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[Hiziv da] LT", nextDay: "[Warcʼhoazh da] LT", nextWeek: "dddd [da] LT", lastDay: "[Decʼh da] LT", lastWeek: "dddd [paset da] LT", sameElse: "L" },
                        relativeTime: {
                            future: "a-benn %s",
                            past: "%s ʼzo",
                            s: "un nebeud segondennoù",
                            ss: "%d eilenn",
                            m: "ur vunutenn",
                            mm: relativeTimeWithMutation,
                            h: "un eur",
                            hh: "%d eur",
                            d: "un devezh",
                            dd: relativeTimeWithMutation,
                            M: "ur miz",
                            MM: relativeTimeWithMutation,
                            y: "ur bloaz",
                            yy: specialMutationForYears,
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(añ|vet)/,
                        ordinal: function (number) {
                            var output = number === 1 ? "añ" : "vet";
                            return number + output;
                        },
                        week: { dow: 1, doy: 4 },
                        meridiemParse: /a.m.|g.m./,
                        isPM: function (token) {
                            return token === "g.m.";
                        },
                        meridiem: function (hour, minute, isLower) {
                            return hour < 12 ? "a.m." : "g.m.";
                        },
                    });
                    return br;
                });
            },
            "./node_modules/moment/locale/bs.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    function translate(number, withoutSuffix, key) {
                        var result = number + " ";
                        switch (key) {
                            case "ss":
                                if (number === 1) {
                                    result += "sekunda";
                                } else if (number === 2 || number === 3 || number === 4) {
                                    result += "sekunde";
                                } else {
                                    result += "sekundi";
                                }
                                return result;
                            case "m":
                                return withoutSuffix ? "jedna minuta" : "jedne minute";
                            case "mm":
                                if (number === 1) {
                                    result += "minuta";
                                } else if (number === 2 || number === 3 || number === 4) {
                                    result += "minute";
                                } else {
                                    result += "minuta";
                                }
                                return result;
                            case "h":
                                return withoutSuffix ? "jedan sat" : "jednog sata";
                            case "hh":
                                if (number === 1) {
                                    result += "sat";
                                } else if (number === 2 || number === 3 || number === 4) {
                                    result += "sata";
                                } else {
                                    result += "sati";
                                }
                                return result;
                            case "dd":
                                if (number === 1) {
                                    result += "dan";
                                } else {
                                    result += "dana";
                                }
                                return result;
                            case "MM":
                                if (number === 1) {
                                    result += "mjesec";
                                } else if (number === 2 || number === 3 || number === 4) {
                                    result += "mjeseca";
                                } else {
                                    result += "mjeseci";
                                }
                                return result;
                            case "yy":
                                if (number === 1) {
                                    result += "godina";
                                } else if (number === 2 || number === 3 || number === 4) {
                                    result += "godine";
                                } else {
                                    result += "godina";
                                }
                                return result;
                        }
                    }
                    var bs = moment.defineLocale("bs", {
                        months: "januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar".split("_"),
                        monthsShort: "jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.".split("_"),
                        monthsParseExact: true,
                        weekdays: "nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota".split("_"),
                        weekdaysShort: "ned._pon._uto._sri._čet._pet._sub.".split("_"),
                        weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd, D. MMMM YYYY H:mm" },
                        calendar: {
                            sameDay: "[danas u] LT",
                            nextDay: "[sutra u] LT",
                            nextWeek: function () {
                                switch (this.day()) {
                                    case 0:
                                        return "[u] [nedjelju] [u] LT";
                                    case 3:
                                        return "[u] [srijedu] [u] LT";
                                    case 6:
                                        return "[u] [subotu] [u] LT";
                                    case 1:
                                    case 2:
                                    case 4:
                                    case 5:
                                        return "[u] dddd [u] LT";
                                }
                            },
                            lastDay: "[jučer u] LT",
                            lastWeek: function () {
                                switch (this.day()) {
                                    case 0:
                                    case 3:
                                        return "[prošlu] dddd [u] LT";
                                    case 6:
                                        return "[prošle] [subote] [u] LT";
                                    case 1:
                                    case 2:
                                    case 4:
                                    case 5:
                                        return "[prošli] dddd [u] LT";
                                }
                            },
                            sameElse: "L",
                        },
                        relativeTime: {
                            future: "za %s",
                            past: "prije %s",
                            s: "par sekundi",
                            ss: translate,
                            m: translate,
                            mm: translate,
                            h: translate,
                            hh: translate,
                            d: "dan",
                            dd: translate,
                            M: "mjesec",
                            MM: translate,
                            y: "godinu",
                            yy: translate,
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}\./,
                        ordinal: "%d.",
                        week: { dow: 1, doy: 7 },
                    });
                    return bs;
                });
            },
            "./node_modules/moment/locale/ca.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var ca = moment.defineLocale("ca", {
                        months: {
                            standalone: "gener_febrer_març_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre".split("_"),
                            format: "de gener_de febrer_de març_d'abril_de maig_de juny_de juliol_d'agost_de setembre_d'octubre_de novembre_de desembre".split("_"),
                            isFormat: /D[oD]?(\s)+MMMM/,
                        },
                        monthsShort: "gen._febr._març_abr._maig_juny_jul._ag._set._oct._nov._des.".split("_"),
                        monthsParseExact: true,
                        weekdays: "diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte".split("_"),
                        weekdaysShort: "dg._dl._dt._dc._dj._dv._ds.".split("_"),
                        weekdaysMin: "dg_dl_dt_dc_dj_dv_ds".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: {
                            LT: "H:mm",
                            LTS: "H:mm:ss",
                            L: "DD/MM/YYYY",
                            LL: "D MMMM [de] YYYY",
                            ll: "D MMM YYYY",
                            LLL: "D MMMM [de] YYYY [a les] H:mm",
                            lll: "D MMM YYYY, H:mm",
                            LLLL: "dddd D MMMM [de] YYYY [a les] H:mm",
                            llll: "ddd D MMM YYYY, H:mm",
                        },
                        calendar: {
                            sameDay: function () {
                                return "[avui a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
                            },
                            nextDay: function () {
                                return "[demà a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
                            },
                            nextWeek: function () {
                                return "dddd [a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
                            },
                            lastDay: function () {
                                return "[ahir a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
                            },
                            lastWeek: function () {
                                return "[el] dddd [passat a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
                            },
                            sameElse: "L",
                        },
                        relativeTime: {
                            future: "d'aquí %s",
                            past: "fa %s",
                            s: "uns segons",
                            ss: "%d segons",
                            m: "un minut",
                            mm: "%d minuts",
                            h: "una hora",
                            hh: "%d hores",
                            d: "un dia",
                            dd: "%d dies",
                            M: "un mes",
                            MM: "%d mesos",
                            y: "un any",
                            yy: "%d anys",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|è|a)/,
                        ordinal: function (number, period) {
                            var output = number === 1 ? "r" : number === 2 ? "n" : number === 3 ? "r" : number === 4 ? "t" : "è";
                            if (period === "w" || period === "W") {
                                output = "a";
                            }
                            return number + output;
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return ca;
                });
            },
            "./node_modules/moment/locale/cs.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var months = {
                            format: "leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec".split("_"),
                            standalone: "ledna_února_března_dubna_května_června_července_srpna_září_října_listopadu_prosince".split("_"),
                        },
                        monthsShort = "led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro".split("_"),
                        monthsParse = [/^led/i, /^úno/i, /^bře/i, /^dub/i, /^kvě/i, /^(čvn|červen$|června)/i, /^(čvc|červenec|července)/i, /^srp/i, /^zář/i, /^říj/i, /^lis/i, /^pro/i],
                        monthsRegex = /^(leden|únor|březen|duben|květen|červenec|července|červen|června|srpen|září|říjen|listopad|prosinec|led|úno|bře|dub|kvě|čvn|čvc|srp|zář|říj|lis|pro)/i;
                    function plural(n) {
                        return n > 1 && n < 5 && ~~(n / 10) !== 1;
                    }
                    function translate(number, withoutSuffix, key, isFuture) {
                        var result = number + " ";
                        switch (key) {
                            case "s":
                                return withoutSuffix || isFuture ? "pár sekund" : "pár sekundami";
                            case "ss":
                                if (withoutSuffix || isFuture) {
                                    return result + (plural(number) ? "sekundy" : "sekund");
                                } else {
                                    return result + "sekundami";
                                }
                            case "m":
                                return withoutSuffix ? "minuta" : isFuture ? "minutu" : "minutou";
                            case "mm":
                                if (withoutSuffix || isFuture) {
                                    return result + (plural(number) ? "minuty" : "minut");
                                } else {
                                    return result + "minutami";
                                }
                            case "h":
                                return withoutSuffix ? "hodina" : isFuture ? "hodinu" : "hodinou";
                            case "hh":
                                if (withoutSuffix || isFuture) {
                                    return result + (plural(number) ? "hodiny" : "hodin");
                                } else {
                                    return result + "hodinami";
                                }
                            case "d":
                                return withoutSuffix || isFuture ? "den" : "dnem";
                            case "dd":
                                if (withoutSuffix || isFuture) {
                                    return result + (plural(number) ? "dny" : "dní");
                                } else {
                                    return result + "dny";
                                }
                            case "M":
                                return withoutSuffix || isFuture ? "měsíc" : "měsícem";
                            case "MM":
                                if (withoutSuffix || isFuture) {
                                    return result + (plural(number) ? "měsíce" : "měsíců");
                                } else {
                                    return result + "měsíci";
                                }
                            case "y":
                                return withoutSuffix || isFuture ? "rok" : "rokem";
                            case "yy":
                                if (withoutSuffix || isFuture) {
                                    return result + (plural(number) ? "roky" : "let");
                                } else {
                                    return result + "lety";
                                }
                        }
                    }
                    var cs = moment.defineLocale("cs", {
                        months: months,
                        monthsShort: monthsShort,
                        monthsRegex: monthsRegex,
                        monthsShortRegex: monthsRegex,
                        monthsStrictRegex: /^(leden|ledna|února|únor|březen|března|duben|dubna|květen|května|červenec|července|červen|června|srpen|srpna|září|říjen|října|listopadu|listopad|prosinec|prosince)/i,
                        monthsShortStrictRegex: /^(led|úno|bře|dub|kvě|čvn|čvc|srp|zář|říj|lis|pro)/i,
                        monthsParse: monthsParse,
                        longMonthsParse: monthsParse,
                        shortMonthsParse: monthsParse,
                        weekdays: "neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota".split("_"),
                        weekdaysShort: "ne_po_út_st_čt_pá_so".split("_"),
                        weekdaysMin: "ne_po_út_st_čt_pá_so".split("_"),
                        longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd D. MMMM YYYY H:mm", l: "D. M. YYYY" },
                        calendar: {
                            sameDay: "[dnes v] LT",
                            nextDay: "[zítra v] LT",
                            nextWeek: function () {
                                switch (this.day()) {
                                    case 0:
                                        return "[v neděli v] LT";
                                    case 1:
                                    case 2:
                                        return "[v] dddd [v] LT";
                                    case 3:
                                        return "[ve středu v] LT";
                                    case 4:
                                        return "[ve čtvrtek v] LT";
                                    case 5:
                                        return "[v pátek v] LT";
                                    case 6:
                                        return "[v sobotu v] LT";
                                }
                            },
                            lastDay: "[včera v] LT",
                            lastWeek: function () {
                                switch (this.day()) {
                                    case 0:
                                        return "[minulou neděli v] LT";
                                    case 1:
                                    case 2:
                                        return "[minulé] dddd [v] LT";
                                    case 3:
                                        return "[minulou středu v] LT";
                                    case 4:
                                    case 5:
                                        return "[minulý] dddd [v] LT";
                                    case 6:
                                        return "[minulou sobotu v] LT";
                                }
                            },
                            sameElse: "L",
                        },
                        relativeTime: {
                            future: "za %s",
                            past: "před %s",
                            s: translate,
                            ss: translate,
                            m: translate,
                            mm: translate,
                            h: translate,
                            hh: translate,
                            d: translate,
                            dd: translate,
                            M: translate,
                            MM: translate,
                            y: translate,
                            yy: translate,
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}\./,
                        ordinal: "%d.",
                        week: { dow: 1, doy: 4 },
                    });
                    return cs;
                });
            },
            "./node_modules/moment/locale/cv.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var cv = moment.defineLocale("cv", {
                        months: "кӑрлач_нарӑс_пуш_ака_май_ҫӗртме_утӑ_ҫурла_авӑн_юпа_чӳк_раштав".split("_"),
                        monthsShort: "кӑр_нар_пуш_ака_май_ҫӗр_утӑ_ҫур_авн_юпа_чӳк_раш".split("_"),
                        weekdays: "вырсарникун_тунтикун_ытларикун_юнкун_кӗҫнерникун_эрнекун_шӑматкун".split("_"),
                        weekdaysShort: "выр_тун_ытл_юн_кӗҫ_эрн_шӑм".split("_"),
                        weekdaysMin: "вр_тн_ыт_юн_кҫ_эр_шм".split("_"),
                        longDateFormat: {
                            LT: "HH:mm",
                            LTS: "HH:mm:ss",
                            L: "DD-MM-YYYY",
                            LL: "YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ]",
                            LLL: "YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm",
                            LLLL: "dddd, YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm",
                        },
                        calendar: { sameDay: "[Паян] LT [сехетре]", nextDay: "[Ыран] LT [сехетре]", lastDay: "[Ӗнер] LT [сехетре]", nextWeek: "[Ҫитес] dddd LT [сехетре]", lastWeek: "[Иртнӗ] dddd LT [сехетре]", sameElse: "L" },
                        relativeTime: {
                            future: function (output) {
                                var affix = /сехет$/i.exec(output) ? "рен" : /ҫул$/i.exec(output) ? "тан" : "ран";
                                return output + affix;
                            },
                            past: "%s каялла",
                            s: "пӗр-ик ҫеккунт",
                            ss: "%d ҫеккунт",
                            m: "пӗр минут",
                            mm: "%d минут",
                            h: "пӗр сехет",
                            hh: "%d сехет",
                            d: "пӗр кун",
                            dd: "%d кун",
                            M: "пӗр уйӑх",
                            MM: "%d уйӑх",
                            y: "пӗр ҫул",
                            yy: "%d ҫул",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}-мӗш/,
                        ordinal: "%d-мӗш",
                        week: { dow: 1, doy: 7 },
                    });
                    return cv;
                });
            },
            "./node_modules/moment/locale/cy.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var cy = moment.defineLocale("cy", {
                        months: "Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr".split("_"),
                        monthsShort: "Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag".split("_"),
                        weekdays: "Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn".split("_"),
                        weekdaysShort: "Sul_Llun_Maw_Mer_Iau_Gwe_Sad".split("_"),
                        weekdaysMin: "Su_Ll_Ma_Me_Ia_Gw_Sa".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[Heddiw am] LT", nextDay: "[Yfory am] LT", nextWeek: "dddd [am] LT", lastDay: "[Ddoe am] LT", lastWeek: "dddd [diwethaf am] LT", sameElse: "L" },
                        relativeTime: {
                            future: "mewn %s",
                            past: "%s yn ôl",
                            s: "ychydig eiliadau",
                            ss: "%d eiliad",
                            m: "munud",
                            mm: "%d munud",
                            h: "awr",
                            hh: "%d awr",
                            d: "diwrnod",
                            dd: "%d diwrnod",
                            M: "mis",
                            MM: "%d mis",
                            y: "blwyddyn",
                            yy: "%d flynedd",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
                        ordinal: function (number) {
                            var b = number,
                                output = "",
                                lookup = ["", "af", "il", "ydd", "ydd", "ed", "ed", "ed", "fed", "fed", "fed", "eg", "fed", "eg", "eg", "fed", "eg", "eg", "fed", "eg", "fed"];
                            if (b > 20) {
                                if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
                                    output = "fed";
                                } else {
                                    output = "ain";
                                }
                            } else if (b > 0) {
                                output = lookup[b];
                            }
                            return number + output;
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return cy;
                });
            },
            "./node_modules/moment/locale/da.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var da = moment.defineLocale("da", {
                        months: "januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december".split("_"),
                        monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),
                        weekdays: "søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag".split("_"),
                        weekdaysShort: "søn_man_tir_ons_tor_fre_lør".split("_"),
                        weekdaysMin: "sø_ma_ti_on_to_fr_lø".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY HH:mm", LLLL: "dddd [d.] D. MMMM YYYY [kl.] HH:mm" },
                        calendar: { sameDay: "[i dag kl.] LT", nextDay: "[i morgen kl.] LT", nextWeek: "på dddd [kl.] LT", lastDay: "[i går kl.] LT", lastWeek: "[i] dddd[s kl.] LT", sameElse: "L" },
                        relativeTime: {
                            future: "om %s",
                            past: "%s siden",
                            s: "få sekunder",
                            ss: "%d sekunder",
                            m: "et minut",
                            mm: "%d minutter",
                            h: "en time",
                            hh: "%d timer",
                            d: "en dag",
                            dd: "%d dage",
                            M: "en måned",
                            MM: "%d måneder",
                            y: "et år",
                            yy: "%d år",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}\./,
                        ordinal: "%d.",
                        week: { dow: 1, doy: 4 },
                    });
                    return da;
                });
            },
            "./node_modules/moment/locale/de-at.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    function processRelativeTime(number, withoutSuffix, key, isFuture) {
                        var format = {
                            m: ["eine Minute", "einer Minute"],
                            h: ["eine Stunde", "einer Stunde"],
                            d: ["ein Tag", "einem Tag"],
                            dd: [number + " Tage", number + " Tagen"],
                            w: ["eine Woche", "einer Woche"],
                            M: ["ein Monat", "einem Monat"],
                            MM: [number + " Monate", number + " Monaten"],
                            y: ["ein Jahr", "einem Jahr"],
                            yy: [number + " Jahre", number + " Jahren"],
                        };
                        return withoutSuffix ? format[key][0] : format[key][1];
                    }
                    var deAt = moment.defineLocale("de-at", {
                        months: "Jänner_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
                        monthsShort: "Jän._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),
                        monthsParseExact: true,
                        weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
                        weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),
                        weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY HH:mm", LLLL: "dddd, D. MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[heute um] LT [Uhr]", sameElse: "L", nextDay: "[morgen um] LT [Uhr]", nextWeek: "dddd [um] LT [Uhr]", lastDay: "[gestern um] LT [Uhr]", lastWeek: "[letzten] dddd [um] LT [Uhr]" },
                        relativeTime: {
                            future: "in %s",
                            past: "vor %s",
                            s: "ein paar Sekunden",
                            ss: "%d Sekunden",
                            m: processRelativeTime,
                            mm: "%d Minuten",
                            h: processRelativeTime,
                            hh: "%d Stunden",
                            d: processRelativeTime,
                            dd: processRelativeTime,
                            w: processRelativeTime,
                            ww: "%d Wochen",
                            M: processRelativeTime,
                            MM: processRelativeTime,
                            y: processRelativeTime,
                            yy: processRelativeTime,
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}\./,
                        ordinal: "%d.",
                        week: { dow: 1, doy: 4 },
                    });
                    return deAt;
                });
            },
            "./node_modules/moment/locale/de-ch.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    function processRelativeTime(number, withoutSuffix, key, isFuture) {
                        var format = {
                            m: ["eine Minute", "einer Minute"],
                            h: ["eine Stunde", "einer Stunde"],
                            d: ["ein Tag", "einem Tag"],
                            dd: [number + " Tage", number + " Tagen"],
                            w: ["eine Woche", "einer Woche"],
                            M: ["ein Monat", "einem Monat"],
                            MM: [number + " Monate", number + " Monaten"],
                            y: ["ein Jahr", "einem Jahr"],
                            yy: [number + " Jahre", number + " Jahren"],
                        };
                        return withoutSuffix ? format[key][0] : format[key][1];
                    }
                    var deCh = moment.defineLocale("de-ch", {
                        months: "Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
                        monthsShort: "Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),
                        monthsParseExact: true,
                        weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
                        weekdaysShort: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
                        weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY HH:mm", LLLL: "dddd, D. MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[heute um] LT [Uhr]", sameElse: "L", nextDay: "[morgen um] LT [Uhr]", nextWeek: "dddd [um] LT [Uhr]", lastDay: "[gestern um] LT [Uhr]", lastWeek: "[letzten] dddd [um] LT [Uhr]" },
                        relativeTime: {
                            future: "in %s",
                            past: "vor %s",
                            s: "ein paar Sekunden",
                            ss: "%d Sekunden",
                            m: processRelativeTime,
                            mm: "%d Minuten",
                            h: processRelativeTime,
                            hh: "%d Stunden",
                            d: processRelativeTime,
                            dd: processRelativeTime,
                            w: processRelativeTime,
                            ww: "%d Wochen",
                            M: processRelativeTime,
                            MM: processRelativeTime,
                            y: processRelativeTime,
                            yy: processRelativeTime,
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}\./,
                        ordinal: "%d.",
                        week: { dow: 1, doy: 4 },
                    });
                    return deCh;
                });
            },
            "./node_modules/moment/locale/de.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    function processRelativeTime(number, withoutSuffix, key, isFuture) {
                        var format = {
                            m: ["eine Minute", "einer Minute"],
                            h: ["eine Stunde", "einer Stunde"],
                            d: ["ein Tag", "einem Tag"],
                            dd: [number + " Tage", number + " Tagen"],
                            w: ["eine Woche", "einer Woche"],
                            M: ["ein Monat", "einem Monat"],
                            MM: [number + " Monate", number + " Monaten"],
                            y: ["ein Jahr", "einem Jahr"],
                            yy: [number + " Jahre", number + " Jahren"],
                        };
                        return withoutSuffix ? format[key][0] : format[key][1];
                    }
                    var de = moment.defineLocale("de", {
                        months: "Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
                        monthsShort: "Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),
                        monthsParseExact: true,
                        weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
                        weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),
                        weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY HH:mm", LLLL: "dddd, D. MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[heute um] LT [Uhr]", sameElse: "L", nextDay: "[morgen um] LT [Uhr]", nextWeek: "dddd [um] LT [Uhr]", lastDay: "[gestern um] LT [Uhr]", lastWeek: "[letzten] dddd [um] LT [Uhr]" },
                        relativeTime: {
                            future: "in %s",
                            past: "vor %s",
                            s: "ein paar Sekunden",
                            ss: "%d Sekunden",
                            m: processRelativeTime,
                            mm: "%d Minuten",
                            h: processRelativeTime,
                            hh: "%d Stunden",
                            d: processRelativeTime,
                            dd: processRelativeTime,
                            w: processRelativeTime,
                            ww: "%d Wochen",
                            M: processRelativeTime,
                            MM: processRelativeTime,
                            y: processRelativeTime,
                            yy: processRelativeTime,
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}\./,
                        ordinal: "%d.",
                        week: { dow: 1, doy: 4 },
                    });
                    return de;
                });
            },
            "./node_modules/moment/locale/dv.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var months = ["ޖެނުއަރީ", "ފެބްރުއަރީ", "މާރިޗު", "އޭޕްރީލު", "މޭ", "ޖޫން", "ޖުލައި", "އޯގަސްޓު", "ސެޕްޓެމްބަރު", "އޮކްޓޯބަރު", "ނޮވެމްބަރު", "ޑިސެމްބަރު"],
                        weekdays = ["އާދިއްތަ", "ހޯމަ", "އަންގާރަ", "ބުދަ", "ބުރާސްފަތި", "ހުކުރު", "ހޮނިހިރު"];
                    var dv = moment.defineLocale("dv", {
                        months: months,
                        monthsShort: months,
                        weekdays: weekdays,
                        weekdaysShort: weekdays,
                        weekdaysMin: "އާދި_ހޯމަ_އަން_ބުދަ_ބުރާ_ހުކު_ހޮނި".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "D/M/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" },
                        meridiemParse: /މކ|މފ/,
                        isPM: function (input) {
                            return "މފ" === input;
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 12) {
                                return "މކ";
                            } else {
                                return "މފ";
                            }
                        },
                        calendar: { sameDay: "[މިއަދު] LT", nextDay: "[މާދަމާ] LT", nextWeek: "dddd LT", lastDay: "[އިއްޔެ] LT", lastWeek: "[ފާއިތުވި] dddd LT", sameElse: "L" },
                        relativeTime: {
                            future: "ތެރޭގައި %s",
                            past: "ކުރިން %s",
                            s: "ސިކުންތުކޮޅެއް",
                            ss: "d% ސިކުންތު",
                            m: "މިނިޓެއް",
                            mm: "މިނިޓު %d",
                            h: "ގަޑިއިރެއް",
                            hh: "ގަޑިއިރު %d",
                            d: "ދުވަހެއް",
                            dd: "ދުވަސް %d",
                            M: "މަހެއް",
                            MM: "މަސް %d",
                            y: "އަހަރެއް",
                            yy: "އަހަރު %d",
                        },
                        preparse: function (string) {
                            return string.replace(/،/g, ",");
                        },
                        postformat: function (string) {
                            return string.replace(/,/g, "،");
                        },
                        week: { dow: 7, doy: 12 },
                    });
                    return dv;
                });
            },
            "./node_modules/moment/locale/el.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    function isFunction(input) {
                        return (typeof Function !== "undefined" && input instanceof Function) || Object.prototype.toString.call(input) === "[object Function]";
                    }
                    var el = moment.defineLocale("el", {
                        monthsNominativeEl: "Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος".split("_"),
                        monthsGenitiveEl: "Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου".split("_"),
                        months: function (momentToFormat, format) {
                            if (!momentToFormat) {
                                return this._monthsNominativeEl;
                            } else if (typeof format === "string" && /D/.test(format.substring(0, format.indexOf("MMMM")))) {
                                return this._monthsGenitiveEl[momentToFormat.month()];
                            } else {
                                return this._monthsNominativeEl[momentToFormat.month()];
                            }
                        },
                        monthsShort: "Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ".split("_"),
                        weekdays: "Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο".split("_"),
                        weekdaysShort: "Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ".split("_"),
                        weekdaysMin: "Κυ_Δε_Τρ_Τε_Πε_Πα_Σα".split("_"),
                        meridiem: function (hours, minutes, isLower) {
                            if (hours > 11) {
                                return isLower ? "μμ" : "ΜΜ";
                            } else {
                                return isLower ? "πμ" : "ΠΜ";
                            }
                        },
                        isPM: function (input) {
                            return (input + "").toLowerCase()[0] === "μ";
                        },
                        meridiemParse: /[ΠΜ]\.?Μ?\.?/i,
                        longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" },
                        calendarEl: {
                            sameDay: "[Σήμερα {}] LT",
                            nextDay: "[Αύριο {}] LT",
                            nextWeek: "dddd [{}] LT",
                            lastDay: "[Χθες {}] LT",
                            lastWeek: function () {
                                switch (this.day()) {
                                    case 6:
                                        return "[το προηγούμενο] dddd [{}] LT";
                                    default:
                                        return "[την προηγούμενη] dddd [{}] LT";
                                }
                            },
                            sameElse: "L",
                        },
                        calendar: function (key, mom) {
                            var output = this._calendarEl[key],
                                hours = mom && mom.hours();
                            if (isFunction(output)) {
                                output = output.apply(mom);
                            }
                            return output.replace("{}", hours % 12 === 1 ? "στη" : "στις");
                        },
                        relativeTime: {
                            future: "σε %s",
                            past: "%s πριν",
                            s: "λίγα δευτερόλεπτα",
                            ss: "%d δευτερόλεπτα",
                            m: "ένα λεπτό",
                            mm: "%d λεπτά",
                            h: "μία ώρα",
                            hh: "%d ώρες",
                            d: "μία μέρα",
                            dd: "%d μέρες",
                            M: "ένας μήνας",
                            MM: "%d μήνες",
                            y: "ένας χρόνος",
                            yy: "%d χρόνια",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}η/,
                        ordinal: "%dη",
                        week: { dow: 1, doy: 4 },
                    });
                    return el;
                });
            },
            "./node_modules/moment/locale/en-au.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var enAu = moment.defineLocale("en-au", {
                        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
                        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
                        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
                        longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" },
                        calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" },
                        relativeTime: {
                            future: "in %s",
                            past: "%s ago",
                            s: "a few seconds",
                            ss: "%d seconds",
                            m: "a minute",
                            mm: "%d minutes",
                            h: "an hour",
                            hh: "%d hours",
                            d: "a day",
                            dd: "%d days",
                            M: "a month",
                            MM: "%d months",
                            y: "a year",
                            yy: "%d years",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
                        ordinal: function (number) {
                            var b = number % 10,
                                output = ~~((number % 100) / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
                            return number + output;
                        },
                        week: { dow: 0, doy: 4 },
                    });
                    return enAu;
                });
            },
            "./node_modules/moment/locale/en-ca.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var enCa = moment.defineLocale("en-ca", {
                        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
                        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
                        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
                        longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "YYYY-MM-DD", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" },
                        calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" },
                        relativeTime: {
                            future: "in %s",
                            past: "%s ago",
                            s: "a few seconds",
                            ss: "%d seconds",
                            m: "a minute",
                            mm: "%d minutes",
                            h: "an hour",
                            hh: "%d hours",
                            d: "a day",
                            dd: "%d days",
                            M: "a month",
                            MM: "%d months",
                            y: "a year",
                            yy: "%d years",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
                        ordinal: function (number) {
                            var b = number % 10,
                                output = ~~((number % 100) / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
                            return number + output;
                        },
                    });
                    return enCa;
                });
            },
            "./node_modules/moment/locale/en-gb.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var enGb = moment.defineLocale("en-gb", {
                        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
                        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
                        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" },
                        relativeTime: {
                            future: "in %s",
                            past: "%s ago",
                            s: "a few seconds",
                            ss: "%d seconds",
                            m: "a minute",
                            mm: "%d minutes",
                            h: "an hour",
                            hh: "%d hours",
                            d: "a day",
                            dd: "%d days",
                            M: "a month",
                            MM: "%d months",
                            y: "a year",
                            yy: "%d years",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
                        ordinal: function (number) {
                            var b = number % 10,
                                output = ~~((number % 100) / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
                            return number + output;
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return enGb;
                });
            },
            "./node_modules/moment/locale/en-ie.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var enIe = moment.defineLocale("en-ie", {
                        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
                        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
                        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" },
                        relativeTime: {
                            future: "in %s",
                            past: "%s ago",
                            s: "a few seconds",
                            ss: "%d seconds",
                            m: "a minute",
                            mm: "%d minutes",
                            h: "an hour",
                            hh: "%d hours",
                            d: "a day",
                            dd: "%d days",
                            M: "a month",
                            MM: "%d months",
                            y: "a year",
                            yy: "%d years",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
                        ordinal: function (number) {
                            var b = number % 10,
                                output = ~~((number % 100) / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
                            return number + output;
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return enIe;
                });
            },
            "./node_modules/moment/locale/en-il.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var enIl = moment.defineLocale("en-il", {
                        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
                        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
                        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" },
                        relativeTime: {
                            future: "in %s",
                            past: "%s ago",
                            s: "a few seconds",
                            ss: "%d seconds",
                            m: "a minute",
                            mm: "%d minutes",
                            h: "an hour",
                            hh: "%d hours",
                            d: "a day",
                            dd: "%d days",
                            M: "a month",
                            MM: "%d months",
                            y: "a year",
                            yy: "%d years",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
                        ordinal: function (number) {
                            var b = number % 10,
                                output = ~~((number % 100) / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
                            return number + output;
                        },
                    });
                    return enIl;
                });
            },
            "./node_modules/moment/locale/en-in.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var enIn = moment.defineLocale("en-in", {
                        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
                        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
                        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
                        longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" },
                        calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" },
                        relativeTime: {
                            future: "in %s",
                            past: "%s ago",
                            s: "a few seconds",
                            ss: "%d seconds",
                            m: "a minute",
                            mm: "%d minutes",
                            h: "an hour",
                            hh: "%d hours",
                            d: "a day",
                            dd: "%d days",
                            M: "a month",
                            MM: "%d months",
                            y: "a year",
                            yy: "%d years",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
                        ordinal: function (number) {
                            var b = number % 10,
                                output = ~~((number % 100) / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
                            return number + output;
                        },
                        week: { dow: 0, doy: 6 },
                    });
                    return enIn;
                });
            },
            "./node_modules/moment/locale/en-nz.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var enNz = moment.defineLocale("en-nz", {
                        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
                        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
                        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
                        longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" },
                        calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" },
                        relativeTime: {
                            future: "in %s",
                            past: "%s ago",
                            s: "a few seconds",
                            ss: "%d seconds",
                            m: "a minute",
                            mm: "%d minutes",
                            h: "an hour",
                            hh: "%d hours",
                            d: "a day",
                            dd: "%d days",
                            M: "a month",
                            MM: "%d months",
                            y: "a year",
                            yy: "%d years",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
                        ordinal: function (number) {
                            var b = number % 10,
                                output = ~~((number % 100) / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
                            return number + output;
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return enNz;
                });
            },
            "./node_modules/moment/locale/en-sg.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var enSg = moment.defineLocale("en-sg", {
                        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                        monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
                        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                        weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
                        weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" },
                        relativeTime: {
                            future: "in %s",
                            past: "%s ago",
                            s: "a few seconds",
                            ss: "%d seconds",
                            m: "a minute",
                            mm: "%d minutes",
                            h: "an hour",
                            hh: "%d hours",
                            d: "a day",
                            dd: "%d days",
                            M: "a month",
                            MM: "%d months",
                            y: "a year",
                            yy: "%d years",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
                        ordinal: function (number) {
                            var b = number % 10,
                                output = ~~((number % 100) / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
                            return number + output;
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return enSg;
                });
            },
            "./node_modules/moment/locale/eo.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var eo = moment.defineLocale("eo", {
                        months: "januaro_februaro_marto_aprilo_majo_junio_julio_aŭgusto_septembro_oktobro_novembro_decembro".split("_"),
                        monthsShort: "jan_feb_mart_apr_maj_jun_jul_aŭg_sept_okt_nov_dec".split("_"),
                        weekdays: "dimanĉo_lundo_mardo_merkredo_ĵaŭdo_vendredo_sabato".split("_"),
                        weekdaysShort: "dim_lun_mard_merk_ĵaŭ_ven_sab".split("_"),
                        weekdaysMin: "di_lu_ma_me_ĵa_ve_sa".split("_"),
                        longDateFormat: {
                            LT: "HH:mm",
                            LTS: "HH:mm:ss",
                            L: "YYYY-MM-DD",
                            LL: "[la] D[-an de] MMMM, YYYY",
                            LLL: "[la] D[-an de] MMMM, YYYY HH:mm",
                            LLLL: "dddd[n], [la] D[-an de] MMMM, YYYY HH:mm",
                            llll: "ddd, [la] D[-an de] MMM, YYYY HH:mm",
                        },
                        meridiemParse: /[ap]\.t\.m/i,
                        isPM: function (input) {
                            return input.charAt(0).toLowerCase() === "p";
                        },
                        meridiem: function (hours, minutes, isLower) {
                            if (hours > 11) {
                                return isLower ? "p.t.m." : "P.T.M.";
                            } else {
                                return isLower ? "a.t.m." : "A.T.M.";
                            }
                        },
                        calendar: { sameDay: "[Hodiaŭ je] LT", nextDay: "[Morgaŭ je] LT", nextWeek: "dddd[n je] LT", lastDay: "[Hieraŭ je] LT", lastWeek: "[pasintan] dddd[n je] LT", sameElse: "L" },
                        relativeTime: {
                            future: "post %s",
                            past: "antaŭ %s",
                            s: "kelkaj sekundoj",
                            ss: "%d sekundoj",
                            m: "unu minuto",
                            mm: "%d minutoj",
                            h: "unu horo",
                            hh: "%d horoj",
                            d: "unu tago",
                            dd: "%d tagoj",
                            M: "unu monato",
                            MM: "%d monatoj",
                            y: "unu jaro",
                            yy: "%d jaroj",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}a/,
                        ordinal: "%da",
                        week: { dow: 1, doy: 7 },
                    });
                    return eo;
                });
            },
            "./node_modules/moment/locale/es-do.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var monthsShortDot = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"),
                        monthsShort = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"),
                        monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i],
                        monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
                    var esDo = moment.defineLocale("es-do", {
                        months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
                        monthsShort: function (m, format) {
                            if (!m) {
                                return monthsShortDot;
                            } else if (/-MMM-/.test(format)) {
                                return monthsShort[m.month()];
                            } else {
                                return monthsShortDot[m.month()];
                            }
                        },
                        monthsRegex: monthsRegex,
                        monthsShortRegex: monthsRegex,
                        monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
                        monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
                        monthsParse: monthsParse,
                        longMonthsParse: monthsParse,
                        shortMonthsParse: monthsParse,
                        weekdays: "domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"),
                        weekdaysShort: "dom._lun._mar._mié._jue._vie._sáb.".split("_"),
                        weekdaysMin: "do_lu_ma_mi_ju_vi_sá".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY h:mm A", LLLL: "dddd, D [de] MMMM [de] YYYY h:mm A" },
                        calendar: {
                            sameDay: function () {
                                return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                            },
                            nextDay: function () {
                                return "[mañana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                            },
                            nextWeek: function () {
                                return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                            },
                            lastDay: function () {
                                return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                            },
                            lastWeek: function () {
                                return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                            },
                            sameElse: "L",
                        },
                        relativeTime: {
                            future: "en %s",
                            past: "hace %s",
                            s: "unos segundos",
                            ss: "%d segundos",
                            m: "un minuto",
                            mm: "%d minutos",
                            h: "una hora",
                            hh: "%d horas",
                            d: "un día",
                            dd: "%d días",
                            w: "una semana",
                            ww: "%d semanas",
                            M: "un mes",
                            MM: "%d meses",
                            y: "un año",
                            yy: "%d años",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}º/,
                        ordinal: "%dº",
                        week: { dow: 1, doy: 4 },
                    });
                    return esDo;
                });
            },
            "./node_modules/moment/locale/es-mx.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var monthsShortDot = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"),
                        monthsShort = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"),
                        monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i],
                        monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
                    var esMx = moment.defineLocale("es-mx", {
                        months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
                        monthsShort: function (m, format) {
                            if (!m) {
                                return monthsShortDot;
                            } else if (/-MMM-/.test(format)) {
                                return monthsShort[m.month()];
                            } else {
                                return monthsShortDot[m.month()];
                            }
                        },
                        monthsRegex: monthsRegex,
                        monthsShortRegex: monthsRegex,
                        monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
                        monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
                        monthsParse: monthsParse,
                        longMonthsParse: monthsParse,
                        shortMonthsParse: monthsParse,
                        weekdays: "domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"),
                        weekdaysShort: "dom._lun._mar._mié._jue._vie._sáb.".split("_"),
                        weekdaysMin: "do_lu_ma_mi_ju_vi_sá".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY H:mm", LLLL: "dddd, D [de] MMMM [de] YYYY H:mm" },
                        calendar: {
                            sameDay: function () {
                                return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                            },
                            nextDay: function () {
                                return "[mañana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                            },
                            nextWeek: function () {
                                return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                            },
                            lastDay: function () {
                                return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                            },
                            lastWeek: function () {
                                return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                            },
                            sameElse: "L",
                        },
                        relativeTime: {
                            future: "en %s",
                            past: "hace %s",
                            s: "unos segundos",
                            ss: "%d segundos",
                            m: "un minuto",
                            mm: "%d minutos",
                            h: "una hora",
                            hh: "%d horas",
                            d: "un día",
                            dd: "%d días",
                            w: "una semana",
                            ww: "%d semanas",
                            M: "un mes",
                            MM: "%d meses",
                            y: "un año",
                            yy: "%d años",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}º/,
                        ordinal: "%dº",
                        week: { dow: 0, doy: 4 },
                        invalidDate: "Fecha inválida",
                    });
                    return esMx;
                });
            },
            "./node_modules/moment/locale/es-us.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var monthsShortDot = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"),
                        monthsShort = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"),
                        monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i],
                        monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
                    var esUs = moment.defineLocale("es-us", {
                        months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
                        monthsShort: function (m, format) {
                            if (!m) {
                                return monthsShortDot;
                            } else if (/-MMM-/.test(format)) {
                                return monthsShort[m.month()];
                            } else {
                                return monthsShortDot[m.month()];
                            }
                        },
                        monthsRegex: monthsRegex,
                        monthsShortRegex: monthsRegex,
                        monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
                        monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
                        monthsParse: monthsParse,
                        longMonthsParse: monthsParse,
                        shortMonthsParse: monthsParse,
                        weekdays: "domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"),
                        weekdaysShort: "dom._lun._mar._mié._jue._vie._sáb.".split("_"),
                        weekdaysMin: "do_lu_ma_mi_ju_vi_sá".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "MM/DD/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY h:mm A", LLLL: "dddd, D [de] MMMM [de] YYYY h:mm A" },
                        calendar: {
                            sameDay: function () {
                                return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                            },
                            nextDay: function () {
                                return "[mañana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                            },
                            nextWeek: function () {
                                return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                            },
                            lastDay: function () {
                                return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                            },
                            lastWeek: function () {
                                return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                            },
                            sameElse: "L",
                        },
                        relativeTime: {
                            future: "en %s",
                            past: "hace %s",
                            s: "unos segundos",
                            ss: "%d segundos",
                            m: "un minuto",
                            mm: "%d minutos",
                            h: "una hora",
                            hh: "%d horas",
                            d: "un día",
                            dd: "%d días",
                            w: "una semana",
                            ww: "%d semanas",
                            M: "un mes",
                            MM: "%d meses",
                            y: "un año",
                            yy: "%d años",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}º/,
                        ordinal: "%dº",
                        week: { dow: 0, doy: 6 },
                    });
                    return esUs;
                });
            },
            "./node_modules/moment/locale/es.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var monthsShortDot = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"),
                        monthsShort = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"),
                        monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i],
                        monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
                    var es = moment.defineLocale("es", {
                        months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
                        monthsShort: function (m, format) {
                            if (!m) {
                                return monthsShortDot;
                            } else if (/-MMM-/.test(format)) {
                                return monthsShort[m.month()];
                            } else {
                                return monthsShortDot[m.month()];
                            }
                        },
                        monthsRegex: monthsRegex,
                        monthsShortRegex: monthsRegex,
                        monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
                        monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
                        monthsParse: monthsParse,
                        longMonthsParse: monthsParse,
                        shortMonthsParse: monthsParse,
                        weekdays: "domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"),
                        weekdaysShort: "dom._lun._mar._mié._jue._vie._sáb.".split("_"),
                        weekdaysMin: "do_lu_ma_mi_ju_vi_sá".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY H:mm", LLLL: "dddd, D [de] MMMM [de] YYYY H:mm" },
                        calendar: {
                            sameDay: function () {
                                return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                            },
                            nextDay: function () {
                                return "[mañana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                            },
                            nextWeek: function () {
                                return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                            },
                            lastDay: function () {
                                return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                            },
                            lastWeek: function () {
                                return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
                            },
                            sameElse: "L",
                        },
                        relativeTime: {
                            future: "en %s",
                            past: "hace %s",
                            s: "unos segundos",
                            ss: "%d segundos",
                            m: "un minuto",
                            mm: "%d minutos",
                            h: "una hora",
                            hh: "%d horas",
                            d: "un día",
                            dd: "%d días",
                            w: "una semana",
                            ww: "%d semanas",
                            M: "un mes",
                            MM: "%d meses",
                            y: "un año",
                            yy: "%d años",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}º/,
                        ordinal: "%dº",
                        week: { dow: 1, doy: 4 },
                        invalidDate: "Fecha inválida",
                    });
                    return es;
                });
            },
            "./node_modules/moment/locale/et.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    function processRelativeTime(number, withoutSuffix, key, isFuture) {
                        var format = {
                            s: ["mõne sekundi", "mõni sekund", "paar sekundit"],
                            ss: [number + "sekundi", number + "sekundit"],
                            m: ["ühe minuti", "üks minut"],
                            mm: [number + " minuti", number + " minutit"],
                            h: ["ühe tunni", "tund aega", "üks tund"],
                            hh: [number + " tunni", number + " tundi"],
                            d: ["ühe päeva", "üks päev"],
                            M: ["kuu aja", "kuu aega", "üks kuu"],
                            MM: [number + " kuu", number + " kuud"],
                            y: ["ühe aasta", "aasta", "üks aasta"],
                            yy: [number + " aasta", number + " aastat"],
                        };
                        if (withoutSuffix) {
                            return format[key][2] ? format[key][2] : format[key][1];
                        }
                        return isFuture ? format[key][0] : format[key][1];
                    }
                    var et = moment.defineLocale("et", {
                        months: "jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember".split("_"),
                        monthsShort: "jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets".split("_"),
                        weekdays: "pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev".split("_"),
                        weekdaysShort: "P_E_T_K_N_R_L".split("_"),
                        weekdaysMin: "P_E_T_K_N_R_L".split("_"),
                        longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd, D. MMMM YYYY H:mm" },
                        calendar: { sameDay: "[Täna,] LT", nextDay: "[Homme,] LT", nextWeek: "[Järgmine] dddd LT", lastDay: "[Eile,] LT", lastWeek: "[Eelmine] dddd LT", sameElse: "L" },
                        relativeTime: {
                            future: "%s pärast",
                            past: "%s tagasi",
                            s: processRelativeTime,
                            ss: processRelativeTime,
                            m: processRelativeTime,
                            mm: processRelativeTime,
                            h: processRelativeTime,
                            hh: processRelativeTime,
                            d: processRelativeTime,
                            dd: "%d päeva",
                            M: processRelativeTime,
                            MM: processRelativeTime,
                            y: processRelativeTime,
                            yy: processRelativeTime,
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}\./,
                        ordinal: "%d.",
                        week: { dow: 1, doy: 4 },
                    });
                    return et;
                });
            },
            "./node_modules/moment/locale/eu.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var eu = moment.defineLocale("eu", {
                        months: "urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua".split("_"),
                        monthsShort: "urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.".split("_"),
                        monthsParseExact: true,
                        weekdays: "igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata".split("_"),
                        weekdaysShort: "ig._al._ar._az._og._ol._lr.".split("_"),
                        weekdaysMin: "ig_al_ar_az_og_ol_lr".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: {
                            LT: "HH:mm",
                            LTS: "HH:mm:ss",
                            L: "YYYY-MM-DD",
                            LL: "YYYY[ko] MMMM[ren] D[a]",
                            LLL: "YYYY[ko] MMMM[ren] D[a] HH:mm",
                            LLLL: "dddd, YYYY[ko] MMMM[ren] D[a] HH:mm",
                            l: "YYYY-M-D",
                            ll: "YYYY[ko] MMM D[a]",
                            lll: "YYYY[ko] MMM D[a] HH:mm",
                            llll: "ddd, YYYY[ko] MMM D[a] HH:mm",
                        },
                        calendar: { sameDay: "[gaur] LT[etan]", nextDay: "[bihar] LT[etan]", nextWeek: "dddd LT[etan]", lastDay: "[atzo] LT[etan]", lastWeek: "[aurreko] dddd LT[etan]", sameElse: "L" },
                        relativeTime: {
                            future: "%s barru",
                            past: "duela %s",
                            s: "segundo batzuk",
                            ss: "%d segundo",
                            m: "minutu bat",
                            mm: "%d minutu",
                            h: "ordu bat",
                            hh: "%d ordu",
                            d: "egun bat",
                            dd: "%d egun",
                            M: "hilabete bat",
                            MM: "%d hilabete",
                            y: "urte bat",
                            yy: "%d urte",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}\./,
                        ordinal: "%d.",
                        week: { dow: 1, doy: 7 },
                    });
                    return eu;
                });
            },
            "./node_modules/moment/locale/fa.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var symbolMap = { 1: "۱", 2: "۲", 3: "۳", 4: "۴", 5: "۵", 6: "۶", 7: "۷", 8: "۸", 9: "۹", 0: "۰" },
                        numberMap = { "۱": "1", "۲": "2", "۳": "3", "۴": "4", "۵": "5", "۶": "6", "۷": "7", "۸": "8", "۹": "9", "۰": "0" };
                    var fa = moment.defineLocale("fa", {
                        months: "ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر".split("_"),
                        monthsShort: "ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر".split("_"),
                        weekdays: "یک‌شنبه_دوشنبه_سه‌شنبه_چهارشنبه_پنج‌شنبه_جمعه_شنبه".split("_"),
                        weekdaysShort: "یک‌شنبه_دوشنبه_سه‌شنبه_چهارشنبه_پنج‌شنبه_جمعه_شنبه".split("_"),
                        weekdaysMin: "ی_د_س_چ_پ_ج_ش".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" },
                        meridiemParse: /قبل از ظهر|بعد از ظهر/,
                        isPM: function (input) {
                            return /بعد از ظهر/.test(input);
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 12) {
                                return "قبل از ظهر";
                            } else {
                                return "بعد از ظهر";
                            }
                        },
                        calendar: { sameDay: "[امروز ساعت] LT", nextDay: "[فردا ساعت] LT", nextWeek: "dddd [ساعت] LT", lastDay: "[دیروز ساعت] LT", lastWeek: "dddd [پیش] [ساعت] LT", sameElse: "L" },
                        relativeTime: {
                            future: "در %s",
                            past: "%s پیش",
                            s: "چند ثانیه",
                            ss: "%d ثانیه",
                            m: "یک دقیقه",
                            mm: "%d دقیقه",
                            h: "یک ساعت",
                            hh: "%d ساعت",
                            d: "یک روز",
                            dd: "%d روز",
                            M: "یک ماه",
                            MM: "%d ماه",
                            y: "یک سال",
                            yy: "%d سال",
                        },
                        preparse: function (string) {
                            return string
                                .replace(/[۰-۹]/g, function (match) {
                                    return numberMap[match];
                                })
                                .replace(/،/g, ",");
                        },
                        postformat: function (string) {
                            return string
                                .replace(/\d/g, function (match) {
                                    return symbolMap[match];
                                })
                                .replace(/,/g, "،");
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}م/,
                        ordinal: "%dم",
                        week: { dow: 6, doy: 12 },
                    });
                    return fa;
                });
            },
            "./node_modules/moment/locale/fi.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var numbersPast = "nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän".split(" "),
                        numbersFuture = ["nolla", "yhden", "kahden", "kolmen", "neljän", "viiden", "kuuden", numbersPast[7], numbersPast[8], numbersPast[9]];
                    function translate(number, withoutSuffix, key, isFuture) {
                        var result = "";
                        switch (key) {
                            case "s":
                                return isFuture ? "muutaman sekunnin" : "muutama sekunti";
                            case "ss":
                                result = isFuture ? "sekunnin" : "sekuntia";
                                break;
                            case "m":
                                return isFuture ? "minuutin" : "minuutti";
                            case "mm":
                                result = isFuture ? "minuutin" : "minuuttia";
                                break;
                            case "h":
                                return isFuture ? "tunnin" : "tunti";
                            case "hh":
                                result = isFuture ? "tunnin" : "tuntia";
                                break;
                            case "d":
                                return isFuture ? "päivän" : "päivä";
                            case "dd":
                                result = isFuture ? "päivän" : "päivää";
                                break;
                            case "M":
                                return isFuture ? "kuukauden" : "kuukausi";
                            case "MM":
                                result = isFuture ? "kuukauden" : "kuukautta";
                                break;
                            case "y":
                                return isFuture ? "vuoden" : "vuosi";
                            case "yy":
                                result = isFuture ? "vuoden" : "vuotta";
                                break;
                        }
                        result = verbalNumber(number, isFuture) + " " + result;
                        return result;
                    }
                    function verbalNumber(number, isFuture) {
                        return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
                    }
                    var fi = moment.defineLocale("fi", {
                        months: "tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu".split("_"),
                        monthsShort: "tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu".split("_"),
                        weekdays: "sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai".split("_"),
                        weekdaysShort: "su_ma_ti_ke_to_pe_la".split("_"),
                        weekdaysMin: "su_ma_ti_ke_to_pe_la".split("_"),
                        longDateFormat: {
                            LT: "HH.mm",
                            LTS: "HH.mm.ss",
                            L: "DD.MM.YYYY",
                            LL: "Do MMMM[ta] YYYY",
                            LLL: "Do MMMM[ta] YYYY, [klo] HH.mm",
                            LLLL: "dddd, Do MMMM[ta] YYYY, [klo] HH.mm",
                            l: "D.M.YYYY",
                            ll: "Do MMM YYYY",
                            lll: "Do MMM YYYY, [klo] HH.mm",
                            llll: "ddd, Do MMM YYYY, [klo] HH.mm",
                        },
                        calendar: { sameDay: "[tänään] [klo] LT", nextDay: "[huomenna] [klo] LT", nextWeek: "dddd [klo] LT", lastDay: "[eilen] [klo] LT", lastWeek: "[viime] dddd[na] [klo] LT", sameElse: "L" },
                        relativeTime: {
                            future: "%s päästä",
                            past: "%s sitten",
                            s: translate,
                            ss: translate,
                            m: translate,
                            mm: translate,
                            h: translate,
                            hh: translate,
                            d: translate,
                            dd: translate,
                            M: translate,
                            MM: translate,
                            y: translate,
                            yy: translate,
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}\./,
                        ordinal: "%d.",
                        week: { dow: 1, doy: 4 },
                    });
                    return fi;
                });
            },
            "./node_modules/moment/locale/fil.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var fil = moment.defineLocale("fil", {
                        months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"),
                        monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"),
                        weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"),
                        weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"),
                        weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "MM/D/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY HH:mm", LLLL: "dddd, MMMM DD, YYYY HH:mm" },
                        calendar: { sameDay: "LT [ngayong araw]", nextDay: "[Bukas ng] LT", nextWeek: "LT [sa susunod na] dddd", lastDay: "LT [kahapon]", lastWeek: "LT [noong nakaraang] dddd", sameElse: "L" },
                        relativeTime: {
                            future: "sa loob ng %s",
                            past: "%s ang nakalipas",
                            s: "ilang segundo",
                            ss: "%d segundo",
                            m: "isang minuto",
                            mm: "%d minuto",
                            h: "isang oras",
                            hh: "%d oras",
                            d: "isang araw",
                            dd: "%d araw",
                            M: "isang buwan",
                            MM: "%d buwan",
                            y: "isang taon",
                            yy: "%d taon",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}/,
                        ordinal: function (number) {
                            return number;
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return fil;
                });
            },
            "./node_modules/moment/locale/fo.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var fo = moment.defineLocale("fo", {
                        months: "januar_februar_mars_apríl_mai_juni_juli_august_september_oktober_november_desember".split("_"),
                        monthsShort: "jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"),
                        weekdays: "sunnudagur_mánadagur_týsdagur_mikudagur_hósdagur_fríggjadagur_leygardagur".split("_"),
                        weekdaysShort: "sun_mán_týs_mik_hós_frí_ley".split("_"),
                        weekdaysMin: "su_má_tý_mi_hó_fr_le".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D. MMMM, YYYY HH:mm" },
                        calendar: { sameDay: "[Í dag kl.] LT", nextDay: "[Í morgin kl.] LT", nextWeek: "dddd [kl.] LT", lastDay: "[Í gjár kl.] LT", lastWeek: "[síðstu] dddd [kl] LT", sameElse: "L" },
                        relativeTime: {
                            future: "um %s",
                            past: "%s síðani",
                            s: "fá sekund",
                            ss: "%d sekundir",
                            m: "ein minuttur",
                            mm: "%d minuttir",
                            h: "ein tími",
                            hh: "%d tímar",
                            d: "ein dagur",
                            dd: "%d dagar",
                            M: "ein mánaður",
                            MM: "%d mánaðir",
                            y: "eitt ár",
                            yy: "%d ár",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}\./,
                        ordinal: "%d.",
                        week: { dow: 1, doy: 4 },
                    });
                    return fo;
                });
            },
            "./node_modules/moment/locale/fr-ca.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var frCa = moment.defineLocale("fr-ca", {
                        months: "janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre".split("_"),
                        monthsShort: "janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.".split("_"),
                        monthsParseExact: true,
                        weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
                        weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
                        weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[Aujourd’hui à] LT", nextDay: "[Demain à] LT", nextWeek: "dddd [à] LT", lastDay: "[Hier à] LT", lastWeek: "dddd [dernier à] LT", sameElse: "L" },
                        relativeTime: {
                            future: "dans %s",
                            past: "il y a %s",
                            s: "quelques secondes",
                            ss: "%d secondes",
                            m: "une minute",
                            mm: "%d minutes",
                            h: "une heure",
                            hh: "%d heures",
                            d: "un jour",
                            dd: "%d jours",
                            M: "un mois",
                            MM: "%d mois",
                            y: "un an",
                            yy: "%d ans",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
                        ordinal: function (number, period) {
                            switch (period) {
                                default:
                                case "M":
                                case "Q":
                                case "D":
                                case "DDD":
                                case "d":
                                    return number + (number === 1 ? "er" : "e");
                                case "w":
                                case "W":
                                    return number + (number === 1 ? "re" : "e");
                            }
                        },
                    });
                    return frCa;
                });
            },
            "./node_modules/moment/locale/fr-ch.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var frCh = moment.defineLocale("fr-ch", {
                        months: "janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre".split("_"),
                        monthsShort: "janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.".split("_"),
                        monthsParseExact: true,
                        weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
                        weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
                        weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[Aujourd’hui à] LT", nextDay: "[Demain à] LT", nextWeek: "dddd [à] LT", lastDay: "[Hier à] LT", lastWeek: "dddd [dernier à] LT", sameElse: "L" },
                        relativeTime: {
                            future: "dans %s",
                            past: "il y a %s",
                            s: "quelques secondes",
                            ss: "%d secondes",
                            m: "une minute",
                            mm: "%d minutes",
                            h: "une heure",
                            hh: "%d heures",
                            d: "un jour",
                            dd: "%d jours",
                            M: "un mois",
                            MM: "%d mois",
                            y: "un an",
                            yy: "%d ans",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
                        ordinal: function (number, period) {
                            switch (period) {
                                default:
                                case "M":
                                case "Q":
                                case "D":
                                case "DDD":
                                case "d":
                                    return number + (number === 1 ? "er" : "e");
                                case "w":
                                case "W":
                                    return number + (number === 1 ? "re" : "e");
                            }
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return frCh;
                });
            },
            "./node_modules/moment/locale/fr.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var monthsStrictRegex = /^(janvier|février|mars|avril|mai|juin|juillet|août|septembre|octobre|novembre|décembre)/i,
                        monthsShortStrictRegex = /(janv\.?|févr\.?|mars|avr\.?|mai|juin|juil\.?|août|sept\.?|oct\.?|nov\.?|déc\.?)/i,
                        monthsRegex = /(janv\.?|févr\.?|mars|avr\.?|mai|juin|juil\.?|août|sept\.?|oct\.?|nov\.?|déc\.?|janvier|février|mars|avril|mai|juin|juillet|août|septembre|octobre|novembre|décembre)/i,
                        monthsParse = [/^janv/i, /^févr/i, /^mars/i, /^avr/i, /^mai/i, /^juin/i, /^juil/i, /^août/i, /^sept/i, /^oct/i, /^nov/i, /^déc/i];
                    var fr = moment.defineLocale("fr", {
                        months: "janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre".split("_"),
                        monthsShort: "janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.".split("_"),
                        monthsRegex: monthsRegex,
                        monthsShortRegex: monthsRegex,
                        monthsStrictRegex: monthsStrictRegex,
                        monthsShortStrictRegex: monthsShortStrictRegex,
                        monthsParse: monthsParse,
                        longMonthsParse: monthsParse,
                        shortMonthsParse: monthsParse,
                        weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
                        weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
                        weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[Aujourd’hui à] LT", nextDay: "[Demain à] LT", nextWeek: "dddd [à] LT", lastDay: "[Hier à] LT", lastWeek: "dddd [dernier à] LT", sameElse: "L" },
                        relativeTime: {
                            future: "dans %s",
                            past: "il y a %s",
                            s: "quelques secondes",
                            ss: "%d secondes",
                            m: "une minute",
                            mm: "%d minutes",
                            h: "une heure",
                            hh: "%d heures",
                            d: "un jour",
                            dd: "%d jours",
                            w: "une semaine",
                            ww: "%d semaines",
                            M: "un mois",
                            MM: "%d mois",
                            y: "un an",
                            yy: "%d ans",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
                        ordinal: function (number, period) {
                            switch (period) {
                                case "D":
                                    return number + (number === 1 ? "er" : "");
                                default:
                                case "M":
                                case "Q":
                                case "DDD":
                                case "d":
                                    return number + (number === 1 ? "er" : "e");
                                case "w":
                                case "W":
                                    return number + (number === 1 ? "re" : "e");
                            }
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return fr;
                });
            },
            "./node_modules/moment/locale/fy.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var monthsShortWithDots = "jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.".split("_"),
                        monthsShortWithoutDots = "jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_");
                    var fy = moment.defineLocale("fy", {
                        months: "jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber".split("_"),
                        monthsShort: function (m, format) {
                            if (!m) {
                                return monthsShortWithDots;
                            } else if (/-MMM-/.test(format)) {
                                return monthsShortWithoutDots[m.month()];
                            } else {
                                return monthsShortWithDots[m.month()];
                            }
                        },
                        monthsParseExact: true,
                        weekdays: "snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon".split("_"),
                        weekdaysShort: "si._mo._ti._wo._to._fr._so.".split("_"),
                        weekdaysMin: "Si_Mo_Ti_Wo_To_Fr_So".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD-MM-YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[hjoed om] LT", nextDay: "[moarn om] LT", nextWeek: "dddd [om] LT", lastDay: "[juster om] LT", lastWeek: "[ôfrûne] dddd [om] LT", sameElse: "L" },
                        relativeTime: {
                            future: "oer %s",
                            past: "%s lyn",
                            s: "in pear sekonden",
                            ss: "%d sekonden",
                            m: "ien minút",
                            mm: "%d minuten",
                            h: "ien oere",
                            hh: "%d oeren",
                            d: "ien dei",
                            dd: "%d dagen",
                            M: "ien moanne",
                            MM: "%d moannen",
                            y: "ien jier",
                            yy: "%d jierren",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
                        ordinal: function (number) {
                            return number + (number === 1 || number === 8 || number >= 20 ? "ste" : "de");
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return fy;
                });
            },
            "./node_modules/moment/locale/ga.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var months = ["Eanáir", "Feabhra", "Márta", "Aibreán", "Bealtaine", "Meitheamh", "Iúil", "Lúnasa", "Meán Fómhair", "Deireadh Fómhair", "Samhain", "Nollaig"],
                        monthsShort = ["Ean", "Feabh", "Márt", "Aib", "Beal", "Meith", "Iúil", "Lún", "M.F.", "D.F.", "Samh", "Noll"],
                        weekdays = ["Dé Domhnaigh", "Dé Luain", "Dé Máirt", "Dé Céadaoin", "Déardaoin", "Dé hAoine", "Dé Sathairn"],
                        weekdaysShort = ["Domh", "Luan", "Máirt", "Céad", "Déar", "Aoine", "Sath"],
                        weekdaysMin = ["Do", "Lu", "Má", "Cé", "Dé", "A", "Sa"];
                    var ga = moment.defineLocale("ga", {
                        months: months,
                        monthsShort: monthsShort,
                        monthsParseExact: true,
                        weekdays: weekdays,
                        weekdaysShort: weekdaysShort,
                        weekdaysMin: weekdaysMin,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[Inniu ag] LT", nextDay: "[Amárach ag] LT", nextWeek: "dddd [ag] LT", lastDay: "[Inné ag] LT", lastWeek: "dddd [seo caite] [ag] LT", sameElse: "L" },
                        relativeTime: {
                            future: "i %s",
                            past: "%s ó shin",
                            s: "cúpla soicind",
                            ss: "%d soicind",
                            m: "nóiméad",
                            mm: "%d nóiméad",
                            h: "uair an chloig",
                            hh: "%d uair an chloig",
                            d: "lá",
                            dd: "%d lá",
                            M: "mí",
                            MM: "%d míonna",
                            y: "bliain",
                            yy: "%d bliain",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
                        ordinal: function (number) {
                            var output = number === 1 ? "d" : number % 10 === 2 ? "na" : "mh";
                            return number + output;
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return ga;
                });
            },
            "./node_modules/moment/locale/gd.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var months = ["Am Faoilleach", "An Gearran", "Am Màrt", "An Giblean", "An Cèitean", "An t-Ògmhios", "An t-Iuchar", "An Lùnastal", "An t-Sultain", "An Dàmhair", "An t-Samhain", "An Dùbhlachd"],
                        monthsShort = ["Faoi", "Gear", "Màrt", "Gibl", "Cèit", "Ògmh", "Iuch", "Lùn", "Sult", "Dàmh", "Samh", "Dùbh"],
                        weekdays = ["Didòmhnaich", "Diluain", "Dimàirt", "Diciadain", "Diardaoin", "Dihaoine", "Disathairne"],
                        weekdaysShort = ["Did", "Dil", "Dim", "Dic", "Dia", "Dih", "Dis"],
                        weekdaysMin = ["Dò", "Lu", "Mà", "Ci", "Ar", "Ha", "Sa"];
                    var gd = moment.defineLocale("gd", {
                        months: months,
                        monthsShort: monthsShort,
                        monthsParseExact: true,
                        weekdays: weekdays,
                        weekdaysShort: weekdaysShort,
                        weekdaysMin: weekdaysMin,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[An-diugh aig] LT", nextDay: "[A-màireach aig] LT", nextWeek: "dddd [aig] LT", lastDay: "[An-dè aig] LT", lastWeek: "dddd [seo chaidh] [aig] LT", sameElse: "L" },
                        relativeTime: {
                            future: "ann an %s",
                            past: "bho chionn %s",
                            s: "beagan diogan",
                            ss: "%d diogan",
                            m: "mionaid",
                            mm: "%d mionaidean",
                            h: "uair",
                            hh: "%d uairean",
                            d: "latha",
                            dd: "%d latha",
                            M: "mìos",
                            MM: "%d mìosan",
                            y: "bliadhna",
                            yy: "%d bliadhna",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
                        ordinal: function (number) {
                            var output = number === 1 ? "d" : number % 10 === 2 ? "na" : "mh";
                            return number + output;
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return gd;
                });
            },
            "./node_modules/moment/locale/gl.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var gl = moment.defineLocale("gl", {
                        months: "xaneiro_febreiro_marzo_abril_maio_xuño_xullo_agosto_setembro_outubro_novembro_decembro".split("_"),
                        monthsShort: "xan._feb._mar._abr._mai._xuñ._xul._ago._set._out._nov._dec.".split("_"),
                        monthsParseExact: true,
                        weekdays: "domingo_luns_martes_mércores_xoves_venres_sábado".split("_"),
                        weekdaysShort: "dom._lun._mar._mér._xov._ven._sáb.".split("_"),
                        weekdaysMin: "do_lu_ma_mé_xo_ve_sá".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY H:mm", LLLL: "dddd, D [de] MMMM [de] YYYY H:mm" },
                        calendar: {
                            sameDay: function () {
                                return "[hoxe " + (this.hours() !== 1 ? "ás" : "á") + "] LT";
                            },
                            nextDay: function () {
                                return "[mañá " + (this.hours() !== 1 ? "ás" : "á") + "] LT";
                            },
                            nextWeek: function () {
                                return "dddd [" + (this.hours() !== 1 ? "ás" : "a") + "] LT";
                            },
                            lastDay: function () {
                                return "[onte " + (this.hours() !== 1 ? "á" : "a") + "] LT";
                            },
                            lastWeek: function () {
                                return "[o] dddd [pasado " + (this.hours() !== 1 ? "ás" : "a") + "] LT";
                            },
                            sameElse: "L",
                        },
                        relativeTime: {
                            future: function (str) {
                                if (str.indexOf("un") === 0) {
                                    return "n" + str;
                                }
                                return "en " + str;
                            },
                            past: "hai %s",
                            s: "uns segundos",
                            ss: "%d segundos",
                            m: "un minuto",
                            mm: "%d minutos",
                            h: "unha hora",
                            hh: "%d horas",
                            d: "un día",
                            dd: "%d días",
                            M: "un mes",
                            MM: "%d meses",
                            y: "un ano",
                            yy: "%d anos",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}º/,
                        ordinal: "%dº",
                        week: { dow: 1, doy: 4 },
                    });
                    return gl;
                });
            },
            "./node_modules/moment/locale/gom-deva.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    function processRelativeTime(number, withoutSuffix, key, isFuture) {
                        var format = {
                            s: ["थोडया सॅकंडांनी", "थोडे सॅकंड"],
                            ss: [number + " सॅकंडांनी", number + " सॅकंड"],
                            m: ["एका मिणटान", "एक मिनूट"],
                            mm: [number + " मिणटांनी", number + " मिणटां"],
                            h: ["एका वरान", "एक वर"],
                            hh: [number + " वरांनी", number + " वरां"],
                            d: ["एका दिसान", "एक दीस"],
                            dd: [number + " दिसांनी", number + " दीस"],
                            M: ["एका म्हयन्यान", "एक म्हयनो"],
                            MM: [number + " म्हयन्यानी", number + " म्हयने"],
                            y: ["एका वर्सान", "एक वर्स"],
                            yy: [number + " वर्सांनी", number + " वर्सां"],
                        };
                        return isFuture ? format[key][0] : format[key][1];
                    }
                    var gomDeva = moment.defineLocale("gom-deva", {
                        months: {
                            standalone: "जानेवारी_फेब्रुवारी_मार्च_एप्रील_मे_जून_जुलय_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर".split("_"),
                            format: "जानेवारीच्या_फेब्रुवारीच्या_मार्चाच्या_एप्रीलाच्या_मेयाच्या_जूनाच्या_जुलयाच्या_ऑगस्टाच्या_सप्टेंबराच्या_ऑक्टोबराच्या_नोव्हेंबराच्या_डिसेंबराच्या".split("_"),
                            isFormat: /MMMM(\s)+D[oD]?/,
                        },
                        monthsShort: "जाने._फेब्रु._मार्च_एप्री._मे_जून_जुल._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.".split("_"),
                        monthsParseExact: true,
                        weekdays: "आयतार_सोमार_मंगळार_बुधवार_बिरेस्तार_सुक्रार_शेनवार".split("_"),
                        weekdaysShort: "आयत._सोम._मंगळ._बुध._ब्रेस्त._सुक्र._शेन.".split("_"),
                        weekdaysMin: "आ_सो_मं_बु_ब्रे_सु_शे".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: {
                            LT: "A h:mm [वाजतां]",
                            LTS: "A h:mm:ss [वाजतां]",
                            L: "DD-MM-YYYY",
                            LL: "D MMMM YYYY",
                            LLL: "D MMMM YYYY A h:mm [वाजतां]",
                            LLLL: "dddd, MMMM Do, YYYY, A h:mm [वाजतां]",
                            llll: "ddd, D MMM YYYY, A h:mm [वाजतां]",
                        },
                        calendar: { sameDay: "[आयज] LT", nextDay: "[फाल्यां] LT", nextWeek: "[फुडलो] dddd[,] LT", lastDay: "[काल] LT", lastWeek: "[फाटलो] dddd[,] LT", sameElse: "L" },
                        relativeTime: {
                            future: "%s",
                            past: "%s आदीं",
                            s: processRelativeTime,
                            ss: processRelativeTime,
                            m: processRelativeTime,
                            mm: processRelativeTime,
                            h: processRelativeTime,
                            hh: processRelativeTime,
                            d: processRelativeTime,
                            dd: processRelativeTime,
                            M: processRelativeTime,
                            MM: processRelativeTime,
                            y: processRelativeTime,
                            yy: processRelativeTime,
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(वेर)/,
                        ordinal: function (number, period) {
                            switch (period) {
                                case "D":
                                    return number + "वेर";
                                default:
                                case "M":
                                case "Q":
                                case "DDD":
                                case "d":
                                case "w":
                                case "W":
                                    return number;
                            }
                        },
                        week: { dow: 0, doy: 3 },
                        meridiemParse: /राती|सकाळीं|दनपारां|सांजे/,
                        meridiemHour: function (hour, meridiem) {
                            if (hour === 12) {
                                hour = 0;
                            }
                            if (meridiem === "राती") {
                                return hour < 4 ? hour : hour + 12;
                            } else if (meridiem === "सकाळीं") {
                                return hour;
                            } else if (meridiem === "दनपारां") {
                                return hour > 12 ? hour : hour + 12;
                            } else if (meridiem === "सांजे") {
                                return hour + 12;
                            }
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 4) {
                                return "राती";
                            } else if (hour < 12) {
                                return "सकाळीं";
                            } else if (hour < 16) {
                                return "दनपारां";
                            } else if (hour < 20) {
                                return "सांजे";
                            } else {
                                return "राती";
                            }
                        },
                    });
                    return gomDeva;
                });
            },
            "./node_modules/moment/locale/gom-latn.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    function processRelativeTime(number, withoutSuffix, key, isFuture) {
                        var format = {
                            s: ["thoddea sekondamni", "thodde sekond"],
                            ss: [number + " sekondamni", number + " sekond"],
                            m: ["eka mintan", "ek minut"],
                            mm: [number + " mintamni", number + " mintam"],
                            h: ["eka voran", "ek vor"],
                            hh: [number + " voramni", number + " voram"],
                            d: ["eka disan", "ek dis"],
                            dd: [number + " disamni", number + " dis"],
                            M: ["eka mhoinean", "ek mhoino"],
                            MM: [number + " mhoineamni", number + " mhoine"],
                            y: ["eka vorsan", "ek voros"],
                            yy: [number + " vorsamni", number + " vorsam"],
                        };
                        return isFuture ? format[key][0] : format[key][1];
                    }
                    var gomLatn = moment.defineLocale("gom-latn", {
                        months: {
                            standalone: "Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr".split("_"),
                            format: "Janerachea_Febrerachea_Marsachea_Abrilachea_Maiachea_Junachea_Julaiachea_Agostachea_Setembrachea_Otubrachea_Novembrachea_Dezembrachea".split("_"),
                            isFormat: /MMMM(\s)+D[oD]?/,
                        },
                        monthsShort: "Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.".split("_"),
                        monthsParseExact: true,
                        weekdays: "Aitar_Somar_Mongllar_Budhvar_Birestar_Sukrar_Son'var".split("_"),
                        weekdaysShort: "Ait._Som._Mon._Bud._Bre._Suk._Son.".split("_"),
                        weekdaysMin: "Ai_Sm_Mo_Bu_Br_Su_Sn".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: {
                            LT: "A h:mm [vazta]",
                            LTS: "A h:mm:ss [vazta]",
                            L: "DD-MM-YYYY",
                            LL: "D MMMM YYYY",
                            LLL: "D MMMM YYYY A h:mm [vazta]",
                            LLLL: "dddd, MMMM Do, YYYY, A h:mm [vazta]",
                            llll: "ddd, D MMM YYYY, A h:mm [vazta]",
                        },
                        calendar: { sameDay: "[Aiz] LT", nextDay: "[Faleam] LT", nextWeek: "[Fuddlo] dddd[,] LT", lastDay: "[Kal] LT", lastWeek: "[Fattlo] dddd[,] LT", sameElse: "L" },
                        relativeTime: {
                            future: "%s",
                            past: "%s adim",
                            s: processRelativeTime,
                            ss: processRelativeTime,
                            m: processRelativeTime,
                            mm: processRelativeTime,
                            h: processRelativeTime,
                            hh: processRelativeTime,
                            d: processRelativeTime,
                            dd: processRelativeTime,
                            M: processRelativeTime,
                            MM: processRelativeTime,
                            y: processRelativeTime,
                            yy: processRelativeTime,
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(er)/,
                        ordinal: function (number, period) {
                            switch (period) {
                                case "D":
                                    return number + "er";
                                default:
                                case "M":
                                case "Q":
                                case "DDD":
                                case "d":
                                case "w":
                                case "W":
                                    return number;
                            }
                        },
                        week: { dow: 0, doy: 3 },
                        meridiemParse: /rati|sokallim|donparam|sanje/,
                        meridiemHour: function (hour, meridiem) {
                            if (hour === 12) {
                                hour = 0;
                            }
                            if (meridiem === "rati") {
                                return hour < 4 ? hour : hour + 12;
                            } else if (meridiem === "sokallim") {
                                return hour;
                            } else if (meridiem === "donparam") {
                                return hour > 12 ? hour : hour + 12;
                            } else if (meridiem === "sanje") {
                                return hour + 12;
                            }
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 4) {
                                return "rati";
                            } else if (hour < 12) {
                                return "sokallim";
                            } else if (hour < 16) {
                                return "donparam";
                            } else if (hour < 20) {
                                return "sanje";
                            } else {
                                return "rati";
                            }
                        },
                    });
                    return gomLatn;
                });
            },
            "./node_modules/moment/locale/gu.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var symbolMap = { 1: "૧", 2: "૨", 3: "૩", 4: "૪", 5: "૫", 6: "૬", 7: "૭", 8: "૮", 9: "૯", 0: "૦" },
                        numberMap = { "૧": "1", "૨": "2", "૩": "3", "૪": "4", "૫": "5", "૬": "6", "૭": "7", "૮": "8", "૯": "9", "૦": "0" };
                    var gu = moment.defineLocale("gu", {
                        months: "જાન્યુઆરી_ફેબ્રુઆરી_માર્ચ_એપ્રિલ_મે_જૂન_જુલાઈ_ઑગસ્ટ_સપ્ટેમ્બર_ઑક્ટ્બર_નવેમ્બર_ડિસેમ્બર".split("_"),
                        monthsShort: "જાન્યુ._ફેબ્રુ._માર્ચ_એપ્રિ._મે_જૂન_જુલા._ઑગ._સપ્ટે._ઑક્ટ્._નવે._ડિસે.".split("_"),
                        monthsParseExact: true,
                        weekdays: "રવિવાર_સોમવાર_મંગળવાર_બુધ્વાર_ગુરુવાર_શુક્રવાર_શનિવાર".split("_"),
                        weekdaysShort: "રવિ_સોમ_મંગળ_બુધ્_ગુરુ_શુક્ર_શનિ".split("_"),
                        weekdaysMin: "ર_સો_મં_બુ_ગુ_શુ_શ".split("_"),
                        longDateFormat: { LT: "A h:mm વાગ્યે", LTS: "A h:mm:ss વાગ્યે", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm વાગ્યે", LLLL: "dddd, D MMMM YYYY, A h:mm વાગ્યે" },
                        calendar: { sameDay: "[આજ] LT", nextDay: "[કાલે] LT", nextWeek: "dddd, LT", lastDay: "[ગઇકાલે] LT", lastWeek: "[પાછલા] dddd, LT", sameElse: "L" },
                        relativeTime: {
                            future: "%s મા",
                            past: "%s પહેલા",
                            s: "અમુક પળો",
                            ss: "%d સેકંડ",
                            m: "એક મિનિટ",
                            mm: "%d મિનિટ",
                            h: "એક કલાક",
                            hh: "%d કલાક",
                            d: "એક દિવસ",
                            dd: "%d દિવસ",
                            M: "એક મહિનો",
                            MM: "%d મહિનો",
                            y: "એક વર્ષ",
                            yy: "%d વર્ષ",
                        },
                        preparse: function (string) {
                            return string.replace(/[૧૨૩૪૫૬૭૮૯૦]/g, function (match) {
                                return numberMap[match];
                            });
                        },
                        postformat: function (string) {
                            return string.replace(/\d/g, function (match) {
                                return symbolMap[match];
                            });
                        },
                        meridiemParse: /રાત|બપોર|સવાર|સાંજ/,
                        meridiemHour: function (hour, meridiem) {
                            if (hour === 12) {
                                hour = 0;
                            }
                            if (meridiem === "રાત") {
                                return hour < 4 ? hour : hour + 12;
                            } else if (meridiem === "સવાર") {
                                return hour;
                            } else if (meridiem === "બપોર") {
                                return hour >= 10 ? hour : hour + 12;
                            } else if (meridiem === "સાંજ") {
                                return hour + 12;
                            }
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 4) {
                                return "રાત";
                            } else if (hour < 10) {
                                return "સવાર";
                            } else if (hour < 17) {
                                return "બપોર";
                            } else if (hour < 20) {
                                return "સાંજ";
                            } else {
                                return "રાત";
                            }
                        },
                        week: { dow: 0, doy: 6 },
                    });
                    return gu;
                });
            },
            "./node_modules/moment/locale/he.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var he = moment.defineLocale("he", {
                        months: "ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר".split("_"),
                        monthsShort: "ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳".split("_"),
                        weekdays: "ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת".split("_"),
                        weekdaysShort: "א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳".split("_"),
                        weekdaysMin: "א_ב_ג_ד_ה_ו_ש".split("_"),
                        longDateFormat: {
                            LT: "HH:mm",
                            LTS: "HH:mm:ss",
                            L: "DD/MM/YYYY",
                            LL: "D [ב]MMMM YYYY",
                            LLL: "D [ב]MMMM YYYY HH:mm",
                            LLLL: "dddd, D [ב]MMMM YYYY HH:mm",
                            l: "D/M/YYYY",
                            ll: "D MMM YYYY",
                            lll: "D MMM YYYY HH:mm",
                            llll: "ddd, D MMM YYYY HH:mm",
                        },
                        calendar: { sameDay: "[היום ב־]LT", nextDay: "[מחר ב־]LT", nextWeek: "dddd [בשעה] LT", lastDay: "[אתמול ב־]LT", lastWeek: "[ביום] dddd [האחרון בשעה] LT", sameElse: "L" },
                        relativeTime: {
                            future: "בעוד %s",
                            past: "לפני %s",
                            s: "מספר שניות",
                            ss: "%d שניות",
                            m: "דקה",
                            mm: "%d דקות",
                            h: "שעה",
                            hh: function (number) {
                                if (number === 2) {
                                    return "שעתיים";
                                }
                                return number + " שעות";
                            },
                            d: "יום",
                            dd: function (number) {
                                if (number === 2) {
                                    return "יומיים";
                                }
                                return number + " ימים";
                            },
                            M: "חודש",
                            MM: function (number) {
                                if (number === 2) {
                                    return "חודשיים";
                                }
                                return number + " חודשים";
                            },
                            y: "שנה",
                            yy: function (number) {
                                if (number === 2) {
                                    return "שנתיים";
                                } else if (number % 10 === 0 && number !== 10) {
                                    return number + " שנה";
                                }
                                return number + " שנים";
                            },
                        },
                        meridiemParse: /אחה"צ|לפנה"צ|אחרי הצהריים|לפני הצהריים|לפנות בוקר|בבוקר|בערב/i,
                        isPM: function (input) {
                            return /^(אחה"צ|אחרי הצהריים|בערב)$/.test(input);
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 5) {
                                return "לפנות בוקר";
                            } else if (hour < 10) {
                                return "בבוקר";
                            } else if (hour < 12) {
                                return isLower ? 'לפנה"צ' : "לפני הצהריים";
                            } else if (hour < 18) {
                                return isLower ? 'אחה"צ' : "אחרי הצהריים";
                            } else {
                                return "בערב";
                            }
                        },
                    });
                    return he;
                });
            },
            "./node_modules/moment/locale/hi.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var symbolMap = { 1: "१", 2: "२", 3: "३", 4: "४", 5: "५", 6: "६", 7: "७", 8: "८", 9: "९", 0: "०" },
                        numberMap = { "१": "1", "२": "2", "३": "3", "४": "4", "५": "5", "६": "6", "७": "7", "८": "8", "९": "9", "०": "0" },
                        monthsParse = [/^जन/i, /^फ़र|फर/i, /^मार्च/i, /^अप्रै/i, /^मई/i, /^जून/i, /^जुल/i, /^अग/i, /^सितं|सित/i, /^अक्टू/i, /^नव|नवं/i, /^दिसं|दिस/i],
                        shortMonthsParse = [/^जन/i, /^फ़र/i, /^मार्च/i, /^अप्रै/i, /^मई/i, /^जून/i, /^जुल/i, /^अग/i, /^सित/i, /^अक्टू/i, /^नव/i, /^दिस/i];
                    var hi = moment.defineLocale("hi", {
                        months: { format: "जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर".split("_"), standalone: "जनवरी_फरवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितंबर_अक्टूबर_नवंबर_दिसंबर".split("_") },
                        monthsShort: "जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.".split("_"),
                        weekdays: "रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार".split("_"),
                        weekdaysShort: "रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि".split("_"),
                        weekdaysMin: "र_सो_मं_बु_गु_शु_श".split("_"),
                        longDateFormat: { LT: "A h:mm बजे", LTS: "A h:mm:ss बजे", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm बजे", LLLL: "dddd, D MMMM YYYY, A h:mm बजे" },
                        monthsParse: monthsParse,
                        longMonthsParse: monthsParse,
                        shortMonthsParse: shortMonthsParse,
                        monthsRegex: /^(जनवरी|जन\.?|फ़रवरी|फरवरी|फ़र\.?|मार्च?|अप्रैल|अप्रै\.?|मई?|जून?|जुलाई|जुल\.?|अगस्त|अग\.?|सितम्बर|सितंबर|सित\.?|अक्टूबर|अक्टू\.?|नवम्बर|नवंबर|नव\.?|दिसम्बर|दिसंबर|दिस\.?)/i,
                        monthsShortRegex: /^(जनवरी|जन\.?|फ़रवरी|फरवरी|फ़र\.?|मार्च?|अप्रैल|अप्रै\.?|मई?|जून?|जुलाई|जुल\.?|अगस्त|अग\.?|सितम्बर|सितंबर|सित\.?|अक्टूबर|अक्टू\.?|नवम्बर|नवंबर|नव\.?|दिसम्बर|दिसंबर|दिस\.?)/i,
                        monthsStrictRegex: /^(जनवरी?|फ़रवरी|फरवरी?|मार्च?|अप्रैल?|मई?|जून?|जुलाई?|अगस्त?|सितम्बर|सितंबर|सित?\.?|अक्टूबर|अक्टू\.?|नवम्बर|नवंबर?|दिसम्बर|दिसंबर?)/i,
                        monthsShortStrictRegex: /^(जन\.?|फ़र\.?|मार्च?|अप्रै\.?|मई?|जून?|जुल\.?|अग\.?|सित\.?|अक्टू\.?|नव\.?|दिस\.?)/i,
                        calendar: { sameDay: "[आज] LT", nextDay: "[कल] LT", nextWeek: "dddd, LT", lastDay: "[कल] LT", lastWeek: "[पिछले] dddd, LT", sameElse: "L" },
                        relativeTime: {
                            future: "%s में",
                            past: "%s पहले",
                            s: "कुछ ही क्षण",
                            ss: "%d सेकंड",
                            m: "एक मिनट",
                            mm: "%d मिनट",
                            h: "एक घंटा",
                            hh: "%d घंटे",
                            d: "एक दिन",
                            dd: "%d दिन",
                            M: "एक महीने",
                            MM: "%d महीने",
                            y: "एक वर्ष",
                            yy: "%d वर्ष",
                        },
                        preparse: function (string) {
                            return string.replace(/[१२३४५६७८९०]/g, function (match) {
                                return numberMap[match];
                            });
                        },
                        postformat: function (string) {
                            return string.replace(/\d/g, function (match) {
                                return symbolMap[match];
                            });
                        },
                        meridiemParse: /रात|सुबह|दोपहर|शाम/,
                        meridiemHour: function (hour, meridiem) {
                            if (hour === 12) {
                                hour = 0;
                            }
                            if (meridiem === "रात") {
                                return hour < 4 ? hour : hour + 12;
                            } else if (meridiem === "सुबह") {
                                return hour;
                            } else if (meridiem === "दोपहर") {
                                return hour >= 10 ? hour : hour + 12;
                            } else if (meridiem === "शाम") {
                                return hour + 12;
                            }
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 4) {
                                return "रात";
                            } else if (hour < 10) {
                                return "सुबह";
                            } else if (hour < 17) {
                                return "दोपहर";
                            } else if (hour < 20) {
                                return "शाम";
                            } else {
                                return "रात";
                            }
                        },
                        week: { dow: 0, doy: 6 },
                    });
                    return hi;
                });
            },
            "./node_modules/moment/locale/hr.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    function translate(number, withoutSuffix, key) {
                        var result = number + " ";
                        switch (key) {
                            case "ss":
                                if (number === 1) {
                                    result += "sekunda";
                                } else if (number === 2 || number === 3 || number === 4) {
                                    result += "sekunde";
                                } else {
                                    result += "sekundi";
                                }
                                return result;
                            case "m":
                                return withoutSuffix ? "jedna minuta" : "jedne minute";
                            case "mm":
                                if (number === 1) {
                                    result += "minuta";
                                } else if (number === 2 || number === 3 || number === 4) {
                                    result += "minute";
                                } else {
                                    result += "minuta";
                                }
                                return result;
                            case "h":
                                return withoutSuffix ? "jedan sat" : "jednog sata";
                            case "hh":
                                if (number === 1) {
                                    result += "sat";
                                } else if (number === 2 || number === 3 || number === 4) {
                                    result += "sata";
                                } else {
                                    result += "sati";
                                }
                                return result;
                            case "dd":
                                if (number === 1) {
                                    result += "dan";
                                } else {
                                    result += "dana";
                                }
                                return result;
                            case "MM":
                                if (number === 1) {
                                    result += "mjesec";
                                } else if (number === 2 || number === 3 || number === 4) {
                                    result += "mjeseca";
                                } else {
                                    result += "mjeseci";
                                }
                                return result;
                            case "yy":
                                if (number === 1) {
                                    result += "godina";
                                } else if (number === 2 || number === 3 || number === 4) {
                                    result += "godine";
                                } else {
                                    result += "godina";
                                }
                                return result;
                        }
                    }
                    var hr = moment.defineLocale("hr", {
                        months: {
                            format: "siječnja_veljače_ožujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca".split("_"),
                            standalone: "siječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac".split("_"),
                        },
                        monthsShort: "sij._velj._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.".split("_"),
                        monthsParseExact: true,
                        weekdays: "nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota".split("_"),
                        weekdaysShort: "ned._pon._uto._sri._čet._pet._sub.".split("_"),
                        weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "Do MMMM YYYY", LLL: "Do MMMM YYYY H:mm", LLLL: "dddd, Do MMMM YYYY H:mm" },
                        calendar: {
                            sameDay: "[danas u] LT",
                            nextDay: "[sutra u] LT",
                            nextWeek: function () {
                                switch (this.day()) {
                                    case 0:
                                        return "[u] [nedjelju] [u] LT";
                                    case 3:
                                        return "[u] [srijedu] [u] LT";
                                    case 6:
                                        return "[u] [subotu] [u] LT";
                                    case 1:
                                    case 2:
                                    case 4:
                                    case 5:
                                        return "[u] dddd [u] LT";
                                }
                            },
                            lastDay: "[jučer u] LT",
                            lastWeek: function () {
                                switch (this.day()) {
                                    case 0:
                                        return "[prošlu] [nedjelju] [u] LT";
                                    case 3:
                                        return "[prošlu] [srijedu] [u] LT";
                                    case 6:
                                        return "[prošle] [subote] [u] LT";
                                    case 1:
                                    case 2:
                                    case 4:
                                    case 5:
                                        return "[prošli] dddd [u] LT";
                                }
                            },
                            sameElse: "L",
                        },
                        relativeTime: {
                            future: "za %s",
                            past: "prije %s",
                            s: "par sekundi",
                            ss: translate,
                            m: translate,
                            mm: translate,
                            h: translate,
                            hh: translate,
                            d: "dan",
                            dd: translate,
                            M: "mjesec",
                            MM: translate,
                            y: "godinu",
                            yy: translate,
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}\./,
                        ordinal: "%d.",
                        week: { dow: 1, doy: 7 },
                    });
                    return hr;
                });
            },
            "./node_modules/moment/locale/hu.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var weekEndings = "vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton".split(" ");
                    function translate(number, withoutSuffix, key, isFuture) {
                        var num = number;
                        switch (key) {
                            case "s":
                                return isFuture || withoutSuffix ? "néhány másodperc" : "néhány másodperce";
                            case "ss":
                                return num + (isFuture || withoutSuffix) ? " másodperc" : " másodperce";
                            case "m":
                                return "egy" + (isFuture || withoutSuffix ? " perc" : " perce");
                            case "mm":
                                return num + (isFuture || withoutSuffix ? " perc" : " perce");
                            case "h":
                                return "egy" + (isFuture || withoutSuffix ? " óra" : " órája");
                            case "hh":
                                return num + (isFuture || withoutSuffix ? " óra" : " órája");
                            case "d":
                                return "egy" + (isFuture || withoutSuffix ? " nap" : " napja");
                            case "dd":
                                return num + (isFuture || withoutSuffix ? " nap" : " napja");
                            case "M":
                                return "egy" + (isFuture || withoutSuffix ? " hónap" : " hónapja");
                            case "MM":
                                return num + (isFuture || withoutSuffix ? " hónap" : " hónapja");
                            case "y":
                                return "egy" + (isFuture || withoutSuffix ? " év" : " éve");
                            case "yy":
                                return num + (isFuture || withoutSuffix ? " év" : " éve");
                        }
                        return "";
                    }
                    function week(isFuture) {
                        return (isFuture ? "" : "[múlt] ") + "[" + weekEndings[this.day()] + "] LT[-kor]";
                    }
                    var hu = moment.defineLocale("hu", {
                        months: "január_február_március_április_május_június_július_augusztus_szeptember_október_november_december".split("_"),
                        monthsShort: "jan._feb._márc._ápr._máj._jún._júl._aug._szept._okt._nov._dec.".split("_"),
                        monthsParseExact: true,
                        weekdays: "vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat".split("_"),
                        weekdaysShort: "vas_hét_kedd_sze_csüt_pén_szo".split("_"),
                        weekdaysMin: "v_h_k_sze_cs_p_szo".split("_"),
                        longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "YYYY.MM.DD.", LL: "YYYY. MMMM D.", LLL: "YYYY. MMMM D. H:mm", LLLL: "YYYY. MMMM D., dddd H:mm" },
                        meridiemParse: /de|du/i,
                        isPM: function (input) {
                            return input.charAt(1).toLowerCase() === "u";
                        },
                        meridiem: function (hours, minutes, isLower) {
                            if (hours < 12) {
                                return isLower === true ? "de" : "DE";
                            } else {
                                return isLower === true ? "du" : "DU";
                            }
                        },
                        calendar: {
                            sameDay: "[ma] LT[-kor]",
                            nextDay: "[holnap] LT[-kor]",
                            nextWeek: function () {
                                return week.call(this, true);
                            },
                            lastDay: "[tegnap] LT[-kor]",
                            lastWeek: function () {
                                return week.call(this, false);
                            },
                            sameElse: "L",
                        },
                        relativeTime: {
                            future: "%s múlva",
                            past: "%s",
                            s: translate,
                            ss: translate,
                            m: translate,
                            mm: translate,
                            h: translate,
                            hh: translate,
                            d: translate,
                            dd: translate,
                            M: translate,
                            MM: translate,
                            y: translate,
                            yy: translate,
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}\./,
                        ordinal: "%d.",
                        week: { dow: 1, doy: 4 },
                    });
                    return hu;
                });
            },
            "./node_modules/moment/locale/hy-am.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var hyAm = moment.defineLocale("hy-am", {
                        months: {
                            format: "հունվարի_փետրվարի_մարտի_ապրիլի_մայիսի_հունիսի_հուլիսի_օգոստոսի_սեպտեմբերի_հոկտեմբերի_նոյեմբերի_դեկտեմբերի".split("_"),
                            standalone: "հունվար_փետրվար_մարտ_ապրիլ_մայիս_հունիս_հուլիս_օգոստոս_սեպտեմբեր_հոկտեմբեր_նոյեմբեր_դեկտեմբեր".split("_"),
                        },
                        monthsShort: "հնվ_փտր_մրտ_ապր_մյս_հնս_հլս_օգս_սպտ_հկտ_նմբ_դկտ".split("_"),
                        weekdays: "կիրակի_երկուշաբթի_երեքշաբթի_չորեքշաբթի_հինգշաբթի_ուրբաթ_շաբաթ".split("_"),
                        weekdaysShort: "կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ".split("_"),
                        weekdaysMin: "կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY թ.", LLL: "D MMMM YYYY թ., HH:mm", LLLL: "dddd, D MMMM YYYY թ., HH:mm" },
                        calendar: {
                            sameDay: "[այսօր] LT",
                            nextDay: "[վաղը] LT",
                            lastDay: "[երեկ] LT",
                            nextWeek: function () {
                                return "dddd [օրը ժամը] LT";
                            },
                            lastWeek: function () {
                                return "[անցած] dddd [օրը ժամը] LT";
                            },
                            sameElse: "L",
                        },
                        relativeTime: {
                            future: "%s հետո",
                            past: "%s առաջ",
                            s: "մի քանի վայրկյան",
                            ss: "%d վայրկյան",
                            m: "րոպե",
                            mm: "%d րոպե",
                            h: "ժամ",
                            hh: "%d ժամ",
                            d: "օր",
                            dd: "%d օր",
                            M: "ամիս",
                            MM: "%d ամիս",
                            y: "տարի",
                            yy: "%d տարի",
                        },
                        meridiemParse: /գիշերվա|առավոտվա|ցերեկվա|երեկոյան/,
                        isPM: function (input) {
                            return /^(ցերեկվա|երեկոյան)$/.test(input);
                        },
                        meridiem: function (hour) {
                            if (hour < 4) {
                                return "գիշերվա";
                            } else if (hour < 12) {
                                return "առավոտվա";
                            } else if (hour < 17) {
                                return "ցերեկվա";
                            } else {
                                return "երեկոյան";
                            }
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(ին|րդ)/,
                        ordinal: function (number, period) {
                            switch (period) {
                                case "DDD":
                                case "w":
                                case "W":
                                case "DDDo":
                                    if (number === 1) {
                                        return number + "-ին";
                                    }
                                    return number + "-րդ";
                                default:
                                    return number;
                            }
                        },
                        week: { dow: 1, doy: 7 },
                    });
                    return hyAm;
                });
            },
            "./node_modules/moment/locale/id.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var id = moment.defineLocale("id", {
                        months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember".split("_"),
                        monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des".split("_"),
                        weekdays: "Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu".split("_"),
                        weekdaysShort: "Min_Sen_Sel_Rab_Kam_Jum_Sab".split("_"),
                        weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sb".split("_"),
                        longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [pukul] HH.mm", LLLL: "dddd, D MMMM YYYY [pukul] HH.mm" },
                        meridiemParse: /pagi|siang|sore|malam/,
                        meridiemHour: function (hour, meridiem) {
                            if (hour === 12) {
                                hour = 0;
                            }
                            if (meridiem === "pagi") {
                                return hour;
                            } else if (meridiem === "siang") {
                                return hour >= 11 ? hour : hour + 12;
                            } else if (meridiem === "sore" || meridiem === "malam") {
                                return hour + 12;
                            }
                        },
                        meridiem: function (hours, minutes, isLower) {
                            if (hours < 11) {
                                return "pagi";
                            } else if (hours < 15) {
                                return "siang";
                            } else if (hours < 19) {
                                return "sore";
                            } else {
                                return "malam";
                            }
                        },
                        calendar: { sameDay: "[Hari ini pukul] LT", nextDay: "[Besok pukul] LT", nextWeek: "dddd [pukul] LT", lastDay: "[Kemarin pukul] LT", lastWeek: "dddd [lalu pukul] LT", sameElse: "L" },
                        relativeTime: {
                            future: "dalam %s",
                            past: "%s yang lalu",
                            s: "beberapa detik",
                            ss: "%d detik",
                            m: "semenit",
                            mm: "%d menit",
                            h: "sejam",
                            hh: "%d jam",
                            d: "sehari",
                            dd: "%d hari",
                            M: "sebulan",
                            MM: "%d bulan",
                            y: "setahun",
                            yy: "%d tahun",
                        },
                        week: { dow: 0, doy: 6 },
                    });
                    return id;
                });
            },
            "./node_modules/moment/locale/is.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    function plural(n) {
                        if (n % 100 === 11) {
                            return true;
                        } else if (n % 10 === 1) {
                            return false;
                        }
                        return true;
                    }
                    function translate(number, withoutSuffix, key, isFuture) {
                        var result = number + " ";
                        switch (key) {
                            case "s":
                                return withoutSuffix || isFuture ? "nokkrar sekúndur" : "nokkrum sekúndum";
                            case "ss":
                                if (plural(number)) {
                                    return result + (withoutSuffix || isFuture ? "sekúndur" : "sekúndum");
                                }
                                return result + "sekúnda";
                            case "m":
                                return withoutSuffix ? "mínúta" : "mínútu";
                            case "mm":
                                if (plural(number)) {
                                    return result + (withoutSuffix || isFuture ? "mínútur" : "mínútum");
                                } else if (withoutSuffix) {
                                    return result + "mínúta";
                                }
                                return result + "mínútu";
                            case "hh":
                                if (plural(number)) {
                                    return result + (withoutSuffix || isFuture ? "klukkustundir" : "klukkustundum");
                                }
                                return result + "klukkustund";
                            case "d":
                                if (withoutSuffix) {
                                    return "dagur";
                                }
                                return isFuture ? "dag" : "degi";
                            case "dd":
                                if (plural(number)) {
                                    if (withoutSuffix) {
                                        return result + "dagar";
                                    }
                                    return result + (isFuture ? "daga" : "dögum");
                                } else if (withoutSuffix) {
                                    return result + "dagur";
                                }
                                return result + (isFuture ? "dag" : "degi");
                            case "M":
                                if (withoutSuffix) {
                                    return "mánuður";
                                }
                                return isFuture ? "mánuð" : "mánuði";
                            case "MM":
                                if (plural(number)) {
                                    if (withoutSuffix) {
                                        return result + "mánuðir";
                                    }
                                    return result + (isFuture ? "mánuði" : "mánuðum");
                                } else if (withoutSuffix) {
                                    return result + "mánuður";
                                }
                                return result + (isFuture ? "mánuð" : "mánuði");
                            case "y":
                                return withoutSuffix || isFuture ? "ár" : "ári";
                            case "yy":
                                if (plural(number)) {
                                    return result + (withoutSuffix || isFuture ? "ár" : "árum");
                                }
                                return result + (withoutSuffix || isFuture ? "ár" : "ári");
                        }
                    }
                    var is = moment.defineLocale("is", {
                        months: "janúar_febrúar_mars_apríl_maí_júní_júlí_ágúst_september_október_nóvember_desember".split("_"),
                        monthsShort: "jan_feb_mar_apr_maí_jún_júl_ágú_sep_okt_nóv_des".split("_"),
                        weekdays: "sunnudagur_mánudagur_þriðjudagur_miðvikudagur_fimmtudagur_föstudagur_laugardagur".split("_"),
                        weekdaysShort: "sun_mán_þri_mið_fim_fös_lau".split("_"),
                        weekdaysMin: "Su_Má_Þr_Mi_Fi_Fö_La".split("_"),
                        longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY [kl.] H:mm", LLLL: "dddd, D. MMMM YYYY [kl.] H:mm" },
                        calendar: { sameDay: "[í dag kl.] LT", nextDay: "[á morgun kl.] LT", nextWeek: "dddd [kl.] LT", lastDay: "[í gær kl.] LT", lastWeek: "[síðasta] dddd [kl.] LT", sameElse: "L" },
                        relativeTime: {
                            future: "eftir %s",
                            past: "fyrir %s síðan",
                            s: translate,
                            ss: translate,
                            m: translate,
                            mm: translate,
                            h: "klukkustund",
                            hh: translate,
                            d: translate,
                            dd: translate,
                            M: translate,
                            MM: translate,
                            y: translate,
                            yy: translate,
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}\./,
                        ordinal: "%d.",
                        week: { dow: 1, doy: 4 },
                    });
                    return is;
                });
            },
            "./node_modules/moment/locale/it-ch.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var itCh = moment.defineLocale("it-ch", {
                        months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"),
                        monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),
                        weekdays: "domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato".split("_"),
                        weekdaysShort: "dom_lun_mar_mer_gio_ven_sab".split("_"),
                        weekdaysMin: "do_lu_ma_me_gi_ve_sa".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" },
                        calendar: {
                            sameDay: "[Oggi alle] LT",
                            nextDay: "[Domani alle] LT",
                            nextWeek: "dddd [alle] LT",
                            lastDay: "[Ieri alle] LT",
                            lastWeek: function () {
                                switch (this.day()) {
                                    case 0:
                                        return "[la scorsa] dddd [alle] LT";
                                    default:
                                        return "[lo scorso] dddd [alle] LT";
                                }
                            },
                            sameElse: "L",
                        },
                        relativeTime: {
                            future: function (s) {
                                return (/^[0-9].+$/.test(s) ? "tra" : "in") + " " + s;
                            },
                            past: "%s fa",
                            s: "alcuni secondi",
                            ss: "%d secondi",
                            m: "un minuto",
                            mm: "%d minuti",
                            h: "un'ora",
                            hh: "%d ore",
                            d: "un giorno",
                            dd: "%d giorni",
                            M: "un mese",
                            MM: "%d mesi",
                            y: "un anno",
                            yy: "%d anni",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}º/,
                        ordinal: "%dº",
                        week: { dow: 1, doy: 4 },
                    });
                    return itCh;
                });
            },
            "./node_modules/moment/locale/it.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var it = moment.defineLocale("it", {
                        months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"),
                        monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),
                        weekdays: "domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato".split("_"),
                        weekdaysShort: "dom_lun_mar_mer_gio_ven_sab".split("_"),
                        weekdaysMin: "do_lu_ma_me_gi_ve_sa".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" },
                        calendar: {
                            sameDay: function () {
                                return "[Oggi a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
                            },
                            nextDay: function () {
                                return "[Domani a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
                            },
                            nextWeek: function () {
                                return "dddd [a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
                            },
                            lastDay: function () {
                                return "[Ieri a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
                            },
                            lastWeek: function () {
                                switch (this.day()) {
                                    case 0:
                                        return "[La scorsa] dddd [a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
                                    default:
                                        return "[Lo scorso] dddd [a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
                                }
                            },
                            sameElse: "L",
                        },
                        relativeTime: {
                            future: "tra %s",
                            past: "%s fa",
                            s: "alcuni secondi",
                            ss: "%d secondi",
                            m: "un minuto",
                            mm: "%d minuti",
                            h: "un'ora",
                            hh: "%d ore",
                            d: "un giorno",
                            dd: "%d giorni",
                            w: "una settimana",
                            ww: "%d settimane",
                            M: "un mese",
                            MM: "%d mesi",
                            y: "un anno",
                            yy: "%d anni",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}º/,
                        ordinal: "%dº",
                        week: { dow: 1, doy: 4 },
                    });
                    return it;
                });
            },
            "./node_modules/moment/locale/ja.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var ja = moment.defineLocale("ja", {
                        eras: [
                            { since: "2019-05-01", offset: 1, name: "令和", narrow: "㋿", abbr: "R" },
                            { since: "1989-01-08", until: "2019-04-30", offset: 1, name: "平成", narrow: "㍻", abbr: "H" },
                            { since: "1926-12-25", until: "1989-01-07", offset: 1, name: "昭和", narrow: "㍼", abbr: "S" },
                            { since: "1912-07-30", until: "1926-12-24", offset: 1, name: "大正", narrow: "㍽", abbr: "T" },
                            { since: "1873-01-01", until: "1912-07-29", offset: 6, name: "明治", narrow: "㍾", abbr: "M" },
                            { since: "0001-01-01", until: "1873-12-31", offset: 1, name: "西暦", narrow: "AD", abbr: "AD" },
                            { since: "0000-12-31", until: -Infinity, offset: 1, name: "紀元前", narrow: "BC", abbr: "BC" },
                        ],
                        eraYearOrdinalRegex: /(元|\d+)年/,
                        eraYearOrdinalParse: function (input, match) {
                            return match[1] === "元" ? 1 : parseInt(match[1] || input, 10);
                        },
                        months: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
                        monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
                        weekdays: "日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日".split("_"),
                        weekdaysShort: "日_月_火_水_木_金_土".split("_"),
                        weekdaysMin: "日_月_火_水_木_金_土".split("_"),
                        longDateFormat: {
                            LT: "HH:mm",
                            LTS: "HH:mm:ss",
                            L: "YYYY/MM/DD",
                            LL: "YYYY年M月D日",
                            LLL: "YYYY年M月D日 HH:mm",
                            LLLL: "YYYY年M月D日 dddd HH:mm",
                            l: "YYYY/MM/DD",
                            ll: "YYYY年M月D日",
                            lll: "YYYY年M月D日 HH:mm",
                            llll: "YYYY年M月D日(ddd) HH:mm",
                        },
                        meridiemParse: /午前|午後/i,
                        isPM: function (input) {
                            return input === "午後";
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 12) {
                                return "午前";
                            } else {
                                return "午後";
                            }
                        },
                        calendar: {
                            sameDay: "[今日] LT",
                            nextDay: "[明日] LT",
                            nextWeek: function (now) {
                                if (now.week() !== this.week()) {
                                    return "[来週]dddd LT";
                                } else {
                                    return "dddd LT";
                                }
                            },
                            lastDay: "[昨日] LT",
                            lastWeek: function (now) {
                                if (this.week() !== now.week()) {
                                    return "[先週]dddd LT";
                                } else {
                                    return "dddd LT";
                                }
                            },
                            sameElse: "L",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}日/,
                        ordinal: function (number, period) {
                            switch (period) {
                                case "y":
                                    return number === 1 ? "元年" : number + "年";
                                case "d":
                                case "D":
                                case "DDD":
                                    return number + "日";
                                default:
                                    return number;
                            }
                        },
                        relativeTime: { future: "%s後", past: "%s前", s: "数秒", ss: "%d秒", m: "1分", mm: "%d分", h: "1時間", hh: "%d時間", d: "1日", dd: "%d日", M: "1ヶ月", MM: "%dヶ月", y: "1年", yy: "%d年" },
                    });
                    return ja;
                });
            },
            "./node_modules/moment/locale/jv.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var jv = moment.defineLocale("jv", {
                        months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember".split("_"),
                        monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des".split("_"),
                        weekdays: "Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu".split("_"),
                        weekdaysShort: "Min_Sen_Sel_Reb_Kem_Jem_Sep".split("_"),
                        weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sp".split("_"),
                        longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [pukul] HH.mm", LLLL: "dddd, D MMMM YYYY [pukul] HH.mm" },
                        meridiemParse: /enjing|siyang|sonten|ndalu/,
                        meridiemHour: function (hour, meridiem) {
                            if (hour === 12) {
                                hour = 0;
                            }
                            if (meridiem === "enjing") {
                                return hour;
                            } else if (meridiem === "siyang") {
                                return hour >= 11 ? hour : hour + 12;
                            } else if (meridiem === "sonten" || meridiem === "ndalu") {
                                return hour + 12;
                            }
                        },
                        meridiem: function (hours, minutes, isLower) {
                            if (hours < 11) {
                                return "enjing";
                            } else if (hours < 15) {
                                return "siyang";
                            } else if (hours < 19) {
                                return "sonten";
                            } else {
                                return "ndalu";
                            }
                        },
                        calendar: { sameDay: "[Dinten puniko pukul] LT", nextDay: "[Mbenjang pukul] LT", nextWeek: "dddd [pukul] LT", lastDay: "[Kala wingi pukul] LT", lastWeek: "dddd [kepengker pukul] LT", sameElse: "L" },
                        relativeTime: {
                            future: "wonten ing %s",
                            past: "%s ingkang kepengker",
                            s: "sawetawis detik",
                            ss: "%d detik",
                            m: "setunggal menit",
                            mm: "%d menit",
                            h: "setunggal jam",
                            hh: "%d jam",
                            d: "sedinten",
                            dd: "%d dinten",
                            M: "sewulan",
                            MM: "%d wulan",
                            y: "setaun",
                            yy: "%d taun",
                        },
                        week: { dow: 1, doy: 7 },
                    });
                    return jv;
                });
            },
            "./node_modules/moment/locale/ka.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var ka = moment.defineLocale("ka", {
                        months: "იანვარი_თებერვალი_მარტი_აპრილი_მაისი_ივნისი_ივლისი_აგვისტო_სექტემბერი_ოქტომბერი_ნოემბერი_დეკემბერი".split("_"),
                        monthsShort: "იან_თებ_მარ_აპრ_მაი_ივნ_ივლ_აგვ_სექ_ოქტ_ნოე_დეკ".split("_"),
                        weekdays: { standalone: "კვირა_ორშაბათი_სამშაბათი_ოთხშაბათი_ხუთშაბათი_პარასკევი_შაბათი".split("_"), format: "კვირას_ორშაბათს_სამშაბათს_ოთხშაბათს_ხუთშაბათს_პარასკევს_შაბათს".split("_"), isFormat: /(წინა|შემდეგ)/ },
                        weekdaysShort: "კვი_ორშ_სამ_ოთხ_ხუთ_პარ_შაბ".split("_"),
                        weekdaysMin: "კვ_ორ_სა_ოთ_ხუ_პა_შა".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[დღეს] LT[-ზე]", nextDay: "[ხვალ] LT[-ზე]", lastDay: "[გუშინ] LT[-ზე]", nextWeek: "[შემდეგ] dddd LT[-ზე]", lastWeek: "[წინა] dddd LT-ზე", sameElse: "L" },
                        relativeTime: {
                            future: function (s) {
                                return s.replace(/(წამ|წუთ|საათ|წელ|დღ|თვ)(ი|ე)/, function ($0, $1, $2) {
                                    return $2 === "ი" ? $1 + "ში" : $1 + $2 + "ში";
                                });
                            },
                            past: function (s) {
                                if (/(წამი|წუთი|საათი|დღე|თვე)/.test(s)) {
                                    return s.replace(/(ი|ე)$/, "ის წინ");
                                }
                                if (/წელი/.test(s)) {
                                    return s.replace(/წელი$/, "წლის წინ");
                                }
                                return s;
                            },
                            s: "რამდენიმე წამი",
                            ss: "%d წამი",
                            m: "წუთი",
                            mm: "%d წუთი",
                            h: "საათი",
                            hh: "%d საათი",
                            d: "დღე",
                            dd: "%d დღე",
                            M: "თვე",
                            MM: "%d თვე",
                            y: "წელი",
                            yy: "%d წელი",
                        },
                        dayOfMonthOrdinalParse: /0|1-ლი|მე-\d{1,2}|\d{1,2}-ე/,
                        ordinal: function (number) {
                            if (number === 0) {
                                return number;
                            }
                            if (number === 1) {
                                return number + "-ლი";
                            }
                            if (number < 20 || (number <= 100 && number % 20 === 0) || number % 100 === 0) {
                                return "მე-" + number;
                            }
                            return number + "-ე";
                        },
                        week: { dow: 1, doy: 7 },
                    });
                    return ka;
                });
            },
            "./node_modules/moment/locale/kk.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var suffixes = {
                        0: "-ші",
                        1: "-ші",
                        2: "-ші",
                        3: "-ші",
                        4: "-ші",
                        5: "-ші",
                        6: "-шы",
                        7: "-ші",
                        8: "-ші",
                        9: "-шы",
                        10: "-шы",
                        20: "-шы",
                        30: "-шы",
                        40: "-шы",
                        50: "-ші",
                        60: "-шы",
                        70: "-ші",
                        80: "-ші",
                        90: "-шы",
                        100: "-ші",
                    };
                    var kk = moment.defineLocale("kk", {
                        months: "қаңтар_ақпан_наурыз_сәуір_мамыр_маусым_шілде_тамыз_қыркүйек_қазан_қараша_желтоқсан".split("_"),
                        monthsShort: "қаң_ақп_нау_сәу_мам_мау_шіл_там_қыр_қаз_қар_жел".split("_"),
                        weekdays: "жексенбі_дүйсенбі_сейсенбі_сәрсенбі_бейсенбі_жұма_сенбі".split("_"),
                        weekdaysShort: "жек_дүй_сей_сәр_бей_жұм_сен".split("_"),
                        weekdaysMin: "жк_дй_сй_ср_бй_жм_сн".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[Бүгін сағат] LT", nextDay: "[Ертең сағат] LT", nextWeek: "dddd [сағат] LT", lastDay: "[Кеше сағат] LT", lastWeek: "[Өткен аптаның] dddd [сағат] LT", sameElse: "L" },
                        relativeTime: {
                            future: "%s ішінде",
                            past: "%s бұрын",
                            s: "бірнеше секунд",
                            ss: "%d секунд",
                            m: "бір минут",
                            mm: "%d минут",
                            h: "бір сағат",
                            hh: "%d сағат",
                            d: "бір күн",
                            dd: "%d күн",
                            M: "бір ай",
                            MM: "%d ай",
                            y: "бір жыл",
                            yy: "%d жыл",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}-(ші|шы)/,
                        ordinal: function (number) {
                            var a = number % 10,
                                b = number >= 100 ? 100 : null;
                            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
                        },
                        week: { dow: 1, doy: 7 },
                    });
                    return kk;
                });
            },
            "./node_modules/moment/locale/km.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var symbolMap = { 1: "១", 2: "២", 3: "៣", 4: "៤", 5: "៥", 6: "៦", 7: "៧", 8: "៨", 9: "៩", 0: "០" },
                        numberMap = { "១": "1", "២": "2", "៣": "3", "៤": "4", "៥": "5", "៦": "6", "៧": "7", "៨": "8", "៩": "9", "០": "0" };
                    var km = moment.defineLocale("km", {
                        months: "មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ".split("_"),
                        monthsShort: "មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ".split("_"),
                        weekdays: "អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍".split("_"),
                        weekdaysShort: "អា_ច_អ_ព_ព្រ_សុ_ស".split("_"),
                        weekdaysMin: "អា_ច_អ_ព_ព្រ_សុ_ស".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" },
                        meridiemParse: /ព្រឹក|ល្ងាច/,
                        isPM: function (input) {
                            return input === "ល្ងាច";
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 12) {
                                return "ព្រឹក";
                            } else {
                                return "ល្ងាច";
                            }
                        },
                        calendar: { sameDay: "[ថ្ងៃនេះ ម៉ោង] LT", nextDay: "[ស្អែក ម៉ោង] LT", nextWeek: "dddd [ម៉ោង] LT", lastDay: "[ម្សិលមិញ ម៉ោង] LT", lastWeek: "dddd [សប្តាហ៍មុន] [ម៉ោង] LT", sameElse: "L" },
                        relativeTime: {
                            future: "%sទៀត",
                            past: "%sមុន",
                            s: "ប៉ុន្មានវិនាទី",
                            ss: "%d វិនាទី",
                            m: "មួយនាទី",
                            mm: "%d នាទី",
                            h: "មួយម៉ោង",
                            hh: "%d ម៉ោង",
                            d: "មួយថ្ងៃ",
                            dd: "%d ថ្ងៃ",
                            M: "មួយខែ",
                            MM: "%d ខែ",
                            y: "មួយឆ្នាំ",
                            yy: "%d ឆ្នាំ",
                        },
                        dayOfMonthOrdinalParse: /ទី\d{1,2}/,
                        ordinal: "ទី%d",
                        preparse: function (string) {
                            return string.replace(/[១២៣៤៥៦៧៨៩០]/g, function (match) {
                                return numberMap[match];
                            });
                        },
                        postformat: function (string) {
                            return string.replace(/\d/g, function (match) {
                                return symbolMap[match];
                            });
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return km;
                });
            },
            "./node_modules/moment/locale/kn.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var symbolMap = { 1: "೧", 2: "೨", 3: "೩", 4: "೪", 5: "೫", 6: "೬", 7: "೭", 8: "೮", 9: "೯", 0: "೦" },
                        numberMap = { "೧": "1", "೨": "2", "೩": "3", "೪": "4", "೫": "5", "೬": "6", "೭": "7", "೮": "8", "೯": "9", "೦": "0" };
                    var kn = moment.defineLocale("kn", {
                        months: "ಜನವರಿ_ಫೆಬ್ರವರಿ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂಬರ್_ಅಕ್ಟೋಬರ್_ನವೆಂಬರ್_ಡಿಸೆಂಬರ್".split("_"),
                        monthsShort: "ಜನ_ಫೆಬ್ರ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂ_ಅಕ್ಟೋ_ನವೆಂ_ಡಿಸೆಂ".split("_"),
                        monthsParseExact: true,
                        weekdays: "ಭಾನುವಾರ_ಸೋಮವಾರ_ಮಂಗಳವಾರ_ಬುಧವಾರ_ಗುರುವಾರ_ಶುಕ್ರವಾರ_ಶನಿವಾರ".split("_"),
                        weekdaysShort: "ಭಾನು_ಸೋಮ_ಮಂಗಳ_ಬುಧ_ಗುರು_ಶುಕ್ರ_ಶನಿ".split("_"),
                        weekdaysMin: "ಭಾ_ಸೋ_ಮಂ_ಬು_ಗು_ಶು_ಶ".split("_"),
                        longDateFormat: { LT: "A h:mm", LTS: "A h:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm", LLLL: "dddd, D MMMM YYYY, A h:mm" },
                        calendar: { sameDay: "[ಇಂದು] LT", nextDay: "[ನಾಳೆ] LT", nextWeek: "dddd, LT", lastDay: "[ನಿನ್ನೆ] LT", lastWeek: "[ಕೊನೆಯ] dddd, LT", sameElse: "L" },
                        relativeTime: {
                            future: "%s ನಂತರ",
                            past: "%s ಹಿಂದೆ",
                            s: "ಕೆಲವು ಕ್ಷಣಗಳು",
                            ss: "%d ಸೆಕೆಂಡುಗಳು",
                            m: "ಒಂದು ನಿಮಿಷ",
                            mm: "%d ನಿಮಿಷ",
                            h: "ಒಂದು ಗಂಟೆ",
                            hh: "%d ಗಂಟೆ",
                            d: "ಒಂದು ದಿನ",
                            dd: "%d ದಿನ",
                            M: "ಒಂದು ತಿಂಗಳು",
                            MM: "%d ತಿಂಗಳು",
                            y: "ಒಂದು ವರ್ಷ",
                            yy: "%d ವರ್ಷ",
                        },
                        preparse: function (string) {
                            return string.replace(/[೧೨೩೪೫೬೭೮೯೦]/g, function (match) {
                                return numberMap[match];
                            });
                        },
                        postformat: function (string) {
                            return string.replace(/\d/g, function (match) {
                                return symbolMap[match];
                            });
                        },
                        meridiemParse: /ರಾತ್ರಿ|ಬೆಳಿಗ್ಗೆ|ಮಧ್ಯಾಹ್ನ|ಸಂಜೆ/,
                        meridiemHour: function (hour, meridiem) {
                            if (hour === 12) {
                                hour = 0;
                            }
                            if (meridiem === "ರಾತ್ರಿ") {
                                return hour < 4 ? hour : hour + 12;
                            } else if (meridiem === "ಬೆಳಿಗ್ಗೆ") {
                                return hour;
                            } else if (meridiem === "ಮಧ್ಯಾಹ್ನ") {
                                return hour >= 10 ? hour : hour + 12;
                            } else if (meridiem === "ಸಂಜೆ") {
                                return hour + 12;
                            }
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 4) {
                                return "ರಾತ್ರಿ";
                            } else if (hour < 10) {
                                return "ಬೆಳಿಗ್ಗೆ";
                            } else if (hour < 17) {
                                return "ಮಧ್ಯಾಹ್ನ";
                            } else if (hour < 20) {
                                return "ಸಂಜೆ";
                            } else {
                                return "ರಾತ್ರಿ";
                            }
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(ನೇ)/,
                        ordinal: function (number) {
                            return number + "ನೇ";
                        },
                        week: { dow: 0, doy: 6 },
                    });
                    return kn;
                });
            },
            "./node_modules/moment/locale/ko.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var ko = moment.defineLocale("ko", {
                        months: "1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월".split("_"),
                        monthsShort: "1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월".split("_"),
                        weekdays: "일요일_월요일_화요일_수요일_목요일_금요일_토요일".split("_"),
                        weekdaysShort: "일_월_화_수_목_금_토".split("_"),
                        weekdaysMin: "일_월_화_수_목_금_토".split("_"),
                        longDateFormat: {
                            LT: "A h:mm",
                            LTS: "A h:mm:ss",
                            L: "YYYY.MM.DD.",
                            LL: "YYYY년 MMMM D일",
                            LLL: "YYYY년 MMMM D일 A h:mm",
                            LLLL: "YYYY년 MMMM D일 dddd A h:mm",
                            l: "YYYY.MM.DD.",
                            ll: "YYYY년 MMMM D일",
                            lll: "YYYY년 MMMM D일 A h:mm",
                            llll: "YYYY년 MMMM D일 dddd A h:mm",
                        },
                        calendar: { sameDay: "오늘 LT", nextDay: "내일 LT", nextWeek: "dddd LT", lastDay: "어제 LT", lastWeek: "지난주 dddd LT", sameElse: "L" },
                        relativeTime: { future: "%s 후", past: "%s 전", s: "몇 초", ss: "%d초", m: "1분", mm: "%d분", h: "한 시간", hh: "%d시간", d: "하루", dd: "%d일", M: "한 달", MM: "%d달", y: "일 년", yy: "%d년" },
                        dayOfMonthOrdinalParse: /\d{1,2}(일|월|주)/,
                        ordinal: function (number, period) {
                            switch (period) {
                                case "d":
                                case "D":
                                case "DDD":
                                    return number + "일";
                                case "M":
                                    return number + "월";
                                case "w":
                                case "W":
                                    return number + "주";
                                default:
                                    return number;
                            }
                        },
                        meridiemParse: /오전|오후/,
                        isPM: function (token) {
                            return token === "오후";
                        },
                        meridiem: function (hour, minute, isUpper) {
                            return hour < 12 ? "오전" : "오후";
                        },
                    });
                    return ko;
                });
            },
            "./node_modules/moment/locale/ku.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var symbolMap = { 1: "١", 2: "٢", 3: "٣", 4: "٤", 5: "٥", 6: "٦", 7: "٧", 8: "٨", 9: "٩", 0: "٠" },
                        numberMap = { "١": "1", "٢": "2", "٣": "3", "٤": "4", "٥": "5", "٦": "6", "٧": "7", "٨": "8", "٩": "9", "٠": "0" },
                        months = ["کانونی دووەم", "شوبات", "ئازار", "نیسان", "ئایار", "حوزەیران", "تەمموز", "ئاب", "ئەیلوول", "تشرینی یەكەم", "تشرینی دووەم", "كانونی یەکەم"];
                    var ku = moment.defineLocale("ku", {
                        months: months,
                        monthsShort: months,
                        weekdays: "یه‌كشه‌ممه‌_دووشه‌ممه‌_سێشه‌ممه‌_چوارشه‌ممه‌_پێنجشه‌ممه‌_هه‌ینی_شه‌ممه‌".split("_"),
                        weekdaysShort: "یه‌كشه‌م_دووشه‌م_سێشه‌م_چوارشه‌م_پێنجشه‌م_هه‌ینی_شه‌ممه‌".split("_"),
                        weekdaysMin: "ی_د_س_چ_پ_ه_ش".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" },
                        meridiemParse: /ئێواره‌|به‌یانی/,
                        isPM: function (input) {
                            return /ئێواره‌/.test(input);
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 12) {
                                return "به‌یانی";
                            } else {
                                return "ئێواره‌";
                            }
                        },
                        calendar: { sameDay: "[ئه‌مرۆ كاتژمێر] LT", nextDay: "[به‌یانی كاتژمێر] LT", nextWeek: "dddd [كاتژمێر] LT", lastDay: "[دوێنێ كاتژمێر] LT", lastWeek: "dddd [كاتژمێر] LT", sameElse: "L" },
                        relativeTime: {
                            future: "له‌ %s",
                            past: "%s",
                            s: "چه‌ند چركه‌یه‌ك",
                            ss: "چركه‌ %d",
                            m: "یه‌ك خوله‌ك",
                            mm: "%d خوله‌ك",
                            h: "یه‌ك كاتژمێر",
                            hh: "%d كاتژمێر",
                            d: "یه‌ك ڕۆژ",
                            dd: "%d ڕۆژ",
                            M: "یه‌ك مانگ",
                            MM: "%d مانگ",
                            y: "یه‌ك ساڵ",
                            yy: "%d ساڵ",
                        },
                        preparse: function (string) {
                            return string
                                .replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
                                    return numberMap[match];
                                })
                                .replace(/،/g, ",");
                        },
                        postformat: function (string) {
                            return string
                                .replace(/\d/g, function (match) {
                                    return symbolMap[match];
                                })
                                .replace(/,/g, "،");
                        },
                        week: { dow: 6, doy: 12 },
                    });
                    return ku;
                });
            },
            "./node_modules/moment/locale/ky.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var suffixes = {
                        0: "-чү",
                        1: "-чи",
                        2: "-чи",
                        3: "-чү",
                        4: "-чү",
                        5: "-чи",
                        6: "-чы",
                        7: "-чи",
                        8: "-чи",
                        9: "-чу",
                        10: "-чу",
                        20: "-чы",
                        30: "-чу",
                        40: "-чы",
                        50: "-чү",
                        60: "-чы",
                        70: "-чи",
                        80: "-чи",
                        90: "-чу",
                        100: "-чү",
                    };
                    var ky = moment.defineLocale("ky", {
                        months: "январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь".split("_"),
                        monthsShort: "янв_фев_март_апр_май_июнь_июль_авг_сен_окт_ноя_дек".split("_"),
                        weekdays: "Жекшемби_Дүйшөмбү_Шейшемби_Шаршемби_Бейшемби_Жума_Ишемби".split("_"),
                        weekdaysShort: "Жек_Дүй_Шей_Шар_Бей_Жум_Ише".split("_"),
                        weekdaysMin: "Жк_Дй_Шй_Шр_Бй_Жм_Иш".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[Бүгүн саат] LT", nextDay: "[Эртең саат] LT", nextWeek: "dddd [саат] LT", lastDay: "[Кечээ саат] LT", lastWeek: "[Өткөн аптанын] dddd [күнү] [саат] LT", sameElse: "L" },
                        relativeTime: {
                            future: "%s ичинде",
                            past: "%s мурун",
                            s: "бирнече секунд",
                            ss: "%d секунд",
                            m: "бир мүнөт",
                            mm: "%d мүнөт",
                            h: "бир саат",
                            hh: "%d саат",
                            d: "бир күн",
                            dd: "%d күн",
                            M: "бир ай",
                            MM: "%d ай",
                            y: "бир жыл",
                            yy: "%d жыл",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}-(чи|чы|чү|чу)/,
                        ordinal: function (number) {
                            var a = number % 10,
                                b = number >= 100 ? 100 : null;
                            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
                        },
                        week: { dow: 1, doy: 7 },
                    });
                    return ky;
                });
            },
            "./node_modules/moment/locale/lb.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    function processRelativeTime(number, withoutSuffix, key, isFuture) {
                        var format = { m: ["eng Minutt", "enger Minutt"], h: ["eng Stonn", "enger Stonn"], d: ["een Dag", "engem Dag"], M: ["ee Mount", "engem Mount"], y: ["ee Joer", "engem Joer"] };
                        return withoutSuffix ? format[key][0] : format[key][1];
                    }
                    function processFutureTime(string) {
                        var number = string.substr(0, string.indexOf(" "));
                        if (eifelerRegelAppliesToNumber(number)) {
                            return "a " + string;
                        }
                        return "an " + string;
                    }
                    function processPastTime(string) {
                        var number = string.substr(0, string.indexOf(" "));
                        if (eifelerRegelAppliesToNumber(number)) {
                            return "viru " + string;
                        }
                        return "virun " + string;
                    }
                    function eifelerRegelAppliesToNumber(number) {
                        number = parseInt(number, 10);
                        if (isNaN(number)) {
                            return false;
                        }
                        if (number < 0) {
                            return true;
                        } else if (number < 10) {
                            if (4 <= number && number <= 7) {
                                return true;
                            }
                            return false;
                        } else if (number < 100) {
                            var lastDigit = number % 10,
                                firstDigit = number / 10;
                            if (lastDigit === 0) {
                                return eifelerRegelAppliesToNumber(firstDigit);
                            }
                            return eifelerRegelAppliesToNumber(lastDigit);
                        } else if (number < 1e4) {
                            while (number >= 10) {
                                number = number / 10;
                            }
                            return eifelerRegelAppliesToNumber(number);
                        } else {
                            number = number / 1e3;
                            return eifelerRegelAppliesToNumber(number);
                        }
                    }
                    var lb = moment.defineLocale("lb", {
                        months: "Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
                        monthsShort: "Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"),
                        monthsParseExact: true,
                        weekdays: "Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg".split("_"),
                        weekdaysShort: "So._Mé._Dë._Më._Do._Fr._Sa.".split("_"),
                        weekdaysMin: "So_Mé_Dë_Më_Do_Fr_Sa".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "H:mm [Auer]", LTS: "H:mm:ss [Auer]", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm [Auer]", LLLL: "dddd, D. MMMM YYYY H:mm [Auer]" },
                        calendar: {
                            sameDay: "[Haut um] LT",
                            sameElse: "L",
                            nextDay: "[Muer um] LT",
                            nextWeek: "dddd [um] LT",
                            lastDay: "[Gëschter um] LT",
                            lastWeek: function () {
                                switch (this.day()) {
                                    case 2:
                                    case 4:
                                        return "[Leschten] dddd [um] LT";
                                    default:
                                        return "[Leschte] dddd [um] LT";
                                }
                            },
                        },
                        relativeTime: {
                            future: processFutureTime,
                            past: processPastTime,
                            s: "e puer Sekonnen",
                            ss: "%d Sekonnen",
                            m: processRelativeTime,
                            mm: "%d Minutten",
                            h: processRelativeTime,
                            hh: "%d Stonnen",
                            d: processRelativeTime,
                            dd: "%d Deeg",
                            M: processRelativeTime,
                            MM: "%d Méint",
                            y: processRelativeTime,
                            yy: "%d Joer",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}\./,
                        ordinal: "%d.",
                        week: { dow: 1, doy: 4 },
                    });
                    return lb;
                });
            },
            "./node_modules/moment/locale/lo.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var lo = moment.defineLocale("lo", {
                        months: "ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ".split("_"),
                        monthsShort: "ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ".split("_"),
                        weekdays: "ອາທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ".split("_"),
                        weekdaysShort: "ທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ".split("_"),
                        weekdaysMin: "ທ_ຈ_ອຄ_ພ_ພຫ_ສກ_ສ".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "ວັນdddd D MMMM YYYY HH:mm" },
                        meridiemParse: /ຕອນເຊົ້າ|ຕອນແລງ/,
                        isPM: function (input) {
                            return input === "ຕອນແລງ";
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 12) {
                                return "ຕອນເຊົ້າ";
                            } else {
                                return "ຕອນແລງ";
                            }
                        },
                        calendar: { sameDay: "[ມື້ນີ້ເວລາ] LT", nextDay: "[ມື້ອື່ນເວລາ] LT", nextWeek: "[ວັນ]dddd[ໜ້າເວລາ] LT", lastDay: "[ມື້ວານນີ້ເວລາ] LT", lastWeek: "[ວັນ]dddd[ແລ້ວນີ້ເວລາ] LT", sameElse: "L" },
                        relativeTime: {
                            future: "ອີກ %s",
                            past: "%sຜ່ານມາ",
                            s: "ບໍ່ເທົ່າໃດວິນາທີ",
                            ss: "%d ວິນາທີ",
                            m: "1 ນາທີ",
                            mm: "%d ນາທີ",
                            h: "1 ຊົ່ວໂມງ",
                            hh: "%d ຊົ່ວໂມງ",
                            d: "1 ມື້",
                            dd: "%d ມື້",
                            M: "1 ເດືອນ",
                            MM: "%d ເດືອນ",
                            y: "1 ປີ",
                            yy: "%d ປີ",
                        },
                        dayOfMonthOrdinalParse: /(ທີ່)\d{1,2}/,
                        ordinal: function (number) {
                            return "ທີ່" + number;
                        },
                    });
                    return lo;
                });
            },
            "./node_modules/moment/locale/lt.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var units = {
                        ss: "sekundė_sekundžių_sekundes",
                        m: "minutė_minutės_minutę",
                        mm: "minutės_minučių_minutes",
                        h: "valanda_valandos_valandą",
                        hh: "valandos_valandų_valandas",
                        d: "diena_dienos_dieną",
                        dd: "dienos_dienų_dienas",
                        M: "mėnuo_mėnesio_mėnesį",
                        MM: "mėnesiai_mėnesių_mėnesius",
                        y: "metai_metų_metus",
                        yy: "metai_metų_metus",
                    };
                    function translateSeconds(number, withoutSuffix, key, isFuture) {
                        if (withoutSuffix) {
                            return "kelios sekundės";
                        } else {
                            return isFuture ? "kelių sekundžių" : "kelias sekundes";
                        }
                    }
                    function translateSingular(number, withoutSuffix, key, isFuture) {
                        return withoutSuffix ? forms(key)[0] : isFuture ? forms(key)[1] : forms(key)[2];
                    }
                    function special(number) {
                        return number % 10 === 0 || (number > 10 && number < 20);
                    }
                    function forms(key) {
                        return units[key].split("_");
                    }
                    function translate(number, withoutSuffix, key, isFuture) {
                        var result = number + " ";
                        if (number === 1) {
                            return result + translateSingular(number, withoutSuffix, key[0], isFuture);
                        } else if (withoutSuffix) {
                            return result + (special(number) ? forms(key)[1] : forms(key)[0]);
                        } else {
                            if (isFuture) {
                                return result + forms(key)[1];
                            } else {
                                return result + (special(number) ? forms(key)[1] : forms(key)[2]);
                            }
                        }
                    }
                    var lt = moment.defineLocale("lt", {
                        months: {
                            format: "sausio_vasario_kovo_balandžio_gegužės_birželio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio".split("_"),
                            standalone: "sausis_vasaris_kovas_balandis_gegužė_birželis_liepa_rugpjūtis_rugsėjis_spalis_lapkritis_gruodis".split("_"),
                            isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/,
                        },
                        monthsShort: "sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd".split("_"),
                        weekdays: {
                            format: "sekmadienį_pirmadienį_antradienį_trečiadienį_ketvirtadienį_penktadienį_šeštadienį".split("_"),
                            standalone: "sekmadienis_pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis".split("_"),
                            isFormat: /dddd HH:mm/,
                        },
                        weekdaysShort: "Sek_Pir_Ant_Tre_Ket_Pen_Šeš".split("_"),
                        weekdaysMin: "S_P_A_T_K_Pn_Š".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: {
                            LT: "HH:mm",
                            LTS: "HH:mm:ss",
                            L: "YYYY-MM-DD",
                            LL: "YYYY [m.] MMMM D [d.]",
                            LLL: "YYYY [m.] MMMM D [d.], HH:mm [val.]",
                            LLLL: "YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]",
                            l: "YYYY-MM-DD",
                            ll: "YYYY [m.] MMMM D [d.]",
                            lll: "YYYY [m.] MMMM D [d.], HH:mm [val.]",
                            llll: "YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]",
                        },
                        calendar: { sameDay: "[Šiandien] LT", nextDay: "[Rytoj] LT", nextWeek: "dddd LT", lastDay: "[Vakar] LT", lastWeek: "[Praėjusį] dddd LT", sameElse: "L" },
                        relativeTime: {
                            future: "po %s",
                            past: "prieš %s",
                            s: translateSeconds,
                            ss: translate,
                            m: translateSingular,
                            mm: translate,
                            h: translateSingular,
                            hh: translate,
                            d: translateSingular,
                            dd: translate,
                            M: translateSingular,
                            MM: translate,
                            y: translateSingular,
                            yy: translate,
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}-oji/,
                        ordinal: function (number) {
                            return number + "-oji";
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return lt;
                });
            },
            "./node_modules/moment/locale/lv.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var units = {
                        ss: "sekundes_sekundēm_sekunde_sekundes".split("_"),
                        m: "minūtes_minūtēm_minūte_minūtes".split("_"),
                        mm: "minūtes_minūtēm_minūte_minūtes".split("_"),
                        h: "stundas_stundām_stunda_stundas".split("_"),
                        hh: "stundas_stundām_stunda_stundas".split("_"),
                        d: "dienas_dienām_diena_dienas".split("_"),
                        dd: "dienas_dienām_diena_dienas".split("_"),
                        M: "mēneša_mēnešiem_mēnesis_mēneši".split("_"),
                        MM: "mēneša_mēnešiem_mēnesis_mēneši".split("_"),
                        y: "gada_gadiem_gads_gadi".split("_"),
                        yy: "gada_gadiem_gads_gadi".split("_"),
                    };
                    function format(forms, number, withoutSuffix) {
                        if (withoutSuffix) {
                            return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
                        } else {
                            return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
                        }
                    }
                    function relativeTimeWithPlural(number, withoutSuffix, key) {
                        return number + " " + format(units[key], number, withoutSuffix);
                    }
                    function relativeTimeWithSingular(number, withoutSuffix, key) {
                        return format(units[key], number, withoutSuffix);
                    }
                    function relativeSeconds(number, withoutSuffix) {
                        return withoutSuffix ? "dažas sekundes" : "dažām sekundēm";
                    }
                    var lv = moment.defineLocale("lv", {
                        months: "janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris".split("_"),
                        monthsShort: "jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec".split("_"),
                        weekdays: "svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena".split("_"),
                        weekdaysShort: "Sv_P_O_T_C_Pk_S".split("_"),
                        weekdaysMin: "Sv_P_O_T_C_Pk_S".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY.", LL: "YYYY. [gada] D. MMMM", LLL: "YYYY. [gada] D. MMMM, HH:mm", LLLL: "YYYY. [gada] D. MMMM, dddd, HH:mm" },
                        calendar: { sameDay: "[Šodien pulksten] LT", nextDay: "[Rīt pulksten] LT", nextWeek: "dddd [pulksten] LT", lastDay: "[Vakar pulksten] LT", lastWeek: "[Pagājušā] dddd [pulksten] LT", sameElse: "L" },
                        relativeTime: {
                            future: "pēc %s",
                            past: "pirms %s",
                            s: relativeSeconds,
                            ss: relativeTimeWithPlural,
                            m: relativeTimeWithSingular,
                            mm: relativeTimeWithPlural,
                            h: relativeTimeWithSingular,
                            hh: relativeTimeWithPlural,
                            d: relativeTimeWithSingular,
                            dd: relativeTimeWithPlural,
                            M: relativeTimeWithSingular,
                            MM: relativeTimeWithPlural,
                            y: relativeTimeWithSingular,
                            yy: relativeTimeWithPlural,
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}\./,
                        ordinal: "%d.",
                        week: { dow: 1, doy: 4 },
                    });
                    return lv;
                });
            },
            "./node_modules/moment/locale/me.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var translator = {
                        words: {
                            ss: ["sekund", "sekunda", "sekundi"],
                            m: ["jedan minut", "jednog minuta"],
                            mm: ["minut", "minuta", "minuta"],
                            h: ["jedan sat", "jednog sata"],
                            hh: ["sat", "sata", "sati"],
                            dd: ["dan", "dana", "dana"],
                            MM: ["mjesec", "mjeseca", "mjeseci"],
                            yy: ["godina", "godine", "godina"],
                        },
                        correctGrammaticalCase: function (number, wordKey) {
                            return number === 1 ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
                        },
                        translate: function (number, withoutSuffix, key) {
                            var wordKey = translator.words[key];
                            if (key.length === 1) {
                                return withoutSuffix ? wordKey[0] : wordKey[1];
                            } else {
                                return number + " " + translator.correctGrammaticalCase(number, wordKey);
                            }
                        },
                    };
                    var me = moment.defineLocale("me", {
                        months: "januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"),
                        monthsShort: "jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"),
                        monthsParseExact: true,
                        weekdays: "nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota".split("_"),
                        weekdaysShort: "ned._pon._uto._sri._čet._pet._sub.".split("_"),
                        weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd, D. MMMM YYYY H:mm" },
                        calendar: {
                            sameDay: "[danas u] LT",
                            nextDay: "[sjutra u] LT",
                            nextWeek: function () {
                                switch (this.day()) {
                                    case 0:
                                        return "[u] [nedjelju] [u] LT";
                                    case 3:
                                        return "[u] [srijedu] [u] LT";
                                    case 6:
                                        return "[u] [subotu] [u] LT";
                                    case 1:
                                    case 2:
                                    case 4:
                                    case 5:
                                        return "[u] dddd [u] LT";
                                }
                            },
                            lastDay: "[juče u] LT",
                            lastWeek: function () {
                                var lastWeekDays = [
                                    "[prošle] [nedjelje] [u] LT",
                                    "[prošlog] [ponedjeljka] [u] LT",
                                    "[prošlog] [utorka] [u] LT",
                                    "[prošle] [srijede] [u] LT",
                                    "[prošlog] [četvrtka] [u] LT",
                                    "[prošlog] [petka] [u] LT",
                                    "[prošle] [subote] [u] LT",
                                ];
                                return lastWeekDays[this.day()];
                            },
                            sameElse: "L",
                        },
                        relativeTime: {
                            future: "za %s",
                            past: "prije %s",
                            s: "nekoliko sekundi",
                            ss: translator.translate,
                            m: translator.translate,
                            mm: translator.translate,
                            h: translator.translate,
                            hh: translator.translate,
                            d: "dan",
                            dd: translator.translate,
                            M: "mjesec",
                            MM: translator.translate,
                            y: "godinu",
                            yy: translator.translate,
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}\./,
                        ordinal: "%d.",
                        week: { dow: 1, doy: 7 },
                    });
                    return me;
                });
            },
            "./node_modules/moment/locale/mi.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var mi = moment.defineLocale("mi", {
                        months: "Kohi-tāte_Hui-tanguru_Poutū-te-rangi_Paenga-whāwhā_Haratua_Pipiri_Hōngoingoi_Here-turi-kōkā_Mahuru_Whiringa-ā-nuku_Whiringa-ā-rangi_Hakihea".split("_"),
                        monthsShort: "Kohi_Hui_Pou_Pae_Hara_Pipi_Hōngoi_Here_Mahu_Whi-nu_Whi-ra_Haki".split("_"),
                        monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
                        monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
                        monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
                        monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
                        weekdays: "Rātapu_Mane_Tūrei_Wenerei_Tāite_Paraire_Hātarei".split("_"),
                        weekdaysShort: "Ta_Ma_Tū_We_Tāi_Pa_Hā".split("_"),
                        weekdaysMin: "Ta_Ma_Tū_We_Tāi_Pa_Hā".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [i] HH:mm", LLLL: "dddd, D MMMM YYYY [i] HH:mm" },
                        calendar: { sameDay: "[i teie mahana, i] LT", nextDay: "[apopo i] LT", nextWeek: "dddd [i] LT", lastDay: "[inanahi i] LT", lastWeek: "dddd [whakamutunga i] LT", sameElse: "L" },
                        relativeTime: {
                            future: "i roto i %s",
                            past: "%s i mua",
                            s: "te hēkona ruarua",
                            ss: "%d hēkona",
                            m: "he meneti",
                            mm: "%d meneti",
                            h: "te haora",
                            hh: "%d haora",
                            d: "he ra",
                            dd: "%d ra",
                            M: "he marama",
                            MM: "%d marama",
                            y: "he tau",
                            yy: "%d tau",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}º/,
                        ordinal: "%dº",
                        week: { dow: 1, doy: 4 },
                    });
                    return mi;
                });
            },
            "./node_modules/moment/locale/mk.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var mk = moment.defineLocale("mk", {
                        months: "јануари_февруари_март_април_мај_јуни_јули_август_септември_октомври_ноември_декември".split("_"),
                        monthsShort: "јан_фев_мар_апр_мај_јун_јул_авг_сеп_окт_ное_дек".split("_"),
                        weekdays: "недела_понеделник_вторник_среда_четврток_петок_сабота".split("_"),
                        weekdaysShort: "нед_пон_вто_сре_чет_пет_саб".split("_"),
                        weekdaysMin: "нe_пo_вт_ср_че_пе_сa".split("_"),
                        longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "D.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY H:mm", LLLL: "dddd, D MMMM YYYY H:mm" },
                        calendar: {
                            sameDay: "[Денес во] LT",
                            nextDay: "[Утре во] LT",
                            nextWeek: "[Во] dddd [во] LT",
                            lastDay: "[Вчера во] LT",
                            lastWeek: function () {
                                switch (this.day()) {
                                    case 0:
                                    case 3:
                                    case 6:
                                        return "[Изминатата] dddd [во] LT";
                                    case 1:
                                    case 2:
                                    case 4:
                                    case 5:
                                        return "[Изминатиот] dddd [во] LT";
                                }
                            },
                            sameElse: "L",
                        },
                        relativeTime: {
                            future: "за %s",
                            past: "пред %s",
                            s: "неколку секунди",
                            ss: "%d секунди",
                            m: "една минута",
                            mm: "%d минути",
                            h: "еден час",
                            hh: "%d часа",
                            d: "еден ден",
                            dd: "%d дена",
                            M: "еден месец",
                            MM: "%d месеци",
                            y: "една година",
                            yy: "%d години",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
                        ordinal: function (number) {
                            var lastDigit = number % 10,
                                last2Digits = number % 100;
                            if (number === 0) {
                                return number + "-ев";
                            } else if (last2Digits === 0) {
                                return number + "-ен";
                            } else if (last2Digits > 10 && last2Digits < 20) {
                                return number + "-ти";
                            } else if (lastDigit === 1) {
                                return number + "-ви";
                            } else if (lastDigit === 2) {
                                return number + "-ри";
                            } else if (lastDigit === 7 || lastDigit === 8) {
                                return number + "-ми";
                            } else {
                                return number + "-ти";
                            }
                        },
                        week: { dow: 1, doy: 7 },
                    });
                    return mk;
                });
            },
            "./node_modules/moment/locale/ml.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var ml = moment.defineLocale("ml", {
                        months: "ജനുവരി_ഫെബ്രുവരി_മാർച്ച്_ഏപ്രിൽ_മേയ്_ജൂൺ_ജൂലൈ_ഓഗസ്റ്റ്_സെപ്റ്റംബർ_ഒക്ടോബർ_നവംബർ_ഡിസംബർ".split("_"),
                        monthsShort: "ജനു._ഫെബ്രു._മാർ._ഏപ്രി._മേയ്_ജൂൺ_ജൂലൈ._ഓഗ._സെപ്റ്റ._ഒക്ടോ._നവം._ഡിസം.".split("_"),
                        monthsParseExact: true,
                        weekdays: "ഞായറാഴ്ച_തിങ്കളാഴ്ച_ചൊവ്വാഴ്ച_ബുധനാഴ്ച_വ്യാഴാഴ്ച_വെള്ളിയാഴ്ച_ശനിയാഴ്ച".split("_"),
                        weekdaysShort: "ഞായർ_തിങ്കൾ_ചൊവ്വ_ബുധൻ_വ്യാഴം_വെള്ളി_ശനി".split("_"),
                        weekdaysMin: "ഞാ_തി_ചൊ_ബു_വ്യാ_വെ_ശ".split("_"),
                        longDateFormat: { LT: "A h:mm -നു", LTS: "A h:mm:ss -നു", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm -നു", LLLL: "dddd, D MMMM YYYY, A h:mm -നു" },
                        calendar: { sameDay: "[ഇന്ന്] LT", nextDay: "[നാളെ] LT", nextWeek: "dddd, LT", lastDay: "[ഇന്നലെ] LT", lastWeek: "[കഴിഞ്ഞ] dddd, LT", sameElse: "L" },
                        relativeTime: {
                            future: "%s കഴിഞ്ഞ്",
                            past: "%s മുൻപ്",
                            s: "അൽപ നിമിഷങ്ങൾ",
                            ss: "%d സെക്കൻഡ്",
                            m: "ഒരു മിനിറ്റ്",
                            mm: "%d മിനിറ്റ്",
                            h: "ഒരു മണിക്കൂർ",
                            hh: "%d മണിക്കൂർ",
                            d: "ഒരു ദിവസം",
                            dd: "%d ദിവസം",
                            M: "ഒരു മാസം",
                            MM: "%d മാസം",
                            y: "ഒരു വർഷം",
                            yy: "%d വർഷം",
                        },
                        meridiemParse: /രാത്രി|രാവിലെ|ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി/i,
                        meridiemHour: function (hour, meridiem) {
                            if (hour === 12) {
                                hour = 0;
                            }
                            if ((meridiem === "രാത്രി" && hour >= 4) || meridiem === "ഉച്ച കഴിഞ്ഞ്" || meridiem === "വൈകുന്നേരം") {
                                return hour + 12;
                            } else {
                                return hour;
                            }
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 4) {
                                return "രാത്രി";
                            } else if (hour < 12) {
                                return "രാവിലെ";
                            } else if (hour < 17) {
                                return "ഉച്ച കഴിഞ്ഞ്";
                            } else if (hour < 20) {
                                return "വൈകുന്നേരം";
                            } else {
                                return "രാത്രി";
                            }
                        },
                    });
                    return ml;
                });
            },
            "./node_modules/moment/locale/mn.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    function translate(number, withoutSuffix, key, isFuture) {
                        switch (key) {
                            case "s":
                                return withoutSuffix ? "хэдхэн секунд" : "хэдхэн секундын";
                            case "ss":
                                return number + (withoutSuffix ? " секунд" : " секундын");
                            case "m":
                            case "mm":
                                return number + (withoutSuffix ? " минут" : " минутын");
                            case "h":
                            case "hh":
                                return number + (withoutSuffix ? " цаг" : " цагийн");
                            case "d":
                            case "dd":
                                return number + (withoutSuffix ? " өдөр" : " өдрийн");
                            case "M":
                            case "MM":
                                return number + (withoutSuffix ? " сар" : " сарын");
                            case "y":
                            case "yy":
                                return number + (withoutSuffix ? " жил" : " жилийн");
                            default:
                                return number;
                        }
                    }
                    var mn = moment.defineLocale("mn", {
                        months: "Нэгдүгээр сар_Хоёрдугаар сар_Гуравдугаар сар_Дөрөвдүгээр сар_Тавдугаар сар_Зургадугаар сар_Долдугаар сар_Наймдугаар сар_Есдүгээр сар_Аравдугаар сар_Арван нэгдүгээр сар_Арван хоёрдугаар сар".split("_"),
                        monthsShort: "1 сар_2 сар_3 сар_4 сар_5 сар_6 сар_7 сар_8 сар_9 сар_10 сар_11 сар_12 сар".split("_"),
                        monthsParseExact: true,
                        weekdays: "Ням_Даваа_Мягмар_Лхагва_Пүрэв_Баасан_Бямба".split("_"),
                        weekdaysShort: "Ням_Дав_Мяг_Лха_Пүр_Баа_Бям".split("_"),
                        weekdaysMin: "Ня_Да_Мя_Лх_Пү_Ба_Бя".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "YYYY оны MMMMын D", LLL: "YYYY оны MMMMын D HH:mm", LLLL: "dddd, YYYY оны MMMMын D HH:mm" },
                        meridiemParse: /ҮӨ|ҮХ/i,
                        isPM: function (input) {
                            return input === "ҮХ";
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 12) {
                                return "ҮӨ";
                            } else {
                                return "ҮХ";
                            }
                        },
                        calendar: { sameDay: "[Өнөөдөр] LT", nextDay: "[Маргааш] LT", nextWeek: "[Ирэх] dddd LT", lastDay: "[Өчигдөр] LT", lastWeek: "[Өнгөрсөн] dddd LT", sameElse: "L" },
                        relativeTime: {
                            future: "%s дараа",
                            past: "%s өмнө",
                            s: translate,
                            ss: translate,
                            m: translate,
                            mm: translate,
                            h: translate,
                            hh: translate,
                            d: translate,
                            dd: translate,
                            M: translate,
                            MM: translate,
                            y: translate,
                            yy: translate,
                        },
                        dayOfMonthOrdinalParse: /\d{1,2} өдөр/,
                        ordinal: function (number, period) {
                            switch (period) {
                                case "d":
                                case "D":
                                case "DDD":
                                    return number + " өдөр";
                                default:
                                    return number;
                            }
                        },
                    });
                    return mn;
                });
            },
            "./node_modules/moment/locale/mr.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var symbolMap = { 1: "१", 2: "२", 3: "३", 4: "४", 5: "५", 6: "६", 7: "७", 8: "८", 9: "९", 0: "०" },
                        numberMap = { "१": "1", "२": "2", "३": "3", "४": "4", "५": "5", "६": "6", "७": "7", "८": "8", "९": "9", "०": "0" };
                    function relativeTimeMr(number, withoutSuffix, string, isFuture) {
                        var output = "";
                        if (withoutSuffix) {
                            switch (string) {
                                case "s":
                                    output = "काही सेकंद";
                                    break;
                                case "ss":
                                    output = "%d सेकंद";
                                    break;
                                case "m":
                                    output = "एक मिनिट";
                                    break;
                                case "mm":
                                    output = "%d मिनिटे";
                                    break;
                                case "h":
                                    output = "एक तास";
                                    break;
                                case "hh":
                                    output = "%d तास";
                                    break;
                                case "d":
                                    output = "एक दिवस";
                                    break;
                                case "dd":
                                    output = "%d दिवस";
                                    break;
                                case "M":
                                    output = "एक महिना";
                                    break;
                                case "MM":
                                    output = "%d महिने";
                                    break;
                                case "y":
                                    output = "एक वर्ष";
                                    break;
                                case "yy":
                                    output = "%d वर्षे";
                                    break;
                            }
                        } else {
                            switch (string) {
                                case "s":
                                    output = "काही सेकंदां";
                                    break;
                                case "ss":
                                    output = "%d सेकंदां";
                                    break;
                                case "m":
                                    output = "एका मिनिटा";
                                    break;
                                case "mm":
                                    output = "%d मिनिटां";
                                    break;
                                case "h":
                                    output = "एका तासा";
                                    break;
                                case "hh":
                                    output = "%d तासां";
                                    break;
                                case "d":
                                    output = "एका दिवसा";
                                    break;
                                case "dd":
                                    output = "%d दिवसां";
                                    break;
                                case "M":
                                    output = "एका महिन्या";
                                    break;
                                case "MM":
                                    output = "%d महिन्यां";
                                    break;
                                case "y":
                                    output = "एका वर्षा";
                                    break;
                                case "yy":
                                    output = "%d वर्षां";
                                    break;
                            }
                        }
                        return output.replace(/%d/i, number);
                    }
                    var mr = moment.defineLocale("mr", {
                        months: "जानेवारी_फेब्रुवारी_मार्च_एप्रिल_मे_जून_जुलै_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर".split("_"),
                        monthsShort: "जाने._फेब्रु._मार्च._एप्रि._मे._जून._जुलै._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.".split("_"),
                        monthsParseExact: true,
                        weekdays: "रविवार_सोमवार_मंगळवार_बुधवार_गुरूवार_शुक्रवार_शनिवार".split("_"),
                        weekdaysShort: "रवि_सोम_मंगळ_बुध_गुरू_शुक्र_शनि".split("_"),
                        weekdaysMin: "र_सो_मं_बु_गु_शु_श".split("_"),
                        longDateFormat: { LT: "A h:mm वाजता", LTS: "A h:mm:ss वाजता", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm वाजता", LLLL: "dddd, D MMMM YYYY, A h:mm वाजता" },
                        calendar: { sameDay: "[आज] LT", nextDay: "[उद्या] LT", nextWeek: "dddd, LT", lastDay: "[काल] LT", lastWeek: "[मागील] dddd, LT", sameElse: "L" },
                        relativeTime: {
                            future: "%sमध्ये",
                            past: "%sपूर्वी",
                            s: relativeTimeMr,
                            ss: relativeTimeMr,
                            m: relativeTimeMr,
                            mm: relativeTimeMr,
                            h: relativeTimeMr,
                            hh: relativeTimeMr,
                            d: relativeTimeMr,
                            dd: relativeTimeMr,
                            M: relativeTimeMr,
                            MM: relativeTimeMr,
                            y: relativeTimeMr,
                            yy: relativeTimeMr,
                        },
                        preparse: function (string) {
                            return string.replace(/[१२३४५६७८९०]/g, function (match) {
                                return numberMap[match];
                            });
                        },
                        postformat: function (string) {
                            return string.replace(/\d/g, function (match) {
                                return symbolMap[match];
                            });
                        },
                        meridiemParse: /पहाटे|सकाळी|दुपारी|सायंकाळी|रात्री/,
                        meridiemHour: function (hour, meridiem) {
                            if (hour === 12) {
                                hour = 0;
                            }
                            if (meridiem === "पहाटे" || meridiem === "सकाळी") {
                                return hour;
                            } else if (meridiem === "दुपारी" || meridiem === "सायंकाळी" || meridiem === "रात्री") {
                                return hour >= 12 ? hour : hour + 12;
                            }
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour >= 0 && hour < 6) {
                                return "पहाटे";
                            } else if (hour < 12) {
                                return "सकाळी";
                            } else if (hour < 17) {
                                return "दुपारी";
                            } else if (hour < 20) {
                                return "सायंकाळी";
                            } else {
                                return "रात्री";
                            }
                        },
                        week: { dow: 0, doy: 6 },
                    });
                    return mr;
                });
            },
            "./node_modules/moment/locale/ms-my.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var msMy = moment.defineLocale("ms-my", {
                        months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"),
                        monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),
                        weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),
                        weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),
                        weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),
                        longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [pukul] HH.mm", LLLL: "dddd, D MMMM YYYY [pukul] HH.mm" },
                        meridiemParse: /pagi|tengahari|petang|malam/,
                        meridiemHour: function (hour, meridiem) {
                            if (hour === 12) {
                                hour = 0;
                            }
                            if (meridiem === "pagi") {
                                return hour;
                            } else if (meridiem === "tengahari") {
                                return hour >= 11 ? hour : hour + 12;
                            } else if (meridiem === "petang" || meridiem === "malam") {
                                return hour + 12;
                            }
                        },
                        meridiem: function (hours, minutes, isLower) {
                            if (hours < 11) {
                                return "pagi";
                            } else if (hours < 15) {
                                return "tengahari";
                            } else if (hours < 19) {
                                return "petang";
                            } else {
                                return "malam";
                            }
                        },
                        calendar: { sameDay: "[Hari ini pukul] LT", nextDay: "[Esok pukul] LT", nextWeek: "dddd [pukul] LT", lastDay: "[Kelmarin pukul] LT", lastWeek: "dddd [lepas pukul] LT", sameElse: "L" },
                        relativeTime: {
                            future: "dalam %s",
                            past: "%s yang lepas",
                            s: "beberapa saat",
                            ss: "%d saat",
                            m: "seminit",
                            mm: "%d minit",
                            h: "sejam",
                            hh: "%d jam",
                            d: "sehari",
                            dd: "%d hari",
                            M: "sebulan",
                            MM: "%d bulan",
                            y: "setahun",
                            yy: "%d tahun",
                        },
                        week: { dow: 1, doy: 7 },
                    });
                    return msMy;
                });
            },
            "./node_modules/moment/locale/ms.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var ms = moment.defineLocale("ms", {
                        months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"),
                        monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),
                        weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),
                        weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),
                        weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),
                        longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [pukul] HH.mm", LLLL: "dddd, D MMMM YYYY [pukul] HH.mm" },
                        meridiemParse: /pagi|tengahari|petang|malam/,
                        meridiemHour: function (hour, meridiem) {
                            if (hour === 12) {
                                hour = 0;
                            }
                            if (meridiem === "pagi") {
                                return hour;
                            } else if (meridiem === "tengahari") {
                                return hour >= 11 ? hour : hour + 12;
                            } else if (meridiem === "petang" || meridiem === "malam") {
                                return hour + 12;
                            }
                        },
                        meridiem: function (hours, minutes, isLower) {
                            if (hours < 11) {
                                return "pagi";
                            } else if (hours < 15) {
                                return "tengahari";
                            } else if (hours < 19) {
                                return "petang";
                            } else {
                                return "malam";
                            }
                        },
                        calendar: { sameDay: "[Hari ini pukul] LT", nextDay: "[Esok pukul] LT", nextWeek: "dddd [pukul] LT", lastDay: "[Kelmarin pukul] LT", lastWeek: "dddd [lepas pukul] LT", sameElse: "L" },
                        relativeTime: {
                            future: "dalam %s",
                            past: "%s yang lepas",
                            s: "beberapa saat",
                            ss: "%d saat",
                            m: "seminit",
                            mm: "%d minit",
                            h: "sejam",
                            hh: "%d jam",
                            d: "sehari",
                            dd: "%d hari",
                            M: "sebulan",
                            MM: "%d bulan",
                            y: "setahun",
                            yy: "%d tahun",
                        },
                        week: { dow: 1, doy: 7 },
                    });
                    return ms;
                });
            },
            "./node_modules/moment/locale/mt.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var mt = moment.defineLocale("mt", {
                        months: "Jannar_Frar_Marzu_April_Mejju_Ġunju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diċembru".split("_"),
                        monthsShort: "Jan_Fra_Mar_Apr_Mej_Ġun_Lul_Aww_Set_Ott_Nov_Diċ".split("_"),
                        weekdays: "Il-Ħadd_It-Tnejn_It-Tlieta_L-Erbgħa_Il-Ħamis_Il-Ġimgħa_Is-Sibt".split("_"),
                        weekdaysShort: "Ħad_Tne_Tli_Erb_Ħam_Ġim_Sib".split("_"),
                        weekdaysMin: "Ħa_Tn_Tl_Er_Ħa_Ġi_Si".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[Illum fil-]LT", nextDay: "[Għada fil-]LT", nextWeek: "dddd [fil-]LT", lastDay: "[Il-bieraħ fil-]LT", lastWeek: "dddd [li għadda] [fil-]LT", sameElse: "L" },
                        relativeTime: {
                            future: "f’ %s",
                            past: "%s ilu",
                            s: "ftit sekondi",
                            ss: "%d sekondi",
                            m: "minuta",
                            mm: "%d minuti",
                            h: "siegħa",
                            hh: "%d siegħat",
                            d: "ġurnata",
                            dd: "%d ġranet",
                            M: "xahar",
                            MM: "%d xhur",
                            y: "sena",
                            yy: "%d sni",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}º/,
                        ordinal: "%dº",
                        week: { dow: 1, doy: 4 },
                    });
                    return mt;
                });
            },
            "./node_modules/moment/locale/my.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var symbolMap = { 1: "၁", 2: "၂", 3: "၃", 4: "၄", 5: "၅", 6: "၆", 7: "၇", 8: "၈", 9: "၉", 0: "၀" },
                        numberMap = { "၁": "1", "၂": "2", "၃": "3", "၄": "4", "၅": "5", "၆": "6", "၇": "7", "၈": "8", "၉": "9", "၀": "0" };
                    var my = moment.defineLocale("my", {
                        months: "ဇန်နဝါရီ_ဖေဖော်ဝါရီ_မတ်_ဧပြီ_မေ_ဇွန်_ဇူလိုင်_သြဂုတ်_စက်တင်ဘာ_အောက်တိုဘာ_နိုဝင်ဘာ_ဒီဇင်ဘာ".split("_"),
                        monthsShort: "ဇန်_ဖေ_မတ်_ပြီ_မေ_ဇွန်_လိုင်_သြ_စက်_အောက်_နို_ဒီ".split("_"),
                        weekdays: "တနင်္ဂနွေ_တနင်္လာ_အင်္ဂါ_ဗုဒ္ဓဟူး_ကြာသပတေး_သောကြာ_စနေ".split("_"),
                        weekdaysShort: "နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ".split("_"),
                        weekdaysMin: "နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[ယနေ.] LT [မှာ]", nextDay: "[မနက်ဖြန်] LT [မှာ]", nextWeek: "dddd LT [မှာ]", lastDay: "[မနေ.က] LT [မှာ]", lastWeek: "[ပြီးခဲ့သော] dddd LT [မှာ]", sameElse: "L" },
                        relativeTime: {
                            future: "လာမည့် %s မှာ",
                            past: "လွန်ခဲ့သော %s က",
                            s: "စက္ကန်.အနည်းငယ်",
                            ss: "%d စက္ကန့်",
                            m: "တစ်မိနစ်",
                            mm: "%d မိနစ်",
                            h: "တစ်နာရီ",
                            hh: "%d နာရီ",
                            d: "တစ်ရက်",
                            dd: "%d ရက်",
                            M: "တစ်လ",
                            MM: "%d လ",
                            y: "တစ်နှစ်",
                            yy: "%d နှစ်",
                        },
                        preparse: function (string) {
                            return string.replace(/[၁၂၃၄၅၆၇၈၉၀]/g, function (match) {
                                return numberMap[match];
                            });
                        },
                        postformat: function (string) {
                            return string.replace(/\d/g, function (match) {
                                return symbolMap[match];
                            });
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return my;
                });
            },
            "./node_modules/moment/locale/nb.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var nb = moment.defineLocale("nb", {
                        months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"),
                        monthsShort: "jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.".split("_"),
                        monthsParseExact: true,
                        weekdays: "søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag".split("_"),
                        weekdaysShort: "sø._ma._ti._on._to._fr._lø.".split("_"),
                        weekdaysMin: "sø_ma_ti_on_to_fr_lø".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY [kl.] HH:mm", LLLL: "dddd D. MMMM YYYY [kl.] HH:mm" },
                        calendar: { sameDay: "[i dag kl.] LT", nextDay: "[i morgen kl.] LT", nextWeek: "dddd [kl.] LT", lastDay: "[i går kl.] LT", lastWeek: "[forrige] dddd [kl.] LT", sameElse: "L" },
                        relativeTime: {
                            future: "om %s",
                            past: "%s siden",
                            s: "noen sekunder",
                            ss: "%d sekunder",
                            m: "ett minutt",
                            mm: "%d minutter",
                            h: "en time",
                            hh: "%d timer",
                            d: "en dag",
                            dd: "%d dager",
                            w: "en uke",
                            ww: "%d uker",
                            M: "en måned",
                            MM: "%d måneder",
                            y: "ett år",
                            yy: "%d år",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}\./,
                        ordinal: "%d.",
                        week: { dow: 1, doy: 4 },
                    });
                    return nb;
                });
            },
            "./node_modules/moment/locale/ne.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var symbolMap = { 1: "१", 2: "२", 3: "३", 4: "४", 5: "५", 6: "६", 7: "७", 8: "८", 9: "९", 0: "०" },
                        numberMap = { "१": "1", "२": "2", "३": "3", "४": "4", "५": "5", "६": "6", "७": "7", "८": "8", "९": "9", "०": "0" };
                    var ne = moment.defineLocale("ne", {
                        months: "जनवरी_फेब्रुवरी_मार्च_अप्रिल_मई_जुन_जुलाई_अगष्ट_सेप्टेम्बर_अक्टोबर_नोभेम्बर_डिसेम्बर".split("_"),
                        monthsShort: "जन._फेब्रु._मार्च_अप्रि._मई_जुन_जुलाई._अग._सेप्ट._अक्टो._नोभे._डिसे.".split("_"),
                        monthsParseExact: true,
                        weekdays: "आइतबार_सोमबार_मङ्गलबार_बुधबार_बिहिबार_शुक्रबार_शनिबार".split("_"),
                        weekdaysShort: "आइत._सोम._मङ्गल._बुध._बिहि._शुक्र._शनि.".split("_"),
                        weekdaysMin: "आ._सो._मं._बु._बि._शु._श.".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "Aको h:mm बजे", LTS: "Aको h:mm:ss बजे", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, Aको h:mm बजे", LLLL: "dddd, D MMMM YYYY, Aको h:mm बजे" },
                        preparse: function (string) {
                            return string.replace(/[१२३४५६७८९०]/g, function (match) {
                                return numberMap[match];
                            });
                        },
                        postformat: function (string) {
                            return string.replace(/\d/g, function (match) {
                                return symbolMap[match];
                            });
                        },
                        meridiemParse: /राति|बिहान|दिउँसो|साँझ/,
                        meridiemHour: function (hour, meridiem) {
                            if (hour === 12) {
                                hour = 0;
                            }
                            if (meridiem === "राति") {
                                return hour < 4 ? hour : hour + 12;
                            } else if (meridiem === "बिहान") {
                                return hour;
                            } else if (meridiem === "दिउँसो") {
                                return hour >= 10 ? hour : hour + 12;
                            } else if (meridiem === "साँझ") {
                                return hour + 12;
                            }
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 3) {
                                return "राति";
                            } else if (hour < 12) {
                                return "बिहान";
                            } else if (hour < 16) {
                                return "दिउँसो";
                            } else if (hour < 20) {
                                return "साँझ";
                            } else {
                                return "राति";
                            }
                        },
                        calendar: { sameDay: "[आज] LT", nextDay: "[भोलि] LT", nextWeek: "[आउँदो] dddd[,] LT", lastDay: "[हिजो] LT", lastWeek: "[गएको] dddd[,] LT", sameElse: "L" },
                        relativeTime: {
                            future: "%sमा",
                            past: "%s अगाडि",
                            s: "केही क्षण",
                            ss: "%d सेकेण्ड",
                            m: "एक मिनेट",
                            mm: "%d मिनेट",
                            h: "एक घण्टा",
                            hh: "%d घण्टा",
                            d: "एक दिन",
                            dd: "%d दिन",
                            M: "एक महिना",
                            MM: "%d महिना",
                            y: "एक बर्ष",
                            yy: "%d बर्ष",
                        },
                        week: { dow: 0, doy: 6 },
                    });
                    return ne;
                });
            },
            "./node_modules/moment/locale/nl-be.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var monthsShortWithDots = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"),
                        monthsShortWithoutDots = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"),
                        monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i],
                        monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
                    var nlBe = moment.defineLocale("nl-be", {
                        months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"),
                        monthsShort: function (m, format) {
                            if (!m) {
                                return monthsShortWithDots;
                            } else if (/-MMM-/.test(format)) {
                                return monthsShortWithoutDots[m.month()];
                            } else {
                                return monthsShortWithDots[m.month()];
                            }
                        },
                        monthsRegex: monthsRegex,
                        monthsShortRegex: monthsRegex,
                        monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
                        monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
                        monthsParse: monthsParse,
                        longMonthsParse: monthsParse,
                        shortMonthsParse: monthsParse,
                        weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),
                        weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"),
                        weekdaysMin: "zo_ma_di_wo_do_vr_za".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[vandaag om] LT", nextDay: "[morgen om] LT", nextWeek: "dddd [om] LT", lastDay: "[gisteren om] LT", lastWeek: "[afgelopen] dddd [om] LT", sameElse: "L" },
                        relativeTime: {
                            future: "over %s",
                            past: "%s geleden",
                            s: "een paar seconden",
                            ss: "%d seconden",
                            m: "één minuut",
                            mm: "%d minuten",
                            h: "één uur",
                            hh: "%d uur",
                            d: "één dag",
                            dd: "%d dagen",
                            M: "één maand",
                            MM: "%d maanden",
                            y: "één jaar",
                            yy: "%d jaar",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
                        ordinal: function (number) {
                            return number + (number === 1 || number === 8 || number >= 20 ? "ste" : "de");
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return nlBe;
                });
            },
            "./node_modules/moment/locale/nl.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var monthsShortWithDots = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"),
                        monthsShortWithoutDots = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"),
                        monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i],
                        monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
                    var nl = moment.defineLocale("nl", {
                        months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"),
                        monthsShort: function (m, format) {
                            if (!m) {
                                return monthsShortWithDots;
                            } else if (/-MMM-/.test(format)) {
                                return monthsShortWithoutDots[m.month()];
                            } else {
                                return monthsShortWithDots[m.month()];
                            }
                        },
                        monthsRegex: monthsRegex,
                        monthsShortRegex: monthsRegex,
                        monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
                        monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
                        monthsParse: monthsParse,
                        longMonthsParse: monthsParse,
                        shortMonthsParse: monthsParse,
                        weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),
                        weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"),
                        weekdaysMin: "zo_ma_di_wo_do_vr_za".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD-MM-YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[vandaag om] LT", nextDay: "[morgen om] LT", nextWeek: "dddd [om] LT", lastDay: "[gisteren om] LT", lastWeek: "[afgelopen] dddd [om] LT", sameElse: "L" },
                        relativeTime: {
                            future: "over %s",
                            past: "%s geleden",
                            s: "een paar seconden",
                            ss: "%d seconden",
                            m: "één minuut",
                            mm: "%d minuten",
                            h: "één uur",
                            hh: "%d uur",
                            d: "één dag",
                            dd: "%d dagen",
                            w: "één week",
                            ww: "%d weken",
                            M: "één maand",
                            MM: "%d maanden",
                            y: "één jaar",
                            yy: "%d jaar",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
                        ordinal: function (number) {
                            return number + (number === 1 || number === 8 || number >= 20 ? "ste" : "de");
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return nl;
                });
            },
            "./node_modules/moment/locale/nn.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var nn = moment.defineLocale("nn", {
                        months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"),
                        monthsShort: "jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.".split("_"),
                        monthsParseExact: true,
                        weekdays: "sundag_måndag_tysdag_onsdag_torsdag_fredag_laurdag".split("_"),
                        weekdaysShort: "su._må._ty._on._to._fr._lau.".split("_"),
                        weekdaysMin: "su_må_ty_on_to_fr_la".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY [kl.] H:mm", LLLL: "dddd D. MMMM YYYY [kl.] HH:mm" },
                        calendar: { sameDay: "[I dag klokka] LT", nextDay: "[I morgon klokka] LT", nextWeek: "dddd [klokka] LT", lastDay: "[I går klokka] LT", lastWeek: "[Føregåande] dddd [klokka] LT", sameElse: "L" },
                        relativeTime: {
                            future: "om %s",
                            past: "%s sidan",
                            s: "nokre sekund",
                            ss: "%d sekund",
                            m: "eit minutt",
                            mm: "%d minutt",
                            h: "ein time",
                            hh: "%d timar",
                            d: "ein dag",
                            dd: "%d dagar",
                            w: "ei veke",
                            ww: "%d veker",
                            M: "ein månad",
                            MM: "%d månader",
                            y: "eit år",
                            yy: "%d år",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}\./,
                        ordinal: "%d.",
                        week: { dow: 1, doy: 4 },
                    });
                    return nn;
                });
            },
            "./node_modules/moment/locale/oc-lnc.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var ocLnc = moment.defineLocale("oc-lnc", {
                        months: {
                            standalone: "genièr_febrièr_març_abril_mai_junh_julhet_agost_setembre_octòbre_novembre_decembre".split("_"),
                            format: "de genièr_de febrièr_de març_d'abril_de mai_de junh_de julhet_d'agost_de setembre_d'octòbre_de novembre_de decembre".split("_"),
                            isFormat: /D[oD]?(\s)+MMMM/,
                        },
                        monthsShort: "gen._febr._març_abr._mai_junh_julh._ago._set._oct._nov._dec.".split("_"),
                        monthsParseExact: true,
                        weekdays: "dimenge_diluns_dimars_dimècres_dijòus_divendres_dissabte".split("_"),
                        weekdaysShort: "dg._dl._dm._dc._dj._dv._ds.".split("_"),
                        weekdaysMin: "dg_dl_dm_dc_dj_dv_ds".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: {
                            LT: "H:mm",
                            LTS: "H:mm:ss",
                            L: "DD/MM/YYYY",
                            LL: "D MMMM [de] YYYY",
                            ll: "D MMM YYYY",
                            LLL: "D MMMM [de] YYYY [a] H:mm",
                            lll: "D MMM YYYY, H:mm",
                            LLLL: "dddd D MMMM [de] YYYY [a] H:mm",
                            llll: "ddd D MMM YYYY, H:mm",
                        },
                        calendar: { sameDay: "[uèi a] LT", nextDay: "[deman a] LT", nextWeek: "dddd [a] LT", lastDay: "[ièr a] LT", lastWeek: "dddd [passat a] LT", sameElse: "L" },
                        relativeTime: {
                            future: "d'aquí %s",
                            past: "fa %s",
                            s: "unas segondas",
                            ss: "%d segondas",
                            m: "una minuta",
                            mm: "%d minutas",
                            h: "una ora",
                            hh: "%d oras",
                            d: "un jorn",
                            dd: "%d jorns",
                            M: "un mes",
                            MM: "%d meses",
                            y: "un an",
                            yy: "%d ans",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|è|a)/,
                        ordinal: function (number, period) {
                            var output = number === 1 ? "r" : number === 2 ? "n" : number === 3 ? "r" : number === 4 ? "t" : "è";
                            if (period === "w" || period === "W") {
                                output = "a";
                            }
                            return number + output;
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return ocLnc;
                });
            },
            "./node_modules/moment/locale/pa-in.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var symbolMap = { 1: "੧", 2: "੨", 3: "੩", 4: "੪", 5: "੫", 6: "੬", 7: "੭", 8: "੮", 9: "੯", 0: "੦" },
                        numberMap = { "੧": "1", "੨": "2", "੩": "3", "੪": "4", "੫": "5", "੬": "6", "੭": "7", "੮": "8", "੯": "9", "੦": "0" };
                    var paIn = moment.defineLocale("pa-in", {
                        months: "ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ".split("_"),
                        monthsShort: "ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ".split("_"),
                        weekdays: "ਐਤਵਾਰ_ਸੋਮਵਾਰ_ਮੰਗਲਵਾਰ_ਬੁਧਵਾਰ_ਵੀਰਵਾਰ_ਸ਼ੁੱਕਰਵਾਰ_ਸ਼ਨੀਚਰਵਾਰ".split("_"),
                        weekdaysShort: "ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ".split("_"),
                        weekdaysMin: "ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ".split("_"),
                        longDateFormat: { LT: "A h:mm ਵਜੇ", LTS: "A h:mm:ss ਵਜੇ", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm ਵਜੇ", LLLL: "dddd, D MMMM YYYY, A h:mm ਵਜੇ" },
                        calendar: { sameDay: "[ਅਜ] LT", nextDay: "[ਕਲ] LT", nextWeek: "[ਅਗਲਾ] dddd, LT", lastDay: "[ਕਲ] LT", lastWeek: "[ਪਿਛਲੇ] dddd, LT", sameElse: "L" },
                        relativeTime: {
                            future: "%s ਵਿੱਚ",
                            past: "%s ਪਿਛਲੇ",
                            s: "ਕੁਝ ਸਕਿੰਟ",
                            ss: "%d ਸਕਿੰਟ",
                            m: "ਇਕ ਮਿੰਟ",
                            mm: "%d ਮਿੰਟ",
                            h: "ਇੱਕ ਘੰਟਾ",
                            hh: "%d ਘੰਟੇ",
                            d: "ਇੱਕ ਦਿਨ",
                            dd: "%d ਦਿਨ",
                            M: "ਇੱਕ ਮਹੀਨਾ",
                            MM: "%d ਮਹੀਨੇ",
                            y: "ਇੱਕ ਸਾਲ",
                            yy: "%d ਸਾਲ",
                        },
                        preparse: function (string) {
                            return string.replace(/[੧੨੩੪੫੬੭੮੯੦]/g, function (match) {
                                return numberMap[match];
                            });
                        },
                        postformat: function (string) {
                            return string.replace(/\d/g, function (match) {
                                return symbolMap[match];
                            });
                        },
                        meridiemParse: /ਰਾਤ|ਸਵੇਰ|ਦੁਪਹਿਰ|ਸ਼ਾਮ/,
                        meridiemHour: function (hour, meridiem) {
                            if (hour === 12) {
                                hour = 0;
                            }
                            if (meridiem === "ਰਾਤ") {
                                return hour < 4 ? hour : hour + 12;
                            } else if (meridiem === "ਸਵੇਰ") {
                                return hour;
                            } else if (meridiem === "ਦੁਪਹਿਰ") {
                                return hour >= 10 ? hour : hour + 12;
                            } else if (meridiem === "ਸ਼ਾਮ") {
                                return hour + 12;
                            }
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 4) {
                                return "ਰਾਤ";
                            } else if (hour < 10) {
                                return "ਸਵੇਰ";
                            } else if (hour < 17) {
                                return "ਦੁਪਹਿਰ";
                            } else if (hour < 20) {
                                return "ਸ਼ਾਮ";
                            } else {
                                return "ਰਾਤ";
                            }
                        },
                        week: { dow: 0, doy: 6 },
                    });
                    return paIn;
                });
            },
            "./node_modules/moment/locale/pl.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var monthsNominative = "styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień".split("_"),
                        monthsSubjective = "stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia".split("_"),
                        monthsParse = [/^sty/i, /^lut/i, /^mar/i, /^kwi/i, /^maj/i, /^cze/i, /^lip/i, /^sie/i, /^wrz/i, /^paź/i, /^lis/i, /^gru/i];
                    function plural(n) {
                        return n % 10 < 5 && n % 10 > 1 && ~~(n / 10) % 10 !== 1;
                    }
                    function translate(number, withoutSuffix, key) {
                        var result = number + " ";
                        switch (key) {
                            case "ss":
                                return result + (plural(number) ? "sekundy" : "sekund");
                            case "m":
                                return withoutSuffix ? "minuta" : "minutę";
                            case "mm":
                                return result + (plural(number) ? "minuty" : "minut");
                            case "h":
                                return withoutSuffix ? "godzina" : "godzinę";
                            case "hh":
                                return result + (plural(number) ? "godziny" : "godzin");
                            case "ww":
                                return result + (plural(number) ? "tygodnie" : "tygodni");
                            case "MM":
                                return result + (plural(number) ? "miesiące" : "miesięcy");
                            case "yy":
                                return result + (plural(number) ? "lata" : "lat");
                        }
                    }
                    var pl = moment.defineLocale("pl", {
                        months: function (momentToFormat, format) {
                            if (!momentToFormat) {
                                return monthsNominative;
                            } else if (/D MMMM/.test(format)) {
                                return monthsSubjective[momentToFormat.month()];
                            } else {
                                return monthsNominative[momentToFormat.month()];
                            }
                        },
                        monthsShort: "sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru".split("_"),
                        monthsParse: monthsParse,
                        longMonthsParse: monthsParse,
                        shortMonthsParse: monthsParse,
                        weekdays: "niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota".split("_"),
                        weekdaysShort: "ndz_pon_wt_śr_czw_pt_sob".split("_"),
                        weekdaysMin: "Nd_Pn_Wt_Śr_Cz_Pt_So".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" },
                        calendar: {
                            sameDay: "[Dziś o] LT",
                            nextDay: "[Jutro o] LT",
                            nextWeek: function () {
                                switch (this.day()) {
                                    case 0:
                                        return "[W niedzielę o] LT";
                                    case 2:
                                        return "[We wtorek o] LT";
                                    case 3:
                                        return "[W środę o] LT";
                                    case 6:
                                        return "[W sobotę o] LT";
                                    default:
                                        return "[W] dddd [o] LT";
                                }
                            },
                            lastDay: "[Wczoraj o] LT",
                            lastWeek: function () {
                                switch (this.day()) {
                                    case 0:
                                        return "[W zeszłą niedzielę o] LT";
                                    case 3:
                                        return "[W zeszłą środę o] LT";
                                    case 6:
                                        return "[W zeszłą sobotę o] LT";
                                    default:
                                        return "[W zeszły] dddd [o] LT";
                                }
                            },
                            sameElse: "L",
                        },
                        relativeTime: {
                            future: "za %s",
                            past: "%s temu",
                            s: "kilka sekund",
                            ss: translate,
                            m: translate,
                            mm: translate,
                            h: translate,
                            hh: translate,
                            d: "1 dzień",
                            dd: "%d dni",
                            w: "tydzień",
                            ww: translate,
                            M: "miesiąc",
                            MM: translate,
                            y: "rok",
                            yy: translate,
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}\./,
                        ordinal: "%d.",
                        week: { dow: 1, doy: 4 },
                    });
                    return pl;
                });
            },
            "./node_modules/moment/locale/pt-br.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var ptBr = moment.defineLocale("pt-br", {
                        months: "janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"),
                        monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),
                        weekdays: "domingo_segunda-feira_terça-feira_quarta-feira_quinta-feira_sexta-feira_sábado".split("_"),
                        weekdaysShort: "dom_seg_ter_qua_qui_sex_sáb".split("_"),
                        weekdaysMin: "do_2ª_3ª_4ª_5ª_6ª_sá".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY [às] HH:mm", LLLL: "dddd, D [de] MMMM [de] YYYY [às] HH:mm" },
                        calendar: {
                            sameDay: "[Hoje às] LT",
                            nextDay: "[Amanhã às] LT",
                            nextWeek: "dddd [às] LT",
                            lastDay: "[Ontem às] LT",
                            lastWeek: function () {
                                return this.day() === 0 || this.day() === 6 ? "[Último] dddd [às] LT" : "[Última] dddd [às] LT";
                            },
                            sameElse: "L",
                        },
                        relativeTime: {
                            future: "em %s",
                            past: "há %s",
                            s: "poucos segundos",
                            ss: "%d segundos",
                            m: "um minuto",
                            mm: "%d minutos",
                            h: "uma hora",
                            hh: "%d horas",
                            d: "um dia",
                            dd: "%d dias",
                            M: "um mês",
                            MM: "%d meses",
                            y: "um ano",
                            yy: "%d anos",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}º/,
                        ordinal: "%dº",
                        invalidDate: "Data inválida",
                    });
                    return ptBr;
                });
            },
            "./node_modules/moment/locale/pt.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var pt = moment.defineLocale("pt", {
                        months: "janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"),
                        monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),
                        weekdays: "Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado".split("_"),
                        weekdaysShort: "Dom_Seg_Ter_Qua_Qui_Sex_Sáb".split("_"),
                        weekdaysMin: "Do_2ª_3ª_4ª_5ª_6ª_Sá".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY HH:mm", LLLL: "dddd, D [de] MMMM [de] YYYY HH:mm" },
                        calendar: {
                            sameDay: "[Hoje às] LT",
                            nextDay: "[Amanhã às] LT",
                            nextWeek: "dddd [às] LT",
                            lastDay: "[Ontem às] LT",
                            lastWeek: function () {
                                return this.day() === 0 || this.day() === 6 ? "[Último] dddd [às] LT" : "[Última] dddd [às] LT";
                            },
                            sameElse: "L",
                        },
                        relativeTime: {
                            future: "em %s",
                            past: "há %s",
                            s: "segundos",
                            ss: "%d segundos",
                            m: "um minuto",
                            mm: "%d minutos",
                            h: "uma hora",
                            hh: "%d horas",
                            d: "um dia",
                            dd: "%d dias",
                            w: "uma semana",
                            ww: "%d semanas",
                            M: "um mês",
                            MM: "%d meses",
                            y: "um ano",
                            yy: "%d anos",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}º/,
                        ordinal: "%dº",
                        week: { dow: 1, doy: 4 },
                    });
                    return pt;
                });
            },
            "./node_modules/moment/locale/ro.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    function relativeTimeWithPlural(number, withoutSuffix, key) {
                        var format = { ss: "secunde", mm: "minute", hh: "ore", dd: "zile", ww: "săptămâni", MM: "luni", yy: "ani" },
                            separator = " ";
                        if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
                            separator = " de ";
                        }
                        return number + separator + format[key];
                    }
                    var ro = moment.defineLocale("ro", {
                        months: "ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie".split("_"),
                        monthsShort: "ian._feb._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.".split("_"),
                        monthsParseExact: true,
                        weekdays: "duminică_luni_marți_miercuri_joi_vineri_sâmbătă".split("_"),
                        weekdaysShort: "Dum_Lun_Mar_Mie_Joi_Vin_Sâm".split("_"),
                        weekdaysMin: "Du_Lu_Ma_Mi_Jo_Vi_Sâ".split("_"),
                        longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY H:mm", LLLL: "dddd, D MMMM YYYY H:mm" },
                        calendar: { sameDay: "[azi la] LT", nextDay: "[mâine la] LT", nextWeek: "dddd [la] LT", lastDay: "[ieri la] LT", lastWeek: "[fosta] dddd [la] LT", sameElse: "L" },
                        relativeTime: {
                            future: "peste %s",
                            past: "%s în urmă",
                            s: "câteva secunde",
                            ss: relativeTimeWithPlural,
                            m: "un minut",
                            mm: relativeTimeWithPlural,
                            h: "o oră",
                            hh: relativeTimeWithPlural,
                            d: "o zi",
                            dd: relativeTimeWithPlural,
                            w: "o săptămână",
                            ww: relativeTimeWithPlural,
                            M: "o lună",
                            MM: relativeTimeWithPlural,
                            y: "un an",
                            yy: relativeTimeWithPlural,
                        },
                        week: { dow: 1, doy: 7 },
                    });
                    return ro;
                });
            },
            "./node_modules/moment/locale/ru.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    function plural(word, num) {
                        var forms = word.split("_");
                        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
                    }
                    function relativeTimeWithPlural(number, withoutSuffix, key) {
                        var format = {
                            ss: withoutSuffix ? "секунда_секунды_секунд" : "секунду_секунды_секунд",
                            mm: withoutSuffix ? "минута_минуты_минут" : "минуту_минуты_минут",
                            hh: "час_часа_часов",
                            dd: "день_дня_дней",
                            ww: "неделя_недели_недель",
                            MM: "месяц_месяца_месяцев",
                            yy: "год_года_лет",
                        };
                        if (key === "m") {
                            return withoutSuffix ? "минута" : "минуту";
                        } else {
                            return number + " " + plural(format[key], +number);
                        }
                    }
                    var monthsParse = [/^янв/i, /^фев/i, /^мар/i, /^апр/i, /^ма[йя]/i, /^июн/i, /^июл/i, /^авг/i, /^сен/i, /^окт/i, /^ноя/i, /^дек/i];
                    var ru = moment.defineLocale("ru", {
                        months: {
                            format: "января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря".split("_"),
                            standalone: "январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь".split("_"),
                        },
                        monthsShort: { format: "янв._февр._мар._апр._мая_июня_июля_авг._сент._окт._нояб._дек.".split("_"), standalone: "янв._февр._март_апр._май_июнь_июль_авг._сент._окт._нояб._дек.".split("_") },
                        weekdays: {
                            standalone: "воскресенье_понедельник_вторник_среда_четверг_пятница_суббота".split("_"),
                            format: "воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу".split("_"),
                            isFormat: /\[ ?[Вв] ?(?:прошлую|следующую|эту)? ?] ?dddd/,
                        },
                        weekdaysShort: "вс_пн_вт_ср_чт_пт_сб".split("_"),
                        weekdaysMin: "вс_пн_вт_ср_чт_пт_сб".split("_"),
                        monthsParse: monthsParse,
                        longMonthsParse: monthsParse,
                        shortMonthsParse: monthsParse,
                        monthsRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,
                        monthsShortRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,
                        monthsStrictRegex: /^(январ[яь]|феврал[яь]|марта?|апрел[яь]|ма[яй]|июн[яь]|июл[яь]|августа?|сентябр[яь]|октябр[яь]|ноябр[яь]|декабр[яь])/i,
                        monthsShortStrictRegex: /^(янв\.|февр?\.|мар[т.]|апр\.|ма[яй]|июн[ья.]|июл[ья.]|авг\.|сент?\.|окт\.|нояб?\.|дек\.)/i,
                        longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY г.", LLL: "D MMMM YYYY г., H:mm", LLLL: "dddd, D MMMM YYYY г., H:mm" },
                        calendar: {
                            sameDay: "[Сегодня, в] LT",
                            nextDay: "[Завтра, в] LT",
                            lastDay: "[Вчера, в] LT",
                            nextWeek: function (now) {
                                if (now.week() !== this.week()) {
                                    switch (this.day()) {
                                        case 0:
                                            return "[В следующее] dddd, [в] LT";
                                        case 1:
                                        case 2:
                                        case 4:
                                            return "[В следующий] dddd, [в] LT";
                                        case 3:
                                        case 5:
                                        case 6:
                                            return "[В следующую] dddd, [в] LT";
                                    }
                                } else {
                                    if (this.day() === 2) {
                                        return "[Во] dddd, [в] LT";
                                    } else {
                                        return "[В] dddd, [в] LT";
                                    }
                                }
                            },
                            lastWeek: function (now) {
                                if (now.week() !== this.week()) {
                                    switch (this.day()) {
                                        case 0:
                                            return "[В прошлое] dddd, [в] LT";
                                        case 1:
                                        case 2:
                                        case 4:
                                            return "[В прошлый] dddd, [в] LT";
                                        case 3:
                                        case 5:
                                        case 6:
                                            return "[В прошлую] dddd, [в] LT";
                                    }
                                } else {
                                    if (this.day() === 2) {
                                        return "[Во] dddd, [в] LT";
                                    } else {
                                        return "[В] dddd, [в] LT";
                                    }
                                }
                            },
                            sameElse: "L",
                        },
                        relativeTime: {
                            future: "через %s",
                            past: "%s назад",
                            s: "несколько секунд",
                            ss: relativeTimeWithPlural,
                            m: relativeTimeWithPlural,
                            mm: relativeTimeWithPlural,
                            h: "час",
                            hh: relativeTimeWithPlural,
                            d: "день",
                            dd: relativeTimeWithPlural,
                            w: "неделя",
                            ww: relativeTimeWithPlural,
                            M: "месяц",
                            MM: relativeTimeWithPlural,
                            y: "год",
                            yy: relativeTimeWithPlural,
                        },
                        meridiemParse: /ночи|утра|дня|вечера/i,
                        isPM: function (input) {
                            return /^(дня|вечера)$/.test(input);
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 4) {
                                return "ночи";
                            } else if (hour < 12) {
                                return "утра";
                            } else if (hour < 17) {
                                return "дня";
                            } else {
                                return "вечера";
                            }
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}-(й|го|я)/,
                        ordinal: function (number, period) {
                            switch (period) {
                                case "M":
                                case "d":
                                case "DDD":
                                    return number + "-й";
                                case "D":
                                    return number + "-го";
                                case "w":
                                case "W":
                                    return number + "-я";
                                default:
                                    return number;
                            }
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return ru;
                });
            },
            "./node_modules/moment/locale/sd.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var months = ["جنوري", "فيبروري", "مارچ", "اپريل", "مئي", "جون", "جولاءِ", "آگسٽ", "سيپٽمبر", "آڪٽوبر", "نومبر", "ڊسمبر"],
                        days = ["آچر", "سومر", "اڱارو", "اربع", "خميس", "جمع", "ڇنڇر"];
                    var sd = moment.defineLocale("sd", {
                        months: months,
                        monthsShort: months,
                        weekdays: days,
                        weekdaysShort: days,
                        weekdaysMin: days,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd، D MMMM YYYY HH:mm" },
                        meridiemParse: /صبح|شام/,
                        isPM: function (input) {
                            return "شام" === input;
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 12) {
                                return "صبح";
                            }
                            return "شام";
                        },
                        calendar: { sameDay: "[اڄ] LT", nextDay: "[سڀاڻي] LT", nextWeek: "dddd [اڳين هفتي تي] LT", lastDay: "[ڪالهه] LT", lastWeek: "[گزريل هفتي] dddd [تي] LT", sameElse: "L" },
                        relativeTime: {
                            future: "%s پوء",
                            past: "%s اڳ",
                            s: "چند سيڪنڊ",
                            ss: "%d سيڪنڊ",
                            m: "هڪ منٽ",
                            mm: "%d منٽ",
                            h: "هڪ ڪلاڪ",
                            hh: "%d ڪلاڪ",
                            d: "هڪ ڏينهن",
                            dd: "%d ڏينهن",
                            M: "هڪ مهينو",
                            MM: "%d مهينا",
                            y: "هڪ سال",
                            yy: "%d سال",
                        },
                        preparse: function (string) {
                            return string.replace(/،/g, ",");
                        },
                        postformat: function (string) {
                            return string.replace(/,/g, "،");
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return sd;
                });
            },
            "./node_modules/moment/locale/se.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var se = moment.defineLocale("se", {
                        months: "ođđajagemánnu_guovvamánnu_njukčamánnu_cuoŋománnu_miessemánnu_geassemánnu_suoidnemánnu_borgemánnu_čakčamánnu_golggotmánnu_skábmamánnu_juovlamánnu".split("_"),
                        monthsShort: "ođđj_guov_njuk_cuo_mies_geas_suoi_borg_čakč_golg_skáb_juov".split("_"),
                        weekdays: "sotnabeaivi_vuossárga_maŋŋebárga_gaskavahkku_duorastat_bearjadat_lávvardat".split("_"),
                        weekdaysShort: "sotn_vuos_maŋ_gask_duor_bear_láv".split("_"),
                        weekdaysMin: "s_v_m_g_d_b_L".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "MMMM D. [b.] YYYY", LLL: "MMMM D. [b.] YYYY [ti.] HH:mm", LLLL: "dddd, MMMM D. [b.] YYYY [ti.] HH:mm" },
                        calendar: { sameDay: "[otne ti] LT", nextDay: "[ihttin ti] LT", nextWeek: "dddd [ti] LT", lastDay: "[ikte ti] LT", lastWeek: "[ovddit] dddd [ti] LT", sameElse: "L" },
                        relativeTime: {
                            future: "%s geažes",
                            past: "maŋit %s",
                            s: "moadde sekunddat",
                            ss: "%d sekunddat",
                            m: "okta minuhta",
                            mm: "%d minuhtat",
                            h: "okta diimmu",
                            hh: "%d diimmut",
                            d: "okta beaivi",
                            dd: "%d beaivvit",
                            M: "okta mánnu",
                            MM: "%d mánut",
                            y: "okta jahki",
                            yy: "%d jagit",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}\./,
                        ordinal: "%d.",
                        week: { dow: 1, doy: 4 },
                    });
                    return se;
                });
            },
            "./node_modules/moment/locale/si.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var si = moment.defineLocale("si", {
                        months: "ජනවාරි_පෙබරවාරි_මාර්තු_අප්‍රේල්_මැයි_ජූනි_ජූලි_අගෝස්තු_සැප්තැම්බර්_ඔක්තෝබර්_නොවැම්බර්_දෙසැම්බර්".split("_"),
                        monthsShort: "ජන_පෙබ_මාර්_අප්_මැයි_ජූනි_ජූලි_අගෝ_සැප්_ඔක්_නොවැ_දෙසැ".split("_"),
                        weekdays: "ඉරිදා_සඳුදා_අඟහරුවාදා_බදාදා_බ්‍රහස්පතින්දා_සිකුරාදා_සෙනසුරාදා".split("_"),
                        weekdaysShort: "ඉරි_සඳු_අඟ_බදා_බ්‍රහ_සිකු_සෙන".split("_"),
                        weekdaysMin: "ඉ_ස_අ_බ_බ්‍ර_සි_සෙ".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "a h:mm", LTS: "a h:mm:ss", L: "YYYY/MM/DD", LL: "YYYY MMMM D", LLL: "YYYY MMMM D, a h:mm", LLLL: "YYYY MMMM D [වැනි] dddd, a h:mm:ss" },
                        calendar: { sameDay: "[අද] LT[ට]", nextDay: "[හෙට] LT[ට]", nextWeek: "dddd LT[ට]", lastDay: "[ඊයේ] LT[ට]", lastWeek: "[පසුගිය] dddd LT[ට]", sameElse: "L" },
                        relativeTime: {
                            future: "%sකින්",
                            past: "%sකට පෙර",
                            s: "තත්පර කිහිපය",
                            ss: "තත්පර %d",
                            m: "මිනිත්තුව",
                            mm: "මිනිත්තු %d",
                            h: "පැය",
                            hh: "පැය %d",
                            d: "දිනය",
                            dd: "දින %d",
                            M: "මාසය",
                            MM: "මාස %d",
                            y: "වසර",
                            yy: "වසර %d",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2} වැනි/,
                        ordinal: function (number) {
                            return number + " වැනි";
                        },
                        meridiemParse: /පෙර වරු|පස් වරු|පෙ.ව|ප.ව./,
                        isPM: function (input) {
                            return input === "ප.ව." || input === "පස් වරු";
                        },
                        meridiem: function (hours, minutes, isLower) {
                            if (hours > 11) {
                                return isLower ? "ප.ව." : "පස් වරු";
                            } else {
                                return isLower ? "පෙ.ව." : "පෙර වරු";
                            }
                        },
                    });
                    return si;
                });
            },
            "./node_modules/moment/locale/sk.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var months = "január_február_marec_apríl_máj_jún_júl_august_september_október_november_december".split("_"),
                        monthsShort = "jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec".split("_");
                    function plural(n) {
                        return n > 1 && n < 5;
                    }
                    function translate(number, withoutSuffix, key, isFuture) {
                        var result = number + " ";
                        switch (key) {
                            case "s":
                                return withoutSuffix || isFuture ? "pár sekúnd" : "pár sekundami";
                            case "ss":
                                if (withoutSuffix || isFuture) {
                                    return result + (plural(number) ? "sekundy" : "sekúnd");
                                } else {
                                    return result + "sekundami";
                                }
                            case "m":
                                return withoutSuffix ? "minúta" : isFuture ? "minútu" : "minútou";
                            case "mm":
                                if (withoutSuffix || isFuture) {
                                    return result + (plural(number) ? "minúty" : "minút");
                                } else {
                                    return result + "minútami";
                                }
                            case "h":
                                return withoutSuffix ? "hodina" : isFuture ? "hodinu" : "hodinou";
                            case "hh":
                                if (withoutSuffix || isFuture) {
                                    return result + (plural(number) ? "hodiny" : "hodín");
                                } else {
                                    return result + "hodinami";
                                }
                            case "d":
                                return withoutSuffix || isFuture ? "deň" : "dňom";
                            case "dd":
                                if (withoutSuffix || isFuture) {
                                    return result + (plural(number) ? "dni" : "dní");
                                } else {
                                    return result + "dňami";
                                }
                            case "M":
                                return withoutSuffix || isFuture ? "mesiac" : "mesiacom";
                            case "MM":
                                if (withoutSuffix || isFuture) {
                                    return result + (plural(number) ? "mesiace" : "mesiacov");
                                } else {
                                    return result + "mesiacmi";
                                }
                            case "y":
                                return withoutSuffix || isFuture ? "rok" : "rokom";
                            case "yy":
                                if (withoutSuffix || isFuture) {
                                    return result + (plural(number) ? "roky" : "rokov");
                                } else {
                                    return result + "rokmi";
                                }
                        }
                    }
                    var sk = moment.defineLocale("sk", {
                        months: months,
                        monthsShort: monthsShort,
                        weekdays: "nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota".split("_"),
                        weekdaysShort: "ne_po_ut_st_št_pi_so".split("_"),
                        weekdaysMin: "ne_po_ut_st_št_pi_so".split("_"),
                        longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd D. MMMM YYYY H:mm" },
                        calendar: {
                            sameDay: "[dnes o] LT",
                            nextDay: "[zajtra o] LT",
                            nextWeek: function () {
                                switch (this.day()) {
                                    case 0:
                                        return "[v nedeľu o] LT";
                                    case 1:
                                    case 2:
                                        return "[v] dddd [o] LT";
                                    case 3:
                                        return "[v stredu o] LT";
                                    case 4:
                                        return "[vo štvrtok o] LT";
                                    case 5:
                                        return "[v piatok o] LT";
                                    case 6:
                                        return "[v sobotu o] LT";
                                }
                            },
                            lastDay: "[včera o] LT",
                            lastWeek: function () {
                                switch (this.day()) {
                                    case 0:
                                        return "[minulú nedeľu o] LT";
                                    case 1:
                                    case 2:
                                        return "[minulý] dddd [o] LT";
                                    case 3:
                                        return "[minulú stredu o] LT";
                                    case 4:
                                    case 5:
                                        return "[minulý] dddd [o] LT";
                                    case 6:
                                        return "[minulú sobotu o] LT";
                                }
                            },
                            sameElse: "L",
                        },
                        relativeTime: {
                            future: "za %s",
                            past: "pred %s",
                            s: translate,
                            ss: translate,
                            m: translate,
                            mm: translate,
                            h: translate,
                            hh: translate,
                            d: translate,
                            dd: translate,
                            M: translate,
                            MM: translate,
                            y: translate,
                            yy: translate,
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}\./,
                        ordinal: "%d.",
                        week: { dow: 1, doy: 4 },
                    });
                    return sk;
                });
            },
            "./node_modules/moment/locale/sl.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    function processRelativeTime(number, withoutSuffix, key, isFuture) {
                        var result = number + " ";
                        switch (key) {
                            case "s":
                                return withoutSuffix || isFuture ? "nekaj sekund" : "nekaj sekundami";
                            case "ss":
                                if (number === 1) {
                                    result += withoutSuffix ? "sekundo" : "sekundi";
                                } else if (number === 2) {
                                    result += withoutSuffix || isFuture ? "sekundi" : "sekundah";
                                } else if (number < 5) {
                                    result += withoutSuffix || isFuture ? "sekunde" : "sekundah";
                                } else {
                                    result += "sekund";
                                }
                                return result;
                            case "m":
                                return withoutSuffix ? "ena minuta" : "eno minuto";
                            case "mm":
                                if (number === 1) {
                                    result += withoutSuffix ? "minuta" : "minuto";
                                } else if (number === 2) {
                                    result += withoutSuffix || isFuture ? "minuti" : "minutama";
                                } else if (number < 5) {
                                    result += withoutSuffix || isFuture ? "minute" : "minutami";
                                } else {
                                    result += withoutSuffix || isFuture ? "minut" : "minutami";
                                }
                                return result;
                            case "h":
                                return withoutSuffix ? "ena ura" : "eno uro";
                            case "hh":
                                if (number === 1) {
                                    result += withoutSuffix ? "ura" : "uro";
                                } else if (number === 2) {
                                    result += withoutSuffix || isFuture ? "uri" : "urama";
                                } else if (number < 5) {
                                    result += withoutSuffix || isFuture ? "ure" : "urami";
                                } else {
                                    result += withoutSuffix || isFuture ? "ur" : "urami";
                                }
                                return result;
                            case "d":
                                return withoutSuffix || isFuture ? "en dan" : "enim dnem";
                            case "dd":
                                if (number === 1) {
                                    result += withoutSuffix || isFuture ? "dan" : "dnem";
                                } else if (number === 2) {
                                    result += withoutSuffix || isFuture ? "dni" : "dnevoma";
                                } else {
                                    result += withoutSuffix || isFuture ? "dni" : "dnevi";
                                }
                                return result;
                            case "M":
                                return withoutSuffix || isFuture ? "en mesec" : "enim mesecem";
                            case "MM":
                                if (number === 1) {
                                    result += withoutSuffix || isFuture ? "mesec" : "mesecem";
                                } else if (number === 2) {
                                    result += withoutSuffix || isFuture ? "meseca" : "mesecema";
                                } else if (number < 5) {
                                    result += withoutSuffix || isFuture ? "mesece" : "meseci";
                                } else {
                                    result += withoutSuffix || isFuture ? "mesecev" : "meseci";
                                }
                                return result;
                            case "y":
                                return withoutSuffix || isFuture ? "eno leto" : "enim letom";
                            case "yy":
                                if (number === 1) {
                                    result += withoutSuffix || isFuture ? "leto" : "letom";
                                } else if (number === 2) {
                                    result += withoutSuffix || isFuture ? "leti" : "letoma";
                                } else if (number < 5) {
                                    result += withoutSuffix || isFuture ? "leta" : "leti";
                                } else {
                                    result += withoutSuffix || isFuture ? "let" : "leti";
                                }
                                return result;
                        }
                    }
                    var sl = moment.defineLocale("sl", {
                        months: "januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december".split("_"),
                        monthsShort: "jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.".split("_"),
                        monthsParseExact: true,
                        weekdays: "nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota".split("_"),
                        weekdaysShort: "ned._pon._tor._sre._čet._pet._sob.".split("_"),
                        weekdaysMin: "ne_po_to_sr_če_pe_so".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD. MM. YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd, D. MMMM YYYY H:mm" },
                        calendar: {
                            sameDay: "[danes ob] LT",
                            nextDay: "[jutri ob] LT",
                            nextWeek: function () {
                                switch (this.day()) {
                                    case 0:
                                        return "[v] [nedeljo] [ob] LT";
                                    case 3:
                                        return "[v] [sredo] [ob] LT";
                                    case 6:
                                        return "[v] [soboto] [ob] LT";
                                    case 1:
                                    case 2:
                                    case 4:
                                    case 5:
                                        return "[v] dddd [ob] LT";
                                }
                            },
                            lastDay: "[včeraj ob] LT",
                            lastWeek: function () {
                                switch (this.day()) {
                                    case 0:
                                        return "[prejšnjo] [nedeljo] [ob] LT";
                                    case 3:
                                        return "[prejšnjo] [sredo] [ob] LT";
                                    case 6:
                                        return "[prejšnjo] [soboto] [ob] LT";
                                    case 1:
                                    case 2:
                                    case 4:
                                    case 5:
                                        return "[prejšnji] dddd [ob] LT";
                                }
                            },
                            sameElse: "L",
                        },
                        relativeTime: {
                            future: "čez %s",
                            past: "pred %s",
                            s: processRelativeTime,
                            ss: processRelativeTime,
                            m: processRelativeTime,
                            mm: processRelativeTime,
                            h: processRelativeTime,
                            hh: processRelativeTime,
                            d: processRelativeTime,
                            dd: processRelativeTime,
                            M: processRelativeTime,
                            MM: processRelativeTime,
                            y: processRelativeTime,
                            yy: processRelativeTime,
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}\./,
                        ordinal: "%d.",
                        week: { dow: 1, doy: 7 },
                    });
                    return sl;
                });
            },
            "./node_modules/moment/locale/sq.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var sq = moment.defineLocale("sq", {
                        months: "Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nëntor_Dhjetor".split("_"),
                        monthsShort: "Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nën_Dhj".split("_"),
                        weekdays: "E Diel_E Hënë_E Martë_E Mërkurë_E Enjte_E Premte_E Shtunë".split("_"),
                        weekdaysShort: "Die_Hën_Mar_Mër_Enj_Pre_Sht".split("_"),
                        weekdaysMin: "D_H_Ma_Më_E_P_Sh".split("_"),
                        weekdaysParseExact: true,
                        meridiemParse: /PD|MD/,
                        isPM: function (input) {
                            return input.charAt(0) === "M";
                        },
                        meridiem: function (hours, minutes, isLower) {
                            return hours < 12 ? "PD" : "MD";
                        },
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[Sot në] LT", nextDay: "[Nesër në] LT", nextWeek: "dddd [në] LT", lastDay: "[Dje në] LT", lastWeek: "dddd [e kaluar në] LT", sameElse: "L" },
                        relativeTime: {
                            future: "në %s",
                            past: "%s më parë",
                            s: "disa sekonda",
                            ss: "%d sekonda",
                            m: "një minutë",
                            mm: "%d minuta",
                            h: "një orë",
                            hh: "%d orë",
                            d: "një ditë",
                            dd: "%d ditë",
                            M: "një muaj",
                            MM: "%d muaj",
                            y: "një vit",
                            yy: "%d vite",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}\./,
                        ordinal: "%d.",
                        week: { dow: 1, doy: 4 },
                    });
                    return sq;
                });
            },
            "./node_modules/moment/locale/sr-cyrl.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var translator = {
                        words: {
                            ss: ["секунда", "секунде", "секунди"],
                            m: ["један минут", "једног минута"],
                            mm: ["минут", "минута", "минута"],
                            h: ["један сат", "једног сата"],
                            hh: ["сат", "сата", "сати"],
                            d: ["један дан", "једног дана"],
                            dd: ["дан", "дана", "дана"],
                            M: ["један месец", "једног месеца"],
                            MM: ["месец", "месеца", "месеци"],
                            y: ["једну годину", "једне године"],
                            yy: ["годину", "године", "година"],
                        },
                        correctGrammaticalCase: function (number, wordKey) {
                            if (number % 10 >= 1 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                                return number % 10 === 1 ? wordKey[0] : wordKey[1];
                            }
                            return wordKey[2];
                        },
                        translate: function (number, withoutSuffix, key, isFuture) {
                            var wordKey = translator.words[key],
                                word;
                            if (key.length === 1) {
                                if (key === "y" && withoutSuffix) return "једна година";
                                return isFuture || withoutSuffix ? wordKey[0] : wordKey[1];
                            }
                            word = translator.correctGrammaticalCase(number, wordKey);
                            if (key === "yy" && withoutSuffix && word === "годину") {
                                return number + " година";
                            }
                            return number + " " + word;
                        },
                    };
                    var srCyrl = moment.defineLocale("sr-cyrl", {
                        months: "јануар_фебруар_март_април_мај_јун_јул_август_септембар_октобар_новембар_децембар".split("_"),
                        monthsShort: "јан._феб._мар._апр._мај_јун_јул_авг._сеп._окт._нов._дец.".split("_"),
                        monthsParseExact: true,
                        weekdays: "недеља_понедељак_уторак_среда_четвртак_петак_субота".split("_"),
                        weekdaysShort: "нед._пон._уто._сре._чет._пет._суб.".split("_"),
                        weekdaysMin: "не_по_ут_ср_че_пе_су".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "D. M. YYYY.", LL: "D. MMMM YYYY.", LLL: "D. MMMM YYYY. H:mm", LLLL: "dddd, D. MMMM YYYY. H:mm" },
                        calendar: {
                            sameDay: "[данас у] LT",
                            nextDay: "[сутра у] LT",
                            nextWeek: function () {
                                switch (this.day()) {
                                    case 0:
                                        return "[у] [недељу] [у] LT";
                                    case 3:
                                        return "[у] [среду] [у] LT";
                                    case 6:
                                        return "[у] [суботу] [у] LT";
                                    case 1:
                                    case 2:
                                    case 4:
                                    case 5:
                                        return "[у] dddd [у] LT";
                                }
                            },
                            lastDay: "[јуче у] LT",
                            lastWeek: function () {
                                var lastWeekDays = [
                                    "[прошле] [недеље] [у] LT",
                                    "[прошлог] [понедељка] [у] LT",
                                    "[прошлог] [уторка] [у] LT",
                                    "[прошле] [среде] [у] LT",
                                    "[прошлог] [четвртка] [у] LT",
                                    "[прошлог] [петка] [у] LT",
                                    "[прошле] [суботе] [у] LT",
                                ];
                                return lastWeekDays[this.day()];
                            },
                            sameElse: "L",
                        },
                        relativeTime: {
                            future: "за %s",
                            past: "пре %s",
                            s: "неколико секунди",
                            ss: translator.translate,
                            m: translator.translate,
                            mm: translator.translate,
                            h: translator.translate,
                            hh: translator.translate,
                            d: translator.translate,
                            dd: translator.translate,
                            M: translator.translate,
                            MM: translator.translate,
                            y: translator.translate,
                            yy: translator.translate,
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}\./,
                        ordinal: "%d.",
                        week: { dow: 1, doy: 7 },
                    });
                    return srCyrl;
                });
            },
            "./node_modules/moment/locale/sr.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var translator = {
                        words: {
                            ss: ["sekunda", "sekunde", "sekundi"],
                            m: ["jedan minut", "jednog minuta"],
                            mm: ["minut", "minuta", "minuta"],
                            h: ["jedan sat", "jednog sata"],
                            hh: ["sat", "sata", "sati"],
                            d: ["jedan dan", "jednog dana"],
                            dd: ["dan", "dana", "dana"],
                            M: ["jedan mesec", "jednog meseca"],
                            MM: ["mesec", "meseca", "meseci"],
                            y: ["jednu godinu", "jedne godine"],
                            yy: ["godinu", "godine", "godina"],
                        },
                        correctGrammaticalCase: function (number, wordKey) {
                            if (number % 10 >= 1 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                                return number % 10 === 1 ? wordKey[0] : wordKey[1];
                            }
                            return wordKey[2];
                        },
                        translate: function (number, withoutSuffix, key, isFuture) {
                            var wordKey = translator.words[key],
                                word;
                            if (key.length === 1) {
                                if (key === "y" && withoutSuffix) return "jedna godina";
                                return isFuture || withoutSuffix ? wordKey[0] : wordKey[1];
                            }
                            word = translator.correctGrammaticalCase(number, wordKey);
                            if (key === "yy" && withoutSuffix && word === "godinu") {
                                return number + " godina";
                            }
                            return number + " " + word;
                        },
                    };
                    var sr = moment.defineLocale("sr", {
                        months: "januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"),
                        monthsShort: "jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"),
                        monthsParseExact: true,
                        weekdays: "nedelja_ponedeljak_utorak_sreda_četvrtak_petak_subota".split("_"),
                        weekdaysShort: "ned._pon._uto._sre._čet._pet._sub.".split("_"),
                        weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "D. M. YYYY.", LL: "D. MMMM YYYY.", LLL: "D. MMMM YYYY. H:mm", LLLL: "dddd, D. MMMM YYYY. H:mm" },
                        calendar: {
                            sameDay: "[danas u] LT",
                            nextDay: "[sutra u] LT",
                            nextWeek: function () {
                                switch (this.day()) {
                                    case 0:
                                        return "[u] [nedelju] [u] LT";
                                    case 3:
                                        return "[u] [sredu] [u] LT";
                                    case 6:
                                        return "[u] [subotu] [u] LT";
                                    case 1:
                                    case 2:
                                    case 4:
                                    case 5:
                                        return "[u] dddd [u] LT";
                                }
                            },
                            lastDay: "[juče u] LT",
                            lastWeek: function () {
                                var lastWeekDays = [
                                    "[prošle] [nedelje] [u] LT",
                                    "[prošlog] [ponedeljka] [u] LT",
                                    "[prošlog] [utorka] [u] LT",
                                    "[prošle] [srede] [u] LT",
                                    "[prošlog] [četvrtka] [u] LT",
                                    "[prošlog] [petka] [u] LT",
                                    "[prošle] [subote] [u] LT",
                                ];
                                return lastWeekDays[this.day()];
                            },
                            sameElse: "L",
                        },
                        relativeTime: {
                            future: "za %s",
                            past: "pre %s",
                            s: "nekoliko sekundi",
                            ss: translator.translate,
                            m: translator.translate,
                            mm: translator.translate,
                            h: translator.translate,
                            hh: translator.translate,
                            d: translator.translate,
                            dd: translator.translate,
                            M: translator.translate,
                            MM: translator.translate,
                            y: translator.translate,
                            yy: translator.translate,
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}\./,
                        ordinal: "%d.",
                        week: { dow: 1, doy: 7 },
                    });
                    return sr;
                });
            },
            "./node_modules/moment/locale/ss.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var ss = moment.defineLocale("ss", {
                        months: "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split("_"),
                        monthsShort: "Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo".split("_"),
                        weekdays: "Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo".split("_"),
                        weekdaysShort: "Lis_Umb_Lsb_Les_Lsi_Lsh_Umg".split("_"),
                        weekdaysMin: "Li_Us_Lb_Lt_Ls_Lh_Ug".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" },
                        calendar: { sameDay: "[Namuhla nga] LT", nextDay: "[Kusasa nga] LT", nextWeek: "dddd [nga] LT", lastDay: "[Itolo nga] LT", lastWeek: "dddd [leliphelile] [nga] LT", sameElse: "L" },
                        relativeTime: {
                            future: "nga %s",
                            past: "wenteka nga %s",
                            s: "emizuzwana lomcane",
                            ss: "%d mzuzwana",
                            m: "umzuzu",
                            mm: "%d emizuzu",
                            h: "lihora",
                            hh: "%d emahora",
                            d: "lilanga",
                            dd: "%d emalanga",
                            M: "inyanga",
                            MM: "%d tinyanga",
                            y: "umnyaka",
                            yy: "%d iminyaka",
                        },
                        meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
                        meridiem: function (hours, minutes, isLower) {
                            if (hours < 11) {
                                return "ekuseni";
                            } else if (hours < 15) {
                                return "emini";
                            } else if (hours < 19) {
                                return "entsambama";
                            } else {
                                return "ebusuku";
                            }
                        },
                        meridiemHour: function (hour, meridiem) {
                            if (hour === 12) {
                                hour = 0;
                            }
                            if (meridiem === "ekuseni") {
                                return hour;
                            } else if (meridiem === "emini") {
                                return hour >= 11 ? hour : hour + 12;
                            } else if (meridiem === "entsambama" || meridiem === "ebusuku") {
                                if (hour === 0) {
                                    return 0;
                                }
                                return hour + 12;
                            }
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}/,
                        ordinal: "%d",
                        week: { dow: 1, doy: 4 },
                    });
                    return ss;
                });
            },
            "./node_modules/moment/locale/sv.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var sv = moment.defineLocale("sv", {
                        months: "januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december".split("_"),
                        monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),
                        weekdays: "söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag".split("_"),
                        weekdaysShort: "sön_mån_tis_ons_tor_fre_lör".split("_"),
                        weekdaysMin: "sö_må_ti_on_to_fr_lö".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [kl.] HH:mm", LLLL: "dddd D MMMM YYYY [kl.] HH:mm", lll: "D MMM YYYY HH:mm", llll: "ddd D MMM YYYY HH:mm" },
                        calendar: { sameDay: "[Idag] LT", nextDay: "[Imorgon] LT", lastDay: "[Igår] LT", nextWeek: "[På] dddd LT", lastWeek: "[I] dddd[s] LT", sameElse: "L" },
                        relativeTime: {
                            future: "om %s",
                            past: "för %s sedan",
                            s: "några sekunder",
                            ss: "%d sekunder",
                            m: "en minut",
                            mm: "%d minuter",
                            h: "en timme",
                            hh: "%d timmar",
                            d: "en dag",
                            dd: "%d dagar",
                            M: "en månad",
                            MM: "%d månader",
                            y: "ett år",
                            yy: "%d år",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(\:e|\:a)/,
                        ordinal: function (number) {
                            var b = number % 10,
                                output = ~~((number % 100) / 10) === 1 ? ":e" : b === 1 ? ":a" : b === 2 ? ":a" : b === 3 ? ":e" : ":e";
                            return number + output;
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return sv;
                });
            },
            "./node_modules/moment/locale/sw.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var sw = moment.defineLocale("sw", {
                        months: "Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba".split("_"),
                        monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des".split("_"),
                        weekdays: "Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi".split("_"),
                        weekdaysShort: "Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos".split("_"),
                        weekdaysMin: "J2_J3_J4_J5_Al_Ij_J1".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "hh:mm A", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[leo saa] LT", nextDay: "[kesho saa] LT", nextWeek: "[wiki ijayo] dddd [saat] LT", lastDay: "[jana] LT", lastWeek: "[wiki iliyopita] dddd [saat] LT", sameElse: "L" },
                        relativeTime: {
                            future: "%s baadaye",
                            past: "tokea %s",
                            s: "hivi punde",
                            ss: "sekunde %d",
                            m: "dakika moja",
                            mm: "dakika %d",
                            h: "saa limoja",
                            hh: "masaa %d",
                            d: "siku moja",
                            dd: "siku %d",
                            M: "mwezi mmoja",
                            MM: "miezi %d",
                            y: "mwaka mmoja",
                            yy: "miaka %d",
                        },
                        week: { dow: 1, doy: 7 },
                    });
                    return sw;
                });
            },
            "./node_modules/moment/locale/ta.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var symbolMap = { 1: "௧", 2: "௨", 3: "௩", 4: "௪", 5: "௫", 6: "௬", 7: "௭", 8: "௮", 9: "௯", 0: "௦" },
                        numberMap = { "௧": "1", "௨": "2", "௩": "3", "௪": "4", "௫": "5", "௬": "6", "௭": "7", "௮": "8", "௯": "9", "௦": "0" };
                    var ta = moment.defineLocale("ta", {
                        months: "ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்".split("_"),
                        monthsShort: "ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்".split("_"),
                        weekdays: "ஞாயிற்றுக்கிழமை_திங்கட்கிழமை_செவ்வாய்கிழமை_புதன்கிழமை_வியாழக்கிழமை_வெள்ளிக்கிழமை_சனிக்கிழமை".split("_"),
                        weekdaysShort: "ஞாயிறு_திங்கள்_செவ்வாய்_புதன்_வியாழன்_வெள்ளி_சனி".split("_"),
                        weekdaysMin: "ஞா_தி_செ_பு_வி_வெ_ச".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, HH:mm", LLLL: "dddd, D MMMM YYYY, HH:mm" },
                        calendar: { sameDay: "[இன்று] LT", nextDay: "[நாளை] LT", nextWeek: "dddd, LT", lastDay: "[நேற்று] LT", lastWeek: "[கடந்த வாரம்] dddd, LT", sameElse: "L" },
                        relativeTime: {
                            future: "%s இல்",
                            past: "%s முன்",
                            s: "ஒரு சில விநாடிகள்",
                            ss: "%d விநாடிகள்",
                            m: "ஒரு நிமிடம்",
                            mm: "%d நிமிடங்கள்",
                            h: "ஒரு மணி நேரம்",
                            hh: "%d மணி நேரம்",
                            d: "ஒரு நாள்",
                            dd: "%d நாட்கள்",
                            M: "ஒரு மாதம்",
                            MM: "%d மாதங்கள்",
                            y: "ஒரு வருடம்",
                            yy: "%d ஆண்டுகள்",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}வது/,
                        ordinal: function (number) {
                            return number + "வது";
                        },
                        preparse: function (string) {
                            return string.replace(/[௧௨௩௪௫௬௭௮௯௦]/g, function (match) {
                                return numberMap[match];
                            });
                        },
                        postformat: function (string) {
                            return string.replace(/\d/g, function (match) {
                                return symbolMap[match];
                            });
                        },
                        meridiemParse: /யாமம்|வைகறை|காலை|நண்பகல்|எற்பாடு|மாலை/,
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 2) {
                                return " யாமம்";
                            } else if (hour < 6) {
                                return " வைகறை";
                            } else if (hour < 10) {
                                return " காலை";
                            } else if (hour < 14) {
                                return " நண்பகல்";
                            } else if (hour < 18) {
                                return " எற்பாடு";
                            } else if (hour < 22) {
                                return " மாலை";
                            } else {
                                return " யாமம்";
                            }
                        },
                        meridiemHour: function (hour, meridiem) {
                            if (hour === 12) {
                                hour = 0;
                            }
                            if (meridiem === "யாமம்") {
                                return hour < 2 ? hour : hour + 12;
                            } else if (meridiem === "வைகறை" || meridiem === "காலை") {
                                return hour;
                            } else if (meridiem === "நண்பகல்") {
                                return hour >= 10 ? hour : hour + 12;
                            } else {
                                return hour + 12;
                            }
                        },
                        week: { dow: 0, doy: 6 },
                    });
                    return ta;
                });
            },
            "./node_modules/moment/locale/te.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var te = moment.defineLocale("te", {
                        months: "జనవరి_ఫిబ్రవరి_మార్చి_ఏప్రిల్_మే_జూన్_జులై_ఆగస్టు_సెప్టెంబర్_అక్టోబర్_నవంబర్_డిసెంబర్".split("_"),
                        monthsShort: "జన._ఫిబ్ర._మార్చి_ఏప్రి._మే_జూన్_జులై_ఆగ._సెప్._అక్టో._నవ._డిసె.".split("_"),
                        monthsParseExact: true,
                        weekdays: "ఆదివారం_సోమవారం_మంగళవారం_బుధవారం_గురువారం_శుక్రవారం_శనివారం".split("_"),
                        weekdaysShort: "ఆది_సోమ_మంగళ_బుధ_గురు_శుక్ర_శని".split("_"),
                        weekdaysMin: "ఆ_సో_మం_బు_గు_శు_శ".split("_"),
                        longDateFormat: { LT: "A h:mm", LTS: "A h:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm", LLLL: "dddd, D MMMM YYYY, A h:mm" },
                        calendar: { sameDay: "[నేడు] LT", nextDay: "[రేపు] LT", nextWeek: "dddd, LT", lastDay: "[నిన్న] LT", lastWeek: "[గత] dddd, LT", sameElse: "L" },
                        relativeTime: {
                            future: "%s లో",
                            past: "%s క్రితం",
                            s: "కొన్ని క్షణాలు",
                            ss: "%d సెకన్లు",
                            m: "ఒక నిమిషం",
                            mm: "%d నిమిషాలు",
                            h: "ఒక గంట",
                            hh: "%d గంటలు",
                            d: "ఒక రోజు",
                            dd: "%d రోజులు",
                            M: "ఒక నెల",
                            MM: "%d నెలలు",
                            y: "ఒక సంవత్సరం",
                            yy: "%d సంవత్సరాలు",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}వ/,
                        ordinal: "%dవ",
                        meridiemParse: /రాత్రి|ఉదయం|మధ్యాహ్నం|సాయంత్రం/,
                        meridiemHour: function (hour, meridiem) {
                            if (hour === 12) {
                                hour = 0;
                            }
                            if (meridiem === "రాత్రి") {
                                return hour < 4 ? hour : hour + 12;
                            } else if (meridiem === "ఉదయం") {
                                return hour;
                            } else if (meridiem === "మధ్యాహ్నం") {
                                return hour >= 10 ? hour : hour + 12;
                            } else if (meridiem === "సాయంత్రం") {
                                return hour + 12;
                            }
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 4) {
                                return "రాత్రి";
                            } else if (hour < 10) {
                                return "ఉదయం";
                            } else if (hour < 17) {
                                return "మధ్యాహ్నం";
                            } else if (hour < 20) {
                                return "సాయంత్రం";
                            } else {
                                return "రాత్రి";
                            }
                        },
                        week: { dow: 0, doy: 6 },
                    });
                    return te;
                });
            },
            "./node_modules/moment/locale/tet.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var tet = moment.defineLocale("tet", {
                        months: "Janeiru_Fevereiru_Marsu_Abril_Maiu_Juñu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru".split("_"),
                        monthsShort: "Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"),
                        weekdays: "Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu".split("_"),
                        weekdaysShort: "Dom_Seg_Ters_Kua_Kint_Sest_Sab".split("_"),
                        weekdaysMin: "Do_Seg_Te_Ku_Ki_Ses_Sa".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[Ohin iha] LT", nextDay: "[Aban iha] LT", nextWeek: "dddd [iha] LT", lastDay: "[Horiseik iha] LT", lastWeek: "dddd [semana kotuk] [iha] LT", sameElse: "L" },
                        relativeTime: {
                            future: "iha %s",
                            past: "%s liuba",
                            s: "segundu balun",
                            ss: "segundu %d",
                            m: "minutu ida",
                            mm: "minutu %d",
                            h: "oras ida",
                            hh: "oras %d",
                            d: "loron ida",
                            dd: "loron %d",
                            M: "fulan ida",
                            MM: "fulan %d",
                            y: "tinan ida",
                            yy: "tinan %d",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
                        ordinal: function (number) {
                            var b = number % 10,
                                output = ~~((number % 100) / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
                            return number + output;
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return tet;
                });
            },
            "./node_modules/moment/locale/tg.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var suffixes = {
                        0: "-ум",
                        1: "-ум",
                        2: "-юм",
                        3: "-юм",
                        4: "-ум",
                        5: "-ум",
                        6: "-ум",
                        7: "-ум",
                        8: "-ум",
                        9: "-ум",
                        10: "-ум",
                        12: "-ум",
                        13: "-ум",
                        20: "-ум",
                        30: "-юм",
                        40: "-ум",
                        50: "-ум",
                        60: "-ум",
                        70: "-ум",
                        80: "-ум",
                        90: "-ум",
                        100: "-ум",
                    };
                    var tg = moment.defineLocale("tg", {
                        months: { format: "январи_феврали_марти_апрели_майи_июни_июли_августи_сентябри_октябри_ноябри_декабри".split("_"), standalone: "январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр".split("_") },
                        monthsShort: "янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек".split("_"),
                        weekdays: "якшанбе_душанбе_сешанбе_чоршанбе_панҷшанбе_ҷумъа_шанбе".split("_"),
                        weekdaysShort: "яшб_дшб_сшб_чшб_пшб_ҷум_шнб".split("_"),
                        weekdaysMin: "яш_дш_сш_чш_пш_ҷм_шб".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[Имрӯз соати] LT", nextDay: "[Фардо соати] LT", lastDay: "[Дирӯз соати] LT", nextWeek: "dddd[и] [ҳафтаи оянда соати] LT", lastWeek: "dddd[и] [ҳафтаи гузашта соати] LT", sameElse: "L" },
                        relativeTime: { future: "баъди %s", past: "%s пеш", s: "якчанд сония", m: "як дақиқа", mm: "%d дақиқа", h: "як соат", hh: "%d соат", d: "як рӯз", dd: "%d рӯз", M: "як моҳ", MM: "%d моҳ", y: "як сол", yy: "%d сол" },
                        meridiemParse: /шаб|субҳ|рӯз|бегоҳ/,
                        meridiemHour: function (hour, meridiem) {
                            if (hour === 12) {
                                hour = 0;
                            }
                            if (meridiem === "шаб") {
                                return hour < 4 ? hour : hour + 12;
                            } else if (meridiem === "субҳ") {
                                return hour;
                            } else if (meridiem === "рӯз") {
                                return hour >= 11 ? hour : hour + 12;
                            } else if (meridiem === "бегоҳ") {
                                return hour + 12;
                            }
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 4) {
                                return "шаб";
                            } else if (hour < 11) {
                                return "субҳ";
                            } else if (hour < 16) {
                                return "рӯз";
                            } else if (hour < 19) {
                                return "бегоҳ";
                            } else {
                                return "шаб";
                            }
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}-(ум|юм)/,
                        ordinal: function (number) {
                            var a = number % 10,
                                b = number >= 100 ? 100 : null;
                            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
                        },
                        week: { dow: 1, doy: 7 },
                    });
                    return tg;
                });
            },
            "./node_modules/moment/locale/th.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var th = moment.defineLocale("th", {
                        months: "มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม".split("_"),
                        monthsShort: "ม.ค._ก.พ._มี.ค._เม.ย._พ.ค._มิ.ย._ก.ค._ส.ค._ก.ย._ต.ค._พ.ย._ธ.ค.".split("_"),
                        monthsParseExact: true,
                        weekdays: "อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์".split("_"),
                        weekdaysShort: "อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์".split("_"),
                        weekdaysMin: "อา._จ._อ._พ._พฤ._ศ._ส.".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY เวลา H:mm", LLLL: "วันddddที่ D MMMM YYYY เวลา H:mm" },
                        meridiemParse: /ก่อนเที่ยง|หลังเที่ยง/,
                        isPM: function (input) {
                            return input === "หลังเที่ยง";
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 12) {
                                return "ก่อนเที่ยง";
                            } else {
                                return "หลังเที่ยง";
                            }
                        },
                        calendar: { sameDay: "[วันนี้ เวลา] LT", nextDay: "[พรุ่งนี้ เวลา] LT", nextWeek: "dddd[หน้า เวลา] LT", lastDay: "[เมื่อวานนี้ เวลา] LT", lastWeek: "[วัน]dddd[ที่แล้ว เวลา] LT", sameElse: "L" },
                        relativeTime: {
                            future: "อีก %s",
                            past: "%sที่แล้ว",
                            s: "ไม่กี่วินาที",
                            ss: "%d วินาที",
                            m: "1 นาที",
                            mm: "%d นาที",
                            h: "1 ชั่วโมง",
                            hh: "%d ชั่วโมง",
                            d: "1 วัน",
                            dd: "%d วัน",
                            w: "1 สัปดาห์",
                            ww: "%d สัปดาห์",
                            M: "1 เดือน",
                            MM: "%d เดือน",
                            y: "1 ปี",
                            yy: "%d ปี",
                        },
                    });
                    return th;
                });
            },
            "./node_modules/moment/locale/tk.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var suffixes = {
                        1: "'inji",
                        5: "'inji",
                        8: "'inji",
                        70: "'inji",
                        80: "'inji",
                        2: "'nji",
                        7: "'nji",
                        20: "'nji",
                        50: "'nji",
                        3: "'ünji",
                        4: "'ünji",
                        100: "'ünji",
                        6: "'njy",
                        9: "'unjy",
                        10: "'unjy",
                        30: "'unjy",
                        60: "'ynjy",
                        90: "'ynjy",
                    };
                    var tk = moment.defineLocale("tk", {
                        months: "Ýanwar_Fewral_Mart_Aprel_Maý_Iýun_Iýul_Awgust_Sentýabr_Oktýabr_Noýabr_Dekabr".split("_"),
                        monthsShort: "Ýan_Few_Mar_Apr_Maý_Iýn_Iýl_Awg_Sen_Okt_Noý_Dek".split("_"),
                        weekdays: "Ýekşenbe_Duşenbe_Sişenbe_Çarşenbe_Penşenbe_Anna_Şenbe".split("_"),
                        weekdaysShort: "Ýek_Duş_Siş_Çar_Pen_Ann_Şen".split("_"),
                        weekdaysMin: "Ýk_Dş_Sş_Çr_Pn_An_Şn".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[bugün sagat] LT", nextDay: "[ertir sagat] LT", nextWeek: "[indiki] dddd [sagat] LT", lastDay: "[düýn] LT", lastWeek: "[geçen] dddd [sagat] LT", sameElse: "L" },
                        relativeTime: {
                            future: "%s soň",
                            past: "%s öň",
                            s: "birnäçe sekunt",
                            m: "bir minut",
                            mm: "%d minut",
                            h: "bir sagat",
                            hh: "%d sagat",
                            d: "bir gün",
                            dd: "%d gün",
                            M: "bir aý",
                            MM: "%d aý",
                            y: "bir ýyl",
                            yy: "%d ýyl",
                        },
                        ordinal: function (number, period) {
                            switch (period) {
                                case "d":
                                case "D":
                                case "Do":
                                case "DD":
                                    return number;
                                default:
                                    if (number === 0) {
                                        return number + "'unjy";
                                    }
                                    var a = number % 10,
                                        b = (number % 100) - a,
                                        c = number >= 100 ? 100 : null;
                                    return number + (suffixes[a] || suffixes[b] || suffixes[c]);
                            }
                        },
                        week: { dow: 1, doy: 7 },
                    });
                    return tk;
                });
            },
            "./node_modules/moment/locale/tl-ph.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var tlPh = moment.defineLocale("tl-ph", {
                        months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"),
                        monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"),
                        weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"),
                        weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"),
                        weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "MM/D/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY HH:mm", LLLL: "dddd, MMMM DD, YYYY HH:mm" },
                        calendar: { sameDay: "LT [ngayong araw]", nextDay: "[Bukas ng] LT", nextWeek: "LT [sa susunod na] dddd", lastDay: "LT [kahapon]", lastWeek: "LT [noong nakaraang] dddd", sameElse: "L" },
                        relativeTime: {
                            future: "sa loob ng %s",
                            past: "%s ang nakalipas",
                            s: "ilang segundo",
                            ss: "%d segundo",
                            m: "isang minuto",
                            mm: "%d minuto",
                            h: "isang oras",
                            hh: "%d oras",
                            d: "isang araw",
                            dd: "%d araw",
                            M: "isang buwan",
                            MM: "%d buwan",
                            y: "isang taon",
                            yy: "%d taon",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}/,
                        ordinal: function (number) {
                            return number;
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return tlPh;
                });
            },
            "./node_modules/moment/locale/tlh.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var numbersNouns = "pagh_wa’_cha’_wej_loS_vagh_jav_Soch_chorgh_Hut".split("_");
                    function translateFuture(output) {
                        var time = output;
                        time = output.indexOf("jaj") !== -1 ? time.slice(0, -3) + "leS" : output.indexOf("jar") !== -1 ? time.slice(0, -3) + "waQ" : output.indexOf("DIS") !== -1 ? time.slice(0, -3) + "nem" : time + " pIq";
                        return time;
                    }
                    function translatePast(output) {
                        var time = output;
                        time = output.indexOf("jaj") !== -1 ? time.slice(0, -3) + "Hu’" : output.indexOf("jar") !== -1 ? time.slice(0, -3) + "wen" : output.indexOf("DIS") !== -1 ? time.slice(0, -3) + "ben" : time + " ret";
                        return time;
                    }
                    function translate(number, withoutSuffix, string, isFuture) {
                        var numberNoun = numberAsNoun(number);
                        switch (string) {
                            case "ss":
                                return numberNoun + " lup";
                            case "mm":
                                return numberNoun + " tup";
                            case "hh":
                                return numberNoun + " rep";
                            case "dd":
                                return numberNoun + " jaj";
                            case "MM":
                                return numberNoun + " jar";
                            case "yy":
                                return numberNoun + " DIS";
                        }
                    }
                    function numberAsNoun(number) {
                        var hundred = Math.floor((number % 1e3) / 100),
                            ten = Math.floor((number % 100) / 10),
                            one = number % 10,
                            word = "";
                        if (hundred > 0) {
                            word += numbersNouns[hundred] + "vatlh";
                        }
                        if (ten > 0) {
                            word += (word !== "" ? " " : "") + numbersNouns[ten] + "maH";
                        }
                        if (one > 0) {
                            word += (word !== "" ? " " : "") + numbersNouns[one];
                        }
                        return word === "" ? "pagh" : word;
                    }
                    var tlh = moment.defineLocale("tlh", {
                        months: "tera’ jar wa’_tera’ jar cha’_tera’ jar wej_tera’ jar loS_tera’ jar vagh_tera’ jar jav_tera’ jar Soch_tera’ jar chorgh_tera’ jar Hut_tera’ jar wa’maH_tera’ jar wa’maH wa’_tera’ jar wa’maH cha’".split("_"),
                        monthsShort: "jar wa’_jar cha’_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wa’maH_jar wa’maH wa’_jar wa’maH cha’".split("_"),
                        monthsParseExact: true,
                        weekdays: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),
                        weekdaysShort: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),
                        weekdaysMin: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[DaHjaj] LT", nextDay: "[wa’leS] LT", nextWeek: "LLL", lastDay: "[wa’Hu’] LT", lastWeek: "LLL", sameElse: "L" },
                        relativeTime: {
                            future: translateFuture,
                            past: translatePast,
                            s: "puS lup",
                            ss: translate,
                            m: "wa’ tup",
                            mm: translate,
                            h: "wa’ rep",
                            hh: translate,
                            d: "wa’ jaj",
                            dd: translate,
                            M: "wa’ jar",
                            MM: translate,
                            y: "wa’ DIS",
                            yy: translate,
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}\./,
                        ordinal: "%d.",
                        week: { dow: 1, doy: 4 },
                    });
                    return tlh;
                });
            },
            "./node_modules/moment/locale/tr.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var suffixes = {
                        1: "'inci",
                        5: "'inci",
                        8: "'inci",
                        70: "'inci",
                        80: "'inci",
                        2: "'nci",
                        7: "'nci",
                        20: "'nci",
                        50: "'nci",
                        3: "'üncü",
                        4: "'üncü",
                        100: "'üncü",
                        6: "'ncı",
                        9: "'uncu",
                        10: "'uncu",
                        30: "'uncu",
                        60: "'ıncı",
                        90: "'ıncı",
                    };
                    var tr = moment.defineLocale("tr", {
                        months: "Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık".split("_"),
                        monthsShort: "Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara".split("_"),
                        weekdays: "Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi".split("_"),
                        weekdaysShort: "Paz_Pzt_Sal_Çar_Per_Cum_Cmt".split("_"),
                        weekdaysMin: "Pz_Pt_Sa_Ça_Pe_Cu_Ct".split("_"),
                        meridiem: function (hours, minutes, isLower) {
                            if (hours < 12) {
                                return isLower ? "öö" : "ÖÖ";
                            } else {
                                return isLower ? "ös" : "ÖS";
                            }
                        },
                        meridiemParse: /öö|ÖÖ|ös|ÖS/,
                        isPM: function (input) {
                            return input === "ös" || input === "ÖS";
                        },
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[bugün saat] LT", nextDay: "[yarın saat] LT", nextWeek: "[gelecek] dddd [saat] LT", lastDay: "[dün] LT", lastWeek: "[geçen] dddd [saat] LT", sameElse: "L" },
                        relativeTime: {
                            future: "%s sonra",
                            past: "%s önce",
                            s: "birkaç saniye",
                            ss: "%d saniye",
                            m: "bir dakika",
                            mm: "%d dakika",
                            h: "bir saat",
                            hh: "%d saat",
                            d: "bir gün",
                            dd: "%d gün",
                            w: "bir hafta",
                            ww: "%d hafta",
                            M: "bir ay",
                            MM: "%d ay",
                            y: "bir yıl",
                            yy: "%d yıl",
                        },
                        ordinal: function (number, period) {
                            switch (period) {
                                case "d":
                                case "D":
                                case "Do":
                                case "DD":
                                    return number;
                                default:
                                    if (number === 0) {
                                        return number + "'ıncı";
                                    }
                                    var a = number % 10,
                                        b = (number % 100) - a,
                                        c = number >= 100 ? 100 : null;
                                    return number + (suffixes[a] || suffixes[b] || suffixes[c]);
                            }
                        },
                        week: { dow: 1, doy: 7 },
                    });
                    return tr;
                });
            },
            "./node_modules/moment/locale/tzl.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var tzl = moment.defineLocale("tzl", {
                        months: "Januar_Fevraglh_Març_Avrïu_Mai_Gün_Julia_Guscht_Setemvar_Listopäts_Noemvar_Zecemvar".split("_"),
                        monthsShort: "Jan_Fev_Mar_Avr_Mai_Gün_Jul_Gus_Set_Lis_Noe_Zec".split("_"),
                        weekdays: "Súladi_Lúneçi_Maitzi_Márcuri_Xhúadi_Viénerçi_Sáturi".split("_"),
                        weekdaysShort: "Súl_Lún_Mai_Már_Xhú_Vié_Sát".split("_"),
                        weekdaysMin: "Sú_Lú_Ma_Má_Xh_Vi_Sá".split("_"),
                        longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD.MM.YYYY", LL: "D. MMMM [dallas] YYYY", LLL: "D. MMMM [dallas] YYYY HH.mm", LLLL: "dddd, [li] D. MMMM [dallas] YYYY HH.mm" },
                        meridiemParse: /d\'o|d\'a/i,
                        isPM: function (input) {
                            return "d'o" === input.toLowerCase();
                        },
                        meridiem: function (hours, minutes, isLower) {
                            if (hours > 11) {
                                return isLower ? "d'o" : "D'O";
                            } else {
                                return isLower ? "d'a" : "D'A";
                            }
                        },
                        calendar: { sameDay: "[oxhi à] LT", nextDay: "[demà à] LT", nextWeek: "dddd [à] LT", lastDay: "[ieiri à] LT", lastWeek: "[sür el] dddd [lasteu à] LT", sameElse: "L" },
                        relativeTime: {
                            future: "osprei %s",
                            past: "ja%s",
                            s: processRelativeTime,
                            ss: processRelativeTime,
                            m: processRelativeTime,
                            mm: processRelativeTime,
                            h: processRelativeTime,
                            hh: processRelativeTime,
                            d: processRelativeTime,
                            dd: processRelativeTime,
                            M: processRelativeTime,
                            MM: processRelativeTime,
                            y: processRelativeTime,
                            yy: processRelativeTime,
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}\./,
                        ordinal: "%d.",
                        week: { dow: 1, doy: 4 },
                    });
                    function processRelativeTime(number, withoutSuffix, key, isFuture) {
                        var format = {
                            s: ["viensas secunds", "'iensas secunds"],
                            ss: [number + " secunds", "" + number + " secunds"],
                            m: ["'n míut", "'iens míut"],
                            mm: [number + " míuts", "" + number + " míuts"],
                            h: ["'n þora", "'iensa þora"],
                            hh: [number + " þoras", "" + number + " þoras"],
                            d: ["'n ziua", "'iensa ziua"],
                            dd: [number + " ziuas", "" + number + " ziuas"],
                            M: ["'n mes", "'iens mes"],
                            MM: [number + " mesen", "" + number + " mesen"],
                            y: ["'n ar", "'iens ar"],
                            yy: [number + " ars", "" + number + " ars"],
                        };
                        return isFuture ? format[key][0] : withoutSuffix ? format[key][0] : format[key][1];
                    }
                    return tzl;
                });
            },
            "./node_modules/moment/locale/tzm-latn.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var tzmLatn = moment.defineLocale("tzm-latn", {
                        months: "innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir".split("_"),
                        monthsShort: "innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir".split("_"),
                        weekdays: "asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas".split("_"),
                        weekdaysShort: "asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas".split("_"),
                        weekdaysMin: "asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[asdkh g] LT", nextDay: "[aska g] LT", nextWeek: "dddd [g] LT", lastDay: "[assant g] LT", lastWeek: "dddd [g] LT", sameElse: "L" },
                        relativeTime: {
                            future: "dadkh s yan %s",
                            past: "yan %s",
                            s: "imik",
                            ss: "%d imik",
                            m: "minuḍ",
                            mm: "%d minuḍ",
                            h: "saɛa",
                            hh: "%d tassaɛin",
                            d: "ass",
                            dd: "%d ossan",
                            M: "ayowr",
                            MM: "%d iyyirn",
                            y: "asgas",
                            yy: "%d isgasn",
                        },
                        week: { dow: 6, doy: 12 },
                    });
                    return tzmLatn;
                });
            },
            "./node_modules/moment/locale/tzm.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var tzm = moment.defineLocale("tzm", {
                        months: "ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ".split("_"),
                        monthsShort: "ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ".split("_"),
                        weekdays: "ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ".split("_"),
                        weekdaysShort: "ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ".split("_"),
                        weekdaysMin: "ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[ⴰⵙⴷⵅ ⴴ] LT", nextDay: "[ⴰⵙⴽⴰ ⴴ] LT", nextWeek: "dddd [ⴴ] LT", lastDay: "[ⴰⵚⴰⵏⵜ ⴴ] LT", lastWeek: "dddd [ⴴ] LT", sameElse: "L" },
                        relativeTime: {
                            future: "ⴷⴰⴷⵅ ⵙ ⵢⴰⵏ %s",
                            past: "ⵢⴰⵏ %s",
                            s: "ⵉⵎⵉⴽ",
                            ss: "%d ⵉⵎⵉⴽ",
                            m: "ⵎⵉⵏⵓⴺ",
                            mm: "%d ⵎⵉⵏⵓⴺ",
                            h: "ⵙⴰⵄⴰ",
                            hh: "%d ⵜⴰⵙⵙⴰⵄⵉⵏ",
                            d: "ⴰⵙⵙ",
                            dd: "%d oⵙⵙⴰⵏ",
                            M: "ⴰⵢoⵓⵔ",
                            MM: "%d ⵉⵢⵢⵉⵔⵏ",
                            y: "ⴰⵙⴳⴰⵙ",
                            yy: "%d ⵉⵙⴳⴰⵙⵏ",
                        },
                        week: { dow: 6, doy: 12 },
                    });
                    return tzm;
                });
            },
            "./node_modules/moment/locale/ug-cn.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var ugCn = moment.defineLocale("ug-cn", {
                        months: "يانۋار_فېۋرال_مارت_ئاپرېل_ماي_ئىيۇن_ئىيۇل_ئاۋغۇست_سېنتەبىر_ئۆكتەبىر_نويابىر_دېكابىر".split("_"),
                        monthsShort: "يانۋار_فېۋرال_مارت_ئاپرېل_ماي_ئىيۇن_ئىيۇل_ئاۋغۇست_سېنتەبىر_ئۆكتەبىر_نويابىر_دېكابىر".split("_"),
                        weekdays: "يەكشەنبە_دۈشەنبە_سەيشەنبە_چارشەنبە_پەيشەنبە_جۈمە_شەنبە".split("_"),
                        weekdaysShort: "يە_دۈ_سە_چا_پە_جۈ_شە".split("_"),
                        weekdaysMin: "يە_دۈ_سە_چا_پە_جۈ_شە".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "YYYY-يىلىM-ئاينىڭD-كۈنى", LLL: "YYYY-يىلىM-ئاينىڭD-كۈنى، HH:mm", LLLL: "dddd، YYYY-يىلىM-ئاينىڭD-كۈنى، HH:mm" },
                        meridiemParse: /يېرىم كېچە|سەھەر|چۈشتىن بۇرۇن|چۈش|چۈشتىن كېيىن|كەچ/,
                        meridiemHour: function (hour, meridiem) {
                            if (hour === 12) {
                                hour = 0;
                            }
                            if (meridiem === "يېرىم كېچە" || meridiem === "سەھەر" || meridiem === "چۈشتىن بۇرۇن") {
                                return hour;
                            } else if (meridiem === "چۈشتىن كېيىن" || meridiem === "كەچ") {
                                return hour + 12;
                            } else {
                                return hour >= 11 ? hour : hour + 12;
                            }
                        },
                        meridiem: function (hour, minute, isLower) {
                            var hm = hour * 100 + minute;
                            if (hm < 600) {
                                return "يېرىم كېچە";
                            } else if (hm < 900) {
                                return "سەھەر";
                            } else if (hm < 1130) {
                                return "چۈشتىن بۇرۇن";
                            } else if (hm < 1230) {
                                return "چۈش";
                            } else if (hm < 1800) {
                                return "چۈشتىن كېيىن";
                            } else {
                                return "كەچ";
                            }
                        },
                        calendar: { sameDay: "[بۈگۈن سائەت] LT", nextDay: "[ئەتە سائەت] LT", nextWeek: "[كېلەركى] dddd [سائەت] LT", lastDay: "[تۆنۈگۈن] LT", lastWeek: "[ئالدىنقى] dddd [سائەت] LT", sameElse: "L" },
                        relativeTime: {
                            future: "%s كېيىن",
                            past: "%s بۇرۇن",
                            s: "نەچچە سېكونت",
                            ss: "%d سېكونت",
                            m: "بىر مىنۇت",
                            mm: "%d مىنۇت",
                            h: "بىر سائەت",
                            hh: "%d سائەت",
                            d: "بىر كۈن",
                            dd: "%d كۈن",
                            M: "بىر ئاي",
                            MM: "%d ئاي",
                            y: "بىر يىل",
                            yy: "%d يىل",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(-كۈنى|-ئاي|-ھەپتە)/,
                        ordinal: function (number, period) {
                            switch (period) {
                                case "d":
                                case "D":
                                case "DDD":
                                    return number + "-كۈنى";
                                case "w":
                                case "W":
                                    return number + "-ھەپتە";
                                default:
                                    return number;
                            }
                        },
                        preparse: function (string) {
                            return string.replace(/،/g, ",");
                        },
                        postformat: function (string) {
                            return string.replace(/,/g, "،");
                        },
                        week: { dow: 1, doy: 7 },
                    });
                    return ugCn;
                });
            },
            "./node_modules/moment/locale/uk.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    function plural(word, num) {
                        var forms = word.split("_");
                        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
                    }
                    function relativeTimeWithPlural(number, withoutSuffix, key) {
                        var format = {
                            ss: withoutSuffix ? "секунда_секунди_секунд" : "секунду_секунди_секунд",
                            mm: withoutSuffix ? "хвилина_хвилини_хвилин" : "хвилину_хвилини_хвилин",
                            hh: withoutSuffix ? "година_години_годин" : "годину_години_годин",
                            dd: "день_дні_днів",
                            MM: "місяць_місяці_місяців",
                            yy: "рік_роки_років",
                        };
                        if (key === "m") {
                            return withoutSuffix ? "хвилина" : "хвилину";
                        } else if (key === "h") {
                            return withoutSuffix ? "година" : "годину";
                        } else {
                            return number + " " + plural(format[key], +number);
                        }
                    }
                    function weekdaysCaseReplace(m, format) {
                        var weekdays = {
                                nominative: "неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота".split("_"),
                                accusative: "неділю_понеділок_вівторок_середу_четвер_п’ятницю_суботу".split("_"),
                                genitive: "неділі_понеділка_вівторка_середи_четверга_п’ятниці_суботи".split("_"),
                            },
                            nounCase;
                        if (m === true) {
                            return weekdays["nominative"].slice(1, 7).concat(weekdays["nominative"].slice(0, 1));
                        }
                        if (!m) {
                            return weekdays["nominative"];
                        }
                        nounCase = /(\[[ВвУу]\]) ?dddd/.test(format) ? "accusative" : /\[?(?:минулої|наступної)? ?\] ?dddd/.test(format) ? "genitive" : "nominative";
                        return weekdays[nounCase][m.day()];
                    }
                    function processHoursFunction(str) {
                        return function () {
                            return str + "о" + (this.hours() === 11 ? "б" : "") + "] LT";
                        };
                    }
                    var uk = moment.defineLocale("uk", {
                        months: {
                            format: "січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня".split("_"),
                            standalone: "січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень".split("_"),
                        },
                        monthsShort: "січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд".split("_"),
                        weekdays: weekdaysCaseReplace,
                        weekdaysShort: "нд_пн_вт_ср_чт_пт_сб".split("_"),
                        weekdaysMin: "нд_пн_вт_ср_чт_пт_сб".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY р.", LLL: "D MMMM YYYY р., HH:mm", LLLL: "dddd, D MMMM YYYY р., HH:mm" },
                        calendar: {
                            sameDay: processHoursFunction("[Сьогодні "),
                            nextDay: processHoursFunction("[Завтра "),
                            lastDay: processHoursFunction("[Вчора "),
                            nextWeek: processHoursFunction("[У] dddd ["),
                            lastWeek: function () {
                                switch (this.day()) {
                                    case 0:
                                    case 3:
                                    case 5:
                                    case 6:
                                        return processHoursFunction("[Минулої] dddd [").call(this);
                                    case 1:
                                    case 2:
                                    case 4:
                                        return processHoursFunction("[Минулого] dddd [").call(this);
                                }
                            },
                            sameElse: "L",
                        },
                        relativeTime: {
                            future: "за %s",
                            past: "%s тому",
                            s: "декілька секунд",
                            ss: relativeTimeWithPlural,
                            m: relativeTimeWithPlural,
                            mm: relativeTimeWithPlural,
                            h: "годину",
                            hh: relativeTimeWithPlural,
                            d: "день",
                            dd: relativeTimeWithPlural,
                            M: "місяць",
                            MM: relativeTimeWithPlural,
                            y: "рік",
                            yy: relativeTimeWithPlural,
                        },
                        meridiemParse: /ночі|ранку|дня|вечора/,
                        isPM: function (input) {
                            return /^(дня|вечора)$/.test(input);
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 4) {
                                return "ночі";
                            } else if (hour < 12) {
                                return "ранку";
                            } else if (hour < 17) {
                                return "дня";
                            } else {
                                return "вечора";
                            }
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}-(й|го)/,
                        ordinal: function (number, period) {
                            switch (period) {
                                case "M":
                                case "d":
                                case "DDD":
                                case "w":
                                case "W":
                                    return number + "-й";
                                case "D":
                                    return number + "-го";
                                default:
                                    return number;
                            }
                        },
                        week: { dow: 1, doy: 7 },
                    });
                    return uk;
                });
            },
            "./node_modules/moment/locale/ur.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var months = ["جنوری", "فروری", "مارچ", "اپریل", "مئی", "جون", "جولائی", "اگست", "ستمبر", "اکتوبر", "نومبر", "دسمبر"],
                        days = ["اتوار", "پیر", "منگل", "بدھ", "جمعرات", "جمعہ", "ہفتہ"];
                    var ur = moment.defineLocale("ur", {
                        months: months,
                        monthsShort: months,
                        weekdays: days,
                        weekdaysShort: days,
                        weekdaysMin: days,
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd، D MMMM YYYY HH:mm" },
                        meridiemParse: /صبح|شام/,
                        isPM: function (input) {
                            return "شام" === input;
                        },
                        meridiem: function (hour, minute, isLower) {
                            if (hour < 12) {
                                return "صبح";
                            }
                            return "شام";
                        },
                        calendar: { sameDay: "[آج بوقت] LT", nextDay: "[کل بوقت] LT", nextWeek: "dddd [بوقت] LT", lastDay: "[گذشتہ روز بوقت] LT", lastWeek: "[گذشتہ] dddd [بوقت] LT", sameElse: "L" },
                        relativeTime: {
                            future: "%s بعد",
                            past: "%s قبل",
                            s: "چند سیکنڈ",
                            ss: "%d سیکنڈ",
                            m: "ایک منٹ",
                            mm: "%d منٹ",
                            h: "ایک گھنٹہ",
                            hh: "%d گھنٹے",
                            d: "ایک دن",
                            dd: "%d دن",
                            M: "ایک ماہ",
                            MM: "%d ماہ",
                            y: "ایک سال",
                            yy: "%d سال",
                        },
                        preparse: function (string) {
                            return string.replace(/،/g, ",");
                        },
                        postformat: function (string) {
                            return string.replace(/,/g, "،");
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return ur;
                });
            },
            "./node_modules/moment/locale/uz-latn.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var uzLatn = moment.defineLocale("uz-latn", {
                        months: "Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr".split("_"),
                        monthsShort: "Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek".split("_"),
                        weekdays: "Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba".split("_"),
                        weekdaysShort: "Yak_Dush_Sesh_Chor_Pay_Jum_Shan".split("_"),
                        weekdaysMin: "Ya_Du_Se_Cho_Pa_Ju_Sha".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "D MMMM YYYY, dddd HH:mm" },
                        calendar: { sameDay: "[Bugun soat] LT [da]", nextDay: "[Ertaga] LT [da]", nextWeek: "dddd [kuni soat] LT [da]", lastDay: "[Kecha soat] LT [da]", lastWeek: "[O'tgan] dddd [kuni soat] LT [da]", sameElse: "L" },
                        relativeTime: {
                            future: "Yaqin %s ichida",
                            past: "Bir necha %s oldin",
                            s: "soniya",
                            ss: "%d soniya",
                            m: "bir daqiqa",
                            mm: "%d daqiqa",
                            h: "bir soat",
                            hh: "%d soat",
                            d: "bir kun",
                            dd: "%d kun",
                            M: "bir oy",
                            MM: "%d oy",
                            y: "bir yil",
                            yy: "%d yil",
                        },
                        week: { dow: 1, doy: 7 },
                    });
                    return uzLatn;
                });
            },
            "./node_modules/moment/locale/uz.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var uz = moment.defineLocale("uz", {
                        months: "январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр".split("_"),
                        monthsShort: "янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек".split("_"),
                        weekdays: "Якшанба_Душанба_Сешанба_Чоршанба_Пайшанба_Жума_Шанба".split("_"),
                        weekdaysShort: "Якш_Душ_Сеш_Чор_Пай_Жум_Шан".split("_"),
                        weekdaysMin: "Як_Ду_Се_Чо_Па_Жу_Ша".split("_"),
                        longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "D MMMM YYYY, dddd HH:mm" },
                        calendar: { sameDay: "[Бугун соат] LT [да]", nextDay: "[Эртага] LT [да]", nextWeek: "dddd [куни соат] LT [да]", lastDay: "[Кеча соат] LT [да]", lastWeek: "[Утган] dddd [куни соат] LT [да]", sameElse: "L" },
                        relativeTime: {
                            future: "Якин %s ичида",
                            past: "Бир неча %s олдин",
                            s: "фурсат",
                            ss: "%d фурсат",
                            m: "бир дакика",
                            mm: "%d дакика",
                            h: "бир соат",
                            hh: "%d соат",
                            d: "бир кун",
                            dd: "%d кун",
                            M: "бир ой",
                            MM: "%d ой",
                            y: "бир йил",
                            yy: "%d йил",
                        },
                        week: { dow: 1, doy: 7 },
                    });
                    return uz;
                });
            },
            "./node_modules/moment/locale/vi.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var vi = moment.defineLocale("vi", {
                        months: "tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12".split("_"),
                        monthsShort: "Thg 01_Thg 02_Thg 03_Thg 04_Thg 05_Thg 06_Thg 07_Thg 08_Thg 09_Thg 10_Thg 11_Thg 12".split("_"),
                        monthsParseExact: true,
                        weekdays: "chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy".split("_"),
                        weekdaysShort: "CN_T2_T3_T4_T5_T6_T7".split("_"),
                        weekdaysMin: "CN_T2_T3_T4_T5_T6_T7".split("_"),
                        weekdaysParseExact: true,
                        meridiemParse: /sa|ch/i,
                        isPM: function (input) {
                            return /^ch$/i.test(input);
                        },
                        meridiem: function (hours, minutes, isLower) {
                            if (hours < 12) {
                                return isLower ? "sa" : "SA";
                            } else {
                                return isLower ? "ch" : "CH";
                            }
                        },
                        longDateFormat: {
                            LT: "HH:mm",
                            LTS: "HH:mm:ss",
                            L: "DD/MM/YYYY",
                            LL: "D MMMM [năm] YYYY",
                            LLL: "D MMMM [năm] YYYY HH:mm",
                            LLLL: "dddd, D MMMM [năm] YYYY HH:mm",
                            l: "DD/M/YYYY",
                            ll: "D MMM YYYY",
                            lll: "D MMM YYYY HH:mm",
                            llll: "ddd, D MMM YYYY HH:mm",
                        },
                        calendar: { sameDay: "[Hôm nay lúc] LT", nextDay: "[Ngày mai lúc] LT", nextWeek: "dddd [tuần tới lúc] LT", lastDay: "[Hôm qua lúc] LT", lastWeek: "dddd [tuần trước lúc] LT", sameElse: "L" },
                        relativeTime: {
                            future: "%s tới",
                            past: "%s trước",
                            s: "vài giây",
                            ss: "%d giây",
                            m: "một phút",
                            mm: "%d phút",
                            h: "một giờ",
                            hh: "%d giờ",
                            d: "một ngày",
                            dd: "%d ngày",
                            w: "một tuần",
                            ww: "%d tuần",
                            M: "một tháng",
                            MM: "%d tháng",
                            y: "một năm",
                            yy: "%d năm",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}/,
                        ordinal: function (number) {
                            return number;
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return vi;
                });
            },
            "./node_modules/moment/locale/x-pseudo.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var xPseudo = moment.defineLocale("x-pseudo", {
                        months: "J~áñúá~rý_F~ébrú~árý_~Márc~h_Áp~ríl_~Máý_~Júñé~_Júl~ý_Áú~gúst~_Sép~témb~ér_Ó~ctób~ér_Ñ~óvém~bér_~Décé~mbér".split("_"),
                        monthsShort: "J~áñ_~Féb_~Már_~Ápr_~Máý_~Júñ_~Júl_~Áúg_~Sép_~Óct_~Ñóv_~Déc".split("_"),
                        monthsParseExact: true,
                        weekdays: "S~úñdá~ý_Mó~ñdáý~_Túé~sdáý~_Wéd~ñésd~áý_T~húrs~dáý_~Fríd~áý_S~átúr~dáý".split("_"),
                        weekdaysShort: "S~úñ_~Móñ_~Túé_~Wéd_~Thú_~Frí_~Sát".split("_"),
                        weekdaysMin: "S~ú_Mó~_Tú_~Wé_T~h_Fr~_Sá".split("_"),
                        weekdaysParseExact: true,
                        longDateFormat: { LT: "HH:mm", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" },
                        calendar: { sameDay: "[T~ódá~ý át] LT", nextDay: "[T~ómó~rró~w át] LT", nextWeek: "dddd [át] LT", lastDay: "[Ý~ést~érdá~ý át] LT", lastWeek: "[L~ást] dddd [át] LT", sameElse: "L" },
                        relativeTime: {
                            future: "í~ñ %s",
                            past: "%s á~gó",
                            s: "á ~féw ~sécó~ñds",
                            ss: "%d s~écóñ~ds",
                            m: "á ~míñ~úté",
                            mm: "%d m~íñú~tés",
                            h: "á~ñ hó~úr",
                            hh: "%d h~óúrs",
                            d: "á ~dáý",
                            dd: "%d d~áýs",
                            M: "á ~móñ~th",
                            MM: "%d m~óñt~hs",
                            y: "á ~ýéár",
                            yy: "%d ý~éárs",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
                        ordinal: function (number) {
                            var b = number % 10,
                                output = ~~((number % 100) / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
                            return number + output;
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return xPseudo;
                });
            },
            "./node_modules/moment/locale/yo.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var yo = moment.defineLocale("yo", {
                        months: "Sẹ́rẹ́_Èrèlè_Ẹrẹ̀nà_Ìgbé_Èbibi_Òkùdu_Agẹmo_Ògún_Owewe_Ọ̀wàrà_Bélú_Ọ̀pẹ̀̀".split("_"),
                        monthsShort: "Sẹ́r_Èrl_Ẹrn_Ìgb_Èbi_Òkù_Agẹ_Ògú_Owe_Ọ̀wà_Bél_Ọ̀pẹ̀̀".split("_"),
                        weekdays: "Àìkú_Ajé_Ìsẹ́gun_Ọjọ́rú_Ọjọ́bọ_Ẹtì_Àbámẹ́ta".split("_"),
                        weekdaysShort: "Àìk_Ajé_Ìsẹ́_Ọjr_Ọjb_Ẹtì_Àbá".split("_"),
                        weekdaysMin: "Àì_Aj_Ìs_Ọr_Ọb_Ẹt_Àb".split("_"),
                        longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" },
                        calendar: { sameDay: "[Ònì ni] LT", nextDay: "[Ọ̀la ni] LT", nextWeek: "dddd [Ọsẹ̀ tón'bọ] [ni] LT", lastDay: "[Àna ni] LT", lastWeek: "dddd [Ọsẹ̀ tólọ́] [ni] LT", sameElse: "L" },
                        relativeTime: {
                            future: "ní %s",
                            past: "%s kọjá",
                            s: "ìsẹjú aayá die",
                            ss: "aayá %d",
                            m: "ìsẹjú kan",
                            mm: "ìsẹjú %d",
                            h: "wákati kan",
                            hh: "wákati %d",
                            d: "ọjọ́ kan",
                            dd: "ọjọ́ %d",
                            M: "osù kan",
                            MM: "osù %d",
                            y: "ọdún kan",
                            yy: "ọdún %d",
                        },
                        dayOfMonthOrdinalParse: /ọjọ́\s\d{1,2}/,
                        ordinal: "ọjọ́ %d",
                        week: { dow: 1, doy: 4 },
                    });
                    return yo;
                });
            },
            "./node_modules/moment/locale/zh-cn.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var zhCn = moment.defineLocale("zh-cn", {
                        months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),
                        monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
                        weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),
                        weekdaysShort: "周日_周一_周二_周三_周四_周五_周六".split("_"),
                        weekdaysMin: "日_一_二_三_四_五_六".split("_"),
                        longDateFormat: {
                            LT: "HH:mm",
                            LTS: "HH:mm:ss",
                            L: "YYYY/MM/DD",
                            LL: "YYYY年M月D日",
                            LLL: "YYYY年M月D日Ah点mm分",
                            LLLL: "YYYY年M月D日ddddAh点mm分",
                            l: "YYYY/M/D",
                            ll: "YYYY年M月D日",
                            lll: "YYYY年M月D日 HH:mm",
                            llll: "YYYY年M月D日dddd HH:mm",
                        },
                        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
                        meridiemHour: function (hour, meridiem) {
                            if (hour === 12) {
                                hour = 0;
                            }
                            if (meridiem === "凌晨" || meridiem === "早上" || meridiem === "上午") {
                                return hour;
                            } else if (meridiem === "下午" || meridiem === "晚上") {
                                return hour + 12;
                            } else {
                                return hour >= 11 ? hour : hour + 12;
                            }
                        },
                        meridiem: function (hour, minute, isLower) {
                            var hm = hour * 100 + minute;
                            if (hm < 600) {
                                return "凌晨";
                            } else if (hm < 900) {
                                return "早上";
                            } else if (hm < 1130) {
                                return "上午";
                            } else if (hm < 1230) {
                                return "中午";
                            } else if (hm < 1800) {
                                return "下午";
                            } else {
                                return "晚上";
                            }
                        },
                        calendar: {
                            sameDay: "[今天]LT",
                            nextDay: "[明天]LT",
                            nextWeek: function (now) {
                                if (now.week() !== this.week()) {
                                    return "[下]dddLT";
                                } else {
                                    return "[本]dddLT";
                                }
                            },
                            lastDay: "[昨天]LT",
                            lastWeek: function (now) {
                                if (this.week() !== now.week()) {
                                    return "[上]dddLT";
                                } else {
                                    return "[本]dddLT";
                                }
                            },
                            sameElse: "L",
                        },
                        dayOfMonthOrdinalParse: /\d{1,2}(日|月|周)/,
                        ordinal: function (number, period) {
                            switch (period) {
                                case "d":
                                case "D":
                                case "DDD":
                                    return number + "日";
                                case "M":
                                    return number + "月";
                                case "w":
                                case "W":
                                    return number + "周";
                                default:
                                    return number;
                            }
                        },
                        relativeTime: {
                            future: "%s后",
                            past: "%s前",
                            s: "几秒",
                            ss: "%d 秒",
                            m: "1 分钟",
                            mm: "%d 分钟",
                            h: "1 小时",
                            hh: "%d 小时",
                            d: "1 天",
                            dd: "%d 天",
                            w: "1 周",
                            ww: "%d 周",
                            M: "1 个月",
                            MM: "%d 个月",
                            y: "1 年",
                            yy: "%d 年",
                        },
                        week: { dow: 1, doy: 4 },
                    });
                    return zhCn;
                });
            },
            "./node_modules/moment/locale/zh-hk.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var zhHk = moment.defineLocale("zh-hk", {
                        months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),
                        monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
                        weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),
                        weekdaysShort: "週日_週一_週二_週三_週四_週五_週六".split("_"),
                        weekdaysMin: "日_一_二_三_四_五_六".split("_"),
                        longDateFormat: {
                            LT: "HH:mm",
                            LTS: "HH:mm:ss",
                            L: "YYYY/MM/DD",
                            LL: "YYYY年M月D日",
                            LLL: "YYYY年M月D日 HH:mm",
                            LLLL: "YYYY年M月D日dddd HH:mm",
                            l: "YYYY/M/D",
                            ll: "YYYY年M月D日",
                            lll: "YYYY年M月D日 HH:mm",
                            llll: "YYYY年M月D日dddd HH:mm",
                        },
                        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
                        meridiemHour: function (hour, meridiem) {
                            if (hour === 12) {
                                hour = 0;
                            }
                            if (meridiem === "凌晨" || meridiem === "早上" || meridiem === "上午") {
                                return hour;
                            } else if (meridiem === "中午") {
                                return hour >= 11 ? hour : hour + 12;
                            } else if (meridiem === "下午" || meridiem === "晚上") {
                                return hour + 12;
                            }
                        },
                        meridiem: function (hour, minute, isLower) {
                            var hm = hour * 100 + minute;
                            if (hm < 600) {
                                return "凌晨";
                            } else if (hm < 900) {
                                return "早上";
                            } else if (hm < 1200) {
                                return "上午";
                            } else if (hm === 1200) {
                                return "中午";
                            } else if (hm < 1800) {
                                return "下午";
                            } else {
                                return "晚上";
                            }
                        },
                        calendar: { sameDay: "[今天]LT", nextDay: "[明天]LT", nextWeek: "[下]ddddLT", lastDay: "[昨天]LT", lastWeek: "[上]ddddLT", sameElse: "L" },
                        dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
                        ordinal: function (number, period) {
                            switch (period) {
                                case "d":
                                case "D":
                                case "DDD":
                                    return number + "日";
                                case "M":
                                    return number + "月";
                                case "w":
                                case "W":
                                    return number + "週";
                                default:
                                    return number;
                            }
                        },
                        relativeTime: { future: "%s後", past: "%s前", s: "幾秒", ss: "%d 秒", m: "1 分鐘", mm: "%d 分鐘", h: "1 小時", hh: "%d 小時", d: "1 天", dd: "%d 天", M: "1 個月", MM: "%d 個月", y: "1 年", yy: "%d 年" },
                    });
                    return zhHk;
                });
            },
            "./node_modules/moment/locale/zh-mo.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var zhMo = moment.defineLocale("zh-mo", {
                        months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),
                        monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
                        weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),
                        weekdaysShort: "週日_週一_週二_週三_週四_週五_週六".split("_"),
                        weekdaysMin: "日_一_二_三_四_五_六".split("_"),
                        longDateFormat: {
                            LT: "HH:mm",
                            LTS: "HH:mm:ss",
                            L: "DD/MM/YYYY",
                            LL: "YYYY年M月D日",
                            LLL: "YYYY年M月D日 HH:mm",
                            LLLL: "YYYY年M月D日dddd HH:mm",
                            l: "D/M/YYYY",
                            ll: "YYYY年M月D日",
                            lll: "YYYY年M月D日 HH:mm",
                            llll: "YYYY年M月D日dddd HH:mm",
                        },
                        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
                        meridiemHour: function (hour, meridiem) {
                            if (hour === 12) {
                                hour = 0;
                            }
                            if (meridiem === "凌晨" || meridiem === "早上" || meridiem === "上午") {
                                return hour;
                            } else if (meridiem === "中午") {
                                return hour >= 11 ? hour : hour + 12;
                            } else if (meridiem === "下午" || meridiem === "晚上") {
                                return hour + 12;
                            }
                        },
                        meridiem: function (hour, minute, isLower) {
                            var hm = hour * 100 + minute;
                            if (hm < 600) {
                                return "凌晨";
                            } else if (hm < 900) {
                                return "早上";
                            } else if (hm < 1130) {
                                return "上午";
                            } else if (hm < 1230) {
                                return "中午";
                            } else if (hm < 1800) {
                                return "下午";
                            } else {
                                return "晚上";
                            }
                        },
                        calendar: { sameDay: "[今天] LT", nextDay: "[明天] LT", nextWeek: "[下]dddd LT", lastDay: "[昨天] LT", lastWeek: "[上]dddd LT", sameElse: "L" },
                        dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
                        ordinal: function (number, period) {
                            switch (period) {
                                case "d":
                                case "D":
                                case "DDD":
                                    return number + "日";
                                case "M":
                                    return number + "月";
                                case "w":
                                case "W":
                                    return number + "週";
                                default:
                                    return number;
                            }
                        },
                        relativeTime: { future: "%s內", past: "%s前", s: "幾秒", ss: "%d 秒", m: "1 分鐘", mm: "%d 分鐘", h: "1 小時", hh: "%d 小時", d: "1 天", dd: "%d 天", M: "1 個月", MM: "%d 個月", y: "1 年", yy: "%d 年" },
                    });
                    return zhMo;
                });
            },
            "./node_modules/moment/locale/zh-tw.js": function (module, exports, __webpack_require__) {
                (function (global, factory) {
                    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) : undefined;
                })(this, function (moment) {
                    "use strict";
                    var zhTw = moment.defineLocale("zh-tw", {
                        months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),
                        monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
                        weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),
                        weekdaysShort: "週日_週一_週二_週三_週四_週五_週六".split("_"),
                        weekdaysMin: "日_一_二_三_四_五_六".split("_"),
                        longDateFormat: {
                            LT: "HH:mm",
                            LTS: "HH:mm:ss",
                            L: "YYYY/MM/DD",
                            LL: "YYYY年M月D日",
                            LLL: "YYYY年M月D日 HH:mm",
                            LLLL: "YYYY年M月D日dddd HH:mm",
                            l: "YYYY/M/D",
                            ll: "YYYY年M月D日",
                            lll: "YYYY年M月D日 HH:mm",
                            llll: "YYYY年M月D日dddd HH:mm",
                        },
                        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
                        meridiemHour: function (hour, meridiem) {
                            if (hour === 12) {
                                hour = 0;
                            }
                            if (meridiem === "凌晨" || meridiem === "早上" || meridiem === "上午") {
                                return hour;
                            } else if (meridiem === "中午") {
                                return hour >= 11 ? hour : hour + 12;
                            } else if (meridiem === "下午" || meridiem === "晚上") {
                                return hour + 12;
                            }
                        },
                        meridiem: function (hour, minute, isLower) {
                            var hm = hour * 100 + minute;
                            if (hm < 600) {
                                return "凌晨";
                            } else if (hm < 900) {
                                return "早上";
                            } else if (hm < 1130) {
                                return "上午";
                            } else if (hm < 1230) {
                                return "中午";
                            } else if (hm < 1800) {
                                return "下午";
                            } else {
                                return "晚上";
                            }
                        },
                        calendar: { sameDay: "[今天] LT", nextDay: "[明天] LT", nextWeek: "[下]dddd LT", lastDay: "[昨天] LT", lastWeek: "[上]dddd LT", sameElse: "L" },
                        dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
                        ordinal: function (number, period) {
                            switch (period) {
                                case "d":
                                case "D":
                                case "DDD":
                                    return number + "日";
                                case "M":
                                    return number + "月";
                                case "w":
                                case "W":
                                    return number + "週";
                                default:
                                    return number;
                            }
                        },
                        relativeTime: { future: "%s後", past: "%s前", s: "幾秒", ss: "%d 秒", m: "1 分鐘", mm: "%d 分鐘", h: "1 小時", hh: "%d 小時", d: "1 天", dd: "%d 天", M: "1 個月", MM: "%d 個月", y: "1 年", yy: "%d 年" },
                    });
                    return zhTw;
                });
            },
            "./node_modules/moment/moment.js": function (module, exports, __webpack_require__) {
                (function (module) {
                    var require;
                    (function (global, factory) {
                        true ? (module.exports = factory()) : undefined;
                    })(this, function () {
                        "use strict";
                        var hookCallback;
                        function hooks() {
                            return hookCallback.apply(null, arguments);
                        }
                        function setHookCallback(callback) {
                            hookCallback = callback;
                        }
                        function isArray(input) {
                            return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
                        }
                        function isObject(input) {
                            return input != null && Object.prototype.toString.call(input) === "[object Object]";
                        }
                        function hasOwnProp(a, b) {
                            return Object.prototype.hasOwnProperty.call(a, b);
                        }
                        function isObjectEmpty(obj) {
                            if (Object.getOwnPropertyNames) {
                                return Object.getOwnPropertyNames(obj).length === 0;
                            } else {
                                var k;
                                for (k in obj) {
                                    if (hasOwnProp(obj, k)) {
                                        return false;
                                    }
                                }
                                return true;
                            }
                        }
                        function isUndefined(input) {
                            return input === void 0;
                        }
                        function isNumber(input) {
                            return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
                        }
                        function isDate(input) {
                            return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
                        }
                        function map(arr, fn) {
                            var res = [],
                                i,
                                arrLen = arr.length;
                            for (i = 0; i < arrLen; ++i) {
                                res.push(fn(arr[i], i));
                            }
                            return res;
                        }
                        function extend(a, b) {
                            for (var i in b) {
                                if (hasOwnProp(b, i)) {
                                    a[i] = b[i];
                                }
                            }
                            if (hasOwnProp(b, "toString")) {
                                a.toString = b.toString;
                            }
                            if (hasOwnProp(b, "valueOf")) {
                                a.valueOf = b.valueOf;
                            }
                            return a;
                        }
                        function createUTC(input, format, locale, strict) {
                            return createLocalOrUTC(input, format, locale, strict, true).utc();
                        }
                        function defaultParsingFlags() {
                            return {
                                empty: false,
                                unusedTokens: [],
                                unusedInput: [],
                                overflow: -2,
                                charsLeftOver: 0,
                                nullInput: false,
                                invalidEra: null,
                                invalidMonth: null,
                                invalidFormat: false,
                                userInvalidated: false,
                                iso: false,
                                parsedDateParts: [],
                                era: null,
                                meridiem: null,
                                rfc2822: false,
                                weekdayMismatch: false,
                            };
                        }
                        function getParsingFlags(m) {
                            if (m._pf == null) {
                                m._pf = defaultParsingFlags();
                            }
                            return m._pf;
                        }
                        var some;
                        if (Array.prototype.some) {
                            some = Array.prototype.some;
                        } else {
                            some = function (fun) {
                                var t = Object(this),
                                    len = t.length >>> 0,
                                    i;
                                for (i = 0; i < len; i++) {
                                    if (i in t && fun.call(this, t[i], i, t)) {
                                        return true;
                                    }
                                }
                                return false;
                            };
                        }
                        function isValid(m) {
                            if (m._isValid == null) {
                                var flags = getParsingFlags(m),
                                    parsedParts = some.call(flags.parsedDateParts, function (i) {
                                        return i != null;
                                    }),
                                    isNowValid =
                                        !isNaN(m._d.getTime()) &&
                                        flags.overflow < 0 &&
                                        !flags.empty &&
                                        !flags.invalidEra &&
                                        !flags.invalidMonth &&
                                        !flags.invalidWeekday &&
                                        !flags.weekdayMismatch &&
                                        !flags.nullInput &&
                                        !flags.invalidFormat &&
                                        !flags.userInvalidated &&
                                        (!flags.meridiem || (flags.meridiem && parsedParts));
                                if (m._strict) {
                                    isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
                                }
                                if (Object.isFrozen == null || !Object.isFrozen(m)) {
                                    m._isValid = isNowValid;
                                } else {
                                    return isNowValid;
                                }
                            }
                            return m._isValid;
                        }
                        function createInvalid(flags) {
                            var m = createUTC(NaN);
                            if (flags != null) {
                                extend(getParsingFlags(m), flags);
                            } else {
                                getParsingFlags(m).userInvalidated = true;
                            }
                            return m;
                        }
                        var momentProperties = (hooks.momentProperties = []),
                            updateInProgress = false;
                        function copyConfig(to, from) {
                            var i,
                                prop,
                                val,
                                momentPropertiesLen = momentProperties.length;
                            if (!isUndefined(from._isAMomentObject)) {
                                to._isAMomentObject = from._isAMomentObject;
                            }
                            if (!isUndefined(from._i)) {
                                to._i = from._i;
                            }
                            if (!isUndefined(from._f)) {
                                to._f = from._f;
                            }
                            if (!isUndefined(from._l)) {
                                to._l = from._l;
                            }
                            if (!isUndefined(from._strict)) {
                                to._strict = from._strict;
                            }
                            if (!isUndefined(from._tzm)) {
                                to._tzm = from._tzm;
                            }
                            if (!isUndefined(from._isUTC)) {
                                to._isUTC = from._isUTC;
                            }
                            if (!isUndefined(from._offset)) {
                                to._offset = from._offset;
                            }
                            if (!isUndefined(from._pf)) {
                                to._pf = getParsingFlags(from);
                            }
                            if (!isUndefined(from._locale)) {
                                to._locale = from._locale;
                            }
                            if (momentPropertiesLen > 0) {
                                for (i = 0; i < momentPropertiesLen; i++) {
                                    prop = momentProperties[i];
                                    val = from[prop];
                                    if (!isUndefined(val)) {
                                        to[prop] = val;
                                    }
                                }
                            }
                            return to;
                        }
                        function Moment(config) {
                            copyConfig(this, config);
                            this._d = new Date(config._d != null ? config._d.getTime() : NaN);
                            if (!this.isValid()) {
                                this._d = new Date(NaN);
                            }
                            if (updateInProgress === false) {
                                updateInProgress = true;
                                hooks.updateOffset(this);
                                updateInProgress = false;
                            }
                        }
                        function isMoment(obj) {
                            return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
                        }
                        function warn(msg) {
                            if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
                                console.warn("Deprecation warning: " + msg);
                            }
                        }
                        function deprecate(msg, fn) {
                            var firstTime = true;
                            return extend(function () {
                                if (hooks.deprecationHandler != null) {
                                    hooks.deprecationHandler(null, msg);
                                }
                                if (firstTime) {
                                    var args = [],
                                        arg,
                                        i,
                                        key,
                                        argLen = arguments.length;
                                    for (i = 0; i < argLen; i++) {
                                        arg = "";
                                        if (typeof arguments[i] === "object") {
                                            arg += "\n[" + i + "] ";
                                            for (key in arguments[0]) {
                                                if (hasOwnProp(arguments[0], key)) {
                                                    arg += key + ": " + arguments[0][key] + ", ";
                                                }
                                            }
                                            arg = arg.slice(0, -2);
                                        } else {
                                            arg = arguments[i];
                                        }
                                        args.push(arg);
                                    }
                                    warn(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack);
                                    firstTime = false;
                                }
                                return fn.apply(this, arguments);
                            }, fn);
                        }
                        var deprecations = {};
                        function deprecateSimple(name, msg) {
                            if (hooks.deprecationHandler != null) {
                                hooks.deprecationHandler(name, msg);
                            }
                            if (!deprecations[name]) {
                                warn(msg);
                                deprecations[name] = true;
                            }
                        }
                        hooks.suppressDeprecationWarnings = false;
                        hooks.deprecationHandler = null;
                        function isFunction(input) {
                            return (typeof Function !== "undefined" && input instanceof Function) || Object.prototype.toString.call(input) === "[object Function]";
                        }
                        function set(config) {
                            var prop, i;
                            for (i in config) {
                                if (hasOwnProp(config, i)) {
                                    prop = config[i];
                                    if (isFunction(prop)) {
                                        this[i] = prop;
                                    } else {
                                        this["_" + i] = prop;
                                    }
                                }
                            }
                            this._config = config;
                            this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
                        }
                        function mergeConfigs(parentConfig, childConfig) {
                            var res = extend({}, parentConfig),
                                prop;
                            for (prop in childConfig) {
                                if (hasOwnProp(childConfig, prop)) {
                                    if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                                        res[prop] = {};
                                        extend(res[prop], parentConfig[prop]);
                                        extend(res[prop], childConfig[prop]);
                                    } else if (childConfig[prop] != null) {
                                        res[prop] = childConfig[prop];
                                    } else {
                                        delete res[prop];
                                    }
                                }
                            }
                            for (prop in parentConfig) {
                                if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
                                    res[prop] = extend({}, res[prop]);
                                }
                            }
                            return res;
                        }
                        function Locale(config) {
                            if (config != null) {
                                this.set(config);
                            }
                        }
                        var keys;
                        if (Object.keys) {
                            keys = Object.keys;
                        } else {
                            keys = function (obj) {
                                var i,
                                    res = [];
                                for (i in obj) {
                                    if (hasOwnProp(obj, i)) {
                                        res.push(i);
                                    }
                                }
                                return res;
                            };
                        }
                        var defaultCalendar = { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" };
                        function calendar(key, mom, now) {
                            var output = this._calendar[key] || this._calendar["sameElse"];
                            return isFunction(output) ? output.call(mom, now) : output;
                        }
                        function zeroFill(number, targetLength, forceSign) {
                            var absNumber = "" + Math.abs(number),
                                zerosToFill = targetLength - absNumber.length,
                                sign = number >= 0;
                            return (sign ? (forceSign ? "+" : "") : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
                        }
                        var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
                            localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
                            formatFunctions = {},
                            formatTokenFunctions = {};
                        function addFormatToken(token, padded, ordinal, callback) {
                            var func = callback;
                            if (typeof callback === "string") {
                                func = function () {
                                    return this[callback]();
                                };
                            }
                            if (token) {
                                formatTokenFunctions[token] = func;
                            }
                            if (padded) {
                                formatTokenFunctions[padded[0]] = function () {
                                    return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
                                };
                            }
                            if (ordinal) {
                                formatTokenFunctions[ordinal] = function () {
                                    return this.localeData().ordinal(func.apply(this, arguments), token);
                                };
                            }
                        }
                        function removeFormattingTokens(input) {
                            if (input.match(/\[[\s\S]/)) {
                                return input.replace(/^\[|\]$/g, "");
                            }
                            return input.replace(/\\/g, "");
                        }
                        function makeFormatFunction(format) {
                            var array = format.match(formattingTokens),
                                i,
                                length;
                            for (i = 0, length = array.length; i < length; i++) {
                                if (formatTokenFunctions[array[i]]) {
                                    array[i] = formatTokenFunctions[array[i]];
                                } else {
                                    array[i] = removeFormattingTokens(array[i]);
                                }
                            }
                            return function (mom) {
                                var output = "",
                                    i;
                                for (i = 0; i < length; i++) {
                                    output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
                                }
                                return output;
                            };
                        }
                        function formatMoment(m, format) {
                            if (!m.isValid()) {
                                return m.localeData().invalidDate();
                            }
                            format = expandFormat(format, m.localeData());
                            formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
                            return formatFunctions[format](m);
                        }
                        function expandFormat(format, locale) {
                            var i = 5;
                            function replaceLongDateFormatTokens(input) {
                                return locale.longDateFormat(input) || input;
                            }
                            localFormattingTokens.lastIndex = 0;
                            while (i >= 0 && localFormattingTokens.test(format)) {
                                format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
                                localFormattingTokens.lastIndex = 0;
                                i -= 1;
                            }
                            return format;
                        }
                        var defaultLongDateFormat = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" };
                        function longDateFormat(key) {
                            var format = this._longDateFormat[key],
                                formatUpper = this._longDateFormat[key.toUpperCase()];
                            if (format || !formatUpper) {
                                return format;
                            }
                            this._longDateFormat[key] = formatUpper
                                .match(formattingTokens)
                                .map(function (tok) {
                                    if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
                                        return tok.slice(1);
                                    }
                                    return tok;
                                })
                                .join("");
                            return this._longDateFormat[key];
                        }
                        var defaultInvalidDate = "Invalid date";
                        function invalidDate() {
                            return this._invalidDate;
                        }
                        var defaultOrdinal = "%d",
                            defaultDayOfMonthOrdinalParse = /\d{1,2}/;
                        function ordinal(number) {
                            return this._ordinal.replace("%d", number);
                        }
                        var defaultRelativeTime = {
                            future: "in %s",
                            past: "%s ago",
                            s: "a few seconds",
                            ss: "%d seconds",
                            m: "a minute",
                            mm: "%d minutes",
                            h: "an hour",
                            hh: "%d hours",
                            d: "a day",
                            dd: "%d days",
                            w: "a week",
                            ww: "%d weeks",
                            M: "a month",
                            MM: "%d months",
                            y: "a year",
                            yy: "%d years",
                        };
                        function relativeTime(number, withoutSuffix, string, isFuture) {
                            var output = this._relativeTime[string];
                            return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
                        }
                        function pastFuture(diff, output) {
                            var format = this._relativeTime[diff > 0 ? "future" : "past"];
                            return isFunction(format) ? format(output) : format.replace(/%s/i, output);
                        }
                        var aliases = {};
                        function addUnitAlias(unit, shorthand) {
                            var lowerCase = unit.toLowerCase();
                            aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
                        }
                        function normalizeUnits(units) {
                            return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : undefined;
                        }
                        function normalizeObjectUnits(inputObject) {
                            var normalizedInput = {},
                                normalizedProp,
                                prop;
                            for (prop in inputObject) {
                                if (hasOwnProp(inputObject, prop)) {
                                    normalizedProp = normalizeUnits(prop);
                                    if (normalizedProp) {
                                        normalizedInput[normalizedProp] = inputObject[prop];
                                    }
                                }
                            }
                            return normalizedInput;
                        }
                        var priorities = {};
                        function addUnitPriority(unit, priority) {
                            priorities[unit] = priority;
                        }
                        function getPrioritizedUnits(unitsObj) {
                            var units = [],
                                u;
                            for (u in unitsObj) {
                                if (hasOwnProp(unitsObj, u)) {
                                    units.push({ unit: u, priority: priorities[u] });
                                }
                            }
                            units.sort(function (a, b) {
                                return a.priority - b.priority;
                            });
                            return units;
                        }
                        function isLeapYear(year) {
                            return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
                        }
                        function absFloor(number) {
                            if (number < 0) {
                                return Math.ceil(number) || 0;
                            } else {
                                return Math.floor(number);
                            }
                        }
                        function toInt(argumentForCoercion) {
                            var coercedNumber = +argumentForCoercion,
                                value = 0;
                            if (coercedNumber !== 0 && isFinite(coercedNumber)) {
                                value = absFloor(coercedNumber);
                            }
                            return value;
                        }
                        function makeGetSet(unit, keepTime) {
                            return function (value) {
                                if (value != null) {
                                    set$1(this, unit, value);
                                    hooks.updateOffset(this, keepTime);
                                    return this;
                                } else {
                                    return get(this, unit);
                                }
                            };
                        }
                        function get(mom, unit) {
                            return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
                        }
                        function set$1(mom, unit, value) {
                            if (mom.isValid() && !isNaN(value)) {
                                if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                                    value = toInt(value);
                                    mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value, mom.month(), daysInMonth(value, mom.month()));
                                } else {
                                    mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
                                }
                            }
                        }
                        function stringGet(units) {
                            units = normalizeUnits(units);
                            if (isFunction(this[units])) {
                                return this[units]();
                            }
                            return this;
                        }
                        function stringSet(units, value) {
                            if (typeof units === "object") {
                                units = normalizeObjectUnits(units);
                                var prioritized = getPrioritizedUnits(units),
                                    i,
                                    prioritizedLen = prioritized.length;
                                for (i = 0; i < prioritizedLen; i++) {
                                    this[prioritized[i].unit](units[prioritized[i].unit]);
                                }
                            } else {
                                units = normalizeUnits(units);
                                if (isFunction(this[units])) {
                                    return this[units](value);
                                }
                            }
                            return this;
                        }
                        var match1 = /\d/,
                            match2 = /\d\d/,
                            match3 = /\d{3}/,
                            match4 = /\d{4}/,
                            match6 = /[+-]?\d{6}/,
                            match1to2 = /\d\d?/,
                            match3to4 = /\d\d\d\d?/,
                            match5to6 = /\d\d\d\d\d\d?/,
                            match1to3 = /\d{1,3}/,
                            match1to4 = /\d{1,4}/,
                            match1to6 = /[+-]?\d{1,6}/,
                            matchUnsigned = /\d+/,
                            matchSigned = /[+-]?\d+/,
                            matchOffset = /Z|[+-]\d\d:?\d\d/gi,
                            matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi,
                            matchTimestamp = /[+-]?\d+(\.\d{1,3})?/,
                            matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
                            regexes;
                        regexes = {};
                        function addRegexToken(token, regex, strictRegex) {
                            regexes[token] = isFunction(regex)
                                ? regex
                                : function (isStrict, localeData) {
                                      return isStrict && strictRegex ? strictRegex : regex;
                                  };
                        }
                        function getParseRegexForToken(token, config) {
                            if (!hasOwnProp(regexes, token)) {
                                return new RegExp(unescapeFormat(token));
                            }
                            return regexes[token](config._strict, config._locale);
                        }
                        function unescapeFormat(s) {
                            return regexEscape(
                                s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
                                    return p1 || p2 || p3 || p4;
                                })
                            );
                        }
                        function regexEscape(s) {
                            return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
                        }
                        var tokens = {};
                        function addParseToken(token, callback) {
                            var i,
                                func = callback,
                                tokenLen;
                            if (typeof token === "string") {
                                token = [token];
                            }
                            if (isNumber(callback)) {
                                func = function (input, array) {
                                    array[callback] = toInt(input);
                                };
                            }
                            tokenLen = token.length;
                            for (i = 0; i < tokenLen; i++) {
                                tokens[token[i]] = func;
                            }
                        }
                        function addWeekParseToken(token, callback) {
                            addParseToken(token, function (input, array, config, token) {
                                config._w = config._w || {};
                                callback(input, config._w, config, token);
                            });
                        }
                        function addTimeToArrayFromToken(token, input, config) {
                            if (input != null && hasOwnProp(tokens, token)) {
                                tokens[token](input, config._a, config, token);
                            }
                        }
                        var YEAR = 0,
                            MONTH = 1,
                            DATE = 2,
                            HOUR = 3,
                            MINUTE = 4,
                            SECOND = 5,
                            MILLISECOND = 6,
                            WEEK = 7,
                            WEEKDAY = 8;
                        function mod(n, x) {
                            return ((n % x) + x) % x;
                        }
                        var indexOf;
                        if (Array.prototype.indexOf) {
                            indexOf = Array.prototype.indexOf;
                        } else {
                            indexOf = function (o) {
                                var i;
                                for (i = 0; i < this.length; ++i) {
                                    if (this[i] === o) {
                                        return i;
                                    }
                                }
                                return -1;
                            };
                        }
                        function daysInMonth(year, month) {
                            if (isNaN(year) || isNaN(month)) {
                                return NaN;
                            }
                            var modMonth = mod(month, 12);
                            year += (month - modMonth) / 12;
                            return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : 31 - ((modMonth % 7) % 2);
                        }
                        addFormatToken("M", ["MM", 2], "Mo", function () {
                            return this.month() + 1;
                        });
                        addFormatToken("MMM", 0, 0, function (format) {
                            return this.localeData().monthsShort(this, format);
                        });
                        addFormatToken("MMMM", 0, 0, function (format) {
                            return this.localeData().months(this, format);
                        });
                        addUnitAlias("month", "M");
                        addUnitPriority("month", 8);
                        addRegexToken("M", match1to2);
                        addRegexToken("MM", match1to2, match2);
                        addRegexToken("MMM", function (isStrict, locale) {
                            return locale.monthsShortRegex(isStrict);
                        });
                        addRegexToken("MMMM", function (isStrict, locale) {
                            return locale.monthsRegex(isStrict);
                        });
                        addParseToken(["M", "MM"], function (input, array) {
                            array[MONTH] = toInt(input) - 1;
                        });
                        addParseToken(["MMM", "MMMM"], function (input, array, config, token) {
                            var month = config._locale.monthsParse(input, token, config._strict);
                            if (month != null) {
                                array[MONTH] = month;
                            } else {
                                getParsingFlags(config).invalidMonth = input;
                            }
                        });
                        var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                            defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
                            MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
                            defaultMonthsShortRegex = matchWord,
                            defaultMonthsRegex = matchWord;
                        function localeMonths(m, format) {
                            if (!m) {
                                return isArray(this._months) ? this._months : this._months["standalone"];
                            }
                            return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? "format" : "standalone"][m.month()];
                        }
                        function localeMonthsShort(m, format) {
                            if (!m) {
                                return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
                            }
                            return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? "format" : "standalone"][m.month()];
                        }
                        function handleStrictParse(monthName, format, strict) {
                            var i,
                                ii,
                                mom,
                                llc = monthName.toLocaleLowerCase();
                            if (!this._monthsParse) {
                                this._monthsParse = [];
                                this._longMonthsParse = [];
                                this._shortMonthsParse = [];
                                for (i = 0; i < 12; ++i) {
                                    mom = createUTC([2e3, i]);
                                    this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase();
                                    this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
                                }
                            }
                            if (strict) {
                                if (format === "MMM") {
                                    ii = indexOf.call(this._shortMonthsParse, llc);
                                    return ii !== -1 ? ii : null;
                                } else {
                                    ii = indexOf.call(this._longMonthsParse, llc);
                                    return ii !== -1 ? ii : null;
                                }
                            } else {
                                if (format === "MMM") {
                                    ii = indexOf.call(this._shortMonthsParse, llc);
                                    if (ii !== -1) {
                                        return ii;
                                    }
                                    ii = indexOf.call(this._longMonthsParse, llc);
                                    return ii !== -1 ? ii : null;
                                } else {
                                    ii = indexOf.call(this._longMonthsParse, llc);
                                    if (ii !== -1) {
                                        return ii;
                                    }
                                    ii = indexOf.call(this._shortMonthsParse, llc);
                                    return ii !== -1 ? ii : null;
                                }
                            }
                        }
                        function localeMonthsParse(monthName, format, strict) {
                            var i, mom, regex;
                            if (this._monthsParseExact) {
                                return handleStrictParse.call(this, monthName, format, strict);
                            }
                            if (!this._monthsParse) {
                                this._monthsParse = [];
                                this._longMonthsParse = [];
                                this._shortMonthsParse = [];
                            }
                            for (i = 0; i < 12; i++) {
                                mom = createUTC([2e3, i]);
                                if (strict && !this._longMonthsParse[i]) {
                                    this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
                                    this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
                                }
                                if (!strict && !this._monthsParse[i]) {
                                    regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
                                    this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
                                }
                                if (strict && format === "MMMM" && this._longMonthsParse[i].test(monthName)) {
                                    return i;
                                } else if (strict && format === "MMM" && this._shortMonthsParse[i].test(monthName)) {
                                    return i;
                                } else if (!strict && this._monthsParse[i].test(monthName)) {
                                    return i;
                                }
                            }
                        }
                        function setMonth(mom, value) {
                            var dayOfMonth;
                            if (!mom.isValid()) {
                                return mom;
                            }
                            if (typeof value === "string") {
                                if (/^\d+$/.test(value)) {
                                    value = toInt(value);
                                } else {
                                    value = mom.localeData().monthsParse(value);
                                    if (!isNumber(value)) {
                                        return mom;
                                    }
                                }
                            }
                            dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
                            mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
                            return mom;
                        }
                        function getSetMonth(value) {
                            if (value != null) {
                                setMonth(this, value);
                                hooks.updateOffset(this, true);
                                return this;
                            } else {
                                return get(this, "Month");
                            }
                        }
                        function getDaysInMonth() {
                            return daysInMonth(this.year(), this.month());
                        }
                        function monthsShortRegex(isStrict) {
                            if (this._monthsParseExact) {
                                if (!hasOwnProp(this, "_monthsRegex")) {
                                    computeMonthsParse.call(this);
                                }
                                if (isStrict) {
                                    return this._monthsShortStrictRegex;
                                } else {
                                    return this._monthsShortRegex;
                                }
                            } else {
                                if (!hasOwnProp(this, "_monthsShortRegex")) {
                                    this._monthsShortRegex = defaultMonthsShortRegex;
                                }
                                return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
                            }
                        }
                        function monthsRegex(isStrict) {
                            if (this._monthsParseExact) {
                                if (!hasOwnProp(this, "_monthsRegex")) {
                                    computeMonthsParse.call(this);
                                }
                                if (isStrict) {
                                    return this._monthsStrictRegex;
                                } else {
                                    return this._monthsRegex;
                                }
                            } else {
                                if (!hasOwnProp(this, "_monthsRegex")) {
                                    this._monthsRegex = defaultMonthsRegex;
                                }
                                return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
                            }
                        }
                        function computeMonthsParse() {
                            function cmpLenRev(a, b) {
                                return b.length - a.length;
                            }
                            var shortPieces = [],
                                longPieces = [],
                                mixedPieces = [],
                                i,
                                mom;
                            for (i = 0; i < 12; i++) {
                                mom = createUTC([2e3, i]);
                                shortPieces.push(this.monthsShort(mom, ""));
                                longPieces.push(this.months(mom, ""));
                                mixedPieces.push(this.months(mom, ""));
                                mixedPieces.push(this.monthsShort(mom, ""));
                            }
                            shortPieces.sort(cmpLenRev);
                            longPieces.sort(cmpLenRev);
                            mixedPieces.sort(cmpLenRev);
                            for (i = 0; i < 12; i++) {
                                shortPieces[i] = regexEscape(shortPieces[i]);
                                longPieces[i] = regexEscape(longPieces[i]);
                            }
                            for (i = 0; i < 24; i++) {
                                mixedPieces[i] = regexEscape(mixedPieces[i]);
                            }
                            this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
                            this._monthsShortRegex = this._monthsRegex;
                            this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
                            this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
                        }
                        addFormatToken("Y", 0, 0, function () {
                            var y = this.year();
                            return y <= 9999 ? zeroFill(y, 4) : "+" + y;
                        });
                        addFormatToken(0, ["YY", 2], 0, function () {
                            return this.year() % 100;
                        });
                        addFormatToken(0, ["YYYY", 4], 0, "year");
                        addFormatToken(0, ["YYYYY", 5], 0, "year");
                        addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
                        addUnitAlias("year", "y");
                        addUnitPriority("year", 1);
                        addRegexToken("Y", matchSigned);
                        addRegexToken("YY", match1to2, match2);
                        addRegexToken("YYYY", match1to4, match4);
                        addRegexToken("YYYYY", match1to6, match6);
                        addRegexToken("YYYYYY", match1to6, match6);
                        addParseToken(["YYYYY", "YYYYYY"], YEAR);
                        addParseToken("YYYY", function (input, array) {
                            array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
                        });
                        addParseToken("YY", function (input, array) {
                            array[YEAR] = hooks.parseTwoDigitYear(input);
                        });
                        addParseToken("Y", function (input, array) {
                            array[YEAR] = parseInt(input, 10);
                        });
                        function daysInYear(year) {
                            return isLeapYear(year) ? 366 : 365;
                        }
                        hooks.parseTwoDigitYear = function (input) {
                            return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
                        };
                        var getSetYear = makeGetSet("FullYear", true);
                        function getIsLeapYear() {
                            return isLeapYear(this.year());
                        }
                        function createDate(y, m, d, h, M, s, ms) {
                            var date;
                            if (y < 100 && y >= 0) {
                                date = new Date(y + 400, m, d, h, M, s, ms);
                                if (isFinite(date.getFullYear())) {
                                    date.setFullYear(y);
                                }
                            } else {
                                date = new Date(y, m, d, h, M, s, ms);
                            }
                            return date;
                        }
                        function createUTCDate(y) {
                            var date, args;
                            if (y < 100 && y >= 0) {
                                args = Array.prototype.slice.call(arguments);
                                args[0] = y + 400;
                                date = new Date(Date.UTC.apply(null, args));
                                if (isFinite(date.getUTCFullYear())) {
                                    date.setUTCFullYear(y);
                                }
                            } else {
                                date = new Date(Date.UTC.apply(null, arguments));
                            }
                            return date;
                        }
                        function firstWeekOffset(year, dow, doy) {
                            var fwd = 7 + dow - doy,
                                fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
                            return -fwdlw + fwd - 1;
                        }
                        function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
                            var localWeekday = (7 + weekday - dow) % 7,
                                weekOffset = firstWeekOffset(year, dow, doy),
                                dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
                                resYear,
                                resDayOfYear;
                            if (dayOfYear <= 0) {
                                resYear = year - 1;
                                resDayOfYear = daysInYear(resYear) + dayOfYear;
                            } else if (dayOfYear > daysInYear(year)) {
                                resYear = year + 1;
                                resDayOfYear = dayOfYear - daysInYear(year);
                            } else {
                                resYear = year;
                                resDayOfYear = dayOfYear;
                            }
                            return { year: resYear, dayOfYear: resDayOfYear };
                        }
                        function weekOfYear(mom, dow, doy) {
                            var weekOffset = firstWeekOffset(mom.year(), dow, doy),
                                week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
                                resWeek,
                                resYear;
                            if (week < 1) {
                                resYear = mom.year() - 1;
                                resWeek = week + weeksInYear(resYear, dow, doy);
                            } else if (week > weeksInYear(mom.year(), dow, doy)) {
                                resWeek = week - weeksInYear(mom.year(), dow, doy);
                                resYear = mom.year() + 1;
                            } else {
                                resYear = mom.year();
                                resWeek = week;
                            }
                            return { week: resWeek, year: resYear };
                        }
                        function weeksInYear(year, dow, doy) {
                            var weekOffset = firstWeekOffset(year, dow, doy),
                                weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
                            return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
                        }
                        addFormatToken("w", ["ww", 2], "wo", "week");
                        addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
                        addUnitAlias("week", "w");
                        addUnitAlias("isoWeek", "W");
                        addUnitPriority("week", 5);
                        addUnitPriority("isoWeek", 5);
                        addRegexToken("w", match1to2);
                        addRegexToken("ww", match1to2, match2);
                        addRegexToken("W", match1to2);
                        addRegexToken("WW", match1to2, match2);
                        addWeekParseToken(["w", "ww", "W", "WW"], function (input, week, config, token) {
                            week[token.substr(0, 1)] = toInt(input);
                        });
                        function localeWeek(mom) {
                            return weekOfYear(mom, this._week.dow, this._week.doy).week;
                        }
                        var defaultLocaleWeek = { dow: 0, doy: 6 };
                        function localeFirstDayOfWeek() {
                            return this._week.dow;
                        }
                        function localeFirstDayOfYear() {
                            return this._week.doy;
                        }
                        function getSetWeek(input) {
                            var week = this.localeData().week(this);
                            return input == null ? week : this.add((input - week) * 7, "d");
                        }
                        function getSetISOWeek(input) {
                            var week = weekOfYear(this, 1, 4).week;
                            return input == null ? week : this.add((input - week) * 7, "d");
                        }
                        addFormatToken("d", 0, "do", "day");
                        addFormatToken("dd", 0, 0, function (format) {
                            return this.localeData().weekdaysMin(this, format);
                        });
                        addFormatToken("ddd", 0, 0, function (format) {
                            return this.localeData().weekdaysShort(this, format);
                        });
                        addFormatToken("dddd", 0, 0, function (format) {
                            return this.localeData().weekdays(this, format);
                        });
                        addFormatToken("e", 0, 0, "weekday");
                        addFormatToken("E", 0, 0, "isoWeekday");
                        addUnitAlias("day", "d");
                        addUnitAlias("weekday", "e");
                        addUnitAlias("isoWeekday", "E");
                        addUnitPriority("day", 11);
                        addUnitPriority("weekday", 11);
                        addUnitPriority("isoWeekday", 11);
                        addRegexToken("d", match1to2);
                        addRegexToken("e", match1to2);
                        addRegexToken("E", match1to2);
                        addRegexToken("dd", function (isStrict, locale) {
                            return locale.weekdaysMinRegex(isStrict);
                        });
                        addRegexToken("ddd", function (isStrict, locale) {
                            return locale.weekdaysShortRegex(isStrict);
                        });
                        addRegexToken("dddd", function (isStrict, locale) {
                            return locale.weekdaysRegex(isStrict);
                        });
                        addWeekParseToken(["dd", "ddd", "dddd"], function (input, week, config, token) {
                            var weekday = config._locale.weekdaysParse(input, token, config._strict);
                            if (weekday != null) {
                                week.d = weekday;
                            } else {
                                getParsingFlags(config).invalidWeekday = input;
                            }
                        });
                        addWeekParseToken(["d", "e", "E"], function (input, week, config, token) {
                            week[token] = toInt(input);
                        });
                        function parseWeekday(input, locale) {
                            if (typeof input !== "string") {
                                return input;
                            }
                            if (!isNaN(input)) {
                                return parseInt(input, 10);
                            }
                            input = locale.weekdaysParse(input);
                            if (typeof input === "number") {
                                return input;
                            }
                            return null;
                        }
                        function parseIsoWeekday(input, locale) {
                            if (typeof input === "string") {
                                return locale.weekdaysParse(input) % 7 || 7;
                            }
                            return isNaN(input) ? null : input;
                        }
                        function shiftWeekdays(ws, n) {
                            return ws.slice(n, 7).concat(ws.slice(0, n));
                        }
                        var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                            defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
                            defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
                            defaultWeekdaysRegex = matchWord,
                            defaultWeekdaysShortRegex = matchWord,
                            defaultWeekdaysMinRegex = matchWord;
                        function localeWeekdays(m, format) {
                            var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? "format" : "standalone"];
                            return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
                        }
                        function localeWeekdaysShort(m) {
                            return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
                        }
                        function localeWeekdaysMin(m) {
                            return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
                        }
                        function handleStrictParse$1(weekdayName, format, strict) {
                            var i,
                                ii,
                                mom,
                                llc = weekdayName.toLocaleLowerCase();
                            if (!this._weekdaysParse) {
                                this._weekdaysParse = [];
                                this._shortWeekdaysParse = [];
                                this._minWeekdaysParse = [];
                                for (i = 0; i < 7; ++i) {
                                    mom = createUTC([2e3, 1]).day(i);
                                    this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase();
                                    this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase();
                                    this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
                                }
                            }
                            if (strict) {
                                if (format === "dddd") {
                                    ii = indexOf.call(this._weekdaysParse, llc);
                                    return ii !== -1 ? ii : null;
                                } else if (format === "ddd") {
                                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                                    return ii !== -1 ? ii : null;
                                } else {
                                    ii = indexOf.call(this._minWeekdaysParse, llc);
                                    return ii !== -1 ? ii : null;
                                }
                            } else {
                                if (format === "dddd") {
                                    ii = indexOf.call(this._weekdaysParse, llc);
                                    if (ii !== -1) {
                                        return ii;
                                    }
                                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                                    if (ii !== -1) {
                                        return ii;
                                    }
                                    ii = indexOf.call(this._minWeekdaysParse, llc);
                                    return ii !== -1 ? ii : null;
                                } else if (format === "ddd") {
                                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                                    if (ii !== -1) {
                                        return ii;
                                    }
                                    ii = indexOf.call(this._weekdaysParse, llc);
                                    if (ii !== -1) {
                                        return ii;
                                    }
                                    ii = indexOf.call(this._minWeekdaysParse, llc);
                                    return ii !== -1 ? ii : null;
                                } else {
                                    ii = indexOf.call(this._minWeekdaysParse, llc);
                                    if (ii !== -1) {
                                        return ii;
                                    }
                                    ii = indexOf.call(this._weekdaysParse, llc);
                                    if (ii !== -1) {
                                        return ii;
                                    }
                                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                                    return ii !== -1 ? ii : null;
                                }
                            }
                        }
                        function localeWeekdaysParse(weekdayName, format, strict) {
                            var i, mom, regex;
                            if (this._weekdaysParseExact) {
                                return handleStrictParse$1.call(this, weekdayName, format, strict);
                            }
                            if (!this._weekdaysParse) {
                                this._weekdaysParse = [];
                                this._minWeekdaysParse = [];
                                this._shortWeekdaysParse = [];
                                this._fullWeekdaysParse = [];
                            }
                            for (i = 0; i < 7; i++) {
                                mom = createUTC([2e3, 1]).day(i);
                                if (strict && !this._fullWeekdaysParse[i]) {
                                    this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", "\\.?") + "$", "i");
                                    this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$", "i");
                                    this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$", "i");
                                }
                                if (!this._weekdaysParse[i]) {
                                    regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
                                    this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
                                }
                                if (strict && format === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
                                    return i;
                                } else if (strict && format === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
                                    return i;
                                } else if (strict && format === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
                                    return i;
                                } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                                    return i;
                                }
                            }
                        }
                        function getSetDayOfWeek(input) {
                            if (!this.isValid()) {
                                return input != null ? this : NaN;
                            }
                            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
                            if (input != null) {
                                input = parseWeekday(input, this.localeData());
                                return this.add(input - day, "d");
                            } else {
                                return day;
                            }
                        }
                        function getSetLocaleDayOfWeek(input) {
                            if (!this.isValid()) {
                                return input != null ? this : NaN;
                            }
                            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
                            return input == null ? weekday : this.add(input - weekday, "d");
                        }
                        function getSetISODayOfWeek(input) {
                            if (!this.isValid()) {
                                return input != null ? this : NaN;
                            }
                            if (input != null) {
                                var weekday = parseIsoWeekday(input, this.localeData());
                                return this.day(this.day() % 7 ? weekday : weekday - 7);
                            } else {
                                return this.day() || 7;
                            }
                        }
                        function weekdaysRegex(isStrict) {
                            if (this._weekdaysParseExact) {
                                if (!hasOwnProp(this, "_weekdaysRegex")) {
                                    computeWeekdaysParse.call(this);
                                }
                                if (isStrict) {
                                    return this._weekdaysStrictRegex;
                                } else {
                                    return this._weekdaysRegex;
                                }
                            } else {
                                if (!hasOwnProp(this, "_weekdaysRegex")) {
                                    this._weekdaysRegex = defaultWeekdaysRegex;
                                }
                                return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
                            }
                        }
                        function weekdaysShortRegex(isStrict) {
                            if (this._weekdaysParseExact) {
                                if (!hasOwnProp(this, "_weekdaysRegex")) {
                                    computeWeekdaysParse.call(this);
                                }
                                if (isStrict) {
                                    return this._weekdaysShortStrictRegex;
                                } else {
                                    return this._weekdaysShortRegex;
                                }
                            } else {
                                if (!hasOwnProp(this, "_weekdaysShortRegex")) {
                                    this._weekdaysShortRegex = defaultWeekdaysShortRegex;
                                }
                                return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
                            }
                        }
                        function weekdaysMinRegex(isStrict) {
                            if (this._weekdaysParseExact) {
                                if (!hasOwnProp(this, "_weekdaysRegex")) {
                                    computeWeekdaysParse.call(this);
                                }
                                if (isStrict) {
                                    return this._weekdaysMinStrictRegex;
                                } else {
                                    return this._weekdaysMinRegex;
                                }
                            } else {
                                if (!hasOwnProp(this, "_weekdaysMinRegex")) {
                                    this._weekdaysMinRegex = defaultWeekdaysMinRegex;
                                }
                                return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
                            }
                        }
                        function computeWeekdaysParse() {
                            function cmpLenRev(a, b) {
                                return b.length - a.length;
                            }
                            var minPieces = [],
                                shortPieces = [],
                                longPieces = [],
                                mixedPieces = [],
                                i,
                                mom,
                                minp,
                                shortp,
                                longp;
                            for (i = 0; i < 7; i++) {
                                mom = createUTC([2e3, 1]).day(i);
                                minp = regexEscape(this.weekdaysMin(mom, ""));
                                shortp = regexEscape(this.weekdaysShort(mom, ""));
                                longp = regexEscape(this.weekdays(mom, ""));
                                minPieces.push(minp);
                                shortPieces.push(shortp);
                                longPieces.push(longp);
                                mixedPieces.push(minp);
                                mixedPieces.push(shortp);
                                mixedPieces.push(longp);
                            }
                            minPieces.sort(cmpLenRev);
                            shortPieces.sort(cmpLenRev);
                            longPieces.sort(cmpLenRev);
                            mixedPieces.sort(cmpLenRev);
                            this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
                            this._weekdaysShortRegex = this._weekdaysRegex;
                            this._weekdaysMinRegex = this._weekdaysRegex;
                            this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
                            this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
                            this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
                        }
                        function hFormat() {
                            return this.hours() % 12 || 12;
                        }
                        function kFormat() {
                            return this.hours() || 24;
                        }
                        addFormatToken("H", ["HH", 2], 0, "hour");
                        addFormatToken("h", ["hh", 2], 0, hFormat);
                        addFormatToken("k", ["kk", 2], 0, kFormat);
                        addFormatToken("hmm", 0, 0, function () {
                            return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
                        });
                        addFormatToken("hmmss", 0, 0, function () {
                            return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
                        });
                        addFormatToken("Hmm", 0, 0, function () {
                            return "" + this.hours() + zeroFill(this.minutes(), 2);
                        });
                        addFormatToken("Hmmss", 0, 0, function () {
                            return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
                        });
                        function meridiem(token, lowercase) {
                            addFormatToken(token, 0, 0, function () {
                                return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
                            });
                        }
                        meridiem("a", true);
                        meridiem("A", false);
                        addUnitAlias("hour", "h");
                        addUnitPriority("hour", 13);
                        function matchMeridiem(isStrict, locale) {
                            return locale._meridiemParse;
                        }
                        addRegexToken("a", matchMeridiem);
                        addRegexToken("A", matchMeridiem);
                        addRegexToken("H", match1to2);
                        addRegexToken("h", match1to2);
                        addRegexToken("k", match1to2);
                        addRegexToken("HH", match1to2, match2);
                        addRegexToken("hh", match1to2, match2);
                        addRegexToken("kk", match1to2, match2);
                        addRegexToken("hmm", match3to4);
                        addRegexToken("hmmss", match5to6);
                        addRegexToken("Hmm", match3to4);
                        addRegexToken("Hmmss", match5to6);
                        addParseToken(["H", "HH"], HOUR);
                        addParseToken(["k", "kk"], function (input, array, config) {
                            var kInput = toInt(input);
                            array[HOUR] = kInput === 24 ? 0 : kInput;
                        });
                        addParseToken(["a", "A"], function (input, array, config) {
                            config._isPm = config._locale.isPM(input);
                            config._meridiem = input;
                        });
                        addParseToken(["h", "hh"], function (input, array, config) {
                            array[HOUR] = toInt(input);
                            getParsingFlags(config).bigHour = true;
                        });
                        addParseToken("hmm", function (input, array, config) {
                            var pos = input.length - 2;
                            array[HOUR] = toInt(input.substr(0, pos));
                            array[MINUTE] = toInt(input.substr(pos));
                            getParsingFlags(config).bigHour = true;
                        });
                        addParseToken("hmmss", function (input, array, config) {
                            var pos1 = input.length - 4,
                                pos2 = input.length - 2;
                            array[HOUR] = toInt(input.substr(0, pos1));
                            array[MINUTE] = toInt(input.substr(pos1, 2));
                            array[SECOND] = toInt(input.substr(pos2));
                            getParsingFlags(config).bigHour = true;
                        });
                        addParseToken("Hmm", function (input, array, config) {
                            var pos = input.length - 2;
                            array[HOUR] = toInt(input.substr(0, pos));
                            array[MINUTE] = toInt(input.substr(pos));
                        });
                        addParseToken("Hmmss", function (input, array, config) {
                            var pos1 = input.length - 4,
                                pos2 = input.length - 2;
                            array[HOUR] = toInt(input.substr(0, pos1));
                            array[MINUTE] = toInt(input.substr(pos1, 2));
                            array[SECOND] = toInt(input.substr(pos2));
                        });
                        function localeIsPM(input) {
                            return (input + "").toLowerCase().charAt(0) === "p";
                        }
                        var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
                            getSetHour = makeGetSet("Hours", true);
                        function localeMeridiem(hours, minutes, isLower) {
                            if (hours > 11) {
                                return isLower ? "pm" : "PM";
                            } else {
                                return isLower ? "am" : "AM";
                            }
                        }
                        var baseConfig = {
                            calendar: defaultCalendar,
                            longDateFormat: defaultLongDateFormat,
                            invalidDate: defaultInvalidDate,
                            ordinal: defaultOrdinal,
                            dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
                            relativeTime: defaultRelativeTime,
                            months: defaultLocaleMonths,
                            monthsShort: defaultLocaleMonthsShort,
                            week: defaultLocaleWeek,
                            weekdays: defaultLocaleWeekdays,
                            weekdaysMin: defaultLocaleWeekdaysMin,
                            weekdaysShort: defaultLocaleWeekdaysShort,
                            meridiemParse: defaultLocaleMeridiemParse,
                        };
                        var locales = {},
                            localeFamilies = {},
                            globalLocale;
                        function commonPrefix(arr1, arr2) {
                            var i,
                                minl = Math.min(arr1.length, arr2.length);
                            for (i = 0; i < minl; i += 1) {
                                if (arr1[i] !== arr2[i]) {
                                    return i;
                                }
                            }
                            return minl;
                        }
                        function normalizeLocale(key) {
                            return key ? key.toLowerCase().replace("_", "-") : key;
                        }
                        function chooseLocale(names) {
                            var i = 0,
                                j,
                                next,
                                locale,
                                split;
                            while (i < names.length) {
                                split = normalizeLocale(names[i]).split("-");
                                j = split.length;
                                next = normalizeLocale(names[i + 1]);
                                next = next ? next.split("-") : null;
                                while (j > 0) {
                                    locale = loadLocale(split.slice(0, j).join("-"));
                                    if (locale) {
                                        return locale;
                                    }
                                    if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
                                        break;
                                    }
                                    j--;
                                }
                                i++;
                            }
                            return globalLocale;
                        }
                        function isLocaleNameSane(name) {
                            return name.match("^[^/\\\\]*$") != null;
                        }
                        function loadLocale(name) {
                            var oldLocale = null,
                                aliasedRequire;
                            if (locales[name] === undefined && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
                                try {
                                    oldLocale = globalLocale._abbr;
                                    aliasedRequire = require;
                                    __webpack_require__("./node_modules/moment/locale sync recursive ^\\.\\/.*$")("./" + name);
                                    getSetGlobalLocale(oldLocale);
                                } catch (e) {
                                    locales[name] = null;
                                }
                            }
                            return locales[name];
                        }
                        function getSetGlobalLocale(key, values) {
                            var data;
                            if (key) {
                                if (isUndefined(values)) {
                                    data = getLocale(key);
                                } else {
                                    data = defineLocale(key, values);
                                }
                                if (data) {
                                    globalLocale = data;
                                } else {
                                    if (typeof console !== "undefined" && console.warn) {
                                        console.warn("Locale " + key + " not found. Did you forget to load it?");
                                    }
                                }
                            }
                            return globalLocale._abbr;
                        }
                        function defineLocale(name, config) {
                            if (config !== null) {
                                var locale,
                                    parentConfig = baseConfig;
                                config.abbr = name;
                                if (locales[name] != null) {
                                    deprecateSimple(
                                        "defineLocaleOverride",
                                        "use moment.updateLocale(localeName, config) to change " +
                                            "an existing locale. moment.defineLocale(localeName, " +
                                            "config) should only be used for creating a new locale " +
                                            "See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
                                    );
                                    parentConfig = locales[name]._config;
                                } else if (config.parentLocale != null) {
                                    if (locales[config.parentLocale] != null) {
                                        parentConfig = locales[config.parentLocale]._config;
                                    } else {
                                        locale = loadLocale(config.parentLocale);
                                        if (locale != null) {
                                            parentConfig = locale._config;
                                        } else {
                                            if (!localeFamilies[config.parentLocale]) {
                                                localeFamilies[config.parentLocale] = [];
                                            }
                                            localeFamilies[config.parentLocale].push({ name: name, config: config });
                                            return null;
                                        }
                                    }
                                }
                                locales[name] = new Locale(mergeConfigs(parentConfig, config));
                                if (localeFamilies[name]) {
                                    localeFamilies[name].forEach(function (x) {
                                        defineLocale(x.name, x.config);
                                    });
                                }
                                getSetGlobalLocale(name);
                                return locales[name];
                            } else {
                                delete locales[name];
                                return null;
                            }
                        }
                        function updateLocale(name, config) {
                            if (config != null) {
                                var locale,
                                    tmpLocale,
                                    parentConfig = baseConfig;
                                if (locales[name] != null && locales[name].parentLocale != null) {
                                    locales[name].set(mergeConfigs(locales[name]._config, config));
                                } else {
                                    tmpLocale = loadLocale(name);
                                    if (tmpLocale != null) {
                                        parentConfig = tmpLocale._config;
                                    }
                                    config = mergeConfigs(parentConfig, config);
                                    if (tmpLocale == null) {
                                        config.abbr = name;
                                    }
                                    locale = new Locale(config);
                                    locale.parentLocale = locales[name];
                                    locales[name] = locale;
                                }
                                getSetGlobalLocale(name);
                            } else {
                                if (locales[name] != null) {
                                    if (locales[name].parentLocale != null) {
                                        locales[name] = locales[name].parentLocale;
                                        if (name === getSetGlobalLocale()) {
                                            getSetGlobalLocale(name);
                                        }
                                    } else if (locales[name] != null) {
                                        delete locales[name];
                                    }
                                }
                            }
                            return locales[name];
                        }
                        function getLocale(key) {
                            var locale;
                            if (key && key._locale && key._locale._abbr) {
                                key = key._locale._abbr;
                            }
                            if (!key) {
                                return globalLocale;
                            }
                            if (!isArray(key)) {
                                locale = loadLocale(key);
                                if (locale) {
                                    return locale;
                                }
                                key = [key];
                            }
                            return chooseLocale(key);
                        }
                        function listLocales() {
                            return keys(locales);
                        }
                        function checkOverflow(m) {
                            var overflow,
                                a = m._a;
                            if (a && getParsingFlags(m).overflow === -2) {
                                overflow =
                                    a[MONTH] < 0 || a[MONTH] > 11
                                        ? MONTH
                                        : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
                                        ? DATE
                                        : a[HOUR] < 0 || a[HOUR] > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0))
                                        ? HOUR
                                        : a[MINUTE] < 0 || a[MINUTE] > 59
                                        ? MINUTE
                                        : a[SECOND] < 0 || a[SECOND] > 59
                                        ? SECOND
                                        : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
                                        ? MILLISECOND
                                        : -1;
                                if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                                    overflow = DATE;
                                }
                                if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                                    overflow = WEEK;
                                }
                                if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                                    overflow = WEEKDAY;
                                }
                                getParsingFlags(m).overflow = overflow;
                            }
                            return m;
                        }
                        var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
                            basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
                            tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
                            isoDates = [
                                ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
                                ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
                                ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
                                ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
                                ["YYYY-DDD", /\d{4}-\d{3}/],
                                ["YYYY-MM", /\d{4}-\d\d/, false],
                                ["YYYYYYMMDD", /[+-]\d{10}/],
                                ["YYYYMMDD", /\d{8}/],
                                ["GGGG[W]WWE", /\d{4}W\d{3}/],
                                ["GGGG[W]WW", /\d{4}W\d{2}/, false],
                                ["YYYYDDD", /\d{7}/],
                                ["YYYYMM", /\d{6}/, false],
                                ["YYYY", /\d{4}/, false],
                            ],
                            isoTimes = [
                                ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
                                ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
                                ["HH:mm:ss", /\d\d:\d\d:\d\d/],
                                ["HH:mm", /\d\d:\d\d/],
                                ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
                                ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
                                ["HHmmss", /\d\d\d\d\d\d/],
                                ["HHmm", /\d\d\d\d/],
                                ["HH", /\d\d/],
                            ],
                            aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
                            rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
                            obsOffsets = { UT: 0, GMT: 0, EDT: -4 * 60, EST: -5 * 60, CDT: -5 * 60, CST: -6 * 60, MDT: -6 * 60, MST: -7 * 60, PDT: -7 * 60, PST: -8 * 60 };
                        function configFromISO(config) {
                            var i,
                                l,
                                string = config._i,
                                match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
                                allowTime,
                                dateFormat,
                                timeFormat,
                                tzFormat,
                                isoDatesLen = isoDates.length,
                                isoTimesLen = isoTimes.length;
                            if (match) {
                                getParsingFlags(config).iso = true;
                                for (i = 0, l = isoDatesLen; i < l; i++) {
                                    if (isoDates[i][1].exec(match[1])) {
                                        dateFormat = isoDates[i][0];
                                        allowTime = isoDates[i][2] !== false;
                                        break;
                                    }
                                }
                                if (dateFormat == null) {
                                    config._isValid = false;
                                    return;
                                }
                                if (match[3]) {
                                    for (i = 0, l = isoTimesLen; i < l; i++) {
                                        if (isoTimes[i][1].exec(match[3])) {
                                            timeFormat = (match[2] || " ") + isoTimes[i][0];
                                            break;
                                        }
                                    }
                                    if (timeFormat == null) {
                                        config._isValid = false;
                                        return;
                                    }
                                }
                                if (!allowTime && timeFormat != null) {
                                    config._isValid = false;
                                    return;
                                }
                                if (match[4]) {
                                    if (tzRegex.exec(match[4])) {
                                        tzFormat = "Z";
                                    } else {
                                        config._isValid = false;
                                        return;
                                    }
                                }
                                config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
                                configFromStringAndFormat(config);
                            } else {
                                config._isValid = false;
                            }
                        }
                        function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
                            var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];
                            if (secondStr) {
                                result.push(parseInt(secondStr, 10));
                            }
                            return result;
                        }
                        function untruncateYear(yearStr) {
                            var year = parseInt(yearStr, 10);
                            if (year <= 49) {
                                return 2e3 + year;
                            } else if (year <= 999) {
                                return 1900 + year;
                            }
                            return year;
                        }
                        function preprocessRFC2822(s) {
                            return s
                                .replace(/\([^)]*\)|[\n\t]/g, " ")
                                .replace(/(\s\s+)/g, " ")
                                .replace(/^\s\s*/, "")
                                .replace(/\s\s*$/, "");
                        }
                        function checkWeekday(weekdayStr, parsedInput, config) {
                            if (weekdayStr) {
                                var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                                    weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
                                if (weekdayProvided !== weekdayActual) {
                                    getParsingFlags(config).weekdayMismatch = true;
                                    config._isValid = false;
                                    return false;
                                }
                            }
                            return true;
                        }
                        function calculateOffset(obsOffset, militaryOffset, numOffset) {
                            if (obsOffset) {
                                return obsOffsets[obsOffset];
                            } else if (militaryOffset) {
                                return 0;
                            } else {
                                var hm = parseInt(numOffset, 10),
                                    m = hm % 100,
                                    h = (hm - m) / 100;
                                return h * 60 + m;
                            }
                        }
                        function configFromRFC2822(config) {
                            var match = rfc2822.exec(preprocessRFC2822(config._i)),
                                parsedArray;
                            if (match) {
                                parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
                                if (!checkWeekday(match[1], parsedArray, config)) {
                                    return;
                                }
                                config._a = parsedArray;
                                config._tzm = calculateOffset(match[8], match[9], match[10]);
                                config._d = createUTCDate.apply(null, config._a);
                                config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
                                getParsingFlags(config).rfc2822 = true;
                            } else {
                                config._isValid = false;
                            }
                        }
                        function configFromString(config) {
                            var matched = aspNetJsonRegex.exec(config._i);
                            if (matched !== null) {
                                config._d = new Date(+matched[1]);
                                return;
                            }
                            configFromISO(config);
                            if (config._isValid === false) {
                                delete config._isValid;
                            } else {
                                return;
                            }
                            configFromRFC2822(config);
                            if (config._isValid === false) {
                                delete config._isValid;
                            } else {
                                return;
                            }
                            if (config._strict) {
                                config._isValid = false;
                            } else {
                                hooks.createFromInputFallback(config);
                            }
                        }
                        hooks.createFromInputFallback = deprecate(
                            "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), " +
                                "which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are " +
                                "discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
                            function (config) {
                                config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
                            }
                        );
                        function defaults(a, b, c) {
                            if (a != null) {
                                return a;
                            }
                            if (b != null) {
                                return b;
                            }
                            return c;
                        }
                        function currentDateArray(config) {
                            var nowValue = new Date(hooks.now());
                            if (config._useUTC) {
                                return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
                            }
                            return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
                        }
                        function configFromArray(config) {
                            var i,
                                date,
                                input = [],
                                currentDate,
                                expectedWeekday,
                                yearToUse;
                            if (config._d) {
                                return;
                            }
                            currentDate = currentDateArray(config);
                            if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
                                dayOfYearFromWeekInfo(config);
                            }
                            if (config._dayOfYear != null) {
                                yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
                                if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                                    getParsingFlags(config)._overflowDayOfYear = true;
                                }
                                date = createUTCDate(yearToUse, 0, config._dayOfYear);
                                config._a[MONTH] = date.getUTCMonth();
                                config._a[DATE] = date.getUTCDate();
                            }
                            for (i = 0; i < 3 && config._a[i] == null; ++i) {
                                config._a[i] = input[i] = currentDate[i];
                            }
                            for (; i < 7; i++) {
                                config._a[i] = input[i] = config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
                            }
                            if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
                                config._nextDay = true;
                                config._a[HOUR] = 0;
                            }
                            config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
                            expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
                            if (config._tzm != null) {
                                config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
                            }
                            if (config._nextDay) {
                                config._a[HOUR] = 24;
                            }
                            if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
                                getParsingFlags(config).weekdayMismatch = true;
                            }
                        }
                        function dayOfYearFromWeekInfo(config) {
                            var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
                            w = config._w;
                            if (w.GG != null || w.W != null || w.E != null) {
                                dow = 1;
                                doy = 4;
                                weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
                                week = defaults(w.W, 1);
                                weekday = defaults(w.E, 1);
                                if (weekday < 1 || weekday > 7) {
                                    weekdayOverflow = true;
                                }
                            } else {
                                dow = config._locale._week.dow;
                                doy = config._locale._week.doy;
                                curWeek = weekOfYear(createLocal(), dow, doy);
                                weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
                                week = defaults(w.w, curWeek.week);
                                if (w.d != null) {
                                    weekday = w.d;
                                    if (weekday < 0 || weekday > 6) {
                                        weekdayOverflow = true;
                                    }
                                } else if (w.e != null) {
                                    weekday = w.e + dow;
                                    if (w.e < 0 || w.e > 6) {
                                        weekdayOverflow = true;
                                    }
                                } else {
                                    weekday = dow;
                                }
                            }
                            if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
                                getParsingFlags(config)._overflowWeeks = true;
                            } else if (weekdayOverflow != null) {
                                getParsingFlags(config)._overflowWeekday = true;
                            } else {
                                temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
                                config._a[YEAR] = temp.year;
                                config._dayOfYear = temp.dayOfYear;
                            }
                        }
                        hooks.ISO_8601 = function () {};
                        hooks.RFC_2822 = function () {};
                        function configFromStringAndFormat(config) {
                            if (config._f === hooks.ISO_8601) {
                                configFromISO(config);
                                return;
                            }
                            if (config._f === hooks.RFC_2822) {
                                configFromRFC2822(config);
                                return;
                            }
                            config._a = [];
                            getParsingFlags(config).empty = true;
                            var string = "" + config._i,
                                i,
                                parsedInput,
                                tokens,
                                token,
                                skipped,
                                stringLength = string.length,
                                totalParsedInputLength = 0,
                                era,
                                tokenLen;
                            tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
                            tokenLen = tokens.length;
                            for (i = 0; i < tokenLen; i++) {
                                token = tokens[i];
                                parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
                                if (parsedInput) {
                                    skipped = string.substr(0, string.indexOf(parsedInput));
                                    if (skipped.length > 0) {
                                        getParsingFlags(config).unusedInput.push(skipped);
                                    }
                                    string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                                    totalParsedInputLength += parsedInput.length;
                                }
                                if (formatTokenFunctions[token]) {
                                    if (parsedInput) {
                                        getParsingFlags(config).empty = false;
                                    } else {
                                        getParsingFlags(config).unusedTokens.push(token);
                                    }
                                    addTimeToArrayFromToken(token, parsedInput, config);
                                } else if (config._strict && !parsedInput) {
                                    getParsingFlags(config).unusedTokens.push(token);
                                }
                            }
                            getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
                            if (string.length > 0) {
                                getParsingFlags(config).unusedInput.push(string);
                            }
                            if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
                                getParsingFlags(config).bigHour = undefined;
                            }
                            getParsingFlags(config).parsedDateParts = config._a.slice(0);
                            getParsingFlags(config).meridiem = config._meridiem;
                            config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
                            era = getParsingFlags(config).era;
                            if (era !== null) {
                                config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
                            }
                            configFromArray(config);
                            checkOverflow(config);
                        }
                        function meridiemFixWrap(locale, hour, meridiem) {
                            var isPm;
                            if (meridiem == null) {
                                return hour;
                            }
                            if (locale.meridiemHour != null) {
                                return locale.meridiemHour(hour, meridiem);
                            } else if (locale.isPM != null) {
                                isPm = locale.isPM(meridiem);
                                if (isPm && hour < 12) {
                                    hour += 12;
                                }
                                if (!isPm && hour === 12) {
                                    hour = 0;
                                }
                                return hour;
                            } else {
                                return hour;
                            }
                        }
                        function configFromStringAndArray(config) {
                            var tempConfig,
                                bestMoment,
                                scoreToBeat,
                                i,
                                currentScore,
                                validFormatFound,
                                bestFormatIsValid = false,
                                configfLen = config._f.length;
                            if (configfLen === 0) {
                                getParsingFlags(config).invalidFormat = true;
                                config._d = new Date(NaN);
                                return;
                            }
                            for (i = 0; i < configfLen; i++) {
                                currentScore = 0;
                                validFormatFound = false;
                                tempConfig = copyConfig({}, config);
                                if (config._useUTC != null) {
                                    tempConfig._useUTC = config._useUTC;
                                }
                                tempConfig._f = config._f[i];
                                configFromStringAndFormat(tempConfig);
                                if (isValid(tempConfig)) {
                                    validFormatFound = true;
                                }
                                currentScore += getParsingFlags(tempConfig).charsLeftOver;
                                currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
                                getParsingFlags(tempConfig).score = currentScore;
                                if (!bestFormatIsValid) {
                                    if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
                                        scoreToBeat = currentScore;
                                        bestMoment = tempConfig;
                                        if (validFormatFound) {
                                            bestFormatIsValid = true;
                                        }
                                    }
                                } else {
                                    if (currentScore < scoreToBeat) {
                                        scoreToBeat = currentScore;
                                        bestMoment = tempConfig;
                                    }
                                }
                            }
                            extend(config, bestMoment || tempConfig);
                        }
                        function configFromObject(config) {
                            if (config._d) {
                                return;
                            }
                            var i = normalizeObjectUnits(config._i),
                                dayOrDate = i.day === undefined ? i.date : i.day;
                            config._a = map([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], function (obj) {
                                return obj && parseInt(obj, 10);
                            });
                            configFromArray(config);
                        }
                        function createFromConfig(config) {
                            var res = new Moment(checkOverflow(prepareConfig(config)));
                            if (res._nextDay) {
                                res.add(1, "d");
                                res._nextDay = undefined;
                            }
                            return res;
                        }
                        function prepareConfig(config) {
                            var input = config._i,
                                format = config._f;
                            config._locale = config._locale || getLocale(config._l);
                            if (input === null || (format === undefined && input === "")) {
                                return createInvalid({ nullInput: true });
                            }
                            if (typeof input === "string") {
                                config._i = input = config._locale.preparse(input);
                            }
                            if (isMoment(input)) {
                                return new Moment(checkOverflow(input));
                            } else if (isDate(input)) {
                                config._d = input;
                            } else if (isArray(format)) {
                                configFromStringAndArray(config);
                            } else if (format) {
                                configFromStringAndFormat(config);
                            } else {
                                configFromInput(config);
                            }
                            if (!isValid(config)) {
                                config._d = null;
                            }
                            return config;
                        }
                        function configFromInput(config) {
                            var input = config._i;
                            if (isUndefined(input)) {
                                config._d = new Date(hooks.now());
                            } else if (isDate(input)) {
                                config._d = new Date(input.valueOf());
                            } else if (typeof input === "string") {
                                configFromString(config);
                            } else if (isArray(input)) {
                                config._a = map(input.slice(0), function (obj) {
                                    return parseInt(obj, 10);
                                });
                                configFromArray(config);
                            } else if (isObject(input)) {
                                configFromObject(config);
                            } else if (isNumber(input)) {
                                config._d = new Date(input);
                            } else {
                                hooks.createFromInputFallback(config);
                            }
                        }
                        function createLocalOrUTC(input, format, locale, strict, isUTC) {
                            var c = {};
                            if (format === true || format === false) {
                                strict = format;
                                format = undefined;
                            }
                            if (locale === true || locale === false) {
                                strict = locale;
                                locale = undefined;
                            }
                            if ((isObject(input) && isObjectEmpty(input)) || (isArray(input) && input.length === 0)) {
                                input = undefined;
                            }
                            c._isAMomentObject = true;
                            c._useUTC = c._isUTC = isUTC;
                            c._l = locale;
                            c._i = input;
                            c._f = format;
                            c._strict = strict;
                            return createFromConfig(c);
                        }
                        function createLocal(input, format, locale, strict) {
                            return createLocalOrUTC(input, format, locale, strict, false);
                        }
                        var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function () {
                                var other = createLocal.apply(null, arguments);
                                if (this.isValid() && other.isValid()) {
                                    return other < this ? this : other;
                                } else {
                                    return createInvalid();
                                }
                            }),
                            prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function () {
                                var other = createLocal.apply(null, arguments);
                                if (this.isValid() && other.isValid()) {
                                    return other > this ? this : other;
                                } else {
                                    return createInvalid();
                                }
                            });
                        function pickBy(fn, moments) {
                            var res, i;
                            if (moments.length === 1 && isArray(moments[0])) {
                                moments = moments[0];
                            }
                            if (!moments.length) {
                                return createLocal();
                            }
                            res = moments[0];
                            for (i = 1; i < moments.length; ++i) {
                                if (!moments[i].isValid() || moments[i][fn](res)) {
                                    res = moments[i];
                                }
                            }
                            return res;
                        }
                        function min() {
                            var args = [].slice.call(arguments, 0);
                            return pickBy("isBefore", args);
                        }
                        function max() {
                            var args = [].slice.call(arguments, 0);
                            return pickBy("isAfter", args);
                        }
                        var now = function () {
                            return Date.now ? Date.now() : +new Date();
                        };
                        var ordering = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];
                        function isDurationValid(m) {
                            var key,
                                unitHasDecimal = false,
                                i,
                                orderLen = ordering.length;
                            for (key in m) {
                                if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                                    return false;
                                }
                            }
                            for (i = 0; i < orderLen; ++i) {
                                if (m[ordering[i]]) {
                                    if (unitHasDecimal) {
                                        return false;
                                    }
                                    if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                                        unitHasDecimal = true;
                                    }
                                }
                            }
                            return true;
                        }
                        function isValid$1() {
                            return this._isValid;
                        }
                        function createInvalid$1() {
                            return createDuration(NaN);
                        }
                        function Duration(duration) {
                            var normalizedInput = normalizeObjectUnits(duration),
                                years = normalizedInput.year || 0,
                                quarters = normalizedInput.quarter || 0,
                                months = normalizedInput.month || 0,
                                weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
                                days = normalizedInput.day || 0,
                                hours = normalizedInput.hour || 0,
                                minutes = normalizedInput.minute || 0,
                                seconds = normalizedInput.second || 0,
                                milliseconds = normalizedInput.millisecond || 0;
                            this._isValid = isDurationValid(normalizedInput);
                            this._milliseconds = +milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 1e3 * 60 * 60;
                            this._days = +days + weeks * 7;
                            this._months = +months + quarters * 3 + years * 12;
                            this._data = {};
                            this._locale = getLocale();
                            this._bubble();
                        }
                        function isDuration(obj) {
                            return obj instanceof Duration;
                        }
                        function absRound(number) {
                            if (number < 0) {
                                return Math.round(-1 * number) * -1;
                            } else {
                                return Math.round(number);
                            }
                        }
                        function compareArrays(array1, array2, dontConvert) {
                            var len = Math.min(array1.length, array2.length),
                                lengthDiff = Math.abs(array1.length - array2.length),
                                diffs = 0,
                                i;
                            for (i = 0; i < len; i++) {
                                if ((dontConvert && array1[i] !== array2[i]) || (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                                    diffs++;
                                }
                            }
                            return diffs + lengthDiff;
                        }
                        function offset(token, separator) {
                            addFormatToken(token, 0, 0, function () {
                                var offset = this.utcOffset(),
                                    sign = "+";
                                if (offset < 0) {
                                    offset = -offset;
                                    sign = "-";
                                }
                                return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
                            });
                        }
                        offset("Z", ":");
                        offset("ZZ", "");
                        addRegexToken("Z", matchShortOffset);
                        addRegexToken("ZZ", matchShortOffset);
                        addParseToken(["Z", "ZZ"], function (input, array, config) {
                            config._useUTC = true;
                            config._tzm = offsetFromString(matchShortOffset, input);
                        });
                        var chunkOffset = /([\+\-]|\d\d)/gi;
                        function offsetFromString(matcher, string) {
                            var matches = (string || "").match(matcher),
                                chunk,
                                parts,
                                minutes;
                            if (matches === null) {
                                return null;
                            }
                            chunk = matches[matches.length - 1] || [];
                            parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
                            minutes = +(parts[1] * 60) + toInt(parts[2]);
                            return minutes === 0 ? 0 : parts[0] === "+" ? minutes : -minutes;
                        }
                        function cloneWithOffset(input, model) {
                            var res, diff;
                            if (model._isUTC) {
                                res = model.clone();
                                diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
                                res._d.setTime(res._d.valueOf() + diff);
                                hooks.updateOffset(res, false);
                                return res;
                            } else {
                                return createLocal(input).local();
                            }
                        }
                        function getDateOffset(m) {
                            return -Math.round(m._d.getTimezoneOffset());
                        }
                        hooks.updateOffset = function () {};
                        function getSetOffset(input, keepLocalTime, keepMinutes) {
                            var offset = this._offset || 0,
                                localAdjust;
                            if (!this.isValid()) {
                                return input != null ? this : NaN;
                            }
                            if (input != null) {
                                if (typeof input === "string") {
                                    input = offsetFromString(matchShortOffset, input);
                                    if (input === null) {
                                        return this;
                                    }
                                } else if (Math.abs(input) < 16 && !keepMinutes) {
                                    input = input * 60;
                                }
                                if (!this._isUTC && keepLocalTime) {
                                    localAdjust = getDateOffset(this);
                                }
                                this._offset = input;
                                this._isUTC = true;
                                if (localAdjust != null) {
                                    this.add(localAdjust, "m");
                                }
                                if (offset !== input) {
                                    if (!keepLocalTime || this._changeInProgress) {
                                        addSubtract(this, createDuration(input - offset, "m"), 1, false);
                                    } else if (!this._changeInProgress) {
                                        this._changeInProgress = true;
                                        hooks.updateOffset(this, true);
                                        this._changeInProgress = null;
                                    }
                                }
                                return this;
                            } else {
                                return this._isUTC ? offset : getDateOffset(this);
                            }
                        }
                        function getSetZone(input, keepLocalTime) {
                            if (input != null) {
                                if (typeof input !== "string") {
                                    input = -input;
                                }
                                this.utcOffset(input, keepLocalTime);
                                return this;
                            } else {
                                return -this.utcOffset();
                            }
                        }
                        function setOffsetToUTC(keepLocalTime) {
                            return this.utcOffset(0, keepLocalTime);
                        }
                        function setOffsetToLocal(keepLocalTime) {
                            if (this._isUTC) {
                                this.utcOffset(0, keepLocalTime);
                                this._isUTC = false;
                                if (keepLocalTime) {
                                    this.subtract(getDateOffset(this), "m");
                                }
                            }
                            return this;
                        }
                        function setOffsetToParsedOffset() {
                            if (this._tzm != null) {
                                this.utcOffset(this._tzm, false, true);
                            } else if (typeof this._i === "string") {
                                var tZone = offsetFromString(matchOffset, this._i);
                                if (tZone != null) {
                                    this.utcOffset(tZone);
                                } else {
                                    this.utcOffset(0, true);
                                }
                            }
                            return this;
                        }
                        function hasAlignedHourOffset(input) {
                            if (!this.isValid()) {
                                return false;
                            }
                            input = input ? createLocal(input).utcOffset() : 0;
                            return (this.utcOffset() - input) % 60 === 0;
                        }
                        function isDaylightSavingTime() {
                            return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
                        }
                        function isDaylightSavingTimeShifted() {
                            if (!isUndefined(this._isDSTShifted)) {
                                return this._isDSTShifted;
                            }
                            var c = {},
                                other;
                            copyConfig(c, this);
                            c = prepareConfig(c);
                            if (c._a) {
                                other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
                                this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
                            } else {
                                this._isDSTShifted = false;
                            }
                            return this._isDSTShifted;
                        }
                        function isLocal() {
                            return this.isValid() ? !this._isUTC : false;
                        }
                        function isUtcOffset() {
                            return this.isValid() ? this._isUTC : false;
                        }
                        function isUtc() {
                            return this.isValid() ? this._isUTC && this._offset === 0 : false;
                        }
                        var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
                            isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
                        function createDuration(input, key) {
                            var duration = input,
                                match = null,
                                sign,
                                ret,
                                diffRes;
                            if (isDuration(input)) {
                                duration = { ms: input._milliseconds, d: input._days, M: input._months };
                            } else if (isNumber(input) || !isNaN(+input)) {
                                duration = {};
                                if (key) {
                                    duration[key] = +input;
                                } else {
                                    duration.milliseconds = +input;
                                }
                            } else if ((match = aspNetRegex.exec(input))) {
                                sign = match[1] === "-" ? -1 : 1;
                                duration = { y: 0, d: toInt(match[DATE]) * sign, h: toInt(match[HOUR]) * sign, m: toInt(match[MINUTE]) * sign, s: toInt(match[SECOND]) * sign, ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign };
                            } else if ((match = isoRegex.exec(input))) {
                                sign = match[1] === "-" ? -1 : 1;
                                duration = {
                                    y: parseIso(match[2], sign),
                                    M: parseIso(match[3], sign),
                                    w: parseIso(match[4], sign),
                                    d: parseIso(match[5], sign),
                                    h: parseIso(match[6], sign),
                                    m: parseIso(match[7], sign),
                                    s: parseIso(match[8], sign),
                                };
                            } else if (duration == null) {
                                duration = {};
                            } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
                                diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
                                duration = {};
                                duration.ms = diffRes.milliseconds;
                                duration.M = diffRes.months;
                            }
                            ret = new Duration(duration);
                            if (isDuration(input) && hasOwnProp(input, "_locale")) {
                                ret._locale = input._locale;
                            }
                            if (isDuration(input) && hasOwnProp(input, "_isValid")) {
                                ret._isValid = input._isValid;
                            }
                            return ret;
                        }
                        createDuration.fn = Duration.prototype;
                        createDuration.invalid = createInvalid$1;
                        function parseIso(inp, sign) {
                            var res = inp && parseFloat(inp.replace(",", "."));
                            return (isNaN(res) ? 0 : res) * sign;
                        }
                        function positiveMomentsDifference(base, other) {
                            var res = {};
                            res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
                            if (base.clone().add(res.months, "M").isAfter(other)) {
                                --res.months;
                            }
                            res.milliseconds = +other - +base.clone().add(res.months, "M");
                            return res;
                        }
                        function momentsDifference(base, other) {
                            var res;
                            if (!(base.isValid() && other.isValid())) {
                                return { milliseconds: 0, months: 0 };
                            }
                            other = cloneWithOffset(other, base);
                            if (base.isBefore(other)) {
                                res = positiveMomentsDifference(base, other);
                            } else {
                                res = positiveMomentsDifference(other, base);
                                res.milliseconds = -res.milliseconds;
                                res.months = -res.months;
                            }
                            return res;
                        }
                        function createAdder(direction, name) {
                            return function (val, period) {
                                var dur, tmp;
                                if (period !== null && !isNaN(+period)) {
                                    deprecateSimple(
                                        name,
                                        "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). " + "See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
                                    );
                                    tmp = val;
                                    val = period;
                                    period = tmp;
                                }
                                dur = createDuration(val, period);
                                addSubtract(this, dur, direction);
                                return this;
                            };
                        }
                        function addSubtract(mom, duration, isAdding, updateOffset) {
                            var milliseconds = duration._milliseconds,
                                days = absRound(duration._days),
                                months = absRound(duration._months);
                            if (!mom.isValid()) {
                                return;
                            }
                            updateOffset = updateOffset == null ? true : updateOffset;
                            if (months) {
                                setMonth(mom, get(mom, "Month") + months * isAdding);
                            }
                            if (days) {
                                set$1(mom, "Date", get(mom, "Date") + days * isAdding);
                            }
                            if (milliseconds) {
                                mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
                            }
                            if (updateOffset) {
                                hooks.updateOffset(mom, days || months);
                            }
                        }
                        var add = createAdder(1, "add"),
                            subtract = createAdder(-1, "subtract");
                        function isString(input) {
                            return typeof input === "string" || input instanceof String;
                        }
                        function isMomentInput(input) {
                            return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === undefined;
                        }
                        function isMomentInputObject(input) {
                            var objectTest = isObject(input) && !isObjectEmpty(input),
                                propertyTest = false,
                                properties = [
                                    "years",
                                    "year",
                                    "y",
                                    "months",
                                    "month",
                                    "M",
                                    "days",
                                    "day",
                                    "d",
                                    "dates",
                                    "date",
                                    "D",
                                    "hours",
                                    "hour",
                                    "h",
                                    "minutes",
                                    "minute",
                                    "m",
                                    "seconds",
                                    "second",
                                    "s",
                                    "milliseconds",
                                    "millisecond",
                                    "ms",
                                ],
                                i,
                                property,
                                propertyLen = properties.length;
                            for (i = 0; i < propertyLen; i += 1) {
                                property = properties[i];
                                propertyTest = propertyTest || hasOwnProp(input, property);
                            }
                            return objectTest && propertyTest;
                        }
                        function isNumberOrStringArray(input) {
                            var arrayTest = isArray(input),
                                dataTypeTest = false;
                            if (arrayTest) {
                                dataTypeTest =
                                    input.filter(function (item) {
                                        return !isNumber(item) && isString(input);
                                    }).length === 0;
                            }
                            return arrayTest && dataTypeTest;
                        }
                        function isCalendarSpec(input) {
                            var objectTest = isObject(input) && !isObjectEmpty(input),
                                propertyTest = false,
                                properties = ["sameDay", "nextDay", "lastDay", "nextWeek", "lastWeek", "sameElse"],
                                i,
                                property;
                            for (i = 0; i < properties.length; i += 1) {
                                property = properties[i];
                                propertyTest = propertyTest || hasOwnProp(input, property);
                            }
                            return objectTest && propertyTest;
                        }
                        function getCalendarFormat(myMoment, now) {
                            var diff = myMoment.diff(now, "days", true);
                            return diff < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse";
                        }
                        function calendar$1(time, formats) {
                            if (arguments.length === 1) {
                                if (!arguments[0]) {
                                    time = undefined;
                                    formats = undefined;
                                } else if (isMomentInput(arguments[0])) {
                                    time = arguments[0];
                                    formats = undefined;
                                } else if (isCalendarSpec(arguments[0])) {
                                    formats = arguments[0];
                                    time = undefined;
                                }
                            }
                            var now = time || createLocal(),
                                sod = cloneWithOffset(now, this).startOf("day"),
                                format = hooks.calendarFormat(this, sod) || "sameElse",
                                output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
                            return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
                        }
                        function clone() {
                            return new Moment(this);
                        }
                        function isAfter(input, units) {
                            var localInput = isMoment(input) ? input : createLocal(input);
                            if (!(this.isValid() && localInput.isValid())) {
                                return false;
                            }
                            units = normalizeUnits(units) || "millisecond";
                            if (units === "millisecond") {
                                return this.valueOf() > localInput.valueOf();
                            } else {
                                return localInput.valueOf() < this.clone().startOf(units).valueOf();
                            }
                        }
                        function isBefore(input, units) {
                            var localInput = isMoment(input) ? input : createLocal(input);
                            if (!(this.isValid() && localInput.isValid())) {
                                return false;
                            }
                            units = normalizeUnits(units) || "millisecond";
                            if (units === "millisecond") {
                                return this.valueOf() < localInput.valueOf();
                            } else {
                                return this.clone().endOf(units).valueOf() < localInput.valueOf();
                            }
                        }
                        function isBetween(from, to, units, inclusivity) {
                            var localFrom = isMoment(from) ? from : createLocal(from),
                                localTo = isMoment(to) ? to : createLocal(to);
                            if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
                                return false;
                            }
                            inclusivity = inclusivity || "()";
                            return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
                        }
                        function isSame(input, units) {
                            var localInput = isMoment(input) ? input : createLocal(input),
                                inputMs;
                            if (!(this.isValid() && localInput.isValid())) {
                                return false;
                            }
                            units = normalizeUnits(units) || "millisecond";
                            if (units === "millisecond") {
                                return this.valueOf() === localInput.valueOf();
                            } else {
                                inputMs = localInput.valueOf();
                                return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
                            }
                        }
                        function isSameOrAfter(input, units) {
                            return this.isSame(input, units) || this.isAfter(input, units);
                        }
                        function isSameOrBefore(input, units) {
                            return this.isSame(input, units) || this.isBefore(input, units);
                        }
                        function diff(input, units, asFloat) {
                            var that, zoneDelta, output;
                            if (!this.isValid()) {
                                return NaN;
                            }
                            that = cloneWithOffset(input, this);
                            if (!that.isValid()) {
                                return NaN;
                            }
                            zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
                            units = normalizeUnits(units);
                            switch (units) {
                                case "year":
                                    output = monthDiff(this, that) / 12;
                                    break;
                                case "month":
                                    output = monthDiff(this, that);
                                    break;
                                case "quarter":
                                    output = monthDiff(this, that) / 3;
                                    break;
                                case "second":
                                    output = (this - that) / 1e3;
                                    break;
                                case "minute":
                                    output = (this - that) / 6e4;
                                    break;
                                case "hour":
                                    output = (this - that) / 36e5;
                                    break;
                                case "day":
                                    output = (this - that - zoneDelta) / 864e5;
                                    break;
                                case "week":
                                    output = (this - that - zoneDelta) / 6048e5;
                                    break;
                                default:
                                    output = this - that;
                            }
                            return asFloat ? output : absFloor(output);
                        }
                        function monthDiff(a, b) {
                            if (a.date() < b.date()) {
                                return -monthDiff(b, a);
                            }
                            var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
                                anchor = a.clone().add(wholeMonthDiff, "months"),
                                anchor2,
                                adjust;
                            if (b - anchor < 0) {
                                anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
                                adjust = (b - anchor) / (anchor - anchor2);
                            } else {
                                anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
                                adjust = (b - anchor) / (anchor2 - anchor);
                            }
                            return -(wholeMonthDiff + adjust) || 0;
                        }
                        hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
                        hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
                        function toString() {
                            return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
                        }
                        function toISOString(keepOffset) {
                            if (!this.isValid()) {
                                return null;
                            }
                            var utc = keepOffset !== true,
                                m = utc ? this.clone().utc() : this;
                            if (m.year() < 0 || m.year() > 9999) {
                                return formatMoment(m, utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ");
                            }
                            if (isFunction(Date.prototype.toISOString)) {
                                if (utc) {
                                    return this.toDate().toISOString();
                                } else {
                                    return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
                                }
                            }
                            return formatMoment(m, utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
                        }
                        function inspect() {
                            if (!this.isValid()) {
                                return "moment.invalid(/* " + this._i + " */)";
                            }
                            var func = "moment",
                                zone = "",
                                prefix,
                                year,
                                datetime,
                                suffix;
                            if (!this.isLocal()) {
                                func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
                                zone = "Z";
                            }
                            prefix = "[" + func + '("]';
                            year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
                            datetime = "-MM-DD[T]HH:mm:ss.SSS";
                            suffix = zone + '[")]';
                            return this.format(prefix + year + datetime + suffix);
                        }
                        function format(inputString) {
                            if (!inputString) {
                                inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
                            }
                            var output = formatMoment(this, inputString);
                            return this.localeData().postformat(output);
                        }
                        function from(time, withoutSuffix) {
                            if (this.isValid() && ((isMoment(time) && time.isValid()) || createLocal(time).isValid())) {
                                return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
                            } else {
                                return this.localeData().invalidDate();
                            }
                        }
                        function fromNow(withoutSuffix) {
                            return this.from(createLocal(), withoutSuffix);
                        }
                        function to(time, withoutSuffix) {
                            if (this.isValid() && ((isMoment(time) && time.isValid()) || createLocal(time).isValid())) {
                                return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
                            } else {
                                return this.localeData().invalidDate();
                            }
                        }
                        function toNow(withoutSuffix) {
                            return this.to(createLocal(), withoutSuffix);
                        }
                        function locale(key) {
                            var newLocaleData;
                            if (key === undefined) {
                                return this._locale._abbr;
                            } else {
                                newLocaleData = getLocale(key);
                                if (newLocaleData != null) {
                                    this._locale = newLocaleData;
                                }
                                return this;
                            }
                        }
                        var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function (key) {
                            if (key === undefined) {
                                return this.localeData();
                            } else {
                                return this.locale(key);
                            }
                        });
                        function localeData() {
                            return this._locale;
                        }
                        var MS_PER_SECOND = 1e3,
                            MS_PER_MINUTE = 60 * MS_PER_SECOND,
                            MS_PER_HOUR = 60 * MS_PER_MINUTE,
                            MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
                        function mod$1(dividend, divisor) {
                            return ((dividend % divisor) + divisor) % divisor;
                        }
                        function localStartOfDate(y, m, d) {
                            if (y < 100 && y >= 0) {
                                return new Date(y + 400, m, d) - MS_PER_400_YEARS;
                            } else {
                                return new Date(y, m, d).valueOf();
                            }
                        }
                        function utcStartOfDate(y, m, d) {
                            if (y < 100 && y >= 0) {
                                return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
                            } else {
                                return Date.UTC(y, m, d);
                            }
                        }
                        function startOf(units) {
                            var time, startOfDate;
                            units = normalizeUnits(units);
                            if (units === undefined || units === "millisecond" || !this.isValid()) {
                                return this;
                            }
                            startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
                            switch (units) {
                                case "year":
                                    time = startOfDate(this.year(), 0, 1);
                                    break;
                                case "quarter":
                                    time = startOfDate(this.year(), this.month() - (this.month() % 3), 1);
                                    break;
                                case "month":
                                    time = startOfDate(this.year(), this.month(), 1);
                                    break;
                                case "week":
                                    time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
                                    break;
                                case "isoWeek":
                                    time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
                                    break;
                                case "day":
                                case "date":
                                    time = startOfDate(this.year(), this.month(), this.date());
                                    break;
                                case "hour":
                                    time = this._d.valueOf();
                                    time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
                                    break;
                                case "minute":
                                    time = this._d.valueOf();
                                    time -= mod$1(time, MS_PER_MINUTE);
                                    break;
                                case "second":
                                    time = this._d.valueOf();
                                    time -= mod$1(time, MS_PER_SECOND);
                                    break;
                            }
                            this._d.setTime(time);
                            hooks.updateOffset(this, true);
                            return this;
                        }
                        function endOf(units) {
                            var time, startOfDate;
                            units = normalizeUnits(units);
                            if (units === undefined || units === "millisecond" || !this.isValid()) {
                                return this;
                            }
                            startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
                            switch (units) {
                                case "year":
                                    time = startOfDate(this.year() + 1, 0, 1) - 1;
                                    break;
                                case "quarter":
                                    time = startOfDate(this.year(), this.month() - (this.month() % 3) + 3, 1) - 1;
                                    break;
                                case "month":
                                    time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                                    break;
                                case "week":
                                    time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
                                    break;
                                case "isoWeek":
                                    time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
                                    break;
                                case "day":
                                case "date":
                                    time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                                    break;
                                case "hour":
                                    time = this._d.valueOf();
                                    time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
                                    break;
                                case "minute":
                                    time = this._d.valueOf();
                                    time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                                    break;
                                case "second":
                                    time = this._d.valueOf();
                                    time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                                    break;
                            }
                            this._d.setTime(time);
                            hooks.updateOffset(this, true);
                            return this;
                        }
                        function valueOf() {
                            return this._d.valueOf() - (this._offset || 0) * 6e4;
                        }
                        function unix() {
                            return Math.floor(this.valueOf() / 1e3);
                        }
                        function toDate() {
                            return new Date(this.valueOf());
                        }
                        function toArray() {
                            var m = this;
                            return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
                        }
                        function toObject() {
                            var m = this;
                            return { years: m.year(), months: m.month(), date: m.date(), hours: m.hours(), minutes: m.minutes(), seconds: m.seconds(), milliseconds: m.milliseconds() };
                        }
                        function toJSON() {
                            return this.isValid() ? this.toISOString() : null;
                        }
                        function isValid$2() {
                            return isValid(this);
                        }
                        function parsingFlags() {
                            return extend({}, getParsingFlags(this));
                        }
                        function invalidAt() {
                            return getParsingFlags(this).overflow;
                        }
                        function creationData() {
                            return { input: this._i, format: this._f, locale: this._locale, isUTC: this._isUTC, strict: this._strict };
                        }
                        addFormatToken("N", 0, 0, "eraAbbr");
                        addFormatToken("NN", 0, 0, "eraAbbr");
                        addFormatToken("NNN", 0, 0, "eraAbbr");
                        addFormatToken("NNNN", 0, 0, "eraName");
                        addFormatToken("NNNNN", 0, 0, "eraNarrow");
                        addFormatToken("y", ["y", 1], "yo", "eraYear");
                        addFormatToken("y", ["yy", 2], 0, "eraYear");
                        addFormatToken("y", ["yyy", 3], 0, "eraYear");
                        addFormatToken("y", ["yyyy", 4], 0, "eraYear");
                        addRegexToken("N", matchEraAbbr);
                        addRegexToken("NN", matchEraAbbr);
                        addRegexToken("NNN", matchEraAbbr);
                        addRegexToken("NNNN", matchEraName);
                        addRegexToken("NNNNN", matchEraNarrow);
                        addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function (input, array, config, token) {
                            var era = config._locale.erasParse(input, token, config._strict);
                            if (era) {
                                getParsingFlags(config).era = era;
                            } else {
                                getParsingFlags(config).invalidEra = input;
                            }
                        });
                        addRegexToken("y", matchUnsigned);
                        addRegexToken("yy", matchUnsigned);
                        addRegexToken("yyy", matchUnsigned);
                        addRegexToken("yyyy", matchUnsigned);
                        addRegexToken("yo", matchEraYearOrdinal);
                        addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
                        addParseToken(["yo"], function (input, array, config, token) {
                            var match;
                            if (config._locale._eraYearOrdinalRegex) {
                                match = input.match(config._locale._eraYearOrdinalRegex);
                            }
                            if (config._locale.eraYearOrdinalParse) {
                                array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
                            } else {
                                array[YEAR] = parseInt(input, 10);
                            }
                        });
                        function localeEras(m, format) {
                            var i,
                                l,
                                date,
                                eras = this._eras || getLocale("en")._eras;
                            for (i = 0, l = eras.length; i < l; ++i) {
                                switch (typeof eras[i].since) {
                                    case "string":
                                        date = hooks(eras[i].since).startOf("day");
                                        eras[i].since = date.valueOf();
                                        break;
                                }
                                switch (typeof eras[i].until) {
                                    case "undefined":
                                        eras[i].until = +Infinity;
                                        break;
                                    case "string":
                                        date = hooks(eras[i].until).startOf("day").valueOf();
                                        eras[i].until = date.valueOf();
                                        break;
                                }
                            }
                            return eras;
                        }
                        function localeErasParse(eraName, format, strict) {
                            var i,
                                l,
                                eras = this.eras(),
                                name,
                                abbr,
                                narrow;
                            eraName = eraName.toUpperCase();
                            for (i = 0, l = eras.length; i < l; ++i) {
                                name = eras[i].name.toUpperCase();
                                abbr = eras[i].abbr.toUpperCase();
                                narrow = eras[i].narrow.toUpperCase();
                                if (strict) {
                                    switch (format) {
                                        case "N":
                                        case "NN":
                                        case "NNN":
                                            if (abbr === eraName) {
                                                return eras[i];
                                            }
                                            break;
                                        case "NNNN":
                                            if (name === eraName) {
                                                return eras[i];
                                            }
                                            break;
                                        case "NNNNN":
                                            if (narrow === eraName) {
                                                return eras[i];
                                            }
                                            break;
                                    }
                                } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
                                    return eras[i];
                                }
                            }
                        }
                        function localeErasConvertYear(era, year) {
                            var dir = era.since <= era.until ? +1 : -1;
                            if (year === undefined) {
                                return hooks(era.since).year();
                            } else {
                                return hooks(era.since).year() + (year - era.offset) * dir;
                            }
                        }
                        function getEraName() {
                            var i,
                                l,
                                val,
                                eras = this.localeData().eras();
                            for (i = 0, l = eras.length; i < l; ++i) {
                                val = this.clone().startOf("day").valueOf();
                                if (eras[i].since <= val && val <= eras[i].until) {
                                    return eras[i].name;
                                }
                                if (eras[i].until <= val && val <= eras[i].since) {
                                    return eras[i].name;
                                }
                            }
                            return "";
                        }
                        function getEraNarrow() {
                            var i,
                                l,
                                val,
                                eras = this.localeData().eras();
                            for (i = 0, l = eras.length; i < l; ++i) {
                                val = this.clone().startOf("day").valueOf();
                                if (eras[i].since <= val && val <= eras[i].until) {
                                    return eras[i].narrow;
                                }
                                if (eras[i].until <= val && val <= eras[i].since) {
                                    return eras[i].narrow;
                                }
                            }
                            return "";
                        }
                        function getEraAbbr() {
                            var i,
                                l,
                                val,
                                eras = this.localeData().eras();
                            for (i = 0, l = eras.length; i < l; ++i) {
                                val = this.clone().startOf("day").valueOf();
                                if (eras[i].since <= val && val <= eras[i].until) {
                                    return eras[i].abbr;
                                }
                                if (eras[i].until <= val && val <= eras[i].since) {
                                    return eras[i].abbr;
                                }
                            }
                            return "";
                        }
                        function getEraYear() {
                            var i,
                                l,
                                dir,
                                val,
                                eras = this.localeData().eras();
                            for (i = 0, l = eras.length; i < l; ++i) {
                                dir = eras[i].since <= eras[i].until ? +1 : -1;
                                val = this.clone().startOf("day").valueOf();
                                if ((eras[i].since <= val && val <= eras[i].until) || (eras[i].until <= val && val <= eras[i].since)) {
                                    return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
                                }
                            }
                            return this.year();
                        }
                        function erasNameRegex(isStrict) {
                            if (!hasOwnProp(this, "_erasNameRegex")) {
                                computeErasParse.call(this);
                            }
                            return isStrict ? this._erasNameRegex : this._erasRegex;
                        }
                        function erasAbbrRegex(isStrict) {
                            if (!hasOwnProp(this, "_erasAbbrRegex")) {
                                computeErasParse.call(this);
                            }
                            return isStrict ? this._erasAbbrRegex : this._erasRegex;
                        }
                        function erasNarrowRegex(isStrict) {
                            if (!hasOwnProp(this, "_erasNarrowRegex")) {
                                computeErasParse.call(this);
                            }
                            return isStrict ? this._erasNarrowRegex : this._erasRegex;
                        }
                        function matchEraAbbr(isStrict, locale) {
                            return locale.erasAbbrRegex(isStrict);
                        }
                        function matchEraName(isStrict, locale) {
                            return locale.erasNameRegex(isStrict);
                        }
                        function matchEraNarrow(isStrict, locale) {
                            return locale.erasNarrowRegex(isStrict);
                        }
                        function matchEraYearOrdinal(isStrict, locale) {
                            return locale._eraYearOrdinalRegex || matchUnsigned;
                        }
                        function computeErasParse() {
                            var abbrPieces = [],
                                namePieces = [],
                                narrowPieces = [],
                                mixedPieces = [],
                                i,
                                l,
                                eras = this.eras();
                            for (i = 0, l = eras.length; i < l; ++i) {
                                namePieces.push(regexEscape(eras[i].name));
                                abbrPieces.push(regexEscape(eras[i].abbr));
                                narrowPieces.push(regexEscape(eras[i].narrow));
                                mixedPieces.push(regexEscape(eras[i].name));
                                mixedPieces.push(regexEscape(eras[i].abbr));
                                mixedPieces.push(regexEscape(eras[i].narrow));
                            }
                            this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
                            this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
                            this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
                            this._erasNarrowRegex = new RegExp("^(" + narrowPieces.join("|") + ")", "i");
                        }
                        addFormatToken(0, ["gg", 2], 0, function () {
                            return this.weekYear() % 100;
                        });
                        addFormatToken(0, ["GG", 2], 0, function () {
                            return this.isoWeekYear() % 100;
                        });
                        function addWeekYearFormatToken(token, getter) {
                            addFormatToken(0, [token, token.length], 0, getter);
                        }
                        addWeekYearFormatToken("gggg", "weekYear");
                        addWeekYearFormatToken("ggggg", "weekYear");
                        addWeekYearFormatToken("GGGG", "isoWeekYear");
                        addWeekYearFormatToken("GGGGG", "isoWeekYear");
                        addUnitAlias("weekYear", "gg");
                        addUnitAlias("isoWeekYear", "GG");
                        addUnitPriority("weekYear", 1);
                        addUnitPriority("isoWeekYear", 1);
                        addRegexToken("G", matchSigned);
                        addRegexToken("g", matchSigned);
                        addRegexToken("GG", match1to2, match2);
                        addRegexToken("gg", match1to2, match2);
                        addRegexToken("GGGG", match1to4, match4);
                        addRegexToken("gggg", match1to4, match4);
                        addRegexToken("GGGGG", match1to6, match6);
                        addRegexToken("ggggg", match1to6, match6);
                        addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function (input, week, config, token) {
                            week[token.substr(0, 2)] = toInt(input);
                        });
                        addWeekParseToken(["gg", "GG"], function (input, week, config, token) {
                            week[token] = hooks.parseTwoDigitYear(input);
                        });
                        function getSetWeekYear(input) {
                            return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
                        }
                        function getSetISOWeekYear(input) {
                            return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
                        }
                        function getISOWeeksInYear() {
                            return weeksInYear(this.year(), 1, 4);
                        }
                        function getISOWeeksInISOWeekYear() {
                            return weeksInYear(this.isoWeekYear(), 1, 4);
                        }
                        function getWeeksInYear() {
                            var weekInfo = this.localeData()._week;
                            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
                        }
                        function getWeeksInWeekYear() {
                            var weekInfo = this.localeData()._week;
                            return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
                        }
                        function getSetWeekYearHelper(input, week, weekday, dow, doy) {
                            var weeksTarget;
                            if (input == null) {
                                return weekOfYear(this, dow, doy).year;
                            } else {
                                weeksTarget = weeksInYear(input, dow, doy);
                                if (week > weeksTarget) {
                                    week = weeksTarget;
                                }
                                return setWeekAll.call(this, input, week, weekday, dow, doy);
                            }
                        }
                        function setWeekAll(weekYear, week, weekday, dow, doy) {
                            var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
                                date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
                            this.year(date.getUTCFullYear());
                            this.month(date.getUTCMonth());
                            this.date(date.getUTCDate());
                            return this;
                        }
                        addFormatToken("Q", 0, "Qo", "quarter");
                        addUnitAlias("quarter", "Q");
                        addUnitPriority("quarter", 7);
                        addRegexToken("Q", match1);
                        addParseToken("Q", function (input, array) {
                            array[MONTH] = (toInt(input) - 1) * 3;
                        });
                        function getSetQuarter(input) {
                            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + (this.month() % 3));
                        }
                        addFormatToken("D", ["DD", 2], "Do", "date");
                        addUnitAlias("date", "D");
                        addUnitPriority("date", 9);
                        addRegexToken("D", match1to2);
                        addRegexToken("DD", match1to2, match2);
                        addRegexToken("Do", function (isStrict, locale) {
                            return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
                        });
                        addParseToken(["D", "DD"], DATE);
                        addParseToken("Do", function (input, array) {
                            array[DATE] = toInt(input.match(match1to2)[0]);
                        });
                        var getSetDayOfMonth = makeGetSet("Date", true);
                        addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
                        addUnitAlias("dayOfYear", "DDD");
                        addUnitPriority("dayOfYear", 4);
                        addRegexToken("DDD", match1to3);
                        addRegexToken("DDDD", match3);
                        addParseToken(["DDD", "DDDD"], function (input, array, config) {
                            config._dayOfYear = toInt(input);
                        });
                        function getSetDayOfYear(input) {
                            var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
                            return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
                        }
                        addFormatToken("m", ["mm", 2], 0, "minute");
                        addUnitAlias("minute", "m");
                        addUnitPriority("minute", 14);
                        addRegexToken("m", match1to2);
                        addRegexToken("mm", match1to2, match2);
                        addParseToken(["m", "mm"], MINUTE);
                        var getSetMinute = makeGetSet("Minutes", false);
                        addFormatToken("s", ["ss", 2], 0, "second");
                        addUnitAlias("second", "s");
                        addUnitPriority("second", 15);
                        addRegexToken("s", match1to2);
                        addRegexToken("ss", match1to2, match2);
                        addParseToken(["s", "ss"], SECOND);
                        var getSetSecond = makeGetSet("Seconds", false);
                        addFormatToken("S", 0, 0, function () {
                            return ~~(this.millisecond() / 100);
                        });
                        addFormatToken(0, ["SS", 2], 0, function () {
                            return ~~(this.millisecond() / 10);
                        });
                        addFormatToken(0, ["SSS", 3], 0, "millisecond");
                        addFormatToken(0, ["SSSS", 4], 0, function () {
                            return this.millisecond() * 10;
                        });
                        addFormatToken(0, ["SSSSS", 5], 0, function () {
                            return this.millisecond() * 100;
                        });
                        addFormatToken(0, ["SSSSSS", 6], 0, function () {
                            return this.millisecond() * 1e3;
                        });
                        addFormatToken(0, ["SSSSSSS", 7], 0, function () {
                            return this.millisecond() * 1e4;
                        });
                        addFormatToken(0, ["SSSSSSSS", 8], 0, function () {
                            return this.millisecond() * 1e5;
                        });
                        addFormatToken(0, ["SSSSSSSSS", 9], 0, function () {
                            return this.millisecond() * 1e6;
                        });
                        addUnitAlias("millisecond", "ms");
                        addUnitPriority("millisecond", 16);
                        addRegexToken("S", match1to3, match1);
                        addRegexToken("SS", match1to3, match2);
                        addRegexToken("SSS", match1to3, match3);
                        var token, getSetMillisecond;
                        for (token = "SSSS"; token.length <= 9; token += "S") {
                            addRegexToken(token, matchUnsigned);
                        }
                        function parseMs(input, array) {
                            array[MILLISECOND] = toInt(("0." + input) * 1e3);
                        }
                        for (token = "S"; token.length <= 9; token += "S") {
                            addParseToken(token, parseMs);
                        }
                        getSetMillisecond = makeGetSet("Milliseconds", false);
                        addFormatToken("z", 0, 0, "zoneAbbr");
                        addFormatToken("zz", 0, 0, "zoneName");
                        function getZoneAbbr() {
                            return this._isUTC ? "UTC" : "";
                        }
                        function getZoneName() {
                            return this._isUTC ? "Coordinated Universal Time" : "";
                        }
                        var proto = Moment.prototype;
                        proto.add = add;
                        proto.calendar = calendar$1;
                        proto.clone = clone;
                        proto.diff = diff;
                        proto.endOf = endOf;
                        proto.format = format;
                        proto.from = from;
                        proto.fromNow = fromNow;
                        proto.to = to;
                        proto.toNow = toNow;
                        proto.get = stringGet;
                        proto.invalidAt = invalidAt;
                        proto.isAfter = isAfter;
                        proto.isBefore = isBefore;
                        proto.isBetween = isBetween;
                        proto.isSame = isSame;
                        proto.isSameOrAfter = isSameOrAfter;
                        proto.isSameOrBefore = isSameOrBefore;
                        proto.isValid = isValid$2;
                        proto.lang = lang;
                        proto.locale = locale;
                        proto.localeData = localeData;
                        proto.max = prototypeMax;
                        proto.min = prototypeMin;
                        proto.parsingFlags = parsingFlags;
                        proto.set = stringSet;
                        proto.startOf = startOf;
                        proto.subtract = subtract;
                        proto.toArray = toArray;
                        proto.toObject = toObject;
                        proto.toDate = toDate;
                        proto.toISOString = toISOString;
                        proto.inspect = inspect;
                        if (typeof Symbol !== "undefined" && Symbol.for != null) {
                            proto[Symbol.for("nodejs.util.inspect.custom")] = function () {
                                return "Moment<" + this.format() + ">";
                            };
                        }
                        proto.toJSON = toJSON;
                        proto.toString = toString;
                        proto.unix = unix;
                        proto.valueOf = valueOf;
                        proto.creationData = creationData;
                        proto.eraName = getEraName;
                        proto.eraNarrow = getEraNarrow;
                        proto.eraAbbr = getEraAbbr;
                        proto.eraYear = getEraYear;
                        proto.year = getSetYear;
                        proto.isLeapYear = getIsLeapYear;
                        proto.weekYear = getSetWeekYear;
                        proto.isoWeekYear = getSetISOWeekYear;
                        proto.quarter = proto.quarters = getSetQuarter;
                        proto.month = getSetMonth;
                        proto.daysInMonth = getDaysInMonth;
                        proto.week = proto.weeks = getSetWeek;
                        proto.isoWeek = proto.isoWeeks = getSetISOWeek;
                        proto.weeksInYear = getWeeksInYear;
                        proto.weeksInWeekYear = getWeeksInWeekYear;
                        proto.isoWeeksInYear = getISOWeeksInYear;
                        proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
                        proto.date = getSetDayOfMonth;
                        proto.day = proto.days = getSetDayOfWeek;
                        proto.weekday = getSetLocaleDayOfWeek;
                        proto.isoWeekday = getSetISODayOfWeek;
                        proto.dayOfYear = getSetDayOfYear;
                        proto.hour = proto.hours = getSetHour;
                        proto.minute = proto.minutes = getSetMinute;
                        proto.second = proto.seconds = getSetSecond;
                        proto.millisecond = proto.milliseconds = getSetMillisecond;
                        proto.utcOffset = getSetOffset;
                        proto.utc = setOffsetToUTC;
                        proto.local = setOffsetToLocal;
                        proto.parseZone = setOffsetToParsedOffset;
                        proto.hasAlignedHourOffset = hasAlignedHourOffset;
                        proto.isDST = isDaylightSavingTime;
                        proto.isLocal = isLocal;
                        proto.isUtcOffset = isUtcOffset;
                        proto.isUtc = isUtc;
                        proto.isUTC = isUtc;
                        proto.zoneAbbr = getZoneAbbr;
                        proto.zoneName = getZoneName;
                        proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
                        proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
                        proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
                        proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone);
                        proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
                        function createUnix(input) {
                            return createLocal(input * 1e3);
                        }
                        function createInZone() {
                            return createLocal.apply(null, arguments).parseZone();
                        }
                        function preParsePostFormat(string) {
                            return string;
                        }
                        var proto$1 = Locale.prototype;
                        proto$1.calendar = calendar;
                        proto$1.longDateFormat = longDateFormat;
                        proto$1.invalidDate = invalidDate;
                        proto$1.ordinal = ordinal;
                        proto$1.preparse = preParsePostFormat;
                        proto$1.postformat = preParsePostFormat;
                        proto$1.relativeTime = relativeTime;
                        proto$1.pastFuture = pastFuture;
                        proto$1.set = set;
                        proto$1.eras = localeEras;
                        proto$1.erasParse = localeErasParse;
                        proto$1.erasConvertYear = localeErasConvertYear;
                        proto$1.erasAbbrRegex = erasAbbrRegex;
                        proto$1.erasNameRegex = erasNameRegex;
                        proto$1.erasNarrowRegex = erasNarrowRegex;
                        proto$1.months = localeMonths;
                        proto$1.monthsShort = localeMonthsShort;
                        proto$1.monthsParse = localeMonthsParse;
                        proto$1.monthsRegex = monthsRegex;
                        proto$1.monthsShortRegex = monthsShortRegex;
                        proto$1.week = localeWeek;
                        proto$1.firstDayOfYear = localeFirstDayOfYear;
                        proto$1.firstDayOfWeek = localeFirstDayOfWeek;
                        proto$1.weekdays = localeWeekdays;
                        proto$1.weekdaysMin = localeWeekdaysMin;
                        proto$1.weekdaysShort = localeWeekdaysShort;
                        proto$1.weekdaysParse = localeWeekdaysParse;
                        proto$1.weekdaysRegex = weekdaysRegex;
                        proto$1.weekdaysShortRegex = weekdaysShortRegex;
                        proto$1.weekdaysMinRegex = weekdaysMinRegex;
                        proto$1.isPM = localeIsPM;
                        proto$1.meridiem = localeMeridiem;
                        function get$1(format, index, field, setter) {
                            var locale = getLocale(),
                                utc = createUTC().set(setter, index);
                            return locale[field](utc, format);
                        }
                        function listMonthsImpl(format, index, field) {
                            if (isNumber(format)) {
                                index = format;
                                format = undefined;
                            }
                            format = format || "";
                            if (index != null) {
                                return get$1(format, index, field, "month");
                            }
                            var i,
                                out = [];
                            for (i = 0; i < 12; i++) {
                                out[i] = get$1(format, i, field, "month");
                            }
                            return out;
                        }
                        function listWeekdaysImpl(localeSorted, format, index, field) {
                            if (typeof localeSorted === "boolean") {
                                if (isNumber(format)) {
                                    index = format;
                                    format = undefined;
                                }
                                format = format || "";
                            } else {
                                format = localeSorted;
                                index = format;
                                localeSorted = false;
                                if (isNumber(format)) {
                                    index = format;
                                    format = undefined;
                                }
                                format = format || "";
                            }
                            var locale = getLocale(),
                                shift = localeSorted ? locale._week.dow : 0,
                                i,
                                out = [];
                            if (index != null) {
                                return get$1(format, (index + shift) % 7, field, "day");
                            }
                            for (i = 0; i < 7; i++) {
                                out[i] = get$1(format, (i + shift) % 7, field, "day");
                            }
                            return out;
                        }
                        function listMonths(format, index) {
                            return listMonthsImpl(format, index, "months");
                        }
                        function listMonthsShort(format, index) {
                            return listMonthsImpl(format, index, "monthsShort");
                        }
                        function listWeekdays(localeSorted, format, index) {
                            return listWeekdaysImpl(localeSorted, format, index, "weekdays");
                        }
                        function listWeekdaysShort(localeSorted, format, index) {
                            return listWeekdaysImpl(localeSorted, format, index, "weekdaysShort");
                        }
                        function listWeekdaysMin(localeSorted, format, index) {
                            return listWeekdaysImpl(localeSorted, format, index, "weekdaysMin");
                        }
                        getSetGlobalLocale("en", {
                            eras: [
                                { since: "0001-01-01", until: +Infinity, offset: 1, name: "Anno Domini", narrow: "AD", abbr: "AD" },
                                { since: "0000-12-31", until: -Infinity, offset: 1, name: "Before Christ", narrow: "BC", abbr: "BC" },
                            ],
                            dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
                            ordinal: function (number) {
                                var b = number % 10,
                                    output = toInt((number % 100) / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
                                return number + output;
                            },
                        });
                        hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
                        hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
                        var mathAbs = Math.abs;
                        function abs() {
                            var data = this._data;
                            this._milliseconds = mathAbs(this._milliseconds);
                            this._days = mathAbs(this._days);
                            this._months = mathAbs(this._months);
                            data.milliseconds = mathAbs(data.milliseconds);
                            data.seconds = mathAbs(data.seconds);
                            data.minutes = mathAbs(data.minutes);
                            data.hours = mathAbs(data.hours);
                            data.months = mathAbs(data.months);
                            data.years = mathAbs(data.years);
                            return this;
                        }
                        function addSubtract$1(duration, input, value, direction) {
                            var other = createDuration(input, value);
                            duration._milliseconds += direction * other._milliseconds;
                            duration._days += direction * other._days;
                            duration._months += direction * other._months;
                            return duration._bubble();
                        }
                        function add$1(input, value) {
                            return addSubtract$1(this, input, value, 1);
                        }
                        function subtract$1(input, value) {
                            return addSubtract$1(this, input, value, -1);
                        }
                        function absCeil(number) {
                            if (number < 0) {
                                return Math.floor(number);
                            } else {
                                return Math.ceil(number);
                            }
                        }
                        function bubble() {
                            var milliseconds = this._milliseconds,
                                days = this._days,
                                months = this._months,
                                data = this._data,
                                seconds,
                                minutes,
                                hours,
                                years,
                                monthsFromDays;
                            if (!((milliseconds >= 0 && days >= 0 && months >= 0) || (milliseconds <= 0 && days <= 0 && months <= 0))) {
                                milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
                                days = 0;
                                months = 0;
                            }
                            data.milliseconds = milliseconds % 1e3;
                            seconds = absFloor(milliseconds / 1e3);
                            data.seconds = seconds % 60;
                            minutes = absFloor(seconds / 60);
                            data.minutes = minutes % 60;
                            hours = absFloor(minutes / 60);
                            data.hours = hours % 24;
                            days += absFloor(hours / 24);
                            monthsFromDays = absFloor(daysToMonths(days));
                            months += monthsFromDays;
                            days -= absCeil(monthsToDays(monthsFromDays));
                            years = absFloor(months / 12);
                            months %= 12;
                            data.days = days;
                            data.months = months;
                            data.years = years;
                            return this;
                        }
                        function daysToMonths(days) {
                            return (days * 4800) / 146097;
                        }
                        function monthsToDays(months) {
                            return (months * 146097) / 4800;
                        }
                        function as(units) {
                            if (!this.isValid()) {
                                return NaN;
                            }
                            var days,
                                months,
                                milliseconds = this._milliseconds;
                            units = normalizeUnits(units);
                            if (units === "month" || units === "quarter" || units === "year") {
                                days = this._days + milliseconds / 864e5;
                                months = this._months + daysToMonths(days);
                                switch (units) {
                                    case "month":
                                        return months;
                                    case "quarter":
                                        return months / 3;
                                    case "year":
                                        return months / 12;
                                }
                            } else {
                                days = this._days + Math.round(monthsToDays(this._months));
                                switch (units) {
                                    case "week":
                                        return days / 7 + milliseconds / 6048e5;
                                    case "day":
                                        return days + milliseconds / 864e5;
                                    case "hour":
                                        return days * 24 + milliseconds / 36e5;
                                    case "minute":
                                        return days * 1440 + milliseconds / 6e4;
                                    case "second":
                                        return days * 86400 + milliseconds / 1e3;
                                    case "millisecond":
                                        return Math.floor(days * 864e5) + milliseconds;
                                    default:
                                        throw new Error("Unknown unit " + units);
                                }
                            }
                        }
                        function valueOf$1() {
                            if (!this.isValid()) {
                                return NaN;
                            }
                            return this._milliseconds + this._days * 864e5 + (this._months % 12) * 2592e6 + toInt(this._months / 12) * 31536e6;
                        }
                        function makeAs(alias) {
                            return function () {
                                return this.as(alias);
                            };
                        }
                        var asMilliseconds = makeAs("ms"),
                            asSeconds = makeAs("s"),
                            asMinutes = makeAs("m"),
                            asHours = makeAs("h"),
                            asDays = makeAs("d"),
                            asWeeks = makeAs("w"),
                            asMonths = makeAs("M"),
                            asQuarters = makeAs("Q"),
                            asYears = makeAs("y");
                        function clone$1() {
                            return createDuration(this);
                        }
                        function get$2(units) {
                            units = normalizeUnits(units);
                            return this.isValid() ? this[units + "s"]() : NaN;
                        }
                        function makeGetter(name) {
                            return function () {
                                return this.isValid() ? this._data[name] : NaN;
                            };
                        }
                        var milliseconds = makeGetter("milliseconds"),
                            seconds = makeGetter("seconds"),
                            minutes = makeGetter("minutes"),
                            hours = makeGetter("hours"),
                            days = makeGetter("days"),
                            months = makeGetter("months"),
                            years = makeGetter("years");
                        function weeks() {
                            return absFloor(this.days() / 7);
                        }
                        var round = Math.round,
                            thresholds = { ss: 44, s: 45, m: 45, h: 22, d: 26, w: null, M: 11 };
                        function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
                            return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
                        }
                        function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
                            var duration = createDuration(posNegDuration).abs(),
                                seconds = round(duration.as("s")),
                                minutes = round(duration.as("m")),
                                hours = round(duration.as("h")),
                                days = round(duration.as("d")),
                                months = round(duration.as("M")),
                                weeks = round(duration.as("w")),
                                years = round(duration.as("y")),
                                a =
                                    (seconds <= thresholds.ss && ["s", seconds]) ||
                                    (seconds < thresholds.s && ["ss", seconds]) ||
                                    (minutes <= 1 && ["m"]) ||
                                    (minutes < thresholds.m && ["mm", minutes]) ||
                                    (hours <= 1 && ["h"]) ||
                                    (hours < thresholds.h && ["hh", hours]) ||
                                    (days <= 1 && ["d"]) ||
                                    (days < thresholds.d && ["dd", days]);
                            if (thresholds.w != null) {
                                a = a || (weeks <= 1 && ["w"]) || (weeks < thresholds.w && ["ww", weeks]);
                            }
                            a = a || (months <= 1 && ["M"]) || (months < thresholds.M && ["MM", months]) || (years <= 1 && ["y"]) || ["yy", years];
                            a[2] = withoutSuffix;
                            a[3] = +posNegDuration > 0;
                            a[4] = locale;
                            return substituteTimeAgo.apply(null, a);
                        }
                        function getSetRelativeTimeRounding(roundingFunction) {
                            if (roundingFunction === undefined) {
                                return round;
                            }
                            if (typeof roundingFunction === "function") {
                                round = roundingFunction;
                                return true;
                            }
                            return false;
                        }
                        function getSetRelativeTimeThreshold(threshold, limit) {
                            if (thresholds[threshold] === undefined) {
                                return false;
                            }
                            if (limit === undefined) {
                                return thresholds[threshold];
                            }
                            thresholds[threshold] = limit;
                            if (threshold === "s") {
                                thresholds.ss = limit - 1;
                            }
                            return true;
                        }
                        function humanize(argWithSuffix, argThresholds) {
                            if (!this.isValid()) {
                                return this.localeData().invalidDate();
                            }
                            var withSuffix = false,
                                th = thresholds,
                                locale,
                                output;
                            if (typeof argWithSuffix === "object") {
                                argThresholds = argWithSuffix;
                                argWithSuffix = false;
                            }
                            if (typeof argWithSuffix === "boolean") {
                                withSuffix = argWithSuffix;
                            }
                            if (typeof argThresholds === "object") {
                                th = Object.assign({}, thresholds, argThresholds);
                                if (argThresholds.s != null && argThresholds.ss == null) {
                                    th.ss = argThresholds.s - 1;
                                }
                            }
                            locale = this.localeData();
                            output = relativeTime$1(this, !withSuffix, th, locale);
                            if (withSuffix) {
                                output = locale.pastFuture(+this, output);
                            }
                            return locale.postformat(output);
                        }
                        var abs$1 = Math.abs;
                        function sign(x) {
                            return (x > 0) - (x < 0) || +x;
                        }
                        function toISOString$1() {
                            if (!this.isValid()) {
                                return this.localeData().invalidDate();
                            }
                            var seconds = abs$1(this._milliseconds) / 1e3,
                                days = abs$1(this._days),
                                months = abs$1(this._months),
                                minutes,
                                hours,
                                years,
                                s,
                                total = this.asSeconds(),
                                totalSign,
                                ymSign,
                                daysSign,
                                hmsSign;
                            if (!total) {
                                return "P0D";
                            }
                            minutes = absFloor(seconds / 60);
                            hours = absFloor(minutes / 60);
                            seconds %= 60;
                            minutes %= 60;
                            years = absFloor(months / 12);
                            months %= 12;
                            s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, "") : "";
                            totalSign = total < 0 ? "-" : "";
                            ymSign = sign(this._months) !== sign(total) ? "-" : "";
                            daysSign = sign(this._days) !== sign(total) ? "-" : "";
                            hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
                            return (
                                totalSign +
                                "P" +
                                (years ? ymSign + years + "Y" : "") +
                                (months ? ymSign + months + "M" : "") +
                                (days ? daysSign + days + "D" : "") +
                                (hours || minutes || seconds ? "T" : "") +
                                (hours ? hmsSign + hours + "H" : "") +
                                (minutes ? hmsSign + minutes + "M" : "") +
                                (seconds ? hmsSign + s + "S" : "")
                            );
                        }
                        var proto$2 = Duration.prototype;
                        proto$2.isValid = isValid$1;
                        proto$2.abs = abs;
                        proto$2.add = add$1;
                        proto$2.subtract = subtract$1;
                        proto$2.as = as;
                        proto$2.asMilliseconds = asMilliseconds;
                        proto$2.asSeconds = asSeconds;
                        proto$2.asMinutes = asMinutes;
                        proto$2.asHours = asHours;
                        proto$2.asDays = asDays;
                        proto$2.asWeeks = asWeeks;
                        proto$2.asMonths = asMonths;
                        proto$2.asQuarters = asQuarters;
                        proto$2.asYears = asYears;
                        proto$2.valueOf = valueOf$1;
                        proto$2._bubble = bubble;
                        proto$2.clone = clone$1;
                        proto$2.get = get$2;
                        proto$2.milliseconds = milliseconds;
                        proto$2.seconds = seconds;
                        proto$2.minutes = minutes;
                        proto$2.hours = hours;
                        proto$2.days = days;
                        proto$2.weeks = weeks;
                        proto$2.months = months;
                        proto$2.years = years;
                        proto$2.humanize = humanize;
                        proto$2.toISOString = toISOString$1;
                        proto$2.toString = toISOString$1;
                        proto$2.toJSON = toISOString$1;
                        proto$2.locale = locale;
                        proto$2.localeData = localeData;
                        proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1);
                        proto$2.lang = lang;
                        addFormatToken("X", 0, 0, "unix");
                        addFormatToken("x", 0, 0, "valueOf");
                        addRegexToken("x", matchSigned);
                        addRegexToken("X", matchTimestamp);
                        addParseToken("X", function (input, array, config) {
                            config._d = new Date(parseFloat(input) * 1e3);
                        });
                        addParseToken("x", function (input, array, config) {
                            config._d = new Date(toInt(input));
                        });
                        hooks.version = "2.29.3";
                        setHookCallback(createLocal);
                        hooks.fn = proto;
                        hooks.min = min;
                        hooks.max = max;
                        hooks.now = now;
                        hooks.utc = createUTC;
                        hooks.unix = createUnix;
                        hooks.months = listMonths;
                        hooks.isDate = isDate;
                        hooks.locale = getSetGlobalLocale;
                        hooks.invalid = createInvalid;
                        hooks.duration = createDuration;
                        hooks.isMoment = isMoment;
                        hooks.weekdays = listWeekdays;
                        hooks.parseZone = createInZone;
                        hooks.localeData = getLocale;
                        hooks.isDuration = isDuration;
                        hooks.monthsShort = listMonthsShort;
                        hooks.weekdaysMin = listWeekdaysMin;
                        hooks.defineLocale = defineLocale;
                        hooks.updateLocale = updateLocale;
                        hooks.locales = listLocales;
                        hooks.weekdaysShort = listWeekdaysShort;
                        hooks.normalizeUnits = normalizeUnits;
                        hooks.relativeTimeRounding = getSetRelativeTimeRounding;
                        hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
                        hooks.calendarFormat = getCalendarFormat;
                        hooks.prototype = proto;
                        hooks.HTML5_FMT = {
                            DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
                            DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
                            DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
                            DATE: "YYYY-MM-DD",
                            TIME: "HH:mm",
                            TIME_SECONDS: "HH:mm:ss",
                            TIME_MS: "HH:mm:ss.SSS",
                            WEEK: "GGGG-[W]WW",
                            MONTH: "YYYY-MM",
                        };
                        return hooks;
                    });
                }.call(this, __webpack_require__("./node_modules/webpack/buildin/module.js")(module)));
            },
            "./node_modules/promise-polyfill/src/allSettled.js": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                function allSettled(arr) {
                    var P = this;
                    return new P(function (resolve, reject) {
                        if (!(arr && typeof arr.length !== "undefined")) {
                            return reject(new TypeError(typeof arr + " " + arr + " is not iterable(cannot read property Symbol(Symbol.iterator))"));
                        }
                        var args = Array.prototype.slice.call(arr);
                        if (args.length === 0) return resolve([]);
                        var remaining = args.length;
                        function res(i, val) {
                            if (val && (typeof val === "object" || typeof val === "function")) {
                                var then = val.then;
                                if (typeof then === "function") {
                                    then.call(
                                        val,
                                        function (val) {
                                            res(i, val);
                                        },
                                        function (e) {
                                            args[i] = { status: "rejected", reason: e };
                                            if (--remaining === 0) {
                                                resolve(args);
                                            }
                                        }
                                    );
                                    return;
                                }
                            }
                            args[i] = { status: "fulfilled", value: val };
                            if (--remaining === 0) {
                                resolve(args);
                            }
                        }
                        for (var i = 0; i < args.length; i++) {
                            res(i, args[i]);
                        }
                    });
                }
                __webpack_exports__["default"] = allSettled;
            },
            "./node_modules/promise-polyfill/src/finally.js": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                function finallyConstructor(callback) {
                    var constructor = this.constructor;
                    return this.then(
                        function (value) {
                            return constructor.resolve(callback()).then(function () {
                                return value;
                            });
                        },
                        function (reason) {
                            return constructor.resolve(callback()).then(function () {
                                return constructor.reject(reason);
                            });
                        }
                    );
                }
                __webpack_exports__["default"] = finallyConstructor;
            },
            "./node_modules/promise-polyfill/src/index.js": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _finally__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/promise-polyfill/src/finally.js");
                var _allSettled__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/promise-polyfill/src/allSettled.js");
                var setTimeoutFunc = setTimeout;
                function isArray(x) {
                    return Boolean(x && typeof x.length !== "undefined");
                }
                function noop() {}
                function bind(fn, thisArg) {
                    return function () {
                        fn.apply(thisArg, arguments);
                    };
                }
                function Promise(fn) {
                    if (!(this instanceof Promise)) throw new TypeError("Promises must be constructed via new");
                    if (typeof fn !== "function") throw new TypeError("not a function");
                    this._state = 0;
                    this._handled = false;
                    this._value = undefined;
                    this._deferreds = [];
                    doResolve(fn, this);
                }
                function handle(self, deferred) {
                    while (self._state === 3) {
                        self = self._value;
                    }
                    if (self._state === 0) {
                        self._deferreds.push(deferred);
                        return;
                    }
                    self._handled = true;
                    Promise._immediateFn(function () {
                        var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
                        if (cb === null) {
                            (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
                            return;
                        }
                        var ret;
                        try {
                            ret = cb(self._value);
                        } catch (e) {
                            reject(deferred.promise, e);
                            return;
                        }
                        resolve(deferred.promise, ret);
                    });
                }
                function resolve(self, newValue) {
                    try {
                        if (newValue === self) throw new TypeError("A promise cannot be resolved with itself.");
                        if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
                            var then = newValue.then;
                            if (newValue instanceof Promise) {
                                self._state = 3;
                                self._value = newValue;
                                finale(self);
                                return;
                            } else if (typeof then === "function") {
                                doResolve(bind(then, newValue), self);
                                return;
                            }
                        }
                        self._state = 1;
                        self._value = newValue;
                        finale(self);
                    } catch (e) {
                        reject(self, e);
                    }
                }
                function reject(self, newValue) {
                    self._state = 2;
                    self._value = newValue;
                    finale(self);
                }
                function finale(self) {
                    if (self._state === 2 && self._deferreds.length === 0) {
                        Promise._immediateFn(function () {
                            if (!self._handled) {
                                Promise._unhandledRejectionFn(self._value);
                            }
                        });
                    }
                    for (var i = 0, len = self._deferreds.length; i < len; i++) {
                        handle(self, self._deferreds[i]);
                    }
                    self._deferreds = null;
                }
                function Handler(onFulfilled, onRejected, promise) {
                    this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
                    this.onRejected = typeof onRejected === "function" ? onRejected : null;
                    this.promise = promise;
                }
                function doResolve(fn, self) {
                    var done = false;
                    try {
                        fn(
                            function (value) {
                                if (done) return;
                                done = true;
                                resolve(self, value);
                            },
                            function (reason) {
                                if (done) return;
                                done = true;
                                reject(self, reason);
                            }
                        );
                    } catch (ex) {
                        if (done) return;
                        done = true;
                        reject(self, ex);
                    }
                }
                Promise.prototype["catch"] = function (onRejected) {
                    return this.then(null, onRejected);
                };
                Promise.prototype.then = function (onFulfilled, onRejected) {
                    var prom = new this.constructor(noop);
                    handle(this, new Handler(onFulfilled, onRejected, prom));
                    return prom;
                };
                Promise.prototype["finally"] = _finally__WEBPACK_IMPORTED_MODULE_0__["default"];
                Promise.all = function (arr) {
                    return new Promise(function (resolve, reject) {
                        if (!isArray(arr)) {
                            return reject(new TypeError("Promise.all accepts an array"));
                        }
                        var args = Array.prototype.slice.call(arr);
                        if (args.length === 0) return resolve([]);
                        var remaining = args.length;
                        function res(i, val) {
                            try {
                                if (val && (typeof val === "object" || typeof val === "function")) {
                                    var then = val.then;
                                    if (typeof then === "function") {
                                        then.call(
                                            val,
                                            function (val) {
                                                res(i, val);
                                            },
                                            reject
                                        );
                                        return;
                                    }
                                }
                                args[i] = val;
                                if (--remaining === 0) {
                                    resolve(args);
                                }
                            } catch (ex) {
                                reject(ex);
                            }
                        }
                        for (var i = 0; i < args.length; i++) {
                            res(i, args[i]);
                        }
                    });
                };
                Promise.allSettled = _allSettled__WEBPACK_IMPORTED_MODULE_1__["default"];
                Promise.resolve = function (value) {
                    if (value && typeof value === "object" && value.constructor === Promise) {
                        return value;
                    }
                    return new Promise(function (resolve) {
                        resolve(value);
                    });
                };
                Promise.reject = function (value) {
                    return new Promise(function (resolve, reject) {
                        reject(value);
                    });
                };
                Promise.race = function (arr) {
                    return new Promise(function (resolve, reject) {
                        if (!isArray(arr)) {
                            return reject(new TypeError("Promise.race accepts an array"));
                        }
                        for (var i = 0, len = arr.length; i < len; i++) {
                            Promise.resolve(arr[i]).then(resolve, reject);
                        }
                    });
                };
                Promise._immediateFn =
                    (typeof setImmediate === "function" &&
                        function (fn) {
                            setImmediate(fn);
                        }) ||
                    function (fn) {
                        setTimeoutFunc(fn, 0);
                    };
                Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
                    if (typeof console !== "undefined" && console) {
                        console.warn("Possible Unhandled Promise Rejection:", err);
                    }
                };
                __webpack_exports__["default"] = Promise;
            },
            "./node_modules/promise-polyfill/src/polyfill.js": function (module, __webpack_exports__, __webpack_require__) {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./node_modules/promise-polyfill/src/index.js");
                var _finally__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./node_modules/promise-polyfill/src/finally.js");
                var _allSettled__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("./node_modules/promise-polyfill/src/allSettled.js");
                var globalNS = (function () {
                    if (typeof self !== "undefined") {
                        return self;
                    }
                    if (typeof window !== "undefined") {
                        return window;
                    }
                    if (typeof global !== "undefined") {
                        return global;
                    }
                    throw new Error("unable to locate global object");
                })();
                if (typeof globalNS["Promise"] !== "function") {
                    globalNS["Promise"] = _index__WEBPACK_IMPORTED_MODULE_0__["default"];
                } else {
                    if (!globalNS.Promise.prototype["finally"]) {
                        globalNS.Promise.prototype["finally"] = _finally__WEBPACK_IMPORTED_MODULE_1__["default"];
                    }
                    if (!globalNS.Promise.allSettled) {
                        globalNS.Promise.allSettled = _allSettled__WEBPACK_IMPORTED_MODULE_2__["default"];
                    }
                }
            },
            "./node_modules/webpack/buildin/amd-define.js": function (module, exports) {
                module.exports = function () {
                    throw new Error("define cannot be used indirect");
                };
            },
            "./node_modules/webpack/buildin/module.js": function (module, exports) {
                module.exports = function (module) {
                    if (!module.webpackPolyfill) {
                        module.deprecate = function () {};
                        module.paths = [];
                        if (!module.children) module.children = [];
                        Object.defineProperty(module, "loaded", {
                            enumerable: true,
                            get: function () {
                                return module.l;
                            },
                        });
                        Object.defineProperty(module, "id", {
                            enumerable: true,
                            get: function () {
                                return module.i;
                            },
                        });
                        module.webpackPolyfill = 1;
                    }
                    return module;
                };
            },
            "./tests/test-streams.js": function (module, exports) {
                function createTestStream(url, description, live, abr, skip_ua) {
                    if (live === void 0) {
                        live = false;
                    }
                    if (abr === void 0) {
                        abr = true;
                    }
                    if (skip_ua === void 0) {
                        skip_ua = [];
                    }
                    return { url: url, description: description, live: live, abr: abr, skip_ua: skip_ua };
                }
                function createTestStreamWithConfig(target, config) {
                    if (typeof target !== "object") {
                        throw new Error("target should be object");
                    }
                    var testStream = createTestStream(target.url, target.description, target.live, target.abr, target.skip_ua);
                    testStream.config = config;
                    return testStream;
                }
                module.exports = {
                    bbb: { url: "https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8", description: "Big Buck Bunny - adaptive qualities", abr: true },
                    fdr: { url: "https://cdn.jwplayer.com/manifests/pZxWPRg4.m3u8", description: "FDR - CDN packaged, 4s segments, 180p - 1080p", abr: true },
                    bigBuckBunny480p: { url: "https://test-streams.mux.dev/x36xhzz/url_6/193039199_mp4_h264_aac_hq_7.m3u8", description: "Big Buck Bunny - 480p only", abr: false },
                    arte: { url: "https://test-streams.mux.dev/test_001/stream.m3u8", description: "ARTE China,ABR", abr: true },
                    deltatreDAI: { url: "https://test-streams.mux.dev/dai-discontinuity-deltatre/manifest.m3u8", description: "Ad-insertion in event stream", abr: false },
                    issue666: { url: "https://playertest.longtailvideo.com/adaptive/issue666/playlists/cisq0gim60007xzvi505emlxx.m3u8", description: "Surveillance footage - https://github.com/video-dev/hls.js/issues/666", abr: false },
                    closedCaptions: { url: "https://playertest.longtailvideo.com/adaptive/captions/playlist.m3u8", description: "CNN special report, with CC", abr: false },
                    customIvBadDts: { url: "https://playertest.longtailvideo.com/adaptive/customIV/prog_index.m3u8", description: "Custom IV with bad PTS DTS", abr: false },
                    oceansAES: { url: "https://playertest.longtailvideo.com/adaptive/oceans_aes/oceans_aes.m3u8", description: "AES-128 encrypted, ABR", abr: true },
                    tracksWithAES: { url: "https://playertest.longtailvideo.com/adaptive/aes-with-tracks/master.m3u8", description: "AES-128 encrypted, TS main with AAC audio track", abr: false },
                    mp3Audio: { url: "https://playertest.longtailvideo.com/adaptive/vod-with-mp3/manifest.m3u8", description: "MP3 VOD demo", abr: false },
                    mpegAudioOnly: { url: "https://pl.streamingvideoprovider.com/mp3-playlist/playlist.m3u8", description: "MPEG Audio Only demo", abr: false, skip_ua: ["MicrosoftEdge", "firefox"] },
                    fmp4: { url: "https://storage.googleapis.com/shaka-demo-assets/angel-one-hls/hls.m3u8", description: "HLS fMP4 Angel-One multiple audio-tracks", abr: true },
                    fmp4Bitmovin: { url: "https://bitdash-a.akamaihd.net/content/MI201109210084_1/m3u8s-fmp4/f08e80da-bf1d-4e3d-8899-f0f6155f6efa.m3u8", description: "HLS fMP4 by Bitmovin", abr: true },
                    fmp4BitmovinHevc: {
                        url: "https://bitmovin-a.akamaihd.net/content/dataset/multi-codec/hevc/stream_fmp4.m3u8",
                        description: "HLS HEVC fMP4 by Bitmovin (Safari and Edge? only as of 2020-08)",
                        abr: true,
                        skipFunctionalTests: true,
                    },
                    offset_pts: { url: "https://test-streams.mux.dev/pts_shift/master.m3u8", description: "DK Turntable, PTS shifted by 2.3s", abr: true },
                    angelOneShakaWidevine: createTestStreamWithConfig(
                        {
                            url: "https://storage.googleapis.com/shaka-demo-assets/angel-one-widevine-hls/hls.m3u8",
                            description: "Shaka-packager Widevine DRM (EME) HLS-fMP4 - Angel One Demo",
                            abr: true,
                            skip_ua: ["firefox", "safari", { name: "chrome", version: "75.0" }, { name: "chrome", version: "79.0" }],
                        },
                        { widevineLicenseUrl: "https://cwip-shaka-proxy.appspot.com/no_auth", emeEnabled: true }
                    ),
                    audioOnlyMultipleLevels: { url: "https://s3.amazonaws.com/qa.jwplayer.com/~alex/121628/new_master.m3u8", description: "Multiple non-alternate audio levels", abr: true },
                    pdtDuplicate: { url: "https://playertest.longtailvideo.com/adaptive/artbeats/manifest.m3u8", description: "Duplicate sequential PDT values", abr: false },
                    pdtLargeGap: { url: "https://playertest.longtailvideo.com/adaptive/boxee/playlist.m3u8", description: "PDTs with large gaps following discontinuities", abr: false },
                    pdtBadValues: { url: "https://playertest.longtailvideo.com/adaptive/progdatime/playlist2.m3u8", description: "PDTs with bad values", abr: false },
                    pdtOneValue: { url: "https://playertest.longtailvideo.com/adaptive/aviion/manifest.m3u8", description: "One PDT, no discontinuities", abr: false },
                    noTrackIntersection: createTestStreamWithConfig(
                        { url: "https://s3.amazonaws.com/qa.jwplayer.com/~alex/123633/new_master.m3u8", description: "Audio/video track PTS values do not intersect; 10 second start gap", abr: false },
                        { avBufferOffset: 10.5 }
                    ),
                    altAudioAndTracks: { url: "https://playertest.longtailvideo.com/adaptive/elephants_dream_v4/index.m3u8", description: "Alternate audio tracks, and multiple VTT tracks", vendor: "wowza", abr: true },
                    altAudioAudioOnly: createTestStreamWithConfig(
                        { url: "https://playertest.longtailvideo.com/adaptive/alt-audio-no-video/sintel/playlist.m3u8", description: "Audio only with alternate audio track (Sintel)", abr: false },
                        { allowedBufferedRangesInSeekTest: 3 }
                    ),
                    altAudioMultiAudioOnly: { url: "https://playertest.longtailvideo.com/adaptive/alt-audio-no-video/angel-one.m3u8", description: "Audio only with multiple alternate audio tracks (Angel One)", abr: false },
                    muxedFmp4: { url: "https://s3.amazonaws.com/qa.jwplayer.com/hlsjs/muxed-fmp4/hls.m3u8", description: 'Muxed av fmp4 - appended to "audiovideo" SourceBuffer', abr: false },
                    altAudioWithPdtAndStartGap: { url: "https://playertest.longtailvideo.com/adaptive/hls-test-streams/test-audio-pdt/playlist.m3u8", description: "PDT before each segment, 1.59s start gap", startSeek: true },
                    AppleAdvancedHevcAvcHls: { url: "https://devstreaming-cdn.apple.com/videos/streaming/examples/bipbop_adv_example_hevc/master.m3u8", description: "Advanced stream (HEVC/H.264, AC-3/AAC,  WebVTT, fMP4 segments)" },
                    MuxLowLatencyHls: {
                        url: "https://stream.mux.com/v69RSHhFelSm4701snP22dYz2jICy4E4FUyk02rW4gxRM.m3u8",
                        description: "Low-Latency HLS sample of Big Buck Bunny loop and a timer. Restarts every 12 hours. (fMP4 segments)",
                        live: true,
                    },
                    groupIds: { url: "https://mtoczko.github.io/hls-test-streams/test-group/playlist.m3u8", description: "Group-id: subtitle and audio", abr: true, skipFunctionalTests: true },
                    redundantLevelsWithTrackGroups: {
                        url: "https://playertest.longtailvideo.com/adaptive/elephants_dream_v4/redundant.m3u8",
                        description: "Redundant levels with subtitle and audio track groups",
                        abr: true,
                        skipFunctionalTests: true,
                    },
                    startDelimiterOverlappingBetweenPESPackets: {
                        url: "https://hlsjs-test-streams-wistia.s3.amazonaws.com/start-delimiter.m3u8",
                        description:
                            "A stream with the start delimiter overlapping between PES packets.\n       Related to https://github.com/video-dev/hls.js/issues/3834, where Apple Silicon chips throw decoding errors if\n       NAL units are not starting right at the beginning of the PES packet when using hardware accelerated decoding.",
                        abr: false,
                    },
                };
            },
        })["default"];
    });
